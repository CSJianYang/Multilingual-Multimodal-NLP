[
    {
        "title": "Number of Good Pairs",
        "question_content": "Given an array of integers nums, return the number of good pairs.\nA pair (i, j) is called good if nums[i] == nums[j] and i < j.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,1,1,3]\nOutput: 4\nExplanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\n\nExample 2:\n\nInput: nums = [1,1,1,1]\nOutput: 6\nExplanation: Each pair in the array are good.\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t1 <= nums[i] <= 100",
        "solutions": [
            {
                "id": 731561,
                "title": "java-c-python-count",
                "content": "## **Explanation**\\n`count` the occurrence of the same elements.\\nFor each new element `a`,\\nthere will be more `count[a]` pairs,\\nwith `A[i] == A[j]` and `i < j`\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numIdenticalPairs(int[] A) {\\n        int res = 0, count[] = new int[101];\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        int res = 0;\\n        unordered_map<int, int> count;\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n1-line from @generationx2020\\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        return accumulate(A.begin(), A.end(), 0, [count = unordered_map<int, int> {}] (auto a, auto b) mutable {\\n            return a + count[b]++;\\n        });\\n    }\\n```\\n**Python:**\\n```py\\n    def numIdenticalPairs(self, A):\\n        return sum(k * (k - 1) / 2 for k in collections.Counter(A).values())\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numIdenticalPairs(int[] A) {\\n        int res = 0, count[] = new int[101];\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        int res = 0;\\n        unordered_map<int, int> count;\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        return accumulate(A.begin(), A.end(), 0, [count = unordered_map<int, int> {}] (auto a, auto b) mutable {\\n            return a + count[b]++;\\n        });\\n    }\\n```\n```py\\n    def numIdenticalPairs(self, A):\\n        return sum(k * (k - 1) / 2 for k in collections.Counter(A).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1457646,
                "title": "java-story-based-0ms-single-pass-easy-to-understand-simple-hashmap",
                "content": "\\n# HANDSHAKES IN GATHERING\\n\\n# **YOU ALL CAN BUY ME A ******BEER \\uD83C\\uDF7A****** AT \\uD83D\\uDC47**\\n\\n**https://www.buymeacoffee.com/deepakgupta**\\n\\nImagine this problem like, There is a gathering organized by some guy, the guest list is [1,2,3,1,1,3].\\nThe problem with the guest is they only handshake with like minded people. (Like minded here is basically the digit should be same , for example, 1 will handshake with 1 only, 2 will handshake with 2 only and so on)\\n\\n\\n\\n**So, finally we just need to count number of handshakes in the gathering. \\uD83D\\uDCAF \\uD83D\\uDCAF**\\n\\n(To distinguish , multiple 1\\'s and 3\\'s , a,b,c,d... letters are used)\\n\\n**\\uD83D\\uDD25 the day of arrival \\uD83D\\uDD25** \\n\\none by one guests are arriving at the gathering\\n\\n\\u2705 first guest: 1\\n\\n\\u2705 second guest: 2\\n(at this moment, in gathering hall we have **1** (2 is about to enter) , since they are not like minded they wont shake hands)\\n\\n\\u2705 third guest:3\\n(at this moment, in gathering hall we have **1 ,2** (3 is about to enter), since they are not like minded they wont shake hands)\\n\\n\\u2705 fourth guest : 1\\n(at this moment, fourth guest will see in gathering hall , there is **one like minded guy** ie(1) , so he will handshake with him)\\ntherefore totalHandShake = 1\\n\\n\\u2705 fifth guest : 1\\n(at this moment, fifth guest will see in gathering hall, there are **two like minded guys** ie(1,1) , so he will handshake with them)\\ntherefore totalHandShake = 1(last handshake between 1a-1b ) + 2(current handshake between 1a-1c, 1b-1c) = 3\\n\\n\\u2705 sixth guest : 3\\n(at this moment, sixth guest will see in gathering hall, there is **one like minded guy** ie(3) , so he will handshake with him)\\ntherefore totalHandShake = 3(last handshake) + 1(3a-3b) = 4 \\n\\n\\nHere, in code we can imagine\\n\\n**given array as guest list.\\nHashmap as gathering hall\\nans as totalHandshakes.**\\n\\n# IF YOU GUYS ENJOYED THIS, PLEASE UPVOTE AND COMMENT, THIS GIVES ME HUGE MOTIVATION.\\n# **YOU ALL CAN BUY ME A BEER \\uD83C\\uDF7A AT \\uD83D\\uDC47**\\n\\n**https://www.buymeacoffee.com/deepakgupta**\\n\\n\\n\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] guestList) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int ans = 0;\\n        \\n        for(int friend:guestList)\\n        {\\n            int friendCount = hm.getOrDefault(friend,0);\\n            ans+=friendCount;\\n            hm.put(friend,friendCount+1);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**SPACE : O(N)\\nTIME   :  O(N)**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] guestList) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int ans = 0;\\n        \\n        for(int friend:guestList)\\n        {\\n            int friendCount = hm.getOrDefault(friend,0);\\n            ans+=friendCount;\\n            hm.put(friend,friendCount+1);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736565,
                "title": "python-simple-o-n-solution",
                "content": "**Solution Idea**\\nThe idea is storing the number of repeated elements in a dictionary/hash table and using mathmatics to calculate the number of combinations.\\n\\n**Fundamental Math Concept (Combinations)**\\nThe \"# of pairs\" can be calculated by summing each value from range 0 to n-1, where n is the \"# of times repeated\". So the \"# of pairs\" for the 5 repeated values, would be 0+1+2+3+4 = 10.\\n\\nAnother way to think about it is:\\n\\nNotice in the table below how the number of pairs increments by adding the previous \"# of times repeated\" to the previous \"# of pairs.\"\\n\\nFor example: to get the \"# of pairs\" for 3 repeated values, you would add the previous \"# of times repeated\" (which is 2) with the previous \"# of pairs\" (which is 1). Therefore, the \"# of pairs for 3 repeated values is 2+1=3. In this method, you don\\'t peform the same computations multiple times.\\n\\nExample Table of # of repeated items with their corresponding # of pairs\\n<table>\\n\\t<tr>\\n    <th># of times repeated</th>\\n    <th># of pairs</th>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>1</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>3</td>\\n  </tr>\\n  <tr>\\n    <td>4</td>\\n    <td>6</td>\\n  </tr>\\n  <tr>\\n    <td>5</td>\\n    <td>10</td>\\n  </tr>\\n  <tr>\\n    <td>6</td>\\n    <td>15</td>\\n  </tr>\\n</table>\\n\\n**My Code Solution**\\n1. Dictionary/Hash Table to store the number of times an element is repeated\\n2. Record total number of pairs (num)\\n3. Iterate through the nums list\\n4. Check to see if each element has already been seen, if not add it to the Hash Table\\n5. If it has been seen, but only once, just add 1 to \"num\"\\n6. If it has been seen, multiple times. Add the number of repeated times to \"num\"\\n7. Increment the number of reapeated times by 1.\\n7. Move onto next element\\n\\n```\\nclass Solution:\\n    \\n    # search for duplicate numbers\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        # number of good pairs\\n        repeat = {}\\n        num = 0\\n        \\n        # for every element in nums\\n        for v in nums:\\n            \\n            # number of repeated digits\\n            if v in repeat:\\n                \\n                # count number of pairs based on duplicate values\\n                if repeat[v] == 1:\\n                    num += 1\\n                else:\\n                    num += repeat[v]\\n                \\n                # increment the number of counts\\n                repeat[v] += 1\\n            # number has not been seen before\\n            else:\\n                repeat[v] = 1\\n        # return\\n        return num\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # search for duplicate numbers\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        # number of good pairs\\n        repeat = {}\\n        num = 0\\n        \\n        # for every element in nums\\n        for v in nums:\\n            \\n            # number of repeated digits\\n            if v in repeat:\\n                \\n                # count number of pairs based on duplicate values\\n                if repeat[v] == 1:\\n                    num += 1\\n                else:\\n                    num += repeat[v]\\n                \\n                # increment the number of counts\\n                repeat[v] += 1\\n            # number has not been seen before\\n            else:\\n                repeat[v] = 1\\n        # return\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733540,
                "title": "java-100-faster-100-space-easy-solution",
                "content": "Method - 1: We can use two for loops and check is <b> nums[i] = nums[j] </b> and i < j and simply increase count by one every time. I think it will give error of time limit exceeded.\\n\\nMethod - 2 : First we can count the frequency of each numbers using array. If a number appears n times, then n * (n \\u2013 1) / 2 pairs can be made with this number.\\n\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int ans = 0;\\n        int[] count = new int[101];\\n        \\n        for(int n: nums)\\n            count[n]++;\\n        \\n        for(int n: count)\\n            ans += (n * (n - 1))/2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int ans = 0;\\n        int[] count = new int[101];\\n        \\n        for(int n: nums)\\n            count[n]++;\\n        \\n        for(int n: count)\\n            ans += (n * (n - 1))/2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749025,
                "title": "python-o-n-simple-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        hashMap = {}\\n        res = 0\\n        for number in nums:            \\n            if number in hashMap:\\n                res += hashMap[number]\\n                hashMap[number] += 1\\n            else:\\n                hashMap[number] = 1\\n        return res\\n```\\n\\n- If the value already exists in the hashMap that means the number of new pairs is equal to the frequency since the current value can be paired with each prior occurrence . \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        hashMap = {}\\n        res = 0\\n        for number in nums:            \\n            if number in hashMap:\\n                res += hashMap[number]\\n                hashMap[number] += 1\\n            else:\\n                hashMap[number] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731571,
                "title": "java-hashmap-o-n",
                "content": "for each i, finds all j where, j < i &&  nums[j] == nums[i];\\n```\\n    public int numIdenticalPairs(int[] nums) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            res += map.get(n) - 1;  // addtional pair can be formed btw n and all previous v == n;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numIdenticalPairs(int[] nums) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            res += map.get(n) - 1;  // addtional pair can be formed btw n and all previous v == n;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731624,
                "title": "c-java-o-n",
                "content": "We can just count each value. Then, `n` elements with the same value can form `n * (n - 1) / 2` pairs.\\n\\n> Why? The first element forms `n - 1` pairs, the second - `n - 2` pairs and so on. So the sum of the [1, n - 1] progression is `n * (n - 1) / 2`.\\n\\n**C++**\\n```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {};\\n    for (auto n: nums)\\n        ++cnt[n];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int s, int i)\\n        { return s + i * (i - 1) / 2; });\\n}\\n```\\n**Java**\\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        ++cnt[n];\\n    for (int i = 0; i <= 100; ++i)\\n        res += cnt[i] * (cnt[i] - 1) / 2;\\n    return res;     \\n}\\n```\\n\\nWe can also simplify the logic a bit by combining the counting and progression.\\n\\n**C++**\\n```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {}, res = 0;\\n    for (auto n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {};\\n    for (auto n: nums)\\n        ++cnt[n];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int s, int i)\\n        { return s + i * (i - 1) / 2; });\\n}\\n```\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        ++cnt[n];\\n    for (int i = 0; i <= 100; ++i)\\n        res += cnt[i] * (cnt[i] - 1) / 2;\\n    return res;     \\n}\\n```\n```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {}, res = 0;\\n    for (auto n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 911686,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(N^2) space O(1)\\n var numIdenticalPairs = function(nums) {\\n     let count = 0\\n    \\n     for(let i=0; i<nums.length; i++) {\\n         for(let j=i+1; j<nums.length; j++) {\\n             if(nums[i] === nums[j]) {\\n                 count++\\n             }\\n         }\\n     }\\n    \\n     return count\\n };\\n```\\n\\n```\\n// time O(N) space O(N)\\nvar numIdenticalPairs = function(nums) {\\n    const map = {}\\n    let count = 0\\n    \\n    for (const number of nums) {\\n        if (map[number]) {\\n            count += map[number];\\n            map[number] += 1;\\n        } else {\\n            map[number] = 1;\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(N^2) space O(1)\\n var numIdenticalPairs = function(nums) {\\n     let count = 0\\n    \\n     for(let i=0; i<nums.length; i++) {\\n         for(let j=i+1; j<nums.length; j++) {\\n             if(nums[i] === nums[j]) {\\n                 count++\\n             }\\n         }\\n     }\\n    \\n     return count\\n };\\n```\n```\\n// time O(N) space O(N)\\nvar numIdenticalPairs = function(nums) {\\n    const map = {}\\n    let count = 0\\n    \\n    for (const number of nums) {\\n        if (map[number]) {\\n            count += map[number];\\n            map[number] += 1;\\n        } else {\\n            map[number] = 1;\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1202414,
                "title": "weeb-explains-python-beats-97-65",
                "content": "![image](https://assets.leetcode.com/users/images/6a27264b-cfe3-42e3-92e0-bfcee79d7d1e_1620717462.3697262.png)\\nfirst try btw and its already 97%\\n\\nOkay, my code looks weird at first glance but its actually pretty easy, just plug in the formula for quadratic sequence\\n\\t\\n\\tclass Solution:\\n\\t\\tdef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, memo = sorted(nums), {} # sort to get the total number of digits that have duplicates\\n\\t\\t\\tfor i in range(len(nums)-1): # lets say nums = [1,1,1,1,2,2,2,3] the total digits with duplicates is 7\\n\\t\\t\\t\\tif nums[i] == nums[i+1]: # because nums has 4 ones and 3 twos so it adds up to 7\\n\\t\\t\\t\\t\\tif nums[i] not in memo: # 3 is not counted because there are no duplicates of it\\n\\t\\t\\t\\t\\t\\tmemo[nums[i]] = 1\\n\\t\\t\\t\\t\\tmemo[nums[i]] = memo[nums[i]] + 1 \\n\\t\\t\\t# nums = [1,1,1,1,2,2,2,3]\\n\\t\\t\\t# so now memo = {1 : 4, 2: 3} which means we have 4 ones and 3 twos\\n\\t\\t\\tanswer = 0\\n\\t\\t\\tfor n in memo.values(): # this is the hard part, please refer to my beautiful drawing to understand this\\n\\t\\t\\t\\tanswer += (n**2 - n)//2 # after looking at the drawing, we repeat with each n value in memo\\n\\n\\t\\t\\treturn answer\\n\\n![image](https://assets.leetcode.com/users/images/62dfbc6c-2157-4b97-bebb-aa4cc1978ac6_1620719423.0946832.png)\\n![image](https://assets.leetcode.com/users/images/d3bba77d-366c-4380-a2e6-8e6844184e97_1620719531.481281.png)\\n\\nDamn, this took some time to do, please give me an upvote if u find it helpful\\n\\nAnways, i want to recommend an anime called **Karakai Jouzu no Takagi-san(Teasing Master Takagi-san)**\\n\\n# Episodes: 24 + 1 OVA\\n# Genres: Romantic comedy, Slice of life\\n\\nI love this anime, its wholesome so go check it out!\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, memo = sorted(nums), {}",
                "codeTag": "Java"
            },
            {
                "id": 939461,
                "title": "java-1-pass-one-pass-solution-intuitive-explanation",
                "content": "**1512. Number of Good Pairs**\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int answer = 0;\\n        for(int i: nums){\\n            if(map.containsKey(i)){ // if number has occurred before\\n                int temp = map.get(i);\\n                answer += temp; // add number of occurrences to the answer\\n                map.put(i,temp+1); // increment number of occurrences\\n            } else {\\n                map.put(i,1); // if it is the first time, add it to the map\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n**PROBLEM OVERVIEW**\\nThe basic premise of the prolem is to find of many times nums[i] == nums[j], where j > i\\nWe are esentially tasked with finding the number of repeats after first occurence of each number.\\n\\n**ASSESSING SOLUTIONS**\\nA hashmap is great for this solution as we can looop through the array of numbers and have 1 of 2 states:\\n\\n*  if it exists, then add the number of currently stores and subsequently increment it\\n* otherwise, set that value as 1 (it exists)\\n\\nThe code is O(n), as it iterates through the entire array\\n\\n**EXPLANATIONS**\\nHere\\'s a way to visualize it. If I have [1,1], then there is only **1** \"good pair,\" which is the first and second 1. **(0+1 = 1)**\\nIf I have [1,1,1] then there are **3** \"good pairs\" ([first,second], [second,third,], [first,third]). **The first 1 has 0 pairs, the second 1 has 1 pair, and the third 1 has 2 pairs. (0+1+2 = 3)!**\\nLikeswise for [1,1,1,1] there are **6** \"good pairs\" **(0+1+2+3 = 6)**\\n\\nFrom this, we can conclude the pattern is **for every subsequent repeat of a number, the number of combinations increases by the current number of appearances of that number.**\\n\\nIn the code, we demonstrate this by incrementing the value in the map by one everytime, signaling the next occurence to add to \"answers\" one more combination than before.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int answer = 0;\\n        for(int i: nums){\\n            if(map.containsKey(i)){ // if number has occurred before\\n                int temp = map.get(i);\\n                answer += temp; // add number of occurrences to the answer\\n                map.put(i,temp+1); // increment number of occurrences\\n            } else {\\n                map.put(i,1); // if it is the first time, add it to the map\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731808,
                "title": "simplest-c-explanation-o-n2-and-o-n",
                "content": "\\n**O(n2)** [100% less memory usage] [75% less time usage]\\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint counter = 0;\\n\\tfor(int i=0;i<nums.size()-1;++i)\\n\\t  for(int j=i+1;j<nums.size();++j)\\n\\t\\tif(nums[i]==nums[j]) counter++;\\n\\treturn counter;\\n}\\n```\\n\\n\\n**O(n)** [100% less memory usage] [100% less time usage]\\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint count[101] = {};\\n\\tfor (auto n: nums)\\n\\t\\t++count[n];\\n\\treturn accumulate(begin(count), end(count), 0, [](int s, int i)\\n\\t\\t{ return s + i * (i - 1) / 2; });\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint counter = 0;\\n\\tfor(int i=0;i<nums.size()-1;++i)\\n\\t  for(int j=i+1;j<nums.size();++j)\\n\\t\\tif(nums[i]==nums[j]) counter++;\\n\\treturn counter;\\n}\\n```\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint count[101] = {};\\n\\tfor (auto n: nums)\\n\\t\\t++count[n];\\n\\treturn accumulate(begin(count), end(count), 0, [](int s, int i)\\n\\t\\t{ return s + i * (i - 1) / 2; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822102,
                "title": "python-99-27-o-n-easy-to-understand-its-math",
                "content": "Because pairs are only created if **nums[i] == nums[j]** and i < j, we can infer a arithmethic sequence from this condition. \\n\\nA hint was also given from the examples:\\n[1,1,1,1] have 6 combination\\nThe first 1 have 3 pairs\\nThe second 1 have 2 pairs\\nThe third 1 have 1 pairs\\nHence for 4 of 1\\'s, we can have 3 + 2 + 1 combination\\n\\nThen we just have to store every value count and then count arithmetic sequence sum from 1 to n, given n is the number of appearance for each number.\\n\\nPlease star it if you like my solution and explanation :), any advice or correction would be appreciated.\\n\\nThanks !\\n\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        for num in d:\\n            val = d[num]\\n            for i in range(val):\\n                pairs += i\\n        return pairs\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        for num in d:\\n            val = d[num]\\n            for i in range(val):\\n                pairs += i\\n        return pairs\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 737778,
                "title": "c-speed-mem-o-n-o-n-w-o-map-video",
                "content": "Since the given nums.length() <= 100, space complexity is O(n).\\nhttps://www.youtube.com/watch?v=FlFxSnK2SmY\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int mem[101] ={0};\\n        int sum=0;\\n        \\n        for(int i=0; i < nums.size(); i++){\\n            sum += mem[nums[i]];\\n            ++mem[nums[i]];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int mem[101] ={0};\\n        int sum=0;\\n        \\n        for(int i=0; i < nums.size(); i++){\\n            sum += mem[nums[i]];\\n            ++mem[nums[i]];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966159,
                "title": "c-single-pass-solution-explained-100-time-96-space",
                "content": "This is a nice one that can be solved trivially, but it has some more challenge if you plan on tackling it in a more optimised way. My core intuition was that for each number `n` we basically need to apply the Gaussian formula to its frequency `f`, `-1` (since numbers can\\'t form couples with themselves in this problem).\\n\\nSo, if we encounter `9` once, we have `0` pairs; twice, we have `1` pair; thrice, we have `1 + 2 == 3` pairs; four times, we have `1 + 2 + 3 == 6` pairs and so on.\\n\\nWith that in mind, we have 2 ways to skin this cat \\uD83D\\uDC08 : the first one is to add for each number the cumulative frequency of its occurrence so far.\\n\\nTo do so, we declare 2 support variables;\\n* `res` to store our ongoing total;\\n* `seen` to collect the frequency of each element (and we know that all the values will go in the `1 - 100` range, so we can just use an array with `101` elements to avoid converting them into a `0`-indexed operation).\\n\\nFor each number `n`, we will:\\n* increase `res` by its previous comulative frequency so far `seen[n]`;\\n* increase said frequency by `1` with `seen[n]++`.\\n\\nOnce done, we can return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        for (auto n: nums) {\\n            // for each occurrence, we had the previously found matches to res...\\n            res += seen[n];\\n            // ...and then we update seen \\n            seen[n]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAlternative version, which would be more perfoming with significantly longer inputs where an optimised multiplicative algorithm trumps manual sums, would do partially the same, first populating `seen` with all the relative frequencies (provided at least one element was found) and then applying the gaussian formula to them.\\n\\nInterestingly enough, this approach proved to be consistently slower and a bit more demanding in terms of memory (I guess due to how multiplications are usually computed):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        // populating seen with all the frequencies\\n        for (int n: nums) seen[n]++;\\n        // updating res based on the found frequencies\\n        for (int f: seen) if (f) res += f * (f - 1) / 2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        for (auto n: nums) {\\n            // for each occurrence, we had the previously found matches to res...\\n            res += seen[n];\\n            // ...and then we update seen \\n            seen[n]++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        // populating seen with all the frequencies\\n        for (int n: nums) seen[n]++;\\n        // updating res based on the found frequencies\\n        for (int f: seen) if (f) res += f * (f - 1) / 2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080300,
                "title": "hash-table-explained-line-by-line-faster",
                "content": "Before solving the question we will keep two thing in mind.\\n1.The use of Vectors\\n2.The use of Hashing.\\n\\nHere, this question can be solved by a direct formula which we will use to find the number of good pairs.\\nThe formula is (n*(n-1))/2.\\n\\n*First we find the count of number occurences of a number. \\n*Then store the number count in the dictionary .\\n[1,2,3,1,1,3]\\n\\nkey - value pair\\n1     :         3\\n2     :         1\\n3     :         2\\n\\n*Then we consider n = value in the hash table\\n*using loop calculate the good pairs.\\n```\\n//Program to find the number of good pairs\\n//Good pairs are those in which nums[i] == nums[j] and i<j\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) \\n    {\\n   \\n        unordered_map<int,int> umap; //Initializing a Hash Table\\n         \\n        for(int i=0;i<nums.size();i++) //Iterating through the vector\\n        {\\n            ++umap[nums[i]];  //Counting the occurences of a number and storing it in value.\\n            \\n        }\\n        int good_pairs = 0;\\n        for(auto i:umap) //Using the formula \\n        {\\n            int n = i.second; //i.second implies -- value of hash table\\n            good_pairs += ((n)*(n-1))/2;\\n            \\n        }\\n        return good_pairs;\\n        \\n        \\n    }\\n};\\n    \\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n//Program to find the number of good pairs\\n//Good pairs are those in which nums[i] == nums[j] and i<j\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) \\n    {\\n   \\n        unordered_map<int,int> umap; //Initializing a Hash Table\\n         \\n        for(int i=0;i<nums.size();i++) //Iterating through the vector\\n        {\\n            ++umap[nums[i]];  //Counting the occurences of a number and storing it in value.\\n            \\n        }\\n        int good_pairs = 0;\\n        for(auto i:umap) //Using the formula \\n        {\\n            int n = i.second; //i.second implies -- value of hash table\\n            good_pairs += ((n)*(n-1))/2;\\n            \\n        }\\n        return good_pairs;\\n        \\n        \\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 975212,
                "title": "one-pass-o-n-time-using-hashmap",
                "content": "This is a basic concept of **combinations**:\\n```\\nn_C_r = n! / r! * (n-r)!\\n\\nwhere:\\nn_C_r\\t= \\tnumber of combinations\\nn\\t= \\ttotal number of objects in the set\\nr\\t= \\tnumber of choosing objects from the set\\n```\\nHere:\\n* The **set** would be with respect to a unique number at a time. (combinations for each distinct number)\\n* **n** is the number of occurences and **r = 2**, since we are choosing pairs. So replacing these values will lead to the formula: **n * (n-1)/2**\\n**Note**: Even with numbers with frequency 1 in total, the respective pairs will amount to 0 based on above formula. (Hence, 0 pairs)\\n\\n\\n# TL;DR\\n**Approach taken with an example:**\\n\\n- For a number with number of occurences count **n**, the number of good pairs would be: **n * (n-1)/2**\\n- We will consider the data structure **HashMap** that will store **key** as the number and number of occurrences as **value**.\\n\\nSo let\\'s say for array **[1,2,3,1,1,3,5,6,5]**, the Hashmap will have the following entries:\\n```\\n{\\n\\t1 : 3,\\n\\t2 : 1,\\n\\t3 : 2,\\n\\t5 : 2,\\n\\t6 : 1\\n}\\n```\\nThe required count would be: **(3 * 2/2) + (1 * 0/2) + (2 * 1/2) + (2 * 1/2) + (1 * 0/2) = 5**\\n, which is true since the good pairs are: **(0, 3), (0, 4), (3, 4), (2, 5), (6, 8)**\\n\\n**Short & Sweet:**\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        int count = 0;\\n        \\n        for(Integer num : nums)\\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n        \\n        for(Integer currCount : countMap.values())\\n            count += currCount * (currCount-1)/2;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nn_C_r = n! / r! * (n-r)!\\n\\nwhere:\\nn_C_r\\t= \\tnumber of combinations\\nn\\t= \\ttotal number of objects in the set\\nr\\t= \\tnumber of choosing objects from the set\\n```\n```\\n{\\n\\t1 : 3,\\n\\t2 : 1,\\n\\t3 : 2,\\n\\t5 : 2,\\n\\t6 : 1\\n}\\n```\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        int count = 0;\\n        \\n        for(Integer num : nums)\\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n        \\n        for(Integer currCount : countMap.values())\\n            count += currCount * (currCount-1)/2;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732910,
                "title": "my-favorite-story-in-maths-the-prince-of-mathematicians",
                "content": "https://nrich.maths.org/2478 & https://nrich.maths.org/2478\\n\\nCarl Friedrich Gauss (1777-1855) is recognised as being one of the greatest mathematicians of all time.\\n\\nThe most well-known story is a tale from when Gauss was still at primary school. One day Gauss\\' teacher asked his class to add together all the numbers from 1 to 100, assuming that this task would occupy them for quite a while. He was shocked when young Gauss, after a few seconds thought, wrote down the answer 5050. The teacher couldn\\'t understand how his pupil had calculated the sum so quickly in his head, but the eight year old Gauss pointed out that the problem was actually quite simple.\\n![image](https://assets.leetcode.com/users/images/0bdd5099-5631-40e9-b3a6-ad5b11ba2eeb_1594576169.009218.png)\\n\\nHe had added the numbers in pairs \\n1. the first and the last (1+100=101)\\n2. the second and the second to last  (2+99=101) \\n3. and so on...\\n\\nso the total would be 50 lots of 101, which is 5050.\\n\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, arr: List[int]) -> int:\\n        \\n\\t\\t#  Gauss\\'s insight as a child  ->  n(n + 1)/2\\n        def sumASeriesOfConsecutiveNumbers(n):\\n            return n*(n + 1)//2\\n        \\n        res = 0\\n        c = collections.Counter(arr)\\n        for v in c.values():\\n            res += sumASeriesOfConsecutiveNumbers(v-1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numIdenticalPairs(self, arr: List[int]) -> int:\\n        \\n\\t\\t#  Gauss\\'s insight as a child  ->  n(n + 1)/2\\n        def sumASeriesOfConsecutiveNumbers(n):\\n            return n*(n + 1)//2\\n        \\n        res = 0\\n        c = collections.Counter(arr)\\n        for v in c.values():\\n            res += sumASeriesOfConsecutiveNumbers(v-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341032,
                "title": "good-pairs-java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n     int counter = 0;\\n\\n     for(int i = 0; i < nums.length; i++){\\n         for(int j = i+1; j < nums.length; j++){\\n             if(nums[i] == nums[j]){\\n                 counter++;\\n                }\\n            }\\n        }\\n        return counter;   \\n    }\\n}\\n```\\nplease upvote me, to nourish the child of curiosity within me!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n     int counter = 0;\\n\\n     for(int i = 0; i < nums.length; i++){\\n         for(int j = i+1; j < nums.length; j++){\\n             if(nums[i] == nums[j]){\\n                 counter++;\\n                }\\n            }\\n        }\\n        return counter;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941264,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n    unordered_map<int,int> map;\\n    int res=0;\\n    for(int i:nums)\\n        res+=map[i]++;\\n    return res;\\n    }\\n};\\n```\\n\\n**Explanation:**\\n\\n[1,2,3,1,1,3]\\nconsider the above example\\n\\nres=0\\n\\n* iteration 1: map[1]=0 so res=0+0 =0 and map[1]=0+1 =1\\n* iteration 2: map[2]=0 so res=0+0 =0 and map[2]=0+1 =1\\n* iteration 3: map[3]=0 so res=0+0 =0 and map[3]=0+1 =1\\n* iteration 4: map[1]=1 so res=0+1 =1 and map[1]=1+1 =2\\n* iteration 5: map[1]=2 so res=2+1 =3 and map[1]=2+1 =3\\n* iteration 6: map[3]=1 so res=3+1 =4 and map[3]=1+1 =2\\n\\nfinally **res=4** is returned",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n    unordered_map<int,int> map;\\n    int res=0;\\n    for(int i:nums)\\n        res+=map[i]++;\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023592,
                "title": "golang-o-n-solution",
                "content": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    cnt := make(map[int]int)\\n    var pairs int\\n    \\n    for _, num := range nums {\\n\\t\\tpairs += cnt[num]     //if num not in hash map \"cnt\", map returns default value of int (ie 0)\\n        cnt[num]++\\n    } \\n    return pairs\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    cnt := make(map[int]int)\\n    var pairs int\\n    \\n    for _, num := range nums {\\n\\t\\tpairs += cnt[num]     //if num not in hash map \"cnt\", map returns default value of int (ie 0)\\n        cnt[num]++\\n    } \\n    return pairs\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 742796,
                "title": "2-lines-in-javascript-using-counter-for-o-n-brute-o-n-2",
                "content": "Short and sweet:\\n```\\nfunction numIdenticalPairs(nums) { // O(n)\\n  const map = nums.reduce((m, n, i) => m.set(n, (m.get(n)||0) + 1), new Map());\\n  return [...map.values()].reduce((num, n) => num + n * (n - 1) / 2, 0);\\n};\\n```\\n\\nFirst line, count how many times each number appears.\\n2nd line, use the `n(n-1)/2`  to get how many combinations are possible.\\n\\nThis is the intuition for the formula, if you have only one number is zero, if you have a pair is two and so on.\\n\\n1: 0\\n2: 1\\n3: 2 + 1 = 3\\n4: 3 + 2 + 1 = 6\\n5: 4 + 3 + 2 + 1 = 10\\n\\nSo of the formula to getting all natural number added up is: `n(n-1)/2`.\\n\\nAlso, you can use the brute force for O(n^2):\\n\\n```js\\nfunction numIdenticalPairs(nums) { // O(n^2)\\n\\tlet sum = 0;\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tfor (let j = i + 1; j < nums.length; j++) {\\n\\t\\t\\tif (nums[i] === nums[j]) sum++;\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction numIdenticalPairs(nums) { // O(n)\\n  const map = nums.reduce((m, n, i) => m.set(n, (m.get(n)||0) + 1), new Map());\\n  return [...map.values()].reduce((num, n) => num + n * (n - 1) / 2, 0);\\n};\\n```\n```js\\nfunction numIdenticalPairs(nums) { // O(n^2)\\n\\tlet sum = 0;\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tfor (let j = i + 1; j < nums.length; j++) {\\n\\t\\t\\tif (nums[i] === nums[j]) sum++;\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738609,
                "title": "javascript-3-solutions",
                "content": "**Brute force solution:**\\nO(N^2) time + O(1) space\\nlogic:\\n- nested loop i (start from beginning) & j (start from end)\\n- if `nums[i] === nums[j]`, increment count\\n```\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0; \\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = nums.length - 1; j > i; j--) {\\n            if (nums[i] === nums[j]) count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```\\n_____\\n**Optimized Time**\\nO(N) time + O(N) space\\nlogic: \\n- Use an object to store numbers (can also use array since this problem have constraint of `1 <= nums[i] <= 100`\\n- when new number is added to object, set 1 as value\\n- if current number already exist in object, add 1 to current value + add the value to `count`\\n```\\nvar numIdenticalPairs = function(nums) {\\n    const map = {};\\n    let count = 0;\\n    nums.forEach(num => {\\n        if (map[num]) {\\n            count += map[num];\\n            map[num]++;\\n        } else {\\n            map[num] = 1;\\n        }\\n    })\\n    return count;\\n};\\n```\\n____ \\n**Optimized Space**\\nO(NlogN) time + O(1) space\\nlogic: \\n- use sorting to sort nums (sorting takes NlogN time)\\n- have `curCount = 1`  and update it as we see same neighboring numbers in the array\\n- add `curCount` to `totalCount`\\n- reset `curCount` to 1 when neighboring numbers are not the same\\n\\n```\\nvar numIdenticalPairs = function(nums) {\\n    nums.sort();\\n    let totalCount = 0; \\n    let curCount = 1;\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] === nums[i-1]) {\\n            totalCount += curCount;\\n            curCount++;\\n        } else {\\n            curCount = 1;\\n        }\\n    }\\n    \\n    return totalCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0; \\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = nums.length - 1; j > i; j--) {\\n            if (nums[i] === nums[j]) count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```\n```\\nvar numIdenticalPairs = function(nums) {\\n    const map = {};\\n    let count = 0;\\n    nums.forEach(num => {\\n        if (map[num]) {\\n            count += map[num];\\n            map[num]++;\\n        } else {\\n            map[num] = 1;\\n        }\\n    })\\n    return count;\\n};\\n```\n```\\nvar numIdenticalPairs = function(nums) {\\n    nums.sort();\\n    let totalCount = 0; \\n    let curCount = 1;\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] === nums[i-1]) {\\n            totalCount += curCount;\\n            curCount++;\\n        } else {\\n            curCount = 1;\\n        }\\n    }\\n    \\n    return totalCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941242,
                "title": "python-simple-solutions",
                "content": "#### Solution 1: Using count\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            c+=nums[:i].count(nums[i])\\n        return c\\n```\\n\\n#### Solution 2: Using dictionary\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={};c=0\\n        for i in nums:\\n            if i in d:\\n                c+=d[i]\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            c+=nums[:i].count(nums[i])\\n        return c\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={};c=0\\n        for i in nums:\\n            if i in d:\\n                c+=d[i]\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154018,
                "title": "swift-number-of-good-pairs",
                "content": "```swift\\nclass Solution {\\n    func numIdenticalPairs(_ nums: [Int]) -> Int {\\n        var res = 0, map = [Int:Int]()\\n        nums.forEach {\\n            res += map[$0] ?? 0\\n            map[$0,default: 0] += 1\\n        }\\n        return res\\n    }\\n}\\n```\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.031 (0.033) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3,1,1,3]), 4)\\n    }\\n    func test1() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,1,1,1]), 6)\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3]), 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func numIdenticalPairs(_ nums: [Int]) -> Int {\\n        var res = 0, map = [Int:Int]()\\n        nums.forEach {\\n            res += map[$0] ?? 0\\n            map[$0,default: 0] += 1\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.031 (0.033) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3,1,1,3]), 4)\\n    }\\n    func test1() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,1,1,1]), 6)\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3]), 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733661,
                "title": "basic-java-solution",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int i=0,j=0,c=0;\\n        \\n        for(i=0;i<nums.length;i++)\\n        {\\n            for(j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                    c++;;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int i=0,j=0,c=0;\\n        \\n        for(i=0;i<nums.length;i++)\\n        {\\n            for(j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                    c++;;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417146,
                "title": "simple-c-code-beats-100-time",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake two iterators, traverse one iterator from other till the end of the vector and check if both have same value or not.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        std::vector<int>::iterator itr1,itr2;\\n        int count=0;\\n        for(itr1=nums.begin();itr1!=nums.end();itr1++)\\n        {\\n            for(itr2=itr1+1;itr2!=nums.end();itr2++)\\n            {\\n                if(*itr1==*itr2)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        std::vector<int>::iterator itr1,itr2;\\n        int count=0;\\n        for(itr1=nums.begin();itr1!=nums.end();itr1++)\\n        {\\n            for(itr2=itr1+1;itr2!=nums.end();itr2++)\\n            {\\n                if(*itr1==*itr2)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564800,
                "title": "python-o-n-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tcountPairs = 0\\n\\tcounter = {}\\n\\n\\tfor n in nums:\\n\\t\\tif n in counter:\\n\\t\\t\\tcountPairs += counter[n]\\n\\t\\t\\tcounter[n] += 1\\n\\n\\t\\telse:\\n\\t\\t\\tcounter[n] = 1\\n\\n\\treturn countPairs\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tcountPairs = 0\\n\\tcounter = {}\\n\\n\\tfor n in nums:\\n\\t\\tif n in counter:\\n\\t\\t\\tcountPairs += counter[n]\\n\\t\\t\\tcounter[n] += 1\\n\\n\\t\\telse:\\n\\t\\t\\tcounter[n] = 1\\n\\n\\treturn countPairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1122623,
                "title": "clear-explanation-using-combinations-for-pairs",
                "content": "We are asked to return the total number of pairs in a list of numbers  (`pair (i,j)` is called good if `nums[i] == nums[j]` and `i < j`).\\n\\nFirst, let\\'s consider a list of just one number, e.g. `nums = [1]`.  Here, this number cannot be paired with any others (other than itself), so the result is zero.\\n\\nNext, let\\'s consider a list of all idential numbers, e.g. `nums = [1, 1, 1, 1]`.  What we are really being asked is how many combinations of two can be made from such a list.  Using zero based indexing, we have the following six pairs of such combinations:\\n```\\n(0, 1), (0, 2), (0, 3)  # The first number at index 0 can be paired with the others at index locations 1, 2 and 3.\\n        (1, 2), (1, 3)  # The second at index 1 can be paired with its matching pair at index locations 2 and 3.\\n\\t\\t        (2, 3)  # The third at index 2 can form a unique pair with the number at index location 3.\\n```\\n\\nMore generally, the combination formula is `n! / [k! * (n - k)!]`.  In this problem, `n` represents the count of a given number and `k=2` because we are looking at unique pairs.  So the general formula becomes `n! / [2 * (n - 2)!]`.  Noting that  `n! / (n - 2)!` is simply `n * (n - 1)` after cancelling the factorial terms, the total number of unique pairs of the same number can be calculated as `n * (n - 1) / 2`.\\n\\nNow let\\'s say we are given the following ten mixed numbers:\\n`nums = [1, 2, 3, 1, 3, 2, 2, 4, 2, 3]`\\n\\nThe first thing we want to do is count the number of occurrences of each number, so `number: count of number`\\n```\\n1: 2\\n2: 4\\n3: 3\\n4: 1\\n```\\n\\nNote that when `n = 1`, then  `n * (n - 1) / 2` is simply zero and can hence be ignored (one item cannot be paired with any matching item).\\n\\nSo, the result is as follows given the above set of ten numbers with their respective counts:\\n```\\n1: 2 -> 2 * (2 - 1) / 2 = 1\\n2: 4 -> 4 * (4 - 1) / 2 = 6\\n3: 3 -> 3 * (3 - 1) / 2 = 3\\n4: 1 -> 1 * (1 - 1) / 2 = 0\\n```\\nThe answer in this example is thus `1 + 6 + 3 = 10`.\\n\\n<strong>Python Implementations</strong>\\n\\nNote that all of this can be solved simply in python using `Counter` and using a generator expression to sum the calculations for each counted value. Note that `n * (n - 1)` always results in an even number because it is the product of an odd number and an even number.  We can therefore use floor division on the summed result because this summed result will be even. All intermediate results are guaranteed to be integers as is the final result.  Note that summing everything and then dividing by two just once is slightly more efficient that summing all intermediate `n * (n - 1) / 2` calculations.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(num * (num - 1) for num in Counter(nums).values()) // 2\\n```\\n\\nAn alternative solution that just uses one pass (`O(n)` time complexity) to calculated the total pairs:\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        counts = {}\\n        for num in nums:\\n            prior_num_count = counts.get(num, 0)\\n            pairs += prior_num_count\\n            counts[num] = prior_num_count + 1\\n        return pairs\\n```\\n\\nBy observing the cumulative count, one notes that it is equal to the sum of the prior counts plus one minus the current total count (i.e. the prior count). The solution immediately above uses this obvservation, increasing the pairs count by one less than the number of occurrences observed for each number.  This solution has the same `O(n)` space complexity as the prior solution, as they both require the use of a dictionary/hashmap to keep track of the counts for each number observed.\\n\\n```\\ncount: sum of prior counts + (count - 1)\\n1: 0\\n2: 1 (0 + 1)\\n3: 3 (1 + 2)\\n4: 6 (3 + 3)\\n5: 10 (6 + 4)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n(0, 1), (0, 2), (0, 3)  # The first number at index 0 can be paired with the others at index locations 1, 2 and 3.\\n        (1, 2), (1, 3)  # The second at index 1 can be paired with its matching pair at index locations 2 and 3.\\n\\t\\t        (2, 3)  # The third at index 2 can form a unique pair with the number at index location 3.\\n```\n```\\n1: 2\\n2: 4\\n3: 3\\n4: 1\\n```\n```\\n1: 2 -> 2 * (2 - 1) / 2 = 1\\n2: 4 -> 4 * (4 - 1) / 2 = 6\\n3: 3 -> 3 * (3 - 1) / 2 = 3\\n4: 1 -> 1 * (1 - 1) / 2 = 0\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(num * (num - 1) for num in Counter(nums).values()) // 2\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        counts = {}\\n        for num in nums:\\n            prior_num_count = counts.get(num, 0)\\n            pairs += prior_num_count\\n            counts[num] = prior_num_count + 1\\n        return pairs\\n```\n```\\ncount: sum of prior counts + (count - 1)\\n1: 0\\n2: 1 (0 + 1)\\n3: 3 (1 + 2)\\n4: 6 (3 + 3)\\n5: 10 (6 + 4)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195779,
                "title": "java-hashmap-100-faster",
                "content": "**1.** we make a HashMap<Integer, Integer> , which we will use to store freq of each num (How many times every num has appeared in array) \\n\\n**2.** we traverse through nums array and for each num :\\n* we check if ( it is already present in our HashMap or not ):\\n*  * A) num is not already present in HashMap : *Then it has only one occurrence and it can not make pair with itself. We simply put it in HashMap with its frequecy as 1.*\\n B) num is already present in HashMap : Then it means there are (one or) more than one occurrences of it previously and now it can make pairs.  ( but how many pairs?  ) \\n To know how many pairs? we need to know how many times it has previously appeared in the array ( that\\'s why we used HashMap instead of Hashset to store the current frequency of num. )\\n we get the frequency ( k ) of num from HashMap ( which is also equal to the number of  pairs it can make ). add then add freq ( k) to count [ count += k; ]. Then increment the freq of that num by one and put new freq in hashMap [ hs.put(n, k + 1); ]\\n \\n** 3.**  we count all such pairs in \\'count\\' variable. which is our final answer.\\n\\n# CODE:\\n\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> hs = new HashMap<>();\\n        int count = 0;\\n        for (int n : nums) {\\n            if (hs.containsKey(n)) {\\n                int k = hs.get(n);\\n                count += k;\\n                hs.put(n, k + 1);\\n            } else {\\n                hs.put(n, 1);\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```\\n\\n# **EXAMPLE DRY RUN:**\\nwe have have array as { 3,3,3,3 } then we start traversing....\\n\\n**index 0 :** value = 3.... and frequency(3) = 0.... and good pairs = 0; \\n===> update frequency(3) = 1 and still good pairs = 0 bcz only one occurrence of 3 till now.\\n\\n**index 1:** value = 3.... and frequency(3) = 1.... and good pairs = 0;\\n===>access previous frequency(3) = 1 and update good pairs = 0+1 (bcz the \\'3\\' at \\'index 1\\' can make *one* new pair with \\'3\\' at \\'index 0\\')\\n===> update frequency(3) = 2\\n\\n**index 2:** value = 3.... and frequency(3) = 2.... and good pairs = 1; \\n===>access previous frequency(3) = 2 and update good pairs = 0+1+2 (bcz the \\'3\\' at \\'index 2\\' can make* two* new pairs with \\'3\\' at \\'index 1\\' & with \\'3\\' at \\'index 0\\' )\\n===> update frequency(3) = 3.\\n\\n**index 3:** value = 3.... and frequency(3) = 3.... and good pairs = 3;\\n===>access previous frequency(3) = 3 and update good pairs = 0+1+2+3 (bcz the \\'3\\' at \\'index 3\\' can make* three *new pairs with \\'3\\' at \\'index 2\\' & with \\'3\\' at \\'index 1\\' & & with \\'3\\' at \\'index 0\\')\\n===> update frequency(3) = 4.\\n\\n*good pairs* = 0+1+2+3 = 6",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> hs = new HashMap<>();\\n        int count = 0;\\n        for (int n : nums) {\\n            if (hs.containsKey(n)) {\\n                int k = hs.get(n);\\n                count += k;\\n                hs.put(n, k + 1);\\n            } else {\\n                hs.put(n, 1);\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066453,
                "title": "c-java-c-python-easy-to-understand-clean-code-with-comment",
                "content": "This code implements an optimized solution to solve the \"Number of Good Pairs\" problem. The problem requires counting the number of good pairs in an array of integers.\\n\\nTo solve the problem, the code follows these steps:\\n\\n- **Initialization**: An array called \"count\" is created with a size of 101. This array will be used to store the counts of each number. Since the problem specifies that the integers in the array are in the range 1 to 100, using an array of size 101 ensures coverage for all possible values. Additionally, a variable named \"goodPairs\" is initialized to keep track of the count of good pairs found so far. This variable will be returned as the final result.\\n\\n- **Iteration**: The code iterates through the \"nums\" array using a foreach loop. For each number, denoted as \"num,\" the following steps are performed:\\n\\n  a. Incrementing goodPairs: The code increases \"goodPairs\" by the current count of \"num\" in the \"count\" array. This step takes into account the number of existing pairs that \"num\" can form with previous occurrences of the same number. For example, if there are \"x\" occurrences of \"num\" before the current iteration, it means that there are \"x\" pairs that \"num\" can form with those previous occurrences. Therefore, \"goodPairs\" is increased by \"x\".\\n\\n  b. Updating count: The code increments the count of \"num\" in the \"count\" array by 1 to account for the current occurrence of \"num.\" This ensures that all occurrences of each number are correctly counted.\\n\\n- **Return**: Finally, the code returns the value of \"goodPairs,\" which represents the total number of good pairs found in the \"nums\" array.\\n\\nIn summary, the code efficiently solves the problem by using an optimized approach with a time complexity of O(n), where \"n\" is the length of the \"nums\" array. The space complexity is constant, O(1), as it uses a fixed-size array (\"count\") to store the counts, which does not depend on the input size.\\n```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        vector<int> count(101, 0);\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        foreach (int num in nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        count = [0] * 101\\n        goodPairs = 0\\n        for num in nums:\\n            goodPairs += count[num]  # Increase goodPairs by the current count\\n            count[num] += 1  # Increment the count of the number\\n        return goodPairs\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        vector<int> count(101, 0);\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        foreach (int num in nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        count = [0] * 101\\n        goodPairs = 0\\n        for num in nums:\\n            goodPairs += count[num]  # Increase goodPairs by the current count\\n            count[num] += 1  # Increment the count of the number\\n        return goodPairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745047,
                "title": "c-o-n-easy-solution-using-unordered-map",
                "content": "We store the count of each number in unordered map, if the count of a number is greater than 1 then we increase the variable res  and store the number of possible combinations which satisfy the given condition given in the question (nums[i] == nums[j] and i<j)\\n```\\nclass Solution {\\npublic:\\n    \\n    int numIdenticalPairs(vector<int>& nums) {\\n        int res=0;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second > 1){\\n                res += (x.second * (x.second - 1))/2; \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numIdenticalPairs(vector<int>& nums) {\\n        int res=0;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second > 1){\\n                res += (x.second * (x.second - 1))/2; \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731660,
                "title": "optimal-and-suboptimal-completely-explained-with-2-solutions",
                "content": "\\nThis is the bruteforce approach.\\n\\nTime:O(n^2)\\nSpace:O(1)\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        res = 0 \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i] == nums[j]:\\n                    res+=1\\n        return res\\n```\\n\\nThis is the optimal solution which stores the {number,[list of indices of occurence of number]} as an event.\\nThen find the number of number of pairs from each event.\\nTime:O(n) | Space:O(n)\\n\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        events = collections.defaultdict(list)\\n        for idx,num in enumerate(nums):\\n            events[num].append(idx)\\n        count = lambda x:x*(x-1)//2 if x>1 else 0\\n        res = 0 \\n        for event in events:\\n            indices = events[event]\\n            length = len(indices)\\n            ans = count(length)\\n            res+=ans\\n        return res\\n```\\n\\nThis is very critical in the interview setting.Dont get satisfied after proposing the first solution.I mean anyone could do the first\\nsolution and its pretty naive.Discuss all possible approaches with their Time and space complexities.If you observe,its a tradeoff with memory\\nand optimising time in the second solution. In eitherway,both solution are good and we need to choose according to the situation based on time,memory constraints.\\n\\nThanks for your time :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        res = 0 \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i] == nums[j]:\\n                    res+=1\\n        return res\\n```\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        events = collections.defaultdict(list)\\n        for idx,num in enumerate(nums):\\n            events[num].append(idx)\\n        count = lambda x:x*(x-1)//2 if x>1 else 0\\n        res = 0 \\n        for event in events:\\n            indices = events[event]\\n            length = len(indices)\\n            ans = count(length)\\n            res+=ans\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675214,
                "title": "java-o-n-1-line-logic-easy",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int ans = 0;\\n        int[] temp = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            ans += temp[nums[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int ans = 0;\\n        int[] temp = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            ans += temp[nums[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601830,
                "title": "simple-o-n-java-solution-hashmap",
                "content": "**Upvote if you LIKE**\\uD83D\\uDE42 \\nclass Solution {\\n\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                count += hm.get(nums[i]);\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n                hm.put(nums[i],1);\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                count += hm.get(nums[i]);\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 851005,
                "title": "c-0-ms-faster-than-100-00-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        //Using map to store frequencies of each element\\n        map<int,int> count;\\n        \\n        int noOfPairs = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            count[nums[i]]+=1;\\n        }\\n        \\n        //if there are say n 1\\'s then idea is that there will\\n        //will be exactly 1+2+....+(n-1) no. of pairs which is\\n        //(n)*(n-1)/2\\n        \\n        for(auto ele: count){\\n            noOfPairs+=(ele.second)*(ele.second - 1)/2; \\n        }\\n        \\n        return noOfPairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        //Using map to store frequencies of each element\\n        map<int,int> count;\\n        \\n        int noOfPairs = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            count[nums[i]]+=1;\\n        }\\n        \\n        //if there are say n 1\\'s then idea is that there will\\n        //will be exactly 1+2+....+(n-1) no. of pairs which is\\n        //(n)*(n-1)/2\\n        \\n        for(auto ele: count){\\n            noOfPairs+=(ele.second)*(ele.second - 1)/2; \\n        }\\n        \\n        return noOfPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731682,
                "title": "c-simple-o-n-2-solution",
                "content": "```csharp\\npublic int NumIdenticalPairs(int[] nums) \\n{\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tfor(int j = i + 1; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(nums[i] == nums[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumIdenticalPairs(int[] nums) \\n{\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tfor(int j = i + 1; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(nums[i] == nums[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109723,
                "title": "simple-solution-number-of-good-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i<j:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i<j:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873992,
                "title": "javascript-solution-faster-than-97-43-of-other-submissions-map-array-reduce",
                "content": "**Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n***Do upvote if you find this solution useful. Happy Coding!***\\n\\nRuntime: 58 ms\\nMemory Usage: 41.7 MB\\n\\n```\\n\\n/**\\n * @param {number[]} nums\\n * @param {Map} map\\n * @return {number}\\n */\\nconst numIdenticalPairs = (nums, map = new Map(), res = 0) => {\\n    for (let i = 0; i < nums.length; i++) {\\n        let temp = map.get(nums[i]);\\n        if (temp) res += temp;\\n        /** Everytime same value is found in other index it can be paired with \\n         * existing one so adding previous value to result \\n         */\\n        map.set(nums[i], temp ? temp + 1 : 1);\\n    }\\n    return res;\\n};\\n```\\n\\n\\nSolution 2 with Map and Array reduce method a slight variation\\n\\n```\\nconst numIdenticalPairs = (nums, map = new Map()) => nums.reduce((prev, cur) => {\\n    if (map.get(cur)) {\\n        prev += map.get(cur);\\n        map.set(cur, map.get(cur) + 1);\\n    } else {\\n        map.set(cur, 1)\\n    }\\n    return prev;\\n}, 0);\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number[]} nums\\n * @param {Map} map\\n * @return {number}\\n */\\nconst numIdenticalPairs = (nums, map = new Map(), res = 0) => {\\n    for (let i = 0; i < nums.length; i++) {\\n        let temp = map.get(nums[i]);\\n        if (temp) res += temp;\\n        /** Everytime same value is found in other index it can be paired with \\n         * existing one so adding previous value to result \\n         */\\n        map.set(nums[i], temp ? temp + 1 : 1);\\n    }\\n    return res;\\n};\\n```\n```\\nconst numIdenticalPairs = (nums, map = new Map()) => nums.reduce((prev, cur) => {\\n    if (map.get(cur)) {\\n        prev += map.get(cur);\\n        map.set(cur, map.get(cur) + 1);\\n    } else {\\n        map.set(cur, 1)\\n    }\\n    return prev;\\n}, 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651454,
                "title": "c-hashmap-solution-explained",
                "content": "**Hello Everyone!**\\nI hope you find this solution helpful, feel free to comment suggestions and critiques!\\n\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            //Go through the vector given and increment the map by 1\\n\\t\\t\\t// everytime the same number appears. This is counting the \\n\\t\\t\\t// frequency of that number\\n\\t\\t\\t++mp[nums[i]];\\n\\t\\t\\t\\n\\t\\t\\t//If the number shows up more than once, then it has atleast one pair\\n            if (mp[nums[i]] > 1)\\n            {\\n\\t\\t\\t\\t//add to the answer the frequency - 1\\n\\t\\t\\t\\t// (appearing two times means there is one pair, three times is two pairs, etc etc\\n                ans += mp[nums[i]] - 1;       \\n            }\\n        }\\n\\t\\t//return the answer\\n        return ans;\\n    }\\n};\\n```\\nPlease leave an upvote if you found this solution helpful!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            //Go through the vector given and increment the map by 1\\n\\t\\t\\t// everytime the same number appears. This is counting the \\n\\t\\t\\t// frequency of that number\\n\\t\\t\\t++mp[nums[i]];\\n\\t\\t\\t\\n\\t\\t\\t//If the number shows up more than once, then it has atleast one pair\\n            if (mp[nums[i]] > 1)\\n            {\\n\\t\\t\\t\\t//add to the answer the frequency - 1\\n\\t\\t\\t\\t// (appearing two times means there is one pair, three times is two pairs, etc etc\\n                ans += mp[nums[i]] - 1;       \\n            }\\n        }\\n\\t\\t//return the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101026,
                "title": "python-1-liner-without-using-counter",
                "content": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        return (sum(i==j for j in nums for i in nums)-len(nums))//2\\n```",
                "solutionTags": [],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        return (sum(i==j for j in nums for i in nums)-len(nums))//2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 990196,
                "title": "python-3-faster-than-99-48",
                "content": "The solution to this problem uses a small math formula and a hash table. The following is the approach I used,\\n\\n1. Build a dictionary to store the array items as keys and the value is a list of indices where this element appears. Ex: nums = [1,2,1,1]. d = { 1: [0,2,3], 2: [1]}. As I am iterating through the array linearly, this automatically guarantees i < j.\\n2. In this dicitionary check for the presence of lists whose length is greater than 1, which means the element repeats. In those cases, it is the number of pairs we can form with the elements of that list incrementally. Say the lenght of a list is n, this is equivalent to summing up the numbers upto n-1. \\n3. Using Gauss\\'s trick, sum of numbers upto n, is n(n+1) / 2. Modifying it slightly for n-1, it is (n-1)n / 2. Add this for each list whose length is greater than 1 to the answer variable. Ex: consider the dictionary d = { 1: [0,2,3], 2: [1]}, for this list 1 has 3 elements, so we add (3-1) * 3 / 2 = 3 to the answer.\\n\\nFollowing code implements it.\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        ans = 0\\n        d = defaultdict(list)\\n        for i in range(len(nums)):\\n            d[nums[i]].append(i)\\n        # print(d)\\n        for k,v in d.items():\\n            n = len(v)\\n            # print(n)\\n            if n > 1:\\n                ans += ((n-1) * n) // 2\\n        return ans\\n```\\n\\nWhile this is faster than 99.48% python 3 solutions, it doesn\\'t perform that well on space.  Any suggestions are appreciated.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        ans = 0\\n        d = defaultdict(list)\\n        for i in range(len(nums)):\\n            d[nums[i]].append(i)\\n        # print(d)\\n        for k,v in d.items():\\n            n = len(v)\\n            # print(n)\\n            if n > 1:\\n                ans += ((n-1) * n) // 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893146,
                "title": "python-98-with-o-n",
                "content": "Solution1: Brute force\\nTC= O(n*2)\\nSC O(n)\\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                 if nums[i]==nums[j] and i<j:\\n                     count +=1\\n        return count\\n```\\n\\nSolution2 : Optimize in O(n)\\n\\nTC O(n)\\nSC O(1)\\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dic = {}\\n        count =0\\n        \\n        for num in nums:\\n            if num in dic:\\n                count +=dic[num]\\n                dic[num] +=1\\n            else:\\n                dic[num] =1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                 if nums[i]==nums[j] and i<j:\\n                     count +=1\\n        return count\\n```\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dic = {}\\n        count =0\\n        \\n        for num in nums:\\n            if num in dic:\\n                count +=dic[num]\\n                dic[num] +=1\\n            else:\\n                dic[num] =1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 879663,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        int ans=0;\\n        for(auto n:nums){\\n            map[n]++;\\n            ans+=(map[n]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        int ans=0;\\n        for(auto n:nums){\\n            map[n]++;\\n            ans+=(map[n]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185645,
                "title": "easy-java-hashmap-explained",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis Java code defines a method named **numIdenticalPairs** that takes an array of integers nums and returns the number of good pairs of indices **(i, j)** such that **nums[i] == nums[j]** and **i < j**. A good pair is a pair of indices that satisfies the condition.\\n\\nThe code first creates a hash map to store the count of occurrences of each number in the input array. It then iterates over the map and computes the count of good pairs for each number using the formula **m*(m-1)/2**, where m is the count of occurrences of the number. The total count of good pairs is accumulated in the count variable and returned.\\n\\nThe time complexity of the code is **O(n)**, where n is the length of the input array, because it uses a hash map to count the occurrences of each number, which takes **O(n)** time, and then iterates over the map, which takes **O(m)** time where m is the number of distinct numbers in the array (which is usually much smaller than n).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++){\\n            if(map.containsKey(nums[i]))\\n                map.put(nums[i],map.get(nums[i])+1);\\n            else\\n                map.put(nums[i],1);\\n        }\\n        for(Map.Entry<Integer,Integer> e: map.entrySet()){\\n            if(e.getValue()>0){\\n                int m = e.getValue();\\n                count+=(m*(m-1))/2;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n## If you find this helpful then pls upvote me..........",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++){\\n            if(map.containsKey(nums[i]))\\n                map.put(nums[i],map.get(nums[i])+1);\\n            else\\n                map.put(nums[i],1);\\n        }\\n        for(Map.Entry<Integer,Integer> e: map.entrySet()){\\n            if(e.getValue()>0){\\n                int m = e.getValue();\\n                count+=(m*(m-1))/2;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746064,
                "title": "java-simple-explanation-o-n-time-0-ms-faster-than-100",
                "content": "We declared an empty array of size 101 since 101 is the max number given in constraints.\\nThe temp array looks like [0, 0, 0, 0, 0, ... , 0] now.\\n\\nWe are now looping in the given nums array and going to each element and adding it\\'s temp count.\\n\\nLet\\'s understand this by an example.\\nGiven `nums = [1,2,3,1,1,3]`\\nwhen i=0, we will check nums[i] which is num[0] = 1.\\nThen we will go to temp[nums[i]] which is temp[1] = 0 for now. So we will add it to count 0 + 0 = 0.\\nThen we will perform temp[1]++ which means we will make the temp array look like [0,1,0,0,0...0]\\n\\nNow, we will have i =1:\\nnums[1]=2\\ntemp[2]++\\ncount = 0 + 0\\nNow the temp array will look like [0, 1, 1, 0, 0, ... , 0]\\n\\ni = 2\\nnums[2] = 3\\ntemp[3]++\\ncount = 0 + 0\\nNow the temp array will look like [0, 1, 1, 1, 0, 0, ... , 0]\\n\\nNow for i = 3\\nnums[3] = 1\\ntemp[1]++\\ncount = 0 + 1\\nNow the temp array will look like [0, 2, 1, 1, 0, 0, ... , 0]\\n\\nNow for i = 4\\nnums[4] = 1\\ntemp[1]++\\ncount = 1 + 2\\nNow the temp array will look like [0, 3, 1, 1, 0, 0, ... , 0]\\n\\nFor i = 5\\nnums[5] = 3\\ntemp[3]++\\ncount = 3 + 1\\nNow the temp array will look like [0, 3, 1, 2, 0, ... , 0]\\n\\nWe will return count which is 4\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] temp = new int[101];\\n        \\n        int count = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            count += temp[nums[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] temp = new int[101];\\n        \\n        int count = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            count += temp[nums[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544514,
                "title": "easy-java-solution-simple-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length; i ++){\\n            for(int j = i + 1; j < nums.length; j ++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length; i ++){\\n            for(int j = i + 1; j < nums.length; j ++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383728,
                "title": "python3-hash-table-o-n-93-3-faster-98-04-memory-efficient",
                "content": "\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={}\\n        c=0\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                d[nums[i]]+=1\\n                c+=d[nums[i]]\\n            else:\\n                d[nums[i]]=0\\n        return c\\n```\\nPlease Upvote\\nHappy Coding!!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={}\\n        c=0\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                d[nums[i]]+=1\\n                c+=d[nums[i]]\\n            else:\\n                d[nums[i]]=0\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1066531,
                "title": "kotlin-1-line",
                "content": "```\\nfun numIdenticalPairs(a: IntArray) = a.mapIndexed { i, n -> a.slice(i + 1..a.lastIndex).count { it == n } }.sum()\\n```\\n**Approach 2:**\\n```\\nfun numIdenticalPairs(a: IntArray): Int {\\n    var c = 0\\n    a.forEachIndexed { i, n -> for (j in i + 1 until a.size) if (n == a[j]) c++ }\\n    return c\\n}\\n```\\n**Approach 3:**\\n```\\nfun numIdenticalPairs(nums: IntArray): Int {\\n    val map = mutableMapOf<Int, Int>()\\n    var count = 0\\n    nums.forEach {\\n        if (map.containsKey(it)) count += map[it]!!\\n        map[it] = map.getOrDefault(it, 0) + 1\\n    }     \\n    return count\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun numIdenticalPairs(a: IntArray) = a.mapIndexed { i, n -> a.slice(i + 1..a.lastIndex).count { it == n } }.sum()\\n```\n```\\nfun numIdenticalPairs(a: IntArray): Int {\\n    var c = 0\\n    a.forEachIndexed { i, n -> for (j in i + 1 until a.size) if (n == a[j]) c++ }\\n    return c\\n}\\n```\n```\\nfun numIdenticalPairs(nums: IntArray): Int {\\n    val map = mutableMapOf<Int, Int>()\\n    var count = 0\\n    nums.forEach {\\n        if (map.containsKey(it)) count += map[it]!!\\n        map[it] = map.getOrDefault(it, 0) + 1\\n    }     \\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1031419,
                "title": "javascript-solution-93-speed-using-map-and-counter",
                "content": "```/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    const map = new Map();\\n    let pairs = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (map.has(nums[i])) {\\n            pairs += map.get(nums[i]);\\n            map.set(nums[i], map.get(nums[i]) + 1);\\n        } else {\\n            map.set(nums[i], 1);\\n        }\\n    }\\n    return pairs;\\n};\\n\\nWe can also use for...of instead of traditional for loop",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    const map = new Map();\\n    let pairs = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (map.has(nums[i])) {\\n            pairs += map.get(nums[i]);\\n            map.set(nums[i], map.get(nums[i]) + 1);\\n        } else {\\n            map.set(nums[i], 1);\\n        }\\n    }\\n    return pairs;\\n};\\n\\nWe can also use for...of instead of traditional for loop",
                "codeTag": "Unknown"
            },
            {
                "id": 935442,
                "title": "simple-javascript-solution",
                "content": "```\\nvar numIdenticalPairs = function(nums) {\\n      let obj = {};\\n      let counter = 0;\\n\\n      for (val of nums) {\\n        if (obj[val]) {\\n          counter += obj[val];\\n          obj[val]++;\\n        } else {\\n          obj[val] = 1;\\n        }\\n      }\\n      console.log(obj);\\n      return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n      let obj = {};\\n      let counter = 0;\\n\\n      for (val of nums) {\\n        if (obj[val]) {\\n          counter += obj[val];\\n          obj[val]++;\\n        } else {\\n          obj[val] = 1;\\n        }\\n      }\\n      console.log(obj);\\n      return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 837450,
                "title": "python3-solution-with-a-single-pass-and-no-if-else-statements",
                "content": "This solution makes use of a single pass and no if-else statements.\\n\\n[@navinmittal29](https://leetcode.com/navinmittal29) Thanks for your suggestion on how to avoid using the if-else statements in my previous solution.\\n\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        my_count = 0\\n        my_dict = {}\\n        \\n        for n in nums:\\n            # Check to see if number has already been encountered\\n            # and increase count by the number of previous instances\\n            my_count += my_dict.get(n, 0) \\n\\n            # Increase the count of previous observation\\n            # Or store newly encountered number along with its count\\n            my_dict[n] = my_dict.get(n, 0) + 1\\n                \\n        return my_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        my_count = 0\\n        my_dict = {}\\n        \\n        for n in nums:\\n            # Check to see if number has already been encountered\\n            # and increase count by the number of previous instances\\n            my_count += my_dict.get(n, 0) \\n\\n            # Increase the count of previous observation\\n            # Or store newly encountered number along with its count\\n            my_dict[n] = my_dict.get(n, 0) + 1\\n                \\n        return my_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731739,
                "title": "java-python-3-4-1-liners-o-n-counting-codes-w-brief-explanation-and-analysis",
                "content": "For any given `i` items, we have `C(i, 2) = (i - 1) * i / 2` combination options if choosing pairs from the `i` elements.\\n```java\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] cnt = new int[101];\\n        for (int n : nums)\\n            ++cnt[n];\\n        return Arrays.stream(cnt).map(i -> (i - 1) * i / 2).sum();\\n    }\\n```\\n```python\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(v * (v - 1) // 2 for v in Counter(nums).values())\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(R)`, where `R = cnt.length`, the range of the `nums`.",
                "solutionTags": [],
                "code": "```java\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] cnt = new int[101];\\n        for (int n : nums)\\n            ++cnt[n];\\n        return Arrays.stream(cnt).map(i -> (i - 1) * i / 2).sum();\\n    }\\n```\n```python\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(v * (v - 1) // 2 for v in Counter(nums).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3837000,
                "title": "c-3-line-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int ans = 0, freq[101] = {0};\\n        for(auto i : nums) ans += freq[i], freq[i] += 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int ans = 0, freq[101] = {0};\\n        for(auto i : nums) ans += freq[i], freq[i] += 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460814,
                "title": "java-o-n-log-n-hashmap-used-for-beginners-explained",
                "content": "# Approach\\n- Create a hashmap\\n- O(n log n) nested loop setup for finding out pairs\\n- If a key == nums[i] does not exist upon finding a pair, push a pair (nums[i] , 1)\\n- If key exist, increment the value corresponding to the key in the hashmap.\\n- for all the key values in the map, return the sum of all the values  \\n\\n# Complexity\\n- Time complexity: O(n log n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j = i+1;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    if(map.containsKey(nums[i]) == true){\\n                        int value = map.get(nums[i]);\\n                        value++;\\n                        map.put(nums[i],value);\\n                    }else{\\n                        map.put(nums[i],1);\\n                    }\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int val: map.keySet()){\\n            sum += map.get(val);\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/50a24157-7d7e-43a9-8524-2a6d895ec72e_1682603816.5533574.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j = i+1;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    if(map.containsKey(nums[i]) == true){\\n                        int value = map.get(nums[i]);\\n                        value++;\\n                        map.put(nums[i],value);\\n                    }else{\\n                        map.put(nums[i],1);\\n                    }\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int val: map.keySet()){\\n            sum += map.get(val);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379741,
                "title": "find-the-number-of-identical-pairs-in-an-array-of-integers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find the number of identical pairs in an array of integers. We can keep track of the frequency of each integer using a hash map, where the keys are the integers and the values are the frequency of occurrence. Then, for each key in the map, we can calculate the number of pairs that can be formed using the formula n * (n-1) / 2, where n is the frequency of the integer. We can then sum up the number of pairs for each integer to get the total number of identical pairs in the array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is to first create a hash map, where we iterate through the input array and keep track of the frequency of each integer. Then, we iterate through the keys in the map and calculate the number of identical pairs that can be formed using the formula mentioned above. Finally, we sum up the number of pairs for each integer to get the total number of identical pairs in the array.\\n# Complexity\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), where n is the length of the input array. This is because we iterate through the array once to create the hash map, and then iterate through the keys in the map, which has a maximum length of the number of unique integers in the array. The space complexity is also O(n), since we are using a hash map to store the frequency of each integer in the array.\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function (nums) {\\n  let m = {};\\n\\n  nums.forEach((element) => {\\n    if (m[element] == undefined) m[element] = 1;\\n    else m[element]++;\\n  });\\n\\n  let res = 0;\\n\\n  for (const key in m) {\\n    if (Object.hasOwnProperty.call(m, key)) {\\n      const element = m[key];\\n      if (element > 1) res += element * (element / 2 - 0.5);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function (nums) {\\n  let m = {};\\n\\n  nums.forEach((element) => {\\n    if (m[element] == undefined) m[element] = 1;\\n    else m[element]++;\\n  });\\n\\n  let res = 0;\\n\\n  for (const key in m) {\\n    if (Object.hasOwnProperty.call(m, key)) {\\n      const element = m[key];\\n      if (element > 1) res += element * (element / 2 - 0.5);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2977892,
                "title": "beats-100-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int count=0;\\n\\n    for(int i=0;i<nums.length;i++){\\n\\n    if(!mp.containsKey(nums[i])){\\n        mp.put(nums[i],1);\\n    }\\n    else{\\n        count+=mp.get(nums[i]);\\n        mp.put(nums[i],mp.get(nums[i])+1);\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int count=0;\\n\\n    for(int i=0;i<nums.length;i++){\\n\\n    if(!mp.containsKey(nums[i])){\\n        mp.put(nums[i],1);\\n    }\\n    else{\\n        count+=mp.get(nums[i]);\\n        mp.put(nums[i],mp.get(nums[i])+1);\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968656,
                "title": "using-basic-combination-with-bucket-array",
                "content": "# Intuition\\n(Read the note below)\\nSince we have to count the number of pairs using `nCr` which is `n!/(n-r)! * r!`\\nTaking `r = 2`, since we are to count the number of pairs\\n\\n`nC2 = n!/(n-2)! * (2)!`\\n\\n# Approach\\nNow next step was to minimize the value of `nC2` else taking the worst case scenario 100 (max value of nums[i]) it\\'ll lead to overflow since 100! is a very big number. \\n\\nTherefore `nC2 = n! / (n-2)! * 2!`\\n`nC2 = n(n-1)(n-2)! / (n-2)! * 2!`\\n`nC2 = n(n-1) / 2`  _cancelling (n-2)! out_\\n\\n# Complexity\\n- Time complexity: __O(2n)__\\n\\n- Space complexity: __O(101)__\\n\\n# Note\\nbuc_arr[] is used to store the frequency of each element present in the nums vector.\\n\\nThe size is taken as 101 as the maximum value of nums[i] is 100 \\nTherefore that means `buc_arr[nums[i]]` cannot exceed a value of `buc_arr[100]` therefore size taken as `101` i.e. to accomodate all values from 0 to 100 \\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // nC2 = n! / (n-2)! x 2!\\n        // nC2 = n(n-1)(n-2)! / (n-2)! x 2!\\n        // nC2 = n(n-1) / 2\\n\\n        vector<int> buc_arr(101);\\n        for(int x: nums)\\n            buc_arr[x]++;\\n        \\n        int sum = 0;\\n        for(int x: buc_arr) {\\n            sum += x*(x-1)/2;\\n        }\\n\\n        return sum;\\n\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // nC2 = n! / (n-2)! x 2!\\n        // nC2 = n(n-1)(n-2)! / (n-2)! x 2!\\n        // nC2 = n(n-1) / 2\\n\\n        vector<int> buc_arr(101);\\n        for(int x: nums)\\n            buc_arr[x]++;\\n        \\n        int sum = 0;\\n        for(int x: buc_arr) {\\n            sum += x*(x-1)/2;\\n        }\\n\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771165,
                "title": "c-map-math-o-n",
                "content": "***Explanation***\\ncount the occurrence of the same elements.\\nFor each new element a,\\nthere will be more count[a] pairs.\\nwith *A[i] == A[j]* and *i < j*\\n\\n***Explaining the logic:***\\n1) We can store the ints like a key in map, and the indexes save in the vector of ints like a  value in a map. \\nFor example 1, it will be like that:\\n[![image](https://assets.leetcode.com/users/images/72269524-2e0d-4d35-9887-e52b219a6485_1667408712.184323.png)\\n](http://)[](http://)\\n2) It is a fact that, to find the sum of numbers from 1 to n, the formula will be:\\n![image](https://assets.leetcode.com/users/images/8e4d0c3b-e70a-48e1-9377-3f314e0135e2_1667408825.1531677.png)\\n**((n)*(n+1))/2**\\n3) Then we can iterate trough the map and take the size of vectors and apply that formula to the sizes of vectors in map:\\n ``\\n int sum = ((i.second.size()-1)*(i.second.size()))/2;\\n ``\\n 4) and make `ans+=sum`\\n\\n***C++ code with comments:***\\n```\\n int numIdenticalPairs(vector<int>& nums) {\\n        map<int,vector<int>> mp; // creating a map with key - int, and value - vector\\n        for(int i = 0 ; i < nums.size();i++){\\n            // For example: key is 1, and we saving the indexes of this number. Example 1:\\n            // [1]:0,3,4\\n            // [2]:1\\n            // and etc...\\n            mp[nums[i]].push_back(i); \\n        }\\n        //declaring the variable to save the numbers of good pairs\\n        int ans = 0;\\n        \\n        for(auto i : mp){\\n            //using the formula to find the sum of numbers\\n            // ((n)*(n+1))/2\\n            // n - the size of the vector\\n            int sum = ((i.second.size()-1)*(i.second.size()))/2;\\n            // saving it to the ans\\n            ans+=sum;\\n        }\\n        //returning ans\\n        return ans;\\n    }\\n```\\n***C++ code without comments:***\\n```\\nint numIdenticalPairs(vector<int> &nums)\\n{\\n    map<int, vector<int>> mp;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        mp[nums[i]].push_back(i);\\n    }\\n    int ans = 0;\\n    for (auto i : mp)\\n    {\\n        int sum = ((i.second.size() - 1) * (i.second.size())) / 2;\\n\\n        ans += sum;\\n    }\\n    return ans;\\n}\\n```\\n\\n***Complexity***\\nTime O(N)\\nSpace O(N)\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n int numIdenticalPairs(vector<int>& nums) {\\n        map<int,vector<int>> mp; // creating a map with key - int, and value - vector\\n        for(int i = 0 ; i < nums.size();i++){\\n            // For example: key is 1, and we saving the indexes of this number. Example 1:\\n            // [1]:0,3,4\\n            // [2]:1\\n            // and etc...\\n            mp[nums[i]].push_back(i); \\n        }\\n        //declaring the variable to save the numbers of good pairs\\n        int ans = 0;\\n        \\n        for(auto i : mp){\\n            //using the formula to find the sum of numbers\\n            // ((n)*(n+1))/2\\n            // n - the size of the vector\\n            int sum = ((i.second.size()-1)*(i.second.size()))/2;\\n            // saving it to the ans\\n            ans+=sum;\\n        }\\n        //returning ans\\n        return ans;\\n    }\\n```\n```\\nint numIdenticalPairs(vector<int> &nums)\\n{\\n    map<int, vector<int>> mp;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        mp[nums[i]].push_back(i);\\n    }\\n    int ans = 0;\\n    for (auto i : mp)\\n    {\\n        int sum = ((i.second.size() - 1) * (i.second.size())) / 2;\\n\\n        ans += sum;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2671622,
                "title": "c-explained-easy-using-permutation",
                "content": "```\\nThe approach is very simple. Count number of duplicates for each element in a given array and calculate nC2 which is used to select two elements at a time.\\n\\nNote: nC2=n*(n-1)/2\\n```\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++) m[nums[i]]++;\\n        int c=0;\\n        for(auto i:m)\\n        {\\n            int n=i.second;\\n            c+=n*(n-1)/2;\\n        }\\n        return c;\\n    }\\n};\\n```\\n```\\nFeel free to comment if any doubt...\\n```",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nThe approach is very simple. Count number of duplicates for each element in a given array and calculate nC2 which is used to select two elements at a time.\\n\\nNote: nC2=n*(n-1)/2\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++) m[nums[i]]++;\\n        int c=0;\\n        for(auto i:m)\\n        {\\n            int n=i.second;\\n            c+=n*(n-1)/2;\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\nFeel free to comment if any doubt...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514502,
                "title": "java-solution-using-hashmap",
                "content": "Time Complexity : O(N)\\n\\n```\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i])+1);\\n            }\\n            else{\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i])+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2449707,
                "title": "c-o-n-best-explanation-easy-understanding",
                "content": "### ***Use new version of leetcode to see latex expressions properly***\\n***\\n```\\n// Time Complexity = O(n)\\n// Space Complexity = O(n)\\n// Runtime : 0ms, faster than 100.00%\\n// Memory Usage : 7.2 MB, less than 60.74%\\n```\\n\\n```\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        unordered_map<int,int> hashmap;\\n        int goodPairs = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n            hashtable[nums[i]] += 1;\\n        \\n        for(auto element : hashtable)\\n            goodPairs += element.second * (element.second - 1) / 2;\\n        \\n        return goodPairs;\\n    }\\n```\\n\\nFirst, we find the count of numbers in the array with **hashmap**.\\n\\nLet our array be [1,2,3,1,1,3,1,1,3]\\nWe can specify good pairs as the count of same numbers after them.\\nThere are 5 1s in an array, where the positions of the numbers don\\'t matter to us because all we\\'re looking at are the numbers that come after them that are the same as themselves. Returning to our example, after the first 1 will come 4 more 1s. The second future is 3 after 1, the third future is 2 after 1, and so on until 1.\\n\\nNow let **a** be the count of 1 in the array. After the first 1 will come a-1 more 1s. The second future is a-2 after 1, the third future is a-3 after 1, and so on until 1.\\n\\nNow let\\'s change our arr a little bit and let our new array be [1,2,3,1,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]\\nLet **a** be the count of 1s here too\\n\\n\\n\\n| Arr | Count of 1s after ***bold-italic*** value (**a** is count of all 1s) |\\n|:-:| :-:|\\n| [***1***,2,3,1,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]| a-1 |\\n| [1,2,3,***1***,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]| a-2 |\\n| [1,2,3,1,***1***,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]| a-3 |\\n| ... | |\\n| [1,2,3,1,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , ***1***,1]| 1 |\\n\\n****\\nIf check the second column you can see numbers goes to 1 from a-1 so we can specify as\\nTotal number of good pairs = $$[(a-1) + (a-2)+(a-3)+...+1]$$\\n\\n\\nIf we use consecutive numbers formula on *Total number of good pairs*\\n\\n$$\\\\Large\\\\frac {n(firstNumber + lastNumber)}{2}$$  $$\\\\leftarrow$$ this is the **consecutive formula**\\n\\nin our problem,\\n*n* = **a-1**, because when size **a** we start from **a-1** \\nfor example 1s count are 5, its sum of good pairs 4+3+2+1. That\\u2019s why size is 5-1 = 4, so **a-1**.\\n\\n*first number* = **a - 1**,\\n*last number* = **1**,\\n\\nIf we substitute the variables\\n$$\\\\Large\\\\frac {(a-1) * (a-1 + 1)}{2} = \\\\Large\\\\frac{(a-1) * a}{2}$$\\n\\nWith $\\\\large\\\\frac{(a-1) * a}{2}$, we calculate the number of good pairs for each different number and return the sum.\\n\\n**If we use the counts of the numbers we keep in the hashmap in this formula and sum the results, we will find the good pairs in the array.**\\n\\n\\n```\\nbool shouldYouUpvote() { return (I helped == true) ? upvote : nothing; }\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\n// Time Complexity = O(n)\\n// Space Complexity = O(n)\\n// Runtime : 0ms, faster than 100.00%\\n// Memory Usage : 7.2 MB, less than 60.74%\\n```\n```\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        unordered_map<int,int> hashmap;\\n        int goodPairs = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n            hashtable[nums[i]] += 1;\\n        \\n        for(auto element : hashtable)\\n            goodPairs += element.second * (element.second - 1) / 2;\\n        \\n        return goodPairs;\\n    }\\n```\n```\\nbool shouldYouUpvote() { return (I helped == true) ? upvote : nothing; }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2094229,
                "title": "python-oneliner-solution",
                "content": "Here is my python one-liner:\\n\\n```python\\n        return sum(c * (c - 1) // 2 for c in Counter(nums).values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        return sum(c * (c - 1) // 2 for c in Counter(nums).values())\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151026,
                "title": "good-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> smap;\\n        int count =0;\\n        for(int  i =0;i<n;i++)\\n        {\\n            count+=smap[nums[i]];\\n            smap[nums[i]]++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> smap;\\n        int count =0;\\n        for(int  i =0;i<n;i++)\\n        {\\n            count+=smap[nums[i]];\\n            smap[nums[i]]++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987128,
                "title": "java-easiest-100-faster",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\tint answer = 0;\\n\\tint[] freq = new int[102];\\n        \\n\\tfor (int i : nums) {\\n\\t\\tif (freq[i] == 0) freq[i]++;\\n\\t\\telse{\\n\\t\\t\\tanswer += freq[i];\\n\\t\\t\\tfreq[i]++;\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\tint answer = 0;\\n\\tint[] freq = new int[102];\\n        \\n\\tfor (int i : nums) {\\n\\t\\tif (freq[i] == 0) freq[i]++;\\n\\t\\telse{\\n\\t\\t\\tanswer += freq[i];\\n\\t\\t\\tfreq[i]++;\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981334,
                "title": "java-0-ms-runtime-beats-100",
                "content": "**Method 1**: T: O(n\\xB2), S: O(1)\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tfor (int i = 0; i < nums.length; i++)\\n\\t\\tfor (int j = i + 1; j < nums.length; j++)\\n\\t\\t\\tif (nums[i] == nums[j])\\n\\t\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\\n\\n**Method 2**: T: O(n), S: O(n)\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tInteger frequency = frequencyByNum.get(num);\\n\\t\\tif (frequency == null) {\\n\\t\\t\\tfrequencyByNum.put(num, 1);\\n\\t\\t} else {\\n\\t\\t\\tcount += frequency;\\n\\t\\t\\tfrequencyByNum.put(num, frequency + 1);\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\\n\\n**Method 2 but simpler**: T: O(n), S: O(n)\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tif (frequencyByNum.containsKey(num))\\n\\t\\t\\tcount += frequencyByNum.get(num);\\n\\t\\tfrequencyByNum.compute(num, (k, v) -> v == null ? 1 : v + 1);\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tfor (int i = 0; i < nums.length; i++)\\n\\t\\tfor (int j = i + 1; j < nums.length; j++)\\n\\t\\t\\tif (nums[i] == nums[j])\\n\\t\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tInteger frequency = frequencyByNum.get(num);\\n\\t\\tif (frequency == null) {\\n\\t\\t\\tfrequencyByNum.put(num, 1);\\n\\t\\t} else {\\n\\t\\t\\tcount += frequency;\\n\\t\\t\\tfrequencyByNum.put(num, frequency + 1);\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tif (frequencyByNum.containsKey(num))\\n\\t\\t\\tcount += frequencyByNum.get(num);\\n\\t\\tfrequencyByNum.compute(num, (k, v) -> v == null ? 1 : v + 1);\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745974,
                "title": "simplest-solution-with-python-3",
                "content": "```\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        set_nums=set(nums)\\n        good=0\\n        for x in set_nums:\\n            n=nums.count(x)\\n            good+=(n*(n-1))/2 \\n\\t\\t\\t#finding number of occurences of element and using nC2 to find good pairs \\n        return int(good)\\n```",
                "solutionTags": [],
                "code": "```\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        set_nums=set(nums)\\n        good=0\\n        for x in set_nums:\\n            n=nums.count(x)\\n            good+=(n*(n-1))/2 \\n\\t\\t\\t#finding number of occurences of element and using nC2 to find good pairs \\n        return int(good)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 732229,
                "title": "python-faster-than-100-of-submission",
                "content": "```\\n        freq={}\\n        output=0\\n        for num in nums:\\n            if not num in freq:\\n                freq[num]=0\\n            freq[num]+=1\\n        \\n        for num in freq:\\n            n=freq[num]\\n            output+=(n*(n-1)//2)\\n            \\n        return output\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n        freq={}\\n        output=0\\n        for num in nums:\\n            if not num in freq:\\n                freq[num]=0\\n            freq[num]+=1\\n        \\n        for num in freq:\\n            n=freq[num]\\n            output+=(n*(n-1)//2)\\n            \\n        return output\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784488,
                "title": "easiest-c-solution-o-n-time-complexity-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        int ans = 0;\\n        for(auto num : nums){\\n            ans += m[num];\\n            m[num]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        int ans = 0;\\n        for(auto num : nums){\\n            ans += m[num];\\n            m[num]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090562,
                "title": "easy-to-understand-c-code-rt-0-ms-memory-7-2-mb",
                "content": "\\n\\n# Complexity\\n- Runtime: 0 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Memory: 7.2 Mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }return c;\\n    }\\n};\\n```\\nIf you like the code approach, make sure to upvote \\u270C\\uFE0F. \\nGooD Day",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055896,
                "title": "easy-python-solution-more-than-80-beats",
                "content": "simply use nested for loop.\\n```\\nfor i in range(0,len(nums)):\\n    for j in range(i+1,len(nums)):\\n```\\nThe outer loop will run from index 0 upto 2nd last index, because in the inner loop we are comparing the items with rest of the list.\\n\\nThe outer loop starts from i+1 and stop as 2nd last index.\\nThat way we can compare every element with rest of the list, if num[i] equals to num[j] then count it.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(0,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfor i in range(0,len(nums)):\\n    for j in range(i+1,len(nums)):\\n```\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(0,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902383,
                "title": "single-loop-o-n-speed-hash-table-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe good pair quantites are same as how many identical number already accululated each time when you encounter the same number. For example, if number 1 appears 4 times already, then the next time you encounter number 1, that will contribute 4 quantites to the good pair. So we only need to record how many times the number appears and save it in a bucket for that number. That is the hash table. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nTaking advantage of only 100 distinct possible numbers, our hash function can directly map the key to the index of hashmap array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nSince we only for loop once, it is O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nWe need full size hashmap, O(n) space complexity\\n\\n# Code\\n```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int hashmap[101] = {0};\\n    for(int i = 0; i < numsSize; i++){\\n        hashmap[0]+= hashmap[nums[i]]++;\\n    }\\n    return hashmap[0];\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int hashmap[101] = {0};\\n    for(int i = 0; i < numsSize; i++){\\n        hashmap[0]+= hashmap[nums[i]]++;\\n    }\\n    return hashmap[0];\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2432446,
                "title": "java-using-hashmaps",
                "content": "```class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap <Integer, Integer> map = new HashMap<>();\\n        HashMap <Integer, Integer> goodPairs = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int curr = nums[i];\\n            if(!map.containsKey(curr)) {\\n                map.put(curr, 1);\\n            } else {\\n                int occurences = map.get(curr);\\n                occurences = occurences + 1;\\n                map.replace(curr, occurences);\\n                if(!goodPairs.containsKey(curr)) {\\n                    goodPairs.put(curr, 1);\\n                } else {\\n                    int goodP = goodPairs.get(curr);\\n                    int pairs = occurences + (goodP -1);\\n                    goodPairs.replace(curr, pairs);\\n                }\\n                \\n            }\\n        }\\n        \\n        Set <Integer> set = new HashSet<>();\\n        set = goodPairs.keySet();\\n        int sum = 0;\\n        \\n        for(int i: set) {\\n            int value = goodPairs.get(i);\\n            sum = sum + value;\\n        }\\n        \\n        return sum;\\n        \\n        \\n        \\n    }\\n}\\n\\n\\n    //math examples\\n//     when occurences = 2 \\n//    + (goodpair-1)\\n//     good pair = 1\\n    \\n//     occurence = 3\\n//     + (goodpair-1)\\n//     good pair = 3\\n    \\n//     occurence = 4\\n//     + (goodpair - 1)\\n//     good pairs = 6\\n    \\n//     occurence = 5\\n//     + (goodpair-1)\\n    \\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap <Integer, Integer> map = new HashMap<>();\\n        HashMap <Integer, Integer> goodPairs = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int curr = nums[i];\\n            if(!map.containsKey(curr)) {\\n                map.put(curr, 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1976561,
                "title": "python-3-99-fast-3-solutions-each-better-than-the-other",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe can use that brute force which can get us the solution in O(n^2) time.\\nBut that would be a naive solution. \\nEvery following solution is built upon previous solution and give us 99% best result after submission when you submit solution 3.\\n\\n**Solution 1:**\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)\\n            \\n        for indexes in mapping.values():\\n            for i in range(len(indexes)-1):\\n                for j in range(i+1, len(indexes)):\\n                    count += 1\\n                    \\n        return count\\n```\\n        \\n**Solution 2**\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)                \\n            \\n        for indexes in mapping.values():\\n            size = len(indexes)\\n            count += (size * (size-1))//2\\n            \\n        return count\\n```\\n\\n**Solution 3**\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.Counter(nums)\\n        count = 0\\n                \\n        for value in mapping.values():\\n            count += (value * (value-1))//2\\n            \\n        return count\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)\\n            \\n        for indexes in mapping.values():\\n            for i in range(len(indexes)-1):\\n                for j in range(i+1, len(indexes)):\\n                    count += 1\\n                    \\n        return count\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)                \\n            \\n        for indexes in mapping.values():\\n            size = len(indexes)\\n            count += (size * (size-1))//2\\n            \\n        return count\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.Counter(nums)\\n        count = 0\\n                \\n        for value in mapping.values():\\n            count += (value * (value-1))//2\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554480,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0;index<nums.size();index++)\\n        {\\n            for(int jindex=index+1;jindex<nums.size();jindex++)\\n            {\\n                if(nums[index]==nums[jindex])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0;index<nums.size();index++)\\n        {\\n            for(int jindex=index+1;jindex<nums.size();jindex++)\\n            {\\n                if(nums[index]==nums[jindex])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520782,
                "title": "java-simple-o-n-time-complexity-easy-to-understand",
                "content": "\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>(); // to count number of occurences of number\\n        int ans = 0; // result\\n        \\n        for (int i : nums) {\\n            int count = map.getOrDefault(i, 0); // if number doesn\\'t exist in array then simply return 0, else return number of time it occurred\\n\\t\\t\\t/**\\n\\t\\t\\tE.g we have nums = [1,2,3,1,1,3]\\n\\t\\t\\ttill [1,2,3] we have 0 ans, map->[{1,1}, {2,1}, {3,1}]\\n\\t\\t\\t1. now  we have first duplicate number come i.e. 1\\n\\t\\t\\tans updated to 1 and map updated to 2\\n\\t\\t\\tmap->[{1,2}, {2,1}, {3,1}], ans->1\\n\\t\\t\\t2. and now again 1 (index 4)\\n\\t\\t\\tans updated to 3 and map updated to 3\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,1}], ans->3\\n\\t\\t\\t3. now come 3 which is second occurence for number 3\\n\\t\\t\\tans updated to 4 (because for key 3 we have value 1 in map)\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,2}], ans->4\\n\\t\\t\\t4. And answer is 4 {as all indexes travelled}\\n\\t\\t\\n\\t\\t\\t*/\\n            ans += count; // add it to result\\n            map.put(i, count + 1);//update the frequency/count of number in map\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numIdenticalPairs(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>(); // to count number of occurences of number\\n        int ans = 0; // result\\n        \\n        for (int i : nums) {\\n            int count = map.getOrDefault(i, 0); // if number doesn\\'t exist in array then simply return 0, else return number of time it occurred\\n\\t\\t\\t/**\\n\\t\\t\\tE.g we have nums = [1,2,3,1,1,3]\\n\\t\\t\\ttill [1,2,3] we have 0 ans, map->[{1,1}, {2,1}, {3,1}]\\n\\t\\t\\t1. now  we have first duplicate number come i.e. 1\\n\\t\\t\\tans updated to 1 and map updated to 2\\n\\t\\t\\tmap->[{1,2}, {2,1}, {3,1}], ans->1\\n\\t\\t\\t2. and now again 1 (index 4)\\n\\t\\t\\tans updated to 3 and map updated to 3\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,1}], ans->3\\n\\t\\t\\t3. now come 3 which is second occurence for number 3\\n\\t\\t\\tans updated to 4 (because for key 3 we have value 1 in map)\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,2}], ans->4\\n\\t\\t\\t4. And answer is 4 {as all indexes travelled}\\n\\t\\t\\n\\t\\t\\t*/\\n            ans += count; // add it to result\\n            map.put(i, count + 1);//update the frequency/count of number in map\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404812,
                "title": "java-fasted-method-100-working-o-n",
                "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int n = nums.length;\\n            \\n        int goodPairs=0;\\n      \\n        int[] map = new int[101];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            map[nums[i]]++;\\n        }\\n        \\n     \\n        for(int i=0;i<=100;i++){\\n            if(map[i] > 1){\\n                goodPairs += (map[i] * (map[i]-1)) / 2; \\n            }\\n        }\\n        return goodPairs;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int n = nums.length;\\n            \\n        int goodPairs=0;\\n      \\n        int[] map = new int[101];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            map[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1353137,
                "title": "c-hashmap-solution-0-n",
                "content": "\\'\\'\\'\\n  class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\nunordered_map<int,int>dp;\\n        \\n        \\n        int good_pairs,x;good_pairs=0;x=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n             dp[nums[i]]++;  //storing the count of each num;  \\n        }\\n        \\n        for(auto i=dp.begin();i!=dp.end();i++)    \\n      {\\n          if(i->second>1)\\n          {\\n        x=(i->second*(i->second-1))>>1;\\n              good_pairs=good_pairs+x;\\n              \\n          }\\n      }\\n        return good_pairs;\\n    \\n                                       \\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\nunordered_map<int,int>dp;\\n        \\n        \\n        int good_pairs,x;good_pairs=0;x=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n             dp[nums[i]]++;  //storing the count of each num;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1281128,
                "title": "c-simple-you-ll-love-it-guaranteed",
                "content": "If you have Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\nstoring values to set to avoid repeatation.\\n\\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tset<int>set1; int pairs = 0;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tif(set1.find(nums[i]) == set1.end()){\\n\\t\\t\\tint cnt = count(begin(nums), end(nums), nums[i]);\\n\\t\\t\\tpairs += cnt * (cnt-1)/2;\\n\\t\\t\\tset1.insert(nums[i]);\\n\\t\\t}\\n\\t}\\n\\treturn pairs;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tset<int>set1; int pairs = 0;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tif(set1.find(nums[i]) == set1.end()){\\n\\t\\t\\tint cnt = count(begin(nums), end(nums), nums[i]);\\n\\t\\t\\tpairs += cnt * (cnt-1)/2;\\n\\t\\t\\tset1.insert(nums[i]);\\n\\t\\t}\\n\\t}\\n\\treturn pairs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1209470,
                "title": "java-100-solution-with-hashmap",
                "content": "\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       \\n        Map<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put( nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }\\n        \\n        int sum=0;\\n        \\n        for(Integer i: map.keySet())\\n        {\\n            int count=map.get(i);\\n            if(count>1)\\n                sum=sum+(count*(count-1))/2;    //for n items, n*(n-1)/2 pairs exist\\n        }\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       \\n        Map<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put( nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 933762,
                "title": "o-n-javascript-solution",
                "content": "```\\nconst numIdenticalPairs = (nums) => {\\n    \\n    let map = {};\\n    let counter = 0;\\n    \\n    for(val of nums) {\\n        !map[val] ? map[val] = 1 : counter += map[val]++ \\n    }\\n    \\n    return counter;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numIdenticalPairs = (nums) => {\\n    \\n    let map = {};\\n    let counter = 0;\\n    \\n    for(val of nums) {\\n        !map[val] ? map[val] = 1 : counter += map[val]++ \\n    }\\n    \\n    return counter;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 910704,
                "title": "simple-java-solution-with-explaination-0ms-o-n-time-constant-space-100-faster-single-loop",
                "content": "1.take output array of size 101 (since this is the max possible numbers) and count variable to store the total number of pairs.\\n2.start counting frequency of each element. before incrementing frequency just add the current frequency to the count. (why? because we need to add pair i.e. one less than the frequency).\\n3. once loop finishes count will hold the answer.\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[]  op = new int[101];\\n        int c=0;\\n        for(int i:nums) {\\n            c+=op[i]++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[]  op = new int[101];\\n        int c=0;\\n        for(int i:nums) {\\n            c+=op[i]++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819035,
                "title": "python-3-98-52-faster-3-techniques-but-only-1-optimal-solution",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nThere are 3 ways of doing this:\\n1. Use 2 for loops. For every ith element, compare with the remaining i+1 to n elements. If match is found, increase the count. This is T=O(n2) and S=O(1)\\n\\n2. Sort the list before processing it. This way all the matching numbers will be near each other. Now searching for the pair can be done using binary search. Assuming sorting is O(n log n) and binary search for every ith element is also O(n log n), overall T = O(n log n) and S = O(1)\\n\\n3. Using dictionary. Record every elements that we encounter. If the element already exists, then increment it\\'s count. We sum the elements that match and return the result. Here T=O(n) at the expense of space, S=O(n)\\n\\n**Implementation of solution 3:**\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tmapping = collections.defaultdict(int)\\n\\ttotal = 0\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += mapping[nums[i]]\\n\\t\\tmapping[nums[i]] += 1\\n\\treturn total\\n```\\n\\n**If this solution helped, please upvote it for others to take advantage of it and learn their techniques**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tmapping = collections.defaultdict(int)\\n\\ttotal = 0\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += mapping[nums[i]]\\n\\t\\tmapping[nums[i]] += 1\\n\\treturn total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 803606,
                "title": "a-simple-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int , int> m; int sum=0;\\n        for(auto i : nums) m[i]++;\\n        for(auto i : m) {\\n        int num = i.second; \\n        if(num>1) sum += (num*(num-1))/2;  \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int , int> m; int sum=0;\\n        for(auto i : nums) m[i]++;\\n        for(auto i : m) {\\n        int num = i.second; \\n        if(num>1) sum += (num*(num-1))/2;  \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787607,
                "title": "python-sol-by-iteration",
                "content": "Python sol by iteration\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        good_pair_count = 0\\n        \\n        for i in range(size - 1):\\n            \\n            for j in range(i+1, size):\\n                \\n                if nums[i] == nums[j]:\\n                    good_pair_count += 1\\n                    \\n        \\n        return good_pair_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        good_pair_count = 0\\n        \\n        for i in range(size - 1):\\n            \\n            for j in range(i+1, size):\\n                \\n                if nums[i] == nums[j]:\\n                    good_pair_count += 1\\n                    \\n        \\n        return good_pair_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783552,
                "title": "three-java-solutions-including-optimal-0ms-and-100-faster",
                "content": "**Approach 1.** \\nNaive brute force solution. O(N^2) time and O(1) space. Max(N) == 100;\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int  ret = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++){\\n                if (nums[i]==nums[j]) ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n\\n``` \\n**APPROACH 2**. \\nCombinatorics. O(N) time (max(N) == 100) and O(N) space complexity. \\nThis approach is based on the number ways to sample r elements (== 2 in our case) from n elements.\\n**C = n!/(r! * (n-r)!)**\\n\\nTime complexity : O(N) space, space is O(1) since the number n is limited to 100;\\nFactorial calculation is DP based. And we need to use BigInteger to avoid overflows\\n\\n```\\nstatic HashMap<Integer, BigInteger> facts = new HashMap<>();\\n\\n    static {\\n        facts.put(1, BigInteger.ONE);\\n        facts.put(0, BigInteger.ONE);\\n        for (int i = 2; i <= 100; i++) {\\n            fact(i);\\n        }\\n    }\\n        \\n     public static int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int ret = 0;\\n\\n        for (int key : counts.values()) {\\n            int numOfComb = key == 1 ? 0 : calcNumbOfComb(key);\\n            if (numOfComb > 0) ret += numOfComb;\\n        }\\n\\n        return ret;\\n    }\\n\\n    private static int calcNumbOfComb(int i) {\\n\\n        BigInteger nF = fact(i);\\n        BigInteger nrFact = fact(i - 2);\\n        return (nF.divide(BigInteger.TWO.multiply(nrFact))).intValue();\\n    }\\n\\n    private static BigInteger fact(int i) {\\n        if (facts.get(i) == null) {\\n            if (facts.get(i - 1) == null)\\n                facts.put(i - 1, fact(i - 2).multiply(BigInteger.valueOf(i - 1)));\\n            facts.put(i, BigInteger.valueOf(i).multiply(facts.get(i - 1)));\\n        }\\n\\n        return facts.get(i);\\n    }\\n```\\n**APPROACH 2 Optimized**. \\nWe can simplify by canceling (n - 2)! in **C = n!/(r! * (n-r)!)**.\\n**C = n!/(r! * (n-r)!) = n * (n-1) * (n-2)!/(2! * (n-2)!) = n * (n-1)/2**. This means that it is not necessary to caculate factorials which simplifies the solution. \\n\\nHere is an example of experimental way to get the same formula\\n\\n\\t// Sample input: [1,1,1,1]. Start looking from the end of the array.\\n    // Number of ones: 1 -> 0 (+0) possible pairs -> 1 * 0/2\\n    // Number of ones: 2 -> 1 (+1) possible pair -> 2 * 1/2\\n    // Number of ones: 3 -> 3 (+2) possible pairs -> 3 * 2/2\\n    // Number of ones: 4 -> 6 (+3) possible pairs -> 4 * 3/2\\n    // Number of ones: 5 -> 10 (+4) possible pairs -> 5 * 4/2\\n\\t// Number of ones: n ->  x (+ n-1) possible pair -> x = n * (n - 1)/2\\n\\n**Here is the final solution**\\n```\\nimport java.math.BigInteger;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    \\npublic static int numIdenticalPairs(int[] nums) {\\n        // Count frequncies \\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n        \\n        // Maximum 100 iterations\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int ret = 0;\\n        \\n        // Maximum 100 iterations\\n        for (int key : counts.values()) {\\n            ret += key * (key - 1)/2;\\n        }\\n\\n        return ret;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int  ret = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++){\\n                if (nums[i]==nums[j]) ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n\\n```\n```\\nstatic HashMap<Integer, BigInteger> facts = new HashMap<>();\\n\\n    static {\\n        facts.put(1, BigInteger.ONE);\\n        facts.put(0, BigInteger.ONE);\\n        for (int i = 2; i <= 100; i++) {\\n            fact(i);\\n        }\\n    }\\n        \\n     public static int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int ret = 0;\\n\\n        for (int key : counts.values()) {\\n            int numOfComb = key == 1 ? 0 : calcNumbOfComb(key);\\n            if (numOfComb > 0) ret += numOfComb;\\n        }\\n\\n        return ret;\\n    }\\n\\n    private static int calcNumbOfComb(int i) {\\n\\n        BigInteger nF = fact(i);\\n        BigInteger nrFact = fact(i - 2);\\n        return (nF.divide(BigInteger.TWO.multiply(nrFact))).intValue();\\n    }\\n\\n    private static BigInteger fact(int i) {\\n        if (facts.get(i) == null) {\\n            if (facts.get(i - 1) == null)\\n                facts.put(i - 1, fact(i - 2).multiply(BigInteger.valueOf(i - 1)));\\n            facts.put(i, BigInteger.valueOf(i).multiply(facts.get(i - 1)));\\n        }\\n\\n        return facts.get(i);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749449,
                "title": "c-dictionary-o-n-solution",
                "content": "**Solution:** \\n\\nUpdated solution with Kiebus\\'s advice.\\n\\nThe idea is count the occurrence of the same elements. nums[i] will contribute dic[nums[i]] pairs to the result. Time complexity and space complexity are both O(n).\\n\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], 1);\\n            else\\n            {               \\n                cnt += dic[nums[i]];\\n                dic[nums[i]]++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```\\n\\n\\noriginal implmentation\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,List<int>> dic = new Dictionary<int,List<int>>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], new List<int>(){nums[i]});\\n            else\\n            {\\n                cnt += dic[nums[i]].Count;\\n                dic[nums[i]].Add(i);\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], 1);\\n            else\\n            {               \\n                cnt += dic[nums[i]];\\n                dic[nums[i]]++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,List<int>> dic = new Dictionary<int,List<int>>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], new List<int>(){nums[i]});\\n            else\\n            {\\n                cnt += dic[nums[i]].Count;\\n                dic[nums[i]].Add(i);\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736026,
                "title": "c",
                "content": "```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int s = 0, a[101] = { 0 };\\n    for (int i = 0; i < numsSize; i++) s += a[nums[i]]++;\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int s = 0, a[101] = { 0 };\\n    for (int i = 0; i < numsSize; i++) s += a[nums[i]]++;\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 734440,
                "title": "c-solution-hashmap-using-map-o-n-simplest-solution-easy-to-understand",
                "content": "This question uses basic math.\\nAlthough shown in HINT the formula is n(n-1)/2, where n is number of time any number occur.\\nWe don\\'t care about the number but only the number of time any number.\\nAlthough every solution shows in 0ms.\\nBut the solution easy to understand is here.\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();++i){\\n            auto  itr=mp.find(nums[i]);\\n            if(itr==mp.end())\\n                mp.insert(make_pair(nums[i],1));\\n            else\\n                itr->second++;\\n        }\\n        int sum=0;\\n        for(auto it=mp.begin();it!=mp.end();++it){\\n            int z=it->second;\\n            sum+=z*(z-1)/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();++i){\\n            auto  itr=mp.find(nums[i]);\\n            if(itr==mp.end())\\n                mp.insert(make_pair(nums[i],1));\\n            else\\n                itr->second++;\\n        }\\n        int sum=0;\\n        for(auto it=mp.begin();it!=mp.end();++it){\\n            int z=it->second;\\n            sum+=z*(z-1)/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732615,
                "title": "python-3-solution-with-defaultdict",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums) -> int:\\n        \"\"\"\\n        Given an array of numbers, this program determines the\\n        number of good pairs [nums[j], nums[k]]. In a good pair,\\n        j < k and nums[j] = nums[k].\\n        \\n        If there are 2 or more ocurrences of a value within nums, then\\n        there is at least 1 good pair for that value. If there are n\\n        occurrences of a value, the number of good pairs is:\\n        \\n                            n!\\n                      ----------------  or  n * (n - 1) / 2\\n                        (n - 2)! * 2!\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :return: number of good pairs\\n        :rtype: int\\n        \"\"\"\\n        counts = defaultdict(int)\\n        for num in nums:\\n            counts[num] += 1\\n        good_pairs = 0\\n        for count in counts.values():\\n            if count > 1:\\n                good_pairs += count * (count - 1) // 2\\n        return good_pairs\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums) -> int:\\n        \"\"\"\\n        Given an array of numbers, this program determines the\\n        number of good pairs [nums[j], nums[k]]. In a good pair,\\n        j < k and nums[j] = nums[k].\\n        \\n        If there are 2 or more ocurrences of a value within nums, then\\n        there is at least 1 good pair for that value. If there are n\\n        occurrences of a value, the number of good pairs is:\\n        \\n                            n!\\n                      ----------------  or  n * (n - 1) / 2\\n                        (n - 2)! * 2!\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :return: number of good pairs\\n        :rtype: int\\n        \"\"\"\\n        counts = defaultdict(int)\\n        for num in nums:\\n            counts[num] += 1\\n        good_pairs = 0\\n        for count in counts.values():\\n            if count > 1:\\n                good_pairs += count * (count - 1) // 2\\n        return good_pairs\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731702,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i] == nums[j]) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i] == nums[j]) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731616,
                "title": "clean-python-3-counter-and-math-o-n",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n```\\nimport collections\\nimport math\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        counter = collections.Counter(nums)\\n        return sum(math.comb(count, 2) for count in counter.values() if count > 1)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport math\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        counter = collections.Counter(nums)\\n        return sum(math.comb(count, 2) for count in counter.values() if count > 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974306,
                "title": "optimized-with-frequency-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrequency Array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int mx=Arrays.stream(nums).max().getAsInt();\\n        int[] freqArray=new int[mx+1];\\n        for(int i:nums){\\n            freqArray[i]++;\\n        }\\n        int ans=0;\\n        for(int i:freqArray){\\n            ans += (i*(i-1))/2;\\n        }return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int mx=Arrays.stream(nums).max().getAsInt();\\n        int[] freqArray=new int[mx+1];\\n        for(int i:nums){\\n            freqArray[i]++;\\n        }\\n        int ans=0;\\n        for(int i:freqArray){\\n            ans += (i*(i-1))/2;\\n        }return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899512,
                "title": "simple-solution-with-dictionary-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, done with brute force where I achieved the task but time complexity is higher i.e. O(n^2), then come up with this dictionary approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        result={}\\n        res=0\\n\\n        for num in nums:\\n            if num in result:\\n                res+=result[num]\\n                result[num]+=1\\n            else:\\n                result[num]=1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        result={}\\n        res=0\\n\\n        for num in nums:\\n            if num in result:\\n                res+=result[num]\\n                result[num]+=1\\n            else:\\n                result[num]=1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526881,
                "title": "c-java-simple-solution-single-iteration-o-n",
                "content": "\\n# Approach\\nWe will use a HashMap to store the numbers and frequency of those numbers.\\nIn single iteration, we will check if the number exists in map we will increase the count by frequency of the number, and increase the frequncy by 1.\\nIf the number does not exist we will add the number to the map with frequency 1.\\n$$ map <int,\\\\hspace{0.1cm}int> \\\\hspace{0.2cm} $$ key = nums[i], value = frequency\\n$$ count \\\\hspace{0.1cm} += map[nums[i]] \\\\hspace{0.2cm} $$\\n*Let 1 exists 3 times then, [1, 1, 1] --> {0, 1}, {1, 2}, {0, 2}*\\n\\n# Dry run\\n$$nums:$$ [ 1, 2, 3, 1, 1, 3 ] $$ \\\\hspace{0.2cm} n:$$ 6\\n\\n$$ i = 0, $$ map = { } $$ \\\\hspace{0.2cm} count = 0 $$\\n$$ i = 1, $$ map = { {1, 1} } $$ \\\\hspace{0.2cm} count = 0 $$\\n$$ i = 2, $$ map = { {1, 1}, {2, 1} } $$ \\\\hspace{0.2cm} count = 0 $$\\n$$ i = 3, $$ map = { {1, 2}, {2, 1}, {3, 1} } $$ \\\\hspace{0.2cm} count = 1 $$\\n$$ i = 4, $$ map = { {1, 3}, {2, 1}, {3, 1} } $$ \\\\hspace{0.2cm} count = 3 $$\\n$$ i = 5, $$ map = { {1, 3}, {2, 1}, {3, 2} } $$ \\\\hspace{0.2cm} count = 4 $$\\n\\n$$ number \\\\hspace{0.1cm} of \\\\hspace{0.1cm} magic \\\\hspace{0.1cm} pairs: $$ 4\\n\\n*Note:* First update the number then change the frequency.\\n\\n# Complexity\\n- Time complexity: **O(n)** $$ To \\\\hspace{0.2cm} traverse \\\\hspace{0.2cm} once \\\\hspace{0.2cm} through \\\\hspace{0.2cm} the \\\\hspace{0.2cm} given \\\\hspace{0.2cm} array.$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** $$ To \\\\hspace{0.2cm} store \\\\hspace{0.2cm} the \\\\hspace{0.2cm} array \\\\hspace{0.2cm} in  \\\\hspace{0.2cm} a \\\\hspace{0.2cm} hashmap. $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int, int> m;\\n        int count = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (m.count(nums[i]) > 0) {\\n                count += m[nums[i]];\\n                m[nums[i]] = m[nums[i]] + 1;\\n            } else {\\n                m[nums[i]] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (map.containsKey(nums[i])) {\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int, int> m;\\n        int count = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (m.count(nums[i]) > 0) {\\n                count += m[nums[i]];\\n                m[nums[i]] = m[nums[i]] + 1;\\n            } else {\\n                m[nums[i]] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (map.containsKey(nums[i])) {\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497764,
                "title": "c-simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        Dictionary<int, int> id = new();\\n        int ans = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int c= id.GetValueOrDefault(nums[i],0);\\n            ans += c;\\n            id[nums[i]] = c + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        Dictionary<int, int> id = new();\\n        int ans = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int c= id.GetValueOrDefault(nums[i],0);\\n            ans += c;\\n            id[nums[i]] = c + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466162,
                "title": "three-c-easy-solutions-with-time-and-space-complexity",
                "content": "\\n**Solution: 1**\\n\\n\\nSimple just compare the ```ith``` and ```jth``` index.\\n```\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(N^2)\\n    Space Complexity : O(N)\\n*/\\n\\n```\\n\\n**Solution:2**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/\\n\\n\\n```\\n\\n\\n**Solution: 3**\\n\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/    \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```ith```\n```jth```\n```\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(N^2)\\n    Space Complexity : O(N)\\n*/\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289788,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280312,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: 82 ms.Beats 76.37% of other solutions.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:38.2 MB.Beats 15.19% of other solutions.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.Length-1;i++){\\n            for(int j=i+1;j<nums.Length;j++)\\n            if(nums[i]==nums[j])count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.Length-1;i++){\\n            for(int j=i+1;j<nums.Length;j++)\\n            if(nums[i]==nums[j])count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168634,
                "title": "python-2-ways",
                "content": "# O(n) time, O(n) space\\nFirst solution is a **hash table**-based approach to count the number of good pairs. Here I use a dictionary `repeats` where the keys are the unique integers in `nums` and the values are the number of times that integer appears in `nums`. Then iterate through `nums` and increments the count of pairs by the number of times the current integer has already appeared in `nums`.\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        repeats: dict[int, int] = {}\\n        pairs = 0\\n        for num in nums:\\n            if num in repeats:\\n                pairs += repeats[num]\\n                repeats[num] += 1\\n            else:\\n                repeats[num] = 1\\n        return pairs\\n\\n```\\n# O(n^2) time, O(1) space\\nSecond solution is a nested loop approach to count the number of good pairs in the given array of integers `nums`. Here I use an outer loop to iterate through `nums`, and an inner loop to compare the current integer to each subsequent integer in `nums`. If the current integer and the next integer are equal, increments the count of pairs.\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        for i, left in enumerate(nums):\\n            j = i + 1\\n            while j < len(nums):\\n                right = nums[j]\\n                if left == right:\\n                    pairs += 1\\n                j += 1\\n        return pairs\\n```\\n...but runtime and memory consumption in submissions are almost equal",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        repeats: dict[int, int] = {}\\n        pairs = 0\\n        for num in nums:\\n            if num in repeats:\\n                pairs += repeats[num]\\n                repeats[num] += 1\\n            else:\\n                repeats[num] = 1\\n        return pairs\\n\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        for i, left in enumerate(nums):\\n            j = i + 1\\n            while j < len(nums):\\n                right = nums[j]\\n                if left == right:\\n                    pairs += 1\\n                j += 1\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063412,
                "title": "java-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to use two for loops but then I decided to reduce the time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used a hashmap which stores the elements count and for the elements having count more than 1,I will apply the formula n*(n-1)/2 as among them we need to choose the pairs and finally add the value to the variable pairs\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!hm.containsKey(nums[i]))\\n                hm.put(nums[i],1);\\n            else{\\n                int val=hm.get(nums[i]);\\n                val++;\\n                hm.put(nums[i],val);\\n            }\\n        }\\n        for(Map.Entry<Integer,Integer> entry : hm.entrySet()) {\\n            int val=entry.getValue();\\n            if(val>1){\\n                pairs+=val*(val-1)/2;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!hm.containsKey(nums[i]))\\n                hm.put(nums[i],1);\\n            else{\\n                int val=hm.get(nums[i]);\\n                val++;\\n                hm.put(nums[i],val);\\n            }\\n        }\\n        for(Map.Entry<Integer,Integer> entry : hm.entrySet()) {\\n            int val=entry.getValue();\\n            if(val>1){\\n                pairs+=val*(val-1)/2;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979550,
                "title": "c-hashmap-explained-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hashmap;\\n        int count=0;\\n        for (int i=0;i<nums.size();i++){\\n    //we will increase the frequency if we encounter the same number again\\n            hashmap[nums[i]]++;\\n//we will add counts of pairs by freq-1 for ex if freq 2 pair will be 1 ,if freq is 3 pair will be 2 etc etc.\\n            if (hashmap[nums[i]]>1){\\n                count+=hashmap[nums[i]]-1;\\n            }\\n       \\n        }\\n//return the ans\\n        return count;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hashmap;\\n        int count=0;\\n        for (int i=0;i<nums.size();i++){\\n    //we will increase the frequency if we encounter the same number again\\n            hashmap[nums[i]]++;\\n//we will add counts of pairs by freq-1 for ex if freq 2 pair will be 1 ,if freq is 3 pair will be 2 etc etc.\\n            if (hashmap[nums[i]]>1){\\n                count+=hashmap[nums[i]]-1;\\n            }\\n       \\n        }\\n//return the ans\\n        return count;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972803,
                "title": "c-solution-2ms-simpleapproach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937996,
                "title": "using-java-simple-code",
                "content": "# Intuition\\nwithout any advance method \\n\\n# Approach\\nmatching approach\\n# Complexity\\n- Time complexity:\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int numIdenticalPairs(int[] nums) {\\n        int c=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int numIdenticalPairs(int[] nums) {\\n        int c=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853022,
                "title": "0ms-solution",
                "content": "```\\nfunc numIdenticalPairs(nums []int) int {\\n\\tvar res int\\n\\thashMap := make(map[int]int)\\n\\tfor _, val := range nums {\\n\\t\\thashMap[val]++\\n\\t}\\n\\tfor _, element := range hashMap {\\n\\t\\tfor i := element - 1; i > 0; i-- {\\n\\t\\t\\tres = res + i\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numIdenticalPairs(nums []int) int {\\n\\tvar res int\\n\\thashMap := make(map[int]int)\\n\\tfor _, val := range nums {\\n\\t\\thashMap[val]++\\n\\t}\\n\\tfor _, element := range hashMap {\\n\\t\\tfor i := element - 1; i > 0; i-- {\\n\\t\\t\\tres = res + i\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2830033,
                "title": "c-nested-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe input size is small enough we can just do nested loops.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWell, nested loops.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int good_pairs = 0;\\n        for (int i = 0; i < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j)\\n                good_pairs += nums[i] == nums[j];\\n        \\n        return good_pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int good_pairs = 0;\\n        for (int i = 0; i < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j)\\n                good_pairs += nums[i] == nums[j];\\n        \\n        return good_pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788796,
                "title": "o-n-java",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer,Integer> m=new HashMap<>();\\n        for(int i:nums)m.put(i,m.getOrDefault(i,0)+1);\\n        \\n        int c=0;\\n        \\n        for(int i:m.keySet()){\\n            int n=m.get(i);\\n            int val=n-1;\\n            if(n>1)c+=(val*(val+1))/2;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer,Integer> m=new HashMap<>();\\n        for(int i:nums)m.put(i,m.getOrDefault(i,0)+1);\\n        \\n        int c=0;\\n        \\n        for(int i:m.keySet()){\\n            int n=m.get(i);\\n            int val=n-1;\\n            if(n>1)c+=(val*(val+1))/2;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785405,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++)\\n                if(nums[i]==nums[j])\\n                    count++;\\n        }\\n        return count;\\n    }\\n\\t}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++)\\n                if(nums[i]==nums[j])\\n                    count++;\\n        }\\n        return count;\\n    }\\n\\t}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2784238,
                "title": "easy-c-o-n-soln-faang-interview-optimized-code",
                "content": "# **Plz Upvote if it helps \\uD83D\\uDE4F**\\n\\n# \\uD83D\\uDC49 Approach-1  (O(n^2) using Bruteforce)\\n> Time Complexity: O(n^2) \\nSpace Complexity: O(1)\\n![Screenshot (3405).png](https://assets.leetcode.com/users/images/dd357b66-2fcc-49a1-8b50-6abf5d4ac4e4_1667720335.9933274.png)\\n\\n\\n# \\uD83D\\uDC49 Approach-2  (O(nlogn) using sort())\\n\\n> Time Complexity: O(nlogn) \\nSpace Complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int count = 1 , p = 0;\\n        for(int i = 0 ; i < nums.size()-1 ; i++){\\n            if(nums[i] == nums[i+1])\\n                count++;\\n            else{\\n                p = p + count*(count-1)/2;\\n                count = 1;\\n            }      \\n        }\\n        p = p + count*(count-1)/2;\\n        return p;\\n    }\\n};\\n```\\n\\n# \\uD83D\\uDC49 Approach-3  (Most Optimal \\uD83D\\uDD25 O(n) using Unordered map )\\n\\n1) Create an unordered map and store no. of time all elements occur in nums.\\n2) If count>1, use the combination formula NC2, which gives n*(n-1)/2;\\n\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n> Time Complexity: O(n) \\uD83D\\uDCAF\\uD83D\\uDCA8\\nSpace Complexity: O(n)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n       unordered_map <int,int> mp;\\n       int res=0;\\n       for(int i = 0 ; i < nums.size() ; i++){\\n           mp[nums[i]]++;\\n       }\\n       for(auto it : mp){\\n           if(it.second>1)\\n               res+=it.second*(it.second-1)/2;\\n       }\\n       return res;\\n    }\\n};\\n```\\n\\n#### ***For \\'n\\' numbers you can have nC2 pairs, which is equal to (n*(n-1))/2.**\\n\\n**I hope it cleared your doubt, if not you can check this out (https://stackoverflow.com/questions/18859430/how-do-i-get-the-total-number-of-unique-pairs-of-a-set-in-the-database)**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int count = 1 , p = 0;\\n        for(int i = 0 ; i < nums.size()-1 ; i++){\\n            if(nums[i] == nums[i+1])\\n                count++;\\n            else{\\n                p = p + count*(count-1)/2;\\n                count = 1;\\n            }      \\n        }\\n        p = p + count*(count-1)/2;\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n       unordered_map <int,int> mp;\\n       int res=0;\\n       for(int i = 0 ; i < nums.size() ; i++){\\n           mp[nums[i]]++;\\n       }\\n       for(auto it : mp){\\n           if(it.second>1)\\n               res+=it.second*(it.second-1)/2;\\n       }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766771,
                "title": "java-easy-solution",
                "content": "Time Complexity: O(N^2)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs = 0;\\n        int length = nums.length;\\n        for (int i = 0; i < length; i++) {\\n            for (int j = i + 1; j < length; j++) {\\n                if (nums[i] == nums[j])\\n                    pairs++;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs = 0;\\n        int length = nums.length;\\n        for (int i = 0; i < length; i++) {\\n            for (int j = i + 1; j < length; j++) {\\n                if (nums[i] == nums[j])\\n                    pairs++;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726864,
                "title": "0ms-100-fastest-cpp-solution-using-hash-map",
                "content": "\\n# # Abb is ke liye ek upvote tho bantha hai yaar..\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numIdenticalPairs(vector<int>& nums) {\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tunordered_map <int,int> mp;\\n\\t\\t\\tfor(int i=0;  i<nums.size();  i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotal  +=  mp[nums[i]];\\n\\t\\t\\t\\tmp[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numIdenticalPairs(vector<int>& nums) {\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tunordered_map <int,int> mp;\\n\\t\\t\\tfor(int i=0;  i<nums.size();  i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotal  +=  mp[nums[i]];\\n\\t\\t\\t\\tmp[nums[i]]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2672879,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int sum = 0;\\n        map<int,int>mp;//To keep track of how many times elements of nums occur\\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            sum += mp[nums[i]]++;//if we get an element, check in map how many times it has occured before and add in sum\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int sum = 0;\\n        map<int,int>mp;//To keep track of how many times elements of nums occur\\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            sum += mp[nums[i]]++;//if we get an element, check in map how many times it has occured before and add in sum\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672346,
                "title": "100-faster-with-easy-understand",
                "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count =0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count =0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2552019,
                "title": "java-hashmap-mathematics-combinations-nc2",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            hm.put(arr[i], hm.getOrDefault(arr[i], 0)+1);\\n        }\\n        int ans = 0;\\n        for(Map.Entry<Integer, Integer> m: hm.entrySet()){\\n            int i = m.getValue();\\n            int res = (i*(i-1))/2;\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            hm.put(arr[i], hm.getOrDefault(arr[i], 0)+1);\\n        }\\n        int ans = 0;\\n        for(Map.Entry<Integer, Integer> m: hm.entrySet()){\\n            int i = m.getValue();\\n            int res = (i*(i-1))/2;\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473799,
                "title": "java-solution-95-faster",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       int i=0;\\n            int j=i+1;\\n            int count=0;\\n            while (i<nums.length-1){\\n                if (nums[i]==nums[j])\\n                    count++;\\n                j++;\\n                if (j==nums.length) {\\n                    i++;\\n                    j=i+1;\\n                }\\n            }\\n            return count; \\n    }\\n}\\n```\\nPlease Give a upvote if you find this helpful",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       int i=0;\\n            int j=i+1;\\n            int count=0;\\n            while (i<nums.length-1){\\n                if (nums[i]==nums[j])\\n                    count++;\\n                j++;\\n                if (j==nums.length) {\\n                    i++;\\n                    j=i+1;\\n                }\\n            }\\n            return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400203,
                "title": "python-o-2-solution",
                "content": "```\\nclass SolutionTwo:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n\\n        goodPairs = 0;\\n        for i in range(0, len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if (nums[i] == nums[j]):\\n                    goodPairs += 1;\\n\\n        return goodPairs;\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass SolutionTwo:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n\\n        goodPairs = 0;\\n        for i in range(0, len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if (nums[i] == nums[j]):\\n                    goodPairs += 1;\\n\\n        return goodPairs;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295967,
                "title": "solution-in-o-n-time-python",
                "content": "If we consider the following example: [1, 2, 3, 1, 1, 2, 1]\\nWe have 6 (1, 1) pairs and 1 (2, 2), total is 7.\\n\\nIn the array, 1 appears 4 times and that gives us 6 pairs, 2 appears twice and that gives 1 pair.\\nWe can try to figure out a relation between frequence of appearance of a number and the numbers of good pairs that genarates.\\n\\nIf we take number 1, based on the following figure, we have 3 + 2 +1 = 6 good pairs.\\nIf we generalize that, if **k is the frequency** of a number in the array, the number of pairs generated by k would be the sum **(k-1) + (k-2) + ... + 1** and that is the sum of the first (k-1) numbers, which is equal to: **(k-1)k/2**.\\n\\n![image](https://assets.leetcode.com/users/images/de7704ef-6180-4263-b806-47245d4efcea_1658072374.5028248.png)\\n\\n\\nSo, first, we need to keep track of the appearance of a number in the array. We can achieve that by using a hashmap/dictionary.\\n```python\\nfor num in nums:\\n\\tif num in freq:\\n\\t\\tfreq[num] += 1\\n\\telse:\\n\\t\\tfreq[num] = 1\\n```\\n\\nSecond, we iterate through the frequencies, and sum up the number of pairs each frequency generates.\\n```python\\nfor num in freq:\\n\\tcount += (freq[num]*(freq[num]-1)//2)\\n```\\n\\nA solution to this problem would then be:\\n\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        freq = {}\\n        for num in nums:\\n            if num in freq:\\n                freq[num] += 1\\n            else:\\n                freq[num] = 1\\n        for num in freq:\\n            count += (freq[num]*(freq[num]-1)//2)\\n        return count \\n```\\n\\n**Time Complexity**: O(N), N being the number of elements in the array. First we iterate though the array to calculate the frequencies. That is done in O(N) time. Then we iterate through the dictionary once to calculate the number of good pairs, that is in worst-case (all numbers are different) done in O(N) time. So, total is O(2N) ~ O(N).\\n**Space Complexity**: O(N), we use a dictionaty to keep track of the frequencies, which in worst-case (all numbers are different) consumes N extra space.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfor num in nums:\\n\\tif num in freq:\\n\\t\\tfreq[num] += 1\\n\\telse:\\n\\t\\tfreq[num] = 1\\n```\n```python\\nfor num in freq:\\n\\tcount += (freq[num]*(freq[num]-1)//2)\\n```\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        freq = {}\\n        for num in nums:\\n            if num in freq:\\n                freq[num] += 1\\n            else:\\n                freq[num] = 1\\n        for num in freq:\\n            count += (freq[num]*(freq[num]-1)//2)\\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250415,
                "title": "python3-o-n-o-n-runtime-47ms-60-77-memory-13-8mb-95-62",
                "content": "```\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 60.77% Memory: 13.8mb 95.62%\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\t\\t\\t\\n        freqOfNumber = Counter(nums)\\n\\t\\t\\n        return sum([key * (key - 1) // 2 for key in freqOfNumber.values()])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 60.77% Memory: 13.8mb 95.62%\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\t\\t\\t\\n        freqOfNumber = Counter(nums)\\n\\t\\t\\n        return sum([key * (key - 1) // 2 for key in freqOfNumber.values()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189733,
                "title": "python-using-hashmap",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        dic = {}\\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] in dic:\\n                ans += dic[nums[i]]\\n                dic[nums[i]] += 1\\n            else:\\n                dic[nums[i]] = 1 \\n        return ans\\n```\\nTime : O(N)\\nSpace : O(N)\\nPlease **UPVOTE**.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        dic = {}\\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] in dic:\\n                ans += dic[nums[i]]\\n                dic[nums[i]] += 1\\n            else:\\n                dic[nums[i]] = 1 \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967855,
                "title": "java-0ms-counting-explanation-simple",
                "content": "The trick to solving this problem is to realize that for any given number, the number of \"good pairs\" that can be made with this number is the number of times we have seen this number previously in the array.\\n\\nWith the above logic, we just need to **iterate** over the input and **count** the number of times we have seen a given number so far, then add that to the total result before incrementing the count for the current number.\\n\\nSomething very important to mention, is that we can only get away with using an array of size 101 because the problem constraints state that no number in the input will be greater than 100. If this constaint didn\\'t exist, we could use something like a **HashMap** to keep track of the counts.\\n\\nUsing a **HashMap** instead of the array is perfectly acceptable and does yield the same runtime, but in practice will be much slower because of **overhead** from the **HashMap**. To recap, the use of a **HashMap** would not change the runtime complexity but it does make the practical performance worse.\\n\\n**Runtime Complexity - O(N)**\\n**Memory Complexity - O(1)**\\nwhere N is the size of the input array.\\n```\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] counts = new int[101];\\n        \\n        int toReturn = 0;\\n        for(int num : nums) {\\n            toReturn += counts[num];\\n            counts[num]++;\\n        }\\n        \\n        return toReturn;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] counts = new int[101];\\n        \\n        int toReturn = 0;\\n        for(int num : nums) {\\n            toReturn += counts[num];\\n            counts[num]++;\\n        }\\n        \\n        return toReturn;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730842,
                "title": "python-beginner-65-fast-using-hashmap-and-explanation",
                "content": "1. getting the count of all the numbers in a hashmap.\\n2. the number can only make a pair when it has frequency in the map more than once so we traverse the array checking frequence in the map we made\\n3. if the frequency is more than one we add to the result no of pairs it can make (number of pairs it can make is 1 less then the current frequency).\\n4. after we add to the result we subtract from the frequency of the count and continue in the loop.\\n\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = Counter(nums)\\n        \\n        #for n in nums:\\n        #    count[n] += 1\\n            \\n        res = 0\\n        \\n        for i in nums:\\n            if count[i] > 1:\\n                res += count[i] - 1\\n                count[i] -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = Counter(nums)\\n        \\n        #for n in nums:\\n        #    count[n] += 1\\n            \\n        res = 0\\n        \\n        for i in nums:\\n            if count[i] > 1:\\n                res += count[i] - 1\\n                count[i] -= 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1701546,
                "title": "100-faster-solution-using-unordered-map-self-explainable",
                "content": "Guys do upvote if you like it, Please.\\nI have used a unordered map to count the occurence of elements in the array .\\nAfter counting ,if count>=2 we need to add their possible no.of pairs to sum(result)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(int i=0;i<nums.size();i++)\\n            map[nums[i]]++;\\n        \\n        int sum=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        { \\n            int count=0;\\n            if(it->second>1)\\n            {\\n                for(int i=1;i<it->second;i++)\\n                    count+=i;\\n                \\n                sum+=count;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(int i=0;i<nums.size();i++)\\n            map[nums[i]]++;\\n        \\n        int sum=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        { \\n            int count=0;\\n            if(it->second>1)\\n            {\\n                for(int i=1;i<it->second;i++)\\n                    count+=i;\\n                \\n                sum+=count;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623759,
                "title": "python-99-7-faster-optimal-hashmap-solution",
                "content": "For the O(n) TC, O(n) SC solution, I used a dictionary to map the number to the number of times a value appears, starting from the last value.\\nI started from the last value because then the next time we see that number, we can count it as a good pair, since the index of the new number will be smaller than the index of the number we have in the dictionary. \\nIf the number is in the dictionary, we can increment our # of good pairs by adding the # of times we\\'ve seen the value.\\nFor example, if we have [1,1,1,1], we add 1 for the i = 2, 2 for i = 1, and 3 for the i = 0. We increment the counter in the dictionary after we\\'ve updated the count so we don\\'t include i = i as a good pair. This is effectively the same as ```n * (n - 1) / 2```, which is the sum from 1 to n-1.\\n\\n```\\n        count, nums_dict = 0, {}\\n        \\n        for i in range(-1, -(len(nums) + 1), -1):\\n            if nums[i] not in nums_dict:\\n                nums_dict[nums[i]] = 1\\n            else:\\n                count += nums_dict[nums[i]]\\n                nums_dict[nums[i]] += 1\\n        print(nums_dict)\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```n * (n - 1) / 2```\n```\\n        count, nums_dict = 0, {}\\n        \\n        for i in range(-1, -(len(nums) + 1), -1):\\n            if nums[i] not in nums_dict:\\n                nums_dict[nums[i]] = 1\\n            else:\\n                count += nums_dict[nums[i]]\\n                nums_dict[nums[i]] += 1\\n        print(nums_dict)\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1554481,
                "title": "easy-to-understand-with-and-without-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            for(int jindex = index + 1 ; jindex < nums.size() ; jindex++)\\n                if(nums[index] == nums[jindex])\\n                  count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n       \\n        int res = 0;\\n        \\n        for(auto n : nums)\\n        {\\n            res += map[n]++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        \\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            map[nums[index]]++;\\n        }\\n        \\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            int n = map[nums[index]];\\n            map[nums[index]] = 0;\\n            count += (n * (n - 1))/2;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            for(int jindex = index + 1 ; jindex < nums.size() ; jindex++)\\n                if(nums[index] == nums[jindex])\\n                  count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n       \\n        int res = 0;\\n        \\n        for(auto n : nums)\\n        {\\n            res += map[n]++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        \\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            map[nums[index]]++;\\n        }\\n        \\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            int n = map[nums[index]];\\n            map[nums[index]] = 0;\\n            count += (n * (n - 1))/2;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495575,
                "title": "super-fast-100",
                "content": "int result =0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                result+=map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n       return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "int result =0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                result+=map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n       return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1479230,
                "title": "python3-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mydict = {}\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] += 1\\n        \\n        count = 0\\n        for i in mydict:\\n            count += (mydict[i]*(mydict[i]-1))/2\\n        return int(count)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mydict = {}",
                "codeTag": "Java"
            },
            {
                "id": 1469620,
                "title": "0-ms-faster-java-hashmap-with-inline-comments",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //declare and initialize a count variable that keeps track of pairs\\n\\t\\tint count = 0;\\n\\t\\t// declare a HashMap that stores <K,V> in form of <nums[i], frequency of nums[i]>\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\t\\n\\t\\t//loop once through the array to store <K,V> in map\\n\\t\\tfor(int i = 0 ; i < nums.length; i++) {\\n\\t\\t\\t//check if map contains nums[i]\\n\\t\\t\\tif(map.containsKey(nums[i])) {\\n                // increase the count as nums[i] is repeated\\n\\t\\t\\t\\tcount += map.get(nums[i]);\\n\\t\\t\\t\\t//if nums[i] exists; add it to the map and increase it\\'s frequency.\\n\\t\\t\\t\\tmap.put(nums[i], map.get(nums[i]) + 1);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n                //add it to map and initialize count to 1 (first occurence of nums[i])\\n\\t\\t\\t\\tmap.put(nums[i], 1);\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```\\ninputs appreciated.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //declare and initialize a count variable that keeps track of pairs\\n\\t\\tint count = 0;\\n\\t\\t// declare a HashMap that stores <K,V> in form of <nums[i], frequency of nums[i]>\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\t\\n\\t\\t//loop once through the array to store <K,V> in map\\n\\t\\tfor(int i = 0 ; i < nums.length; i++) {\\n\\t\\t\\t//check if map contains nums[i]\\n\\t\\t\\tif(map.containsKey(nums[i])) {\\n                // increase the count as nums[i] is repeated\\n\\t\\t\\t\\tcount += map.get(nums[i]);\\n\\t\\t\\t\\t//if nums[i] exists; add it to the map and increase it\\'s frequency.\\n\\t\\t\\t\\tmap.put(nums[i], map.get(nums[i]) + 1);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n                //add it to map and initialize count to 1 (first occurence of nums[i])\\n\\t\\t\\t\\tmap.put(nums[i], 1);\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191619,
                "title": "go",
                "content": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    c:=0\\n    m := make(map[int]int)\\n    for i:=0;i<len(nums);i++{\\n            if _, ok := m[nums[i]]; ok {\\n                c+=m[nums[i]]\\n            } \\n            m[nums[i]]++\\n    }\\n    return c\\n}",
                "solutionTags": [],
                "code": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    c:=0\\n    m := make(map[int]int)\\n    for i:=0;i<len(nums);i++{\\n            if _, ok := m[nums[i]]; ok {\\n                c+=m[nums[i]]\\n            } \\n            m[nums[i]]++\\n    }\\n    return c\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1148606,
                "title": "rust-one-line-solution",
                "content": "```\\nimpl Solution {\\n    pub fn num_identical_pairs(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold([0i32; 101], |mut acc, &x| {\\n                acc[x as usize] += 1;\\n                acc\\n            })\\n            .iter()\\n            .filter(|&&x| x > 1)\\n            .map(|&x| x * (x - 1) / 2)\\n            .sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_identical_pairs(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold([0i32; 101], |mut acc, &x| {\\n                acc[x as usize] += 1;\\n                acc\\n            })\\n            .iter()\\n            .filter(|&&x| x > 1)\\n            .map(|&x| x * (x - 1) / 2)\\n            .sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1147877,
                "title": "brute-force-solution",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums) - 1):\\n            for j in range(i + 1 , len(nums)):\\n                if(nums[i] == nums[j]): count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums) - 1):\\n            for j in range(i + 1 , len(nums)):\\n                if(nums[i] == nums[j]): count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123625,
                "title": "64-ms-faster-than-99-80-of-javascript",
                "content": "Runtime: 64 ms, faster than 99.80% of JavaScript online submissions for Number of Good Pairs.\\nMemory Usage: 38.3 MB, less than 86.10% of JavaScript online submissions for Number of Good Pairs.\\n\\n```\\nvar numIdenticalPairs = function(nums) {\\n  let result = 0\\n  nums.forEach((number, index) => {\\n    index = nums.indexOf(number, index + 1)\\n    while(index > 0) {\\n      result++\\n      index = nums.indexOf(number, index + 1)\\n    }\\n  })\\n  return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n  let result = 0\\n  nums.forEach((number, index) => {\\n    index = nums.indexOf(number, index + 1)\\n    while(index > 0) {\\n      result++\\n      index = nums.indexOf(number, index + 1)\\n    }\\n  })\\n  return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1070483,
                "title": "java-o-n",
                "content": "```\\nimport java.util.HashMap; \\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> h = new HashMap<>();\\n        for (int num:nums){\\n            h.put(num, h.getOrDefault(num, 0) + 1);\\n        }\\n        int sum = 0;\\n        \\n        for(int n: h.values()){\\n            sum += ((n*(n-1))/2);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.HashMap; \\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> h = new HashMap<>();\\n        for (int num:nums){\\n            h.put(num, h.getOrDefault(num, 0) + 1);\\n        }\\n        int sum = 0;\\n        \\n        for(int n: h.values()){\\n            sum += ((n*(n-1))/2);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012671,
                "title": "java-0-ms-using-hashmap",
                "content": "```\\n\\npublic static  int numIdenticalPairs(int [] nums){\\n\\tMap<Integer,Integer> numbersMap = new HashMap<>();\\n\\tint counter = 0;\\n\\t\\n\\tfor(int keys : nums){\\n\\t\\tnumbersMap.put(keys,numbersMap.getOrDefault(keys,0)+1);\\n\\t}\\n\\t\\n\\tfor(int keys : numbersMap.keySet()){\\n\\t\\tint values = numbersMap.get(keys);\\n\\n\\t\\tif(values > 1){\\n\\t\\t\\tcounter += values * (values - 1) / 2;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn counter;\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic static  int numIdenticalPairs(int [] nums){\\n\\tMap<Integer,Integer> numbersMap = new HashMap<>();\\n\\tint counter = 0;\\n\\t\\n\\tfor(int keys : nums){\\n\\t\\tnumbersMap.put(keys,numbersMap.getOrDefault(keys,0)+1);\\n\\t}\\n\\t\\n\\tfor(int keys : numbersMap.keySet()){\\n\\t\\tint values = numbersMap.get(keys);\\n\\n\\t\\tif(values > 1){\\n\\t\\t\\tcounter += values * (values - 1) / 2;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn counter;\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989147,
                "title": "python-3",
                "content": "Runtime: 32 ms\\nMemory Usage: 14.2 MB\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        good_pairs = 0\\n\\t\\t\\n\\t\\t#continue this while loop till the list is empty \\n        while nums != []:\\n\\t\\t\\n\\t\\t#for loop: from 2nd element onwards\\n            for i in range(1, len(nums)):\\n\\t\\t\\t\\n\\t\\t\\t#if first element is equal to the 2nd element\\n                if nums[0] == nums[i]:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#add to good_pairs\\n                    good_pairs+=1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#after going checking element 1&2, 1&3, til 1&n, remove the first element \\n\\t\\t\\t#this is to prevent counting the same pair twice\\n            nums.remove(nums[0])\\n\\t\\t\\t\\n\\t\\t#while loop continues till we remove all elements\\n\\t\\t\\n        return good_pairs\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        good_pairs = 0\\n\\t\\t\\n\\t\\t#continue this while loop till the list is empty \\n        while nums != []:\\n\\t\\t\\n\\t\\t#for loop: from 2nd element onwards\\n            for i in range(1, len(nums)):\\n\\t\\t\\t\\n\\t\\t\\t#if first element is equal to the 2nd element\\n                if nums[0] == nums[i]:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#add to good_pairs\\n                    good_pairs+=1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#after going checking element 1&2, 1&3, til 1&n, remove the first element \\n\\t\\t\\t#this is to prevent counting the same pair twice\\n            nums.remove(nums[0])\\n\\t\\t\\t\\n\\t\\t#while loop continues till we remove all elements\\n\\t\\t\\n        return good_pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955727,
                "title": "python-simple-o-n-dict-solution",
                "content": "\\t\\tans = 0\\n        d = {}\\n        for num in nums:\\n            if num in d:\\n                ans += d[num]\\n            d[num] = d.get(num,0) + 1\\n\\n        return ans",
                "solutionTags": [],
                "code": "\\t\\tans = 0\\n        d = {}\\n        for num in nums:\\n            if num in d:\\n                ans += d[num]\\n            d[num] = d.get(num,0) + 1\\n\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 885329,
                "title": "java-solution-hashmap-o-n",
                "content": "Open to optimisations, feel the additional map.get can be removed.\\n\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //we need nested loop to compare OR\\n        //use dictionary to store unique values then see if they come up again, increment, add to final count\\n        \\n        HashMap<Integer, Integer> numSet = new HashMap();\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(!numSet.containsKey(nums[i])) numSet.put(nums[i], 1); //marks each unique value\\n            else if(numSet.containsKey(nums[i])){\\n                count += numSet.get(nums[i]); //adds amount of each value\\n                numSet.put(nums[i], numSet.get(nums[i]) + 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //we need nested loop to compare OR\\n        //use dictionary to store unique values then see if they come up again, increment, add to final count\\n        \\n        HashMap<Integer, Integer> numSet = new HashMap();\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(!numSet.containsKey(nums[i])) numSet.put(nums[i], 1); //marks each unique value\\n            else if(numSet.containsKey(nums[i])){\\n                count += numSet.get(nums[i]); //adds amount of each value\\n                numSet.put(nums[i], numSet.get(nums[i]) + 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834972,
                "title": "java-solution-think-bigger",
                "content": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i : nums) {\\n            map.put(i, map.getOrDefault(i,0) + 1);\\n        }\\n           // System.out.print(i + \"\\\\t\" + map.get(i) + \"\\\\n\");\\n        \\n        for(int i: map.keySet()) {\\n            if(map.get(i) > 1) {\\n                int c = map.get(i);\\n                int r = 2;\\n                // int ncr = nCr(c, r);\\n                int ncr = (factorial(c).divide((factorial(c-r).multiply(BigInteger.TWO)))).intValue();\\n                res += ncr;\\n                // System.out.print(i + \"\\\\t\" + map.get(i) + \"\\\\t\" + ncr + \"\\\\n\");\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    /*\\n     * Java method to calculate factorial of a large number\\n     * @return BigInteger factorial of given number\\n     */\\n    public BigInteger factorial(int number) {\\n        BigInteger factorial = BigInteger.ONE;\\n\\n        for (int i = number; i > 0; i--) {\\n            factorial = factorial.multiply(BigInteger.valueOf(i));\\n        }\\n\\n        return factorial;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i : nums) {\\n            map.put(i, map.getOrDefault(i,0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 783177,
                "title": "java-0-n-solution-with-0-1-space-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    //make an integer array of size 101\\n    //iterate over the input array and increment the frequency at the index corresponding to the number in the array.\\n    //Use the formuale freqCount - 1 * freqCount / 2;\\n    //Logic Behind:\\n    //No. of fours = 4, No. of pairs = 6\\n    // No. of ones = 3, No. of pairs = 3\\n    // No. of two\\'s = 2, No, of pairs = 1\\n\\n    // If you try to note this down on a paper and try to work out how the number of pairs are being calculated:\\n    // As an example, Lets use No. of fours = 4:\\n    // there are four fours in our list, ignore the other numbers for now.:\\n    // 4 4 4 4\\n    // how many pairs can we make out of this ?\\n    // You can straight away use combinatorics.\\n\\n    // OR\\n\\n    // If you try to work this out and tell how we came to 6 pairs,\\n    // You can see that first 4 can be paired to the 3 fours in front of it.\\n    // The second four can be paired with the 2 fours in front of it (it has already been paired with the first one)\\n    // The third four can be paired with the last four.\\n    \\n    // If you count= 3 + 2 + 1\\n\\n    // you will immediately make the connection to the summation formulae (n(n+1))/2, but n here is 1 less than the             actual number.\\n\\n    \\n    //keep adding the results of factorial to the result i.e sum\\n    \\n    \\n    //TimeComplexity = O(n);\\n    //SpaceComplexity = O(1);\\n  \\n    public int numIdenticalPairs(int[] nums) {\\n        int goodPairs = 0;\\n        int[] freqCount = new int[101];\\n        \\n        for(int i=0; i<nums.length; i++){\\n            freqCount[nums[i]]++;\\n        }\\n                \\n        int r = 2;\\n        \\n        for(int i=0; i<101; i++){\\n            \\n            if(freqCount[i] > 1){\\n                goodPairs += (freqCount[i] - 1) * (freqCount[i]) / 2;\\n            }\\n            \\n        }\\n        \\n        return goodPairs;\\n        \\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    //make an integer array of size 101\\n    //iterate over the input array and increment the frequency at the index corresponding to the number in the array.\\n    //Use the formuale freqCount - 1 * freqCount / 2;\\n    //Logic Behind:\\n    //No. of fours = 4, No. of pairs = 6\\n    // No. of ones = 3, No. of pairs = 3\\n    // No. of two\\'s = 2, No, of pairs = 1\\n\\n    // If you try to note this down on a paper and try to work out how the number of pairs are being calculated:\\n    // As an example, Lets use No. of fours = 4:\\n    // there are four fours in our list, ignore the other numbers for now.:\\n    // 4 4 4 4\\n    // how many pairs can we make out of this ?\\n    // You can straight away use combinatorics.\\n\\n    // OR\\n\\n    // If you try to work this out and tell how we came to 6 pairs,\\n    // You can see that first 4 can be paired to the 3 fours in front of it.\\n    // The second four can be paired with the 2 fours in front of it (it has already been paired with the first one)\\n    // The third four can be paired with the last four.\\n    \\n    // If you count= 3 + 2 + 1\\n\\n    // you will immediately make the connection to the summation formulae (n(n+1))/2, but n here is 1 less than the             actual number.\\n\\n    \\n    //keep adding the results of factorial to the result i.e sum\\n    \\n    \\n    //TimeComplexity = O(n);\\n    //SpaceComplexity = O(1);\\n  \\n    public int numIdenticalPairs(int[] nums) {\\n        int goodPairs = 0;\\n        int[] freqCount = new int[101];\\n        \\n        for(int i=0; i<nums.length; i++){\\n            freqCount[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 776829,
                "title": "java-o-n-solution",
                "content": "The most naive solution is two scan to get the answer. After reviewing other solutions, I get the optimize one.\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int pivot = nums[i];\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j] == pivot){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nThe idea of optimze solution is to use hashmap to record the occurrence of each elment of array. We initialize the hashmap with key of array element, value of 1. Each time a same element found, we update the value by add 1. We incrementally update the count to record the occurrence of element so far.\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){\\n            if(map.containsKey(i)){\\n                count += map.get(i);\\n                map.put(i, map.get(i) + 1);\\n                \\n            }else{\\n                \\n                map.put(i, 1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int pivot = nums[i];\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j] == pivot){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){\\n            if(map.containsKey(i)){\\n                count += map.get(i);\\n                map.put(i, map.get(i) + 1);\\n                \\n            }else{\\n                \\n                map.put(i, 1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759183,
                "title": "javascript-map",
                "content": "```\\n\\nvar numIdenticalPairs = function(nums) {\\n    let map = new Map(); //store n,freq\\n    for(let n of nums){\\n        map.set(n, (map.get(n) || 0) + 1);\\n    }\\n    let res = 0;\\n    for(const [k,v] of map){\\n        res += parseInt((map.get(k) * (map.get(k) -1)) / 2);\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar numIdenticalPairs = function(nums) {\\n    let map = new Map(); //store n,freq\\n    for(let n of nums){\\n        map.set(n, (map.get(n) || 0) + 1);\\n    }\\n    let res = 0;\\n    for(const [k,v] of map){\\n        res += parseInt((map.get(k) * (map.get(k) -1)) / 2);\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732511,
                "title": "java-solution-using-hashmap",
                "content": "Here we have used a hashmap to store the number of times one particular element is found in the array.\\nWe store the number of times an elemnts appears in the array. \\nExolaining it with an example:-\\n\\n[1,2,3,1,1,3]\\n\\nStarting with first iteration we will add 1 in hashmap with coressponding value of occurrence i.e 1. \\nSame will happen for 2,3.\\nNow when we will reach 4th iteration 1 has to be updated so we get the value from hashmap and add in the variable sum defining that we have found the first pair(here value of sum is 1 now). Here after adding the value in sum we update the hashmap and put the value against 1 as 2, indicating that if 1 appears again in the array it can form pair with 2 ones. which happens for the case of 5th iteration where we find 1 again and add 2 in sum.(Now the value of sum is 3). In the last iteration we find 3 in hashmap for which 1 is stored which is added in the sum.\\nHence at last we get 4 as value which is the answer.\\n\\n\\n\\'\\'\\'\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        \\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(map.containsKey(nums[i])){               //Here we keep on updating the value in hashmap and keep on adding the value in sum\\n                \\n                \\n                \\n                int temp = map.get(nums[i]);\\n                sum+=temp;\\n                temp++;\\n                map.replace(nums[i],temp);\\n                \\n                \\n            }else{\\n                \\n                \\n                map.put(nums[i],1);  //for the first time value of hashmap for an element is always 1.\\n                \\n            }\\n            \\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        \\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(map.containsKey(nums[i])){               //Here we keep on updating the value in hashmap and keep on adding the value in sum\\n                \\n                \\n                \\n                int temp = map.get(nums[i]);\\n                sum+=temp;\\n                temp++;\\n                map.replace(nums[i],temp);\\n                \\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 731850,
                "title": "javascript-few-solutions-o-n",
                "content": "Using Object:\\n```\\nvar numIdenticalPairs = function(nums) {\\n  let obj = {};\\n  let p = 0;\\n  for (let n of nums) {\\n    if (obj[n]) {\\n      p += obj[n];\\n      obj[n] = obj[n] + 1;\\n    } else obj[n] = 1;\\n  }\\n  return p;\\n};\\n```\\nOne-liner:\\n```\\nlet numIdenticalPairs = A => A.map((_, i) => i + 1 == A.length ? 0 : A.slice(i).map((_, j) => Number(A[i] == A[i + j + 1])).reduce((a, b) => a + b)).reduce((a, b) => a + b);\\n```\\n2-liner:\\n```\\nvar numIdenticalPairs = function(nums, count = 0) {\\n  for (let i = 0; i < nums.length - 1; i += 1) for (let j = i + 1; j < nums.length; j += 1) count += nums[i] === nums[j];\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n  let obj = {};\\n  let p = 0;\\n  for (let n of nums) {\\n    if (obj[n]) {\\n      p += obj[n];\\n      obj[n] = obj[n] + 1;\\n    } else obj[n] = 1;\\n  }\\n  return p;\\n};\\n```\n```\\nlet numIdenticalPairs = A => A.map((_, i) => i + 1 == A.length ? 0 : A.slice(i).map((_, j) => Number(A[i] == A[i + j + 1])).reduce((a, b) => a + b)).reduce((a, b) => a + b);\\n```\n```\\nvar numIdenticalPairs = function(nums, count = 0) {\\n  for (let i = 0; i < nums.length - 1; i += 1) for (let j = i + 1; j < nums.length; j += 1) count += nums[i] === nums[j];\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731674,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        long long ans = 0;\\n        unordered_map<int,int>m;\\n        for(int x:nums) m[x]++;  // count occurance\\n        for(auto p: m){\\n            if(p.second > 1) ans += (p.second * (p.second-1) )/2;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        long long ans = 0;\\n        unordered_map<int,int>m;\\n        for(int x:nums) m[x]++;  // count occurance\\n        for(auto p: m){\\n            if(p.second > 1) ans += (p.second * (p.second-1) )/2;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731559,
                "title": "c-o-n-2-o-n",
                "content": "//TC-O(N^2) , SC-O(1)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int cnt = 0;\\n        for(int i=0; i<nums.size(); ++i)//take each number\\n        {\\n            for(int j=i+1; j<nums.size(); ++j)//check in next numbers\\n            {\\n                if(nums[i]==nums[j])//if they are same increment the counter for good pair\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n//TC-O(N) & SC-O(N)\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hash;\\n        int cnt = 0;\\n        for(auto n:nums)//take each number\\n        {//for 1 occurence add 0, for second occ add 1, for third occ add 2, (1 +2= 3), for 4th occ, add 3.(1+2+3=6)\\n            \\n           cnt += hash[n]++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n//2- 1\\n//3- 3\\n//4- 6\\n//5- 10\\n//6- 15\\n//7- 21\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int cnt = 0;\\n        for(int i=0; i<nums.size(); ++i)//take each number\\n        {\\n            for(int j=i+1; j<nums.size(); ++j)//check in next numbers\\n            {\\n                if(nums[i]==nums[j])//if they are same increment the counter for good pair\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hash;\\n        int cnt = 0;\\n        for(auto n:nums)//take each number\\n        {//for 1 occurence add 0, for second occ add 1, for third occ add 2, (1 +2= 3), for 4th occ, add 3.(1+2+3=6)\\n            \\n           cnt += hash[n]++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n//2- 1\\n//3- 3\\n//4- 6\\n//5- 10\\n//6- 15\\n//7- 21\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072440,
                "title": "easy-without-brute-force-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let holder = new Map();\\n    for(let i=0; i<nums.length; i++) {\\n        if(holder.has(nums[i])) {\\n            holder.set(nums[i], holder.get(nums[i])+1);\\n        }\\n        else {\\n            holder.set(nums[i], 1);\\n        }\\n    }\\n\\n    let count=0;\\n    holder.forEach (function(value, key) {\\n        let val = value-1;\\n        count = count + ((1 + val)/2 * val);\\n\\n    })\\n    return count;\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let holder = new Map();\\n    for(let i=0; i<nums.length; i++) {\\n        if(holder.has(nums[i])) {\\n            holder.set(nums[i], holder.get(nums[i])+1);\\n        }\\n        else {\\n            holder.set(nums[i], 1);\\n        }\\n    }\\n\\n    let count=0;\\n    holder.forEach (function(value, key) {\\n        let val = value-1;\\n        count = count + ((1 + val)/2 * val);\\n\\n    })\\n    return count;\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037632,
                "title": "solution-of-number-of-good-pairs-problem",
                "content": "# Approach\\n- Solved using nCr formula.\\n- nCr is the number of ways of selecting some objects out of given objects where the order of the objects does not matter. It is expressed as nCr = n!/(r! * (n-r)!)\\n- You can use math.factorial(n) istead of function \"factorial\" to solve the problem\\n- n is the number of repeating digits\\n- r is the number of things to be chosen out of n things (r is equal to 2 in our case).\\n\\n\\n# Code with factorial()\\n```\\ndef factorial(n):\\n    if n==1 or n==0:\\n        return 1\\n    return n*factorial(n-1)\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = factorial(nums.count(nums[i]))\\n                r_factorial = factorial(nums.count(nums[i]) - 2)\\n                count += n_factorial/(r_factorial * 2)\\n            visited.add(nums[i])\\n        return int(count)   \\n```\\n# Code with math.factorial()\\n```\\nimport math\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = math.factorial(nums.count(nums[i]))\\n                r_factorial = math.factorial(nums.count(nums[i])-2)\\n                count += n_factorial/(r_factorial*2)\\n            visited.add(nums[i])\\n        return int(count)          \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\ndef factorial(n):\\n    if n==1 or n==0:\\n        return 1\\n    return n*factorial(n-1)\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = factorial(nums.count(nums[i]))\\n                r_factorial = factorial(nums.count(nums[i]) - 2)\\n                count += n_factorial/(r_factorial * 2)\\n            visited.add(nums[i])\\n        return int(count)   \\n```\n```\\nimport math\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = math.factorial(nums.count(nums[i]))\\n                r_factorial = math.factorial(nums.count(nums[i])-2)\\n                count += n_factorial/(r_factorial*2)\\n            visited.add(nums[i])\\n        return int(count)          \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001148,
                "title": "easy-java-solution-with-simple-concept-for-beginners",
                "content": "# Intuition\\nAs the problem statement was to find the number of pairs so we can use the general array concept to get the pair \\n\\n# Approach\\nFirst initialize the counter and assign for loop and nested for loop \\nand increament the iteration part and check the condition that if itearated value of i and j is equal means return counter iteration.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n- Space complexity:\\n-O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int len =nums.length;\\n        int counter=0;\\n        for (int i =0;i<len;i++){\\n            for (int j=i+1;j<len;j++){\\n                if(nums[i]==nums[j]){\\n                    counter++; \\n                }           \\n            }\\n            \\n        }\\n        return counter;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int len =nums.length;\\n        int counter=0;\\n        for (int i =0;i<len;i++){\\n            for (int j=i+1;j<len;j++){\\n                if(nums[i]==nums[j]){\\n                    counter++; \\n                }           \\n            }\\n            \\n        }\\n        return counter;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690308,
                "title": "easy-javascript-solution-using-creating-map-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numIdenticalPairs(nums: number[]): number {\\n   let goodPair = 0 \\n   let map = {}\\n   for(let num of nums) {\\n     if(map[num]) {\\n       goodPair += map[num]\\n       map[num]++\\n     } else {\\n       map[num] = 1\\n     }\\n   }\\n  return goodPair\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction numIdenticalPairs(nums: number[]): number {\\n   let goodPair = 0 \\n   let map = {}\\n   for(let num of nums) {\\n     if(map[num]) {\\n       goodPair += map[num]\\n       map[num]++\\n     } else {\\n       map[num] = 1\\n     }\\n   }\\n  return goodPair\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596640,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int numIdenticalPairs(vector<int>& nums) {\\n\\t\\n        int ans = 0 ; \\n        for(int i=0 ; i<nums.size() ;i++){\\n            for(int j=i+1; j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    ans++;\\n                }\\n            }\\n        }return ans; \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int numIdenticalPairs(vector<int>& nums) {\\n\\t\\n        int ans = 0 ; \\n        for(int i=0 ; i<nums.size() ;i++){\\n            for(int j=i+1; j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3535804,
                "title": "without-hashing-nested-loop-for-beginner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508765,
                "title": "simplest-efficient-c-code-time-o-n-2-space-o-1",
                "content": "# Intuition\\nThe problem is asking to find the number of indices (i,j) such that i < j and nums[i] == nums[j]. One way to approach this problem is to iterate through the array and compare each element with all the elements that come after it. If we find any element that is equal to the current element, we increase a counter. At the end, the counter will hold the number of identical pairs.\\n\\n# Approach\\nThe given code is implementing the above approach. It is using two nested loops to iterate through the array and compare each element with all the elements that come after it. If the elements are equal, it increases the counter. At the end, it returns the counter.\\n\\n# Complexity\\n- Time complexity : $O(n^2)$, where n is the size of the array. This is because we are using two nested loops to iterate through the array.\\n\\n- Space complexity : $O(1)$. The algorithm uses a constant amount of extra space regardless of the size of the input.\\n\\n# Code\\n```\\nint numIdenticalPairs(int* nums, int n)\\n{\\n    int count=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i+1;j<n;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numIdenticalPairs(int* nums, int n)\\n{\\n    int count=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i+1;j<n;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570274,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574043,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1566648,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574190,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1725781,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1576708,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575197,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575646,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574126,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575984,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1570274,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574043,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1566648,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574190,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1725781,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1576708,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575197,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575646,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574126,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575984,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 2065324,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2050477,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2018803,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1988708,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1873411,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849584,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1842293,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1831229,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1824255,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1820535,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1801889,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1783702,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1778125,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1778122,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1752985,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1748692,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1744198,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1742060,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1740071,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1734618,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Substrings With Only 1s",
        "question_content": "<p>Given a binary string <code>s</code>, return <em>the number of substrings with all characters</em> <code>1</code><em>&#39;s</em>. Since the answer may be too large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0110111&quot;\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> There are 9 substring in total with only 1&#39;s characters.\n&quot;1&quot; -&gt; 5 times.\n&quot;11&quot; -&gt; 3 times.\n&quot;111&quot; -&gt; 1 time.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;101&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Substring &quot;1&quot; is shown 2 times in s.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;111111&quot;\n<strong>Output:</strong> 21\n<strong>Explanation:</strong> Each substring contains only 1&#39;s characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 731580,
                "title": "java-c-python-count",
                "content": "## **Explanation**\\n`count` the current number of consecutive \"1\".\\nFor each new element,\\nthere will be more `count` substring,\\nwith all characters 1\\'s.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numSub(String s) {\\n        int res = 0, count = 0, mod = (int)1e9 + 7;\\n        for (int i = 0; i < s.length(); ++i) {\\n            count = s.charAt(i) == \\'1\\' ? count + 1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numSub(string s) {\\n        int res = 0, count = 0, mod = 1e9 + 7;\\n        for (char c: s) {\\n            count = c == \\'1\\' ? count + 1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\nO(n) space though\\n```py\\n    def numSub(self, s):\\n        return sum(len(a) * (len(a) + 1) / 2 for a in s.split(\\'0\\')) % (10**9 + 7)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numSub(String s) {\\n        int res = 0, count = 0, mod = (int)1e9 + 7;\\n        for (int i = 0; i < s.length(); ++i) {\\n            count = s.charAt(i) == \\'1\\' ? count + 1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numSub(string s) {\\n        int res = 0, count = 0, mod = 1e9 + 7;\\n        for (char c: s) {\\n            count = c == \\'1\\' ? count + 1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def numSub(self, s):\\n        return sum(len(a) * (len(a) + 1) / 2 for a in s.split(\\'0\\')) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 731558,
                "title": "python-easy-readable-code",
                "content": "The example would be self explanatoy:\\n\"0110111\" can be evaluated to -->\\n0120123\\nNow if we sum up all these digits:\\n1+2+1+2+3 = 9 is the result!\\n\\n```\\nclass Solution(object):\\n    def numSub(self, s):\\n        res, currsum = 0,0\\n        for digit in s:\\n            if digit == \\'0\\':\\n                currsum = 0\\n            else:\\n                currsum += 1 \\n                res+=currsum \\n        return res % (10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSub(self, s):\\n        res, currsum = 0,0\\n        for digit in s:\\n            if digit == \\'0\\':\\n                currsum = 0\\n            else:\\n                currsum += 1 \\n                res+=currsum \\n        return res % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731633,
                "title": "c-java-sliding-window",
                "content": "Well, it\\'s easy - \\'0\\' cuts the previous string. So, when we see \\'0\\', we calculate how many strings can be formed between `i - 1` and `j`.\\n\\nThe formula is just sum of arithmetic progression (n * (n + 1) /2, or (i - j) * (i - j + 1) /2).\\n\\n**C++**\\n```cpp\\nint numSub(string s) {\\n    long res = 0;\\n    for (long i = 0, j = 0; i <= s.size(); ++i)\\n        if (i == s.size() || s[i] == \\'0\\') {\\n            res = (res + (i - j) * (i - j + 1) / 2) % 1000000007;\\n            j = i + 1;\\n        }\\n    return res;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int numSub(String s) {\\n    long res = 0;\\n    for (long i = 0, j = 0; i <= s.length(); ++i)\\n        if (i == s.length() || s.charAt((int)i) == \\'0\\') {\\n            res = (res + (i - j) * (i - j + 1) / 2) % 1000000007;\\n            j = i + 1;\\n        }\\n    return (int)res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint numSub(string s) {\\n    long res = 0;\\n    for (long i = 0, j = 0; i <= s.size(); ++i)\\n        if (i == s.size() || s[i] == \\'0\\') {\\n            res = (res + (i - j) * (i - j + 1) / 2) % 1000000007;\\n            j = i + 1;\\n        }\\n    return res;\\n}\\n```\n```java\\npublic int numSub(String s) {\\n    long res = 0;\\n    for (long i = 0, j = 0; i <= s.length(); ++i)\\n        if (i == s.length() || s.charAt((int)i) == \\'0\\') {\\n            res = (res + (i - j) * (i - j + 1) / 2) % 1000000007;\\n            j = i + 1;\\n        }\\n    return (int)res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731622,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\n\\tint numSub(string s) {\\n        long res = 0;\\n        for(int i =0; i < s.length(); ++i)\\n        {\\n            long count = 0;\\n            while(s[i] == \\'1\\')\\n                count++, i++;\\n            res += count*(count+1)/2;\\n        }\\n        return res%1000000007;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tint numSub(string s) {\\n        long res = 0;\\n        for(int i =0; i < s.length(); ++i)\\n        {\\n            long count = 0;\\n            while(s[i] == \\'1\\')\\n                count++, i++;\\n            res += count*(count+1)/2;\\n        }\\n        return res%1000000007;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 731552,
                "title": "java-1-loop-o-n",
                "content": "```\\n    public int numSub(String s) {\\n        int res = 0, cnt = 0, mod = 1_000_000_007;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'1\\') res = (res + ++cnt) % mod;  // added cnt of subarrays ended with c;\\n            else cnt = 0;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numSub(String s) {\\n        int res = 0, cnt = 0, mod = 1_000_000_007;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'1\\') res = (res + ++cnt) % mod;  // added cnt of subarrays ended with c;\\n            else cnt = 0;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731757,
                "title": "java-python-3-count-continuous-1-s-o-n-one-liner-codes-w-brief-explanation-and-analysis",
                "content": "For `k` continuous `1`s, we have `1,  2, ..., k` substrings ending at `1st, 2nd, ..., kth 1`s, respectively; Therefore, there are `k * (k + 1) / 2` substrings for any `k` continuous `1`.\\n```java\\n    public int numSub(String s) {\\n        int sum = 0;\\n        for (int i = 0, cnt = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'1\\') {\\n                sum += ++cnt;\\n                sum %= 1_000_000_007;\\n            }else {\\n                cnt = 0;\\n            }\\n        }\\n        return sum;\\n    }\\n```\\n```python\\n    def numSub(self, s: str) -> int:\\n        sum = cnt = 0\\n        for c in s:\\n            if c == \\'1\\':\\n                cnt += 1\\n                sum = (sum + cnt) % (10 ** 9 + 7)\\n            else:\\n                cnt = 0\\n        return sum\\n```\\n\\n----\\n**1 liners:**\\n```java\\n    public int numSub(String s) {\\n        return (int)(Arrays.stream(s.split(\"0+\")).mapToLong(u -> u.length() * (u.length() + 1L) / 2).sum() % 1_000_000_007);\\n    }\\n```\\n```python\\n    def numSub(self, s: str) -> int:\\n        return sum(map(lambda x : len(x) * (len(x) + 1) // 2, s.split(\\'0\\'))) % (10 ** 9 + 7)\\n```\\n\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = s.length().",
                "solutionTags": [],
                "code": "```java\\n    public int numSub(String s) {\\n        int sum = 0;\\n        for (int i = 0, cnt = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'1\\') {\\n                sum += ++cnt;\\n                sum %= 1_000_000_007;\\n            }else {\\n                cnt = 0;\\n            }\\n        }\\n        return sum;\\n    }\\n```\n```python\\n    def numSub(self, s: str) -> int:\\n        sum = cnt = 0\\n        for c in s:\\n            if c == \\'1\\':\\n                cnt += 1\\n                sum = (sum + cnt) % (10 ** 9 + 7)\\n            else:\\n                cnt = 0\\n        return sum\\n```\n```java\\n    public int numSub(String s) {\\n        return (int)(Arrays.stream(s.split(\"0+\")).mapToLong(u -> u.length() * (u.length() + 1L) / 2).sum() % 1_000_000_007);\\n    }\\n```\n```python\\n    def numSub(self, s: str) -> int:\\n        return sum(map(lambda x : len(x) * (len(x) + 1) // 2, s.split(\\'0\\'))) % (10 ** 9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 731754,
                "title": "python-sum-of-arithmetic-progression-with-explanation-100-00-faster",
                "content": "There is a ***pattern***, you will find that the ***result is the sum of arithmetic progression***.\\nArithmetic progression: **t(n) = a + d(n-1)**\\nSum of arithmetic progression: **s(n) = (n / 2) * (2a + d(n-1))**\\n\\nIn this problem, the first term(a) will be the the length of \"1\" and the number of terms will also be the length of \"1\".\\n\\nThe common difference(d) is **-1**.\\n\\n**E.g. input is \"111111\"**\\nThen, \\n**n = 6\\na = 6\\nd = -1**\\nAfterthat, calculate the sum of arithmetic progression with the formula of **s(n) = (n / 2) * (2a + d(n-1))**,\\nCalculate step by step:  **(6-0) + (6-1) + (6-2) + (6-3) + (6-4) + (6-5) = 21**,\\nwhich is the result of this problem.\\n\\n***Solution***\\n*100% Faster, Memory Usage less than 100.00% of Python3 online submissions.*\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int: \\n            res = 0\\n            s = s.split(\"0\")\\n\\n            for one in s:\\n                if one == \"\":\\n                    continue\\n                    \\n                n = len(one)\\n                temp = (n / 2)*(2*n + (n-1)*-1)\\n                    \\n                if temp >= 1000000007:\\n                    res += temp % 1000000007\\n                else:\\n                    res += temp\\n            return int(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int: \\n            res = 0\\n            s = s.split(\"0\")\\n\\n            for one in s:\\n                if one == \"\":\\n                    continue\\n                    \\n                n = len(one)\\n                temp = (n / 2)*(2*n + (n-1)*-1)\\n                    \\n                if temp >= 1000000007:\\n                    res += temp % 1000000007\\n                else:\\n                    res += temp\\n            return int(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206806,
                "title": "c-easy-math-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numSub(string s) {\\n\\t\\t\\tlong count = 0;\\n\\t\\t\\tlong ans = 0;\\n\\t\\t\\tfor(int i  = 0; i < s.size(); i++){\\n\\t\\t\\t\\tif(s[i] == \\'1\\'){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tans += (count * (count + 1)) / 2;\\n\\t\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn (ans + (count * (count + 1)) / 2) % 1000000007;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numSub(string s) {\\n\\t\\t\\tlong count = 0;\\n\\t\\t\\tlong ans = 0;\\n\\t\\t\\tfor(int i  = 0; i < s.size(); i++){\\n\\t\\t\\t\\tif(s[i] == \\'1\\'){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 786651,
                "title": "java-counting-linear-time-constant-space-explained",
                "content": "Algorithm ideas:\\neach next consequent 1 contributes to all unique strings with length 1 to k (where k is number of subsequent 1s), k substrings overall. In other words count of possible substrings increased by k\\neach 0 should reset the count of 1s\\n\\nO(n) time - scan every character in S once\\nO(1) space - no extra space\\n\\n```\\n    public int numSub(String s) {\\n        long count = 0;\\n        int ones = 0;\\n        \\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                ones = 0;\\n            } else {\\n                count+=++ones;\\n            }\\n        }\\n        return (int) (count%1_000_000_007);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\n    public int numSub(String s) {\\n        long count = 0;\\n        int ones = 0;\\n        \\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                ones = 0;\\n            } else {\\n                count+=++ones;\\n            }\\n        }\\n        return (int) (count%1_000_000_007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1304820,
                "title": "c-o-n-full-beginner-friendly-explanation",
                "content": "**Please upvote, if you find the solution helpful !**\\n\\nSolution : \\nLogic : We count the number of total number of 1\\'s in every substring which contain only 1\\'s.\\n\\n **Wait, Let me explain!**\\n Let\\'s take an example : suppose our string is **conscOnes** = \"111\" i.e. comprising of all 1\\'s. \\n\\nNow, \\n**How to calculate  the total number of substrings that contains only 1\\'s?**\\nSimple - we have consider all the substrings, So :-\\nThe number of substrings containing only one 1 will be : 3 (i.e. all individual 1\\'s)\\nThe number of substrings containing two 1\\'s will be : 2 (i.e. combining 2 consecutive 1\\'s at a time )\\nThe number of substrings containing three 1\\'s will be : 1(i.e. combining 3 consecutive 1\\'s at a time)\\nSo, the total number of such substrings would be (3 + 2 + 1 ... in this case). \\n\\nBut can you see a general pattern ??\\nYes, if the size of such a string ( **string conscOnes** ) is **n** then, the number of substrings would be **( n + (n-1) + (n-2) + . . . (1) )** which is = **(n * (n + 1)) / 2 .**\\nSo, if we know the number of 1\\'s in a **conscOnes** string then we can calculate the number of substrings using the above formula.\\n\\nNow, our task is reduced to : **find the number of 1\\'s** in **every conscOnes string** present in string S, and then we know what to do ! (wink!)\\nNow, Do you agree to the fact that, while traversing the string S if a \\'1\\' is encountered then a new conscOnes string will start and if a \\'0\\' is encountered the conscOnes string will end.\\n\\nThat\\'s it : as soon as a conscOnes string start we increment a count variable, and as soon as it ends, we add ( count * ( count + 1 ) ) / 2) to our final ans variable.\\n \\n```\\nint numSub(string s) \\n    {\\n\\t\\t// since the answer can overflow, that\\'s why long long int is taken instead of int\\n        long long int ans = 0, count = 0;\\n        int mod = 1000000007;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                ans += ( (count * (count + 1)) / 2);\\n                count = 0;\\n            }\\n            else\\n                count++;\\n        }\\n        \\n        ans += ( (count * (count + 1)) / 2);\\n        \\n        return ans % mod;\\n    }",
                "solutionTags": [],
                "code": "**Please upvote, if you find the solution helpful !**\\n\\nSolution : \\nLogic : We count the number of total number of 1\\'s in every substring which contain only 1\\'s.\\n\\n **Wait, Let me explain!**\\n Let\\'s take an example : suppose our string is **conscOnes** = \"111\" i.e. comprising of all 1\\'s. \\n\\nNow, \\n**How to calculate  the total number of substrings that contains only 1\\'s?**\\nSimple - we have consider all the substrings, So :-\\nThe number of substrings containing only one 1 will be : 3 (i.e. all individual 1\\'s)\\nThe number of substrings containing two 1\\'s will be : 2 (i.e. combining 2 consecutive 1\\'s at a time )\\nThe number of substrings containing three 1\\'s will be : 1(i.e. combining 3 consecutive 1\\'s at a time)\\nSo, the total number of such substrings would be (3 + 2 + 1 ... in this case). \\n\\nBut can you see a general pattern ??\\nYes, if the size of such a string ( **string conscOnes** ) is **n** then, the number of substrings would be **( n + (n-1) + (n-2) + . . . (1) )** which is = **(n * (n + 1)) / 2 .**\\nSo, if we know the number of 1\\'s in a **conscOnes** string then we can calculate the number of substrings using the above formula.\\n\\nNow, our task is reduced to : **find the number of 1\\'s** in **every conscOnes string** present in string S, and then we know what to do ! (wink!)\\nNow, Do you agree to the fact that, while traversing the string S if a \\'1\\' is encountered then a new conscOnes string will start and if a \\'0\\' is encountered the conscOnes string will end.\\n\\nThat\\'s it : as soon as a conscOnes string start we increment a count variable, and as soon as it ends, we add ( count * ( count + 1 ) ) / 2) to our final ans variable.\\n \\n```\\nint numSub(string s) \\n    {\\n\\t\\t// since the answer can overflow, that\\'s why long long int is taken instead of int\\n        long long int ans = 0, count = 0;\\n        int mod = 1000000007;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                ans += ( (count * (count + 1)) / 2);\\n                count = 0;\\n            }\\n            else\\n                count++;\\n        }\\n        \\n        ans += ( (count * (count + 1)) / 2);\\n        \\n        return ans % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 731593,
                "title": "clean-python-3-counting-ones-with-math-o-n",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        mod = 10 ** 9 + 7\\n        seq = (len(ones) for ones in s.split(\\'0\\') if ones)\\n        return sum((ones * (ones + 1)) // 2 for ones in seq) % mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        mod = 10 ** 9 + 7\\n        seq = (len(ones) for ones in s.split(\\'0\\') if ones)\\n        return sum((ones * (ones + 1)) // 2 for ones in seq) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731574,
                "title": "c-o-n-find-the-pattern",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) \\n    {\\n        int res=0;\\n        int i=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                long long count=0;\\n                while(s[i]==\\'1\\')\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                count=((count*(count+1))%1000000007)/2;  // #substrings in a string of n characters is n*(n+1)/2\\n                res=(res+count)%1000000007;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nderivation of #substrings in a string of length n\\n\\nnumber of substrings in \"1\"=1(1)\\nnumber of substrings in \"11\"=3(1+2)\\nnumber of substrings in \"111\"=6(1+2+3)\\nnumber of substrings in \"1111\"=10(1+2+3+4)\\n.\\n.\\n.\\nnumber of substrings in \"111....n times\"=(1+2+3+...+n=n(n+1)/2)\\n\\nonce we know this,we can easily find the number of substrings with ony 1s in any string,\\n\\ns=\"0110111\"\\n#substrings in \"11\"=3\\n#substrings in \"111\"=6\\ntotal=3+6=9",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) \\n    {\\n        int res=0;\\n        int i=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                long long count=0;\\n                while(s[i]==\\'1\\')\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                count=((count*(count+1))%1000000007)/2;  // #substrings in a string of n characters is n*(n+1)/2\\n                res=(res+count)%1000000007;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963888,
                "title": "easy-java-solution-tc-o-n-sc-o-1",
                "content": "```\\n  public int numSub(String s) {\\n        int prev=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'1\\'){\\n\\t\\t\\t\\t// If current element =1\\n                prev=prev+1;\\n            }else{\\n\\t\\t\\t\\t// If current element =0, reset prev=0\\n                prev=0;\\n            }\\n           ans+=prev;\\n           ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int numSub(String s) {\\n        int prev=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'1\\'){\\n\\t\\t\\t\\t// If current element =1\\n                prev=prev+1;\\n            }else{\\n\\t\\t\\t\\t// If current element =0, reset prev=0\\n                prev=0;\\n            }\\n           ans+=prev;\\n           ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849450,
                "title": "faster-than-94-2-approach-cpp-easy-understanding",
                "content": "```\\n//1.\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int num=0;\\n        long long count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\')\\n                count++;\\n            else{\\n\\t\\t\\t   // number of all substrings till n  = n * (n+1) / 2 \\n                count=((count*(count+1)%1000000007)/2);\\n                num=(num+count)%1000000007;\\n                count=0;\\n            } \\n        }\\n\\t\\t//to handle the edge case\\n        count=((count*(count+1)%1000000007)/2);\\n        num=(num+count)%1000000007;\\n        return num;\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n         int num=0,count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') count++;\\n            else count=0;\\n            num=(num+count)%1000000007;\\n        }\\n        return num;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int num=0;\\n        long long count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\')\\n                count++;\\n            else{\\n\\t\\t\\t   // number of all substrings till n  = n * (n+1) / 2 \\n                count=((count*(count+1)%1000000007)/2);\\n                num=(num+count)%1000000007;\\n                count=0;\\n            } \\n        }\\n\\t\\t//to handle the edge case\\n        count=((count*(count+1)%1000000007)/2);\\n        num=(num+count)%1000000007;\\n        return num;\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n         int num=0,count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') count++;\\n            else count=0;\\n            num=(num+count)%1000000007;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623044,
                "title": "java-shortest-solution",
                "content": "### *Please Upvote !!!* **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0, total = 0, mod = 1_000_000_007;\\n        \\n        for (char c : s.toCharArray()) {\\n            count = (c == \\'1\\') ? count + 1 : 0;\\n            total = (total + count) % mod;\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0, total = 0, mod = 1_000_000_007;\\n        \\n        for (char c : s.toCharArray()) {\\n            count = (c == \\'1\\') ? count + 1 : 0;\\n            total = (total + count) % mod;\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307948,
                "title": "one-liner-faster-than-98-sc-90",
                "content": "```\\n        return sum(map(lambda x: ((1+len(x))*len(x)//2)%(10**9+7), s.split(\\'0\\')))\\n```\\nIF THIS HELP U KINDLY UPVOTE THIS TO HELP OTHERS TO GET THIS SOLUTION\\nIF U DONT GET IT KINDLY COMMENT AND FEEL FREE TO ASK\\nAND CORRECT MEIF I AM WRONG",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        return sum(map(lambda x: ((1+len(x))*len(x)//2)%(10**9+7), s.split(\\'0\\')))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732058,
                "title": "just-a-clever-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        const int m=1000000007;\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        while(j<s.length()){\\n            if(s[j]==\\'1\\'){\\n                while(i<j and s[i]!=\\'1\\')\\n                    i++;\\n                res=(res%m+(j-i+1)%m)%m;\\n            }\\n            else if(s[j]==\\'0\\')\\n                i=j;\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWhen you see  j pointing to 1 reset i to the starting 1 of the chain.\\nand when the chain of one ends reset i to the next zero after the chain of ones.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        const int m=1000000007;\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        while(j<s.length()){\\n            if(s[j]==\\'1\\'){\\n                while(i<j and s[i]!=\\'1\\')\\n                    i++;\\n                res=(res%m+(j-i+1)%m)%m;\\n            }\\n            else if(s[j]==\\'0\\')\\n                i=j;\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731721,
                "title": "c-o-n",
                "content": "Apporach: \\n``array = [0 1 1 0 1 1 1]`` , lengths of subarray are 2 and 3\\nfor n -> (n* n+1 )/2\\n2 -> 3\\n3 -> 6\\n6+3 = 9\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long ans = 0;\\n        int mp = 1000000007;\\n        int n = s.length();\\n        long long count = 0,i=0;\\n        while(i<n && s[i] == \\'0\\') i++;\\n        if(i==n) return 0;\\n        for(;i<n;i++){\\n            if(s[i] == \\'1\\') count++;\\n            else{\\n                ans = (ans % mp + ((count*(count+1))/2 )%mp) % mp;\\n                count = 0;\\n            }\\n        }\\n        if(count > 0) ans = (ans % mp + ((count*(count+1))/2 )%mp) % mp;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long ans = 0;\\n        int mp = 1000000007;\\n        int n = s.length();\\n        long long count = 0,i=0;\\n        while(i<n && s[i] == \\'0\\') i++;\\n        if(i==n) return 0;\\n        for(;i<n;i++){\\n            if(s[i] == \\'1\\') count++;\\n            else{\\n                ans = (ans % mp + ((count*(count+1))/2 )%mp) % mp;\\n                count = 0;\\n            }\\n        }\\n        if(count > 0) ans = (ans % mp + ((count*(count+1))/2 )%mp) % mp;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731600,
                "title": "javascript-python3-c-sum-of-the-series",
                "content": "**Synopsis:**\\n\\nAccumulate the sum of the series for each `run` of consecutive 1s length.\\n\\n---\\n\\n**Contest 197 - Screenshare:** https://www.youtube.com/watch?v=-oXf4Ikou_c&feature=youtu.be\\n\\n---\\n\\n**Solutions:**\\n\\n*Javascript*\\n```\\nlet numSub = s => s.split(\\'0\\').map(run => run.length).reduce((sum, n) => (sum + Math.floor(n * (n + 1) / 2)) % (1e9 + 7), 0);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return reduce(lambda sum, n: (sum + (n * (n + 1)) // 2) % int(1e9 + 7), list(map(lambda run: len(run), s.split(\\'0\\'))), 0)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VLL = vector<LL>;\\n    int numSub(string s, int len = 0, VLL run = {}, int sum = 0) {\\n        s.push_back(\\'0\\'); // sentinel value to terminate the last run (if it exists)\\n        for (auto c: s)\\n            if (c == \\'1\\') ++len; else run.push_back(len), len = 0;\\n        for (auto n: run)\\n            sum = (sum + (n * (n + 1) / 2)) % LL(1e9 + 7);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet numSub = s => s.split(\\'0\\').map(run => run.length).reduce((sum, n) => (sum + Math.floor(n * (n + 1) / 2)) % (1e9 + 7), 0);\\n```\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return reduce(lambda sum, n: (sum + (n * (n + 1)) // 2) % int(1e9 + 7), list(map(lambda run: len(run), s.split(\\'0\\'))), 0)\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VLL = vector<LL>;\\n    int numSub(string s, int len = 0, VLL run = {}, int sum = 0) {\\n        s.push_back(\\'0\\'); // sentinel value to terminate the last run (if it exists)\\n        for (auto c: s)\\n            if (c == \\'1\\') ++len; else run.push_back(len), len = 0;\\n        for (auto n: run)\\n            sum = (sum + (n * (n + 1) / 2)) % LL(1e9 + 7);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829406,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long int ans = 0, i = 0, j= 0, n = s.length(),mod = 1e9+7;\\n        while(i<n){\\n            j = i;\\n            while(j<n && s[i] == s[j]){\\n                j++;\\n                if(s[i]==\\'1\\'){\\n                    ans = (ans+j-i)%mod;\\n                }\\n            }\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long int ans = 0, i = 0, j= 0, n = s.length(),mod = 1e9+7;\\n        while(i<n){\\n            j = i;\\n            while(j<n && s[i] == s[j]){\\n                j++;\\n                if(s[i]==\\'1\\'){\\n                    ans = (ans+j-i)%mod;\\n                }\\n            }\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747384,
                "title": "sum-of-n-numbers-python",
                "content": "Basically, the no. of consecutions \\'1\\'s can form n*(n+1)//2 substrings\\n11 -> 2 1s, 1 2s = 2+1\\n111 -> 3 1s, 2 2s, 1 3s = 3+2+1\\n1111 -> 4 1s, 3 2s, 2 3s, 1 4s = 4+3+2+1\\n\\n```\\n    def numSub(self, s: str) -> int:\\n        c=0\\n        ans=[]\\n        for x in s:\\n            if x==\\'1\\':\\n                c=c+1\\n            else:\\n                ans.append(c)\\n                c=0\\n        ans.append(c)\\n        \\n        res=0\\n        for x in ans:\\n            res=res+x*(x+1)//2\\n        return res%1000000007\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def numSub(self, s: str) -> int:\\n        c=0\\n        ans=[]\\n        for x in s:\\n            if x==\\'1\\':\\n                c=c+1\\n            else:\\n                ans.append(c)\\n                c=0\\n        ans.append(c)\\n        \\n        res=0\\n        for x in ans:\\n            res=res+x*(x+1)//2\\n        return res%1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2180878,
                "title": "go-2ms-beats-100",
                "content": "```\\nfunc numSub(s string) int {\\n\\tif len(s) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif len(s) == 1 {\\n\\t\\tif s[0] == 49 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\n\\t\\treturn 0\\n\\t}\\n\\n\\tleft := 0\\n\\n    for left < len(s) && s[left] != 49 {\\n\\t\\tleft++\\n\\t}\\n\\n\\tvar res int\\n\\n\\tfor i := left; i < len(s); i++ {\\n\\t\\tif s[i] == s[left] {\\n\\t\\t\\tcontinue\\n\\t\\t} else {\\n\\t\\t\\tif s[i] == 48 {\\n\\t\\t\\t\\tres += helper(i - left)\\n\\t\\t\\t}\\n\\n\\t\\t\\tleft = i\\n\\t\\t}\\n\\t}\\n\\n    if left < len(s) && s[left] == 49 {\\n\\t\\tres += helper(len(s) - left)\\n\\t}\\n\\n\\treturn res % (int(math.Pow10(9)) + 7)\\n}\\n\\nfunc helper(length int) int {\\n\\tif length < 2 {\\n\\t\\treturn length\\n\\t}\\n\\n\\tvar res int\\n\\n\\tfor i := 1; i < length; i++ {\\n\\t\\tres += length - i\\n\\t}\\n\\n\\treturn res + length\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numSub(s string) int {\\n\\tif len(s) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif len(s) == 1 {\\n\\t\\tif s[0] == 49 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\n\\t\\treturn 0\\n\\t}\\n\\n\\tleft := 0\\n\\n    for left < len(s) && s[left] != 49 {\\n\\t\\tleft++\\n\\t}\\n\\n\\tvar res int\\n\\n\\tfor i := left; i < len(s); i++ {\\n\\t\\tif s[i] == s[left] {\\n\\t\\t\\tcontinue\\n\\t\\t} else {\\n\\t\\t\\tif s[i] == 48 {\\n\\t\\t\\t\\tres += helper(i - left)\\n\\t\\t\\t}\\n\\n\\t\\t\\tleft = i\\n\\t\\t}\\n\\t}\\n\\n    if left < len(s) && s[left] == 49 {\\n\\t\\tres += helper(len(s) - left)\\n\\t}\\n\\n\\treturn res % (int(math.Pow10(9)) + 7)\\n}\\n\\nfunc helper(length int) int {\\n\\tif length < 2 {\\n\\t\\treturn length\\n\\t}\\n\\n\\tvar res int\\n\\n\\tfor i := 1; i < length; i++ {\\n\\t\\tres += length - i\\n\\t}\\n\\n\\treturn res + length\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128225,
                "title": "python-solution-one-pass",
                "content": "class Solution:\\n\\n    def numSub(self, s: str) -> int:\\n        ans = cum = 0\\n        for x in s:\\n            if x == \"1\":\\n                cum+=1\\n                ans+=cum\\n            else:\\n                cum = 0\\n        return ans%(10**9+7)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\n    def numSub(self, s: str) -> int:\\n        ans = cum = 0\\n        for x in s:\\n            if x == \"1\":\\n                cum+=1\\n                ans+=cum\\n            else:\\n                cum = 0\\n        return ans%(10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 829441,
                "title": "java-solution-checking-for-consecutive-one",
                "content": "Here , I just counted the number of consecutive 1, and updated a counter varibale whenever we encountered with a 1. This varibale actually keep track of consecutive 1.\\n\\nNow we add this count with our result variable. The moment we see a 0, we reset the counter variable back to 0 and again start counting when we see the next 1.\\n\\n\\n\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        if (s.length() == 0)\\n            return 0;\\n        int count = 0;\\n        int modulus = (int)1e9 + 7;\\n        int result = 0;\\n        for (int i=0; i<s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\')\\n                count += 1;\\n            else\\n                count = 0;\\n            result = (result + count) % modulus;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        if (s.length() == 0)\\n            return 0;\\n        int count = 0;\\n        int modulus = (int)1e9 + 7;\\n        int result = 0;\\n        for (int i=0; i<s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\')\\n                count += 1;\\n            else\\n                count = 0;\\n            result = (result + count) % modulus;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734717,
                "title": "javascript-1-line-solution",
                "content": "_Runtime: 80 ms, faster than 100.00% of JavaScript online submissions_\\n_Memory Usage: 37.7 MB, less than 100.00% of JavaScript online submissions_\\n\\n```javascript\\nconst numSub = s =>\\n  s\\n    .split(\\'0\\')\\n    .reduce((cnt, { length: len }) => cnt + (len * (len + 1)) / 2, 0) %\\n  (10 ** 9 + 7);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst numSub = s =>\\n  s\\n    .split(\\'0\\')\\n    .reduce((cnt, { length: len }) => cnt + (len * (len + 1)) / 2, 0) %\\n  (10 ** 9 + 7);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732043,
                "title": "easy-count-and-sum-javascript-solution",
                "content": "```\\nvar numSub = function(s) {\\n    let result = 0;\\n    let len = 0;    \\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"1\") {\\n            len++;\\n            result += len;\\n        } else {\\n            len = 0;\\n        }\\n    }\\n    \\n    return result % 1000000007;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numSub = function(s) {\\n    let result = 0;\\n    let len = 0;    \\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"1\") {\\n            len++;\\n            result += len;\\n        } else {\\n            len = 0;\\n        }\\n    }\\n    \\n    return result % 1000000007;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731679,
                "title": "python-easy-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def numSub(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        arr = s.split(\"0\")\\n        for i in arr:\\n            n = len(i)\\n            if n == 0:\\n                continue\\n            res += n*(n+1)/2\\n            res = res % (10**9 + 7)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSub(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        arr = s.split(\"0\")\\n        for i in arr:\\n            n = len(i)\\n            if n == 0:\\n                continue\\n            res += n*(n+1)/2\\n            res = res % (10**9 + 7)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731634,
                "title": "python3-count-continuous-1",
                "content": "Algo\\nCount number of continuous `1` and use formula `n*(n+1)//2` to compute the answer. \\n\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        ans = n = 0\\n        for c in s:\\n            if c == \"0\": \\n                ans = (ans + n*(n+1)//2) % 1_000_000_007\\n                n = 0\\n            else: n += 1\\n        return (ans + n*(n+1)//2) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        ans = n = 0\\n        for c in s:\\n            if c == \"0\": \\n                ans = (ans + n*(n+1)//2) % 1_000_000_007\\n                n = 0\\n            else: n += 1\\n        return (ans + n*(n+1)//2) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819507,
                "title": "beats-90-cpp-sol",
                "content": "# **Pls Upvote if you found it Helpful \\uD83D\\uDE07**\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int numSub(string s) {\\n\\n        int front = 0;\\n        int back = 0;\\n        int ans = 0;\\n\\n        while(front < s.size()){\\n            while(front<s.size() && s[front] != \\'1\\'){\\n                front++;\\n            }\\n            back = front;\\n            while(front<s.size() && s[front] == \\'1\\'){\\n                ans = ans + (front-back+1);\\n                ans = ans % mod;\\n                front++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int numSub(string s) {\\n\\n        int front = 0;\\n        int back = 0;\\n        int ans = 0;\\n\\n        while(front < s.size()){\\n            while(front<s.size() && s[front] != \\'1\\'){\\n                front++;\\n            }\\n            back = front;\\n            while(front<s.size() && s[front] == \\'1\\'){\\n                ans = ans + (front-back+1);\\n                ans = ans % mod;\\n                front++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757780,
                "title": "easy-peasy-implementation-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.length(), mod = 1e9+7;\\n        int cnt = 0;\\n        long long ans = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'1\\'){\\n                cnt++;\\n                ans += cnt;\\n                ans = ans%mod;\\n            }\\n            else cnt = 0;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.length(), mod = 1e9+7;\\n        int cnt = 0;\\n        long long ans = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'1\\'){\\n                cnt++;\\n                ans += cnt;\\n                ans = ans%mod;\\n            }\\n            else cnt = 0;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730817,
                "title": "q1513-accepted-c-sliding-win-counting-easiest-method",
                "content": "CRUX\\n1) All single 1\\'s are the part of the ans. Inital loop for counting the number of 1\\'s in the string s.\\n2) Keeping the count as 1 and increment if 1\\'s are found consecutively.\\n3) Otherwise put count as 1 again.\\n\\nThe code is very readable, Please go through the code and read the above points again for better understanding .\\n\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int numSub(string s) {\\n        int n = s.size();\\n        int ans = 0,count = 1;\\n        for(int i=0;i<n;i++)\\n            if(s[i] == \\'1\\')\\n                ans++;\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i] == \\'1\\' && s[i-1] == \\'1\\'){\\n                ans = (ans+count)%MOD;\\n                count++;\\n            }\\n            else\\n                count = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int numSub(string s) {\\n        int n = s.size();\\n        int ans = 0,count = 1;\\n        for(int i=0;i<n;i++)\\n            if(s[i] == \\'1\\')\\n                ans++;\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i] == \\'1\\' && s[i-1] == \\'1\\'){\\n                ans = (ans+count)%MOD;\\n                count++;\\n            }\\n            else\\n                count = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917224,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long c=0, p=0, t = pow(10,9);\\n        for(auto& i : s){\\n            if(i==\\'1\\'){\\n                ++c;\\n            }\\n            else{\\n                p += c*(c+1)/2;\\n                c=0;\\n            }\\n        }\\n        p += c*(c+1)/2;\\n        return p%(t+7);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long c=0, p=0, t = pow(10,9);\\n        for(auto& i : s){\\n            if(i==\\'1\\'){\\n                ++c;\\n            }\\n            else{\\n                p += c*(c+1)/2;\\n                c=0;\\n            }\\n        }\\n        p += c*(c+1)/2;\\n        return p%(t+7);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827205,
                "title": "beginner-friendly-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n         long long consecutiveOnes = 0, ans = 0, mod = 1e9+7;\\n        for(int i = 0; i < s.size(); i++){\\n            // if the string of consecutiveOnes get broken add the answer\\n            if(s[i] == \\'0\\'){\\n                ans += consecutiveOnes*(consecutiveOnes+1)/2;\\n                consecutiveOnes = 0; //Setting consecutiveOnes to 0 so that next time consecutiveOnes will be calculated from 0 not from a precalculated value\\n            }\\n            else consecutiveOnes++;\\n        }\\n            ans += consecutiveOnes*(consecutiveOnes+1)/2;\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n         long long consecutiveOnes = 0, ans = 0, mod = 1e9+7;\\n        for(int i = 0; i < s.size(); i++){\\n            // if the string of consecutiveOnes get broken add the answer\\n            if(s[i] == \\'0\\'){\\n                ans += consecutiveOnes*(consecutiveOnes+1)/2;\\n                consecutiveOnes = 0; //Setting consecutiveOnes to 0 so that next time consecutiveOnes will be calculated from 0 not from a precalculated value\\n            }\\n            else consecutiveOnes++;\\n        }\\n            ans += consecutiveOnes*(consecutiveOnes+1)/2;\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826045,
                "title": "most-optimal-java-solution",
                "content": "```\\n public int numSub(String s) {\\n        long count = 0 , res = 0 , mod = (int)1e9+7 ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            count+=s.charAt(i)-\\'0\\';\\n            if(s.charAt(i)-\\'0\\'==0){\\n                res+=((count*(count+1))/2);\\n                count = 0 ;\\n            }\\n        }\\n        res+=((count*(count+1))/2);\\n        return (int)(res%mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public int numSub(String s) {\\n        long count = 0 , res = 0 , mod = (int)1e9+7 ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            count+=s.charAt(i)-\\'0\\';\\n            if(s.charAt(i)-\\'0\\'==0){\\n                res+=((count*(count+1))/2);\\n                count = 0 ;\\n            }\\n        }\\n        res+=((count*(count+1))/2);\\n        return (int)(res%mod);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2666927,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        vector<long> dp(s.length(), 0);\\n        if(s[0] == \\'1\\')\\n            dp[0] = 1;\\n        \\n        long sum = 0;\\n        for(int i = 1 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'1\\')\\n                dp[i] = dp[i - 1] + 1;\\n        }\\n        for(int i = 0 ; i < dp.size() - 1; i++)\\n        {\\n            if(dp[i] != 0 and dp[i + 1] == 0)\\n            {\\n                sum += ((dp[i])*(dp[i] + 1)/2)% 1000000007;\\n            }\\n        }\\n        if(dp[dp.size() - 1] != 0)\\n            sum += ((dp[dp.size() - 1])*(dp[dp.size() - 1] + 1)/2)% 1000000007;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        vector<long> dp(s.length(), 0);\\n        if(s[0] == \\'1\\')\\n            dp[0] = 1;\\n        \\n        long sum = 0;\\n        for(int i = 1 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'1\\')\\n                dp[i] = dp[i - 1] + 1;\\n        }\\n        for(int i = 0 ; i < dp.size() - 1; i++)\\n        {\\n            if(dp[i] != 0 and dp[i + 1] == 0)\\n            {\\n                sum += ((dp[i])*(dp[i] + 1)/2)% 1000000007;\\n            }\\n        }\\n        if(dp[dp.size() - 1] != 0)\\n            sum += ((dp[dp.size() - 1])*(dp[dp.size() - 1] + 1)/2)% 1000000007;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540843,
                "title": "java-simple-solution-runtime-7ms",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        if(s.indexOf(\"1\") < 0)\\n            return 0;\\n        int count = 0,res=0, mod = 1_000_000_007;\\n        for(int i=0 ; i < s.length(); i++){\\n            count = s.charAt(i) == \\'1\\' ? count+1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        if(s.indexOf(\"1\") < 0)\\n            return 0;\\n        int count = 0,res=0, mod = 1_000_000_007;\\n        for(int i=0 ; i < s.length(); i++){\\n            count = s.charAt(i) == \\'1\\' ? count+1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430342,
                "title": "help-needed-sliding-window-logic",
                "content": "**54/56 testcases passed!!!**\\n\\n\\'\\'\\'\\nclass Solution {\\n    public int numSub(String s) {\\n        int i,j;\\n    \\n\\t\\ti=0;j=0;\\n\\t\\tint ans=0;\\n\\t\\twhile(j<s.length())\\n\\t\\t{\\n\\t\\t    if(s.charAt(j)==\\'0\\')\\n\\t\\t    {\\n\\t\\t        i=j+1;\\n\\t\\t        j++;\\n\\t\\t    }\\n\\t\\t    \\n\\t\\t    else if(s.charAt(j)==\\'1\\')\\n\\t\\t    {\\n\\t\\t        ans+=j-i+1;\\n\\t\\t        j++;\\n\\t\\t    }\\n\\t\\t}\\n\\t\\t\\n        return ans%1000000007;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int numSub(String s) {\\n        int i,j;\\n    \\n\\t\\ti=0;j=0;\\n\\t\\tint ans=0;\\n\\t\\twhile(j<s.length())\\n\\t\\t{\\n\\t\\t    if(s.charAt(j)==\\'0\\')\\n\\t\\t    {\\n\\t\\t        i=j+1;\\n\\t\\t        j++;\\n\\t\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 2335800,
                "title": "run-length-counting-c-solution-o-n-and-no-branching",
                "content": "We note that the number of sub-strings is just the partial sum of the natural numbers up until the length of the original string, i.e. given a string of `1`\\'s of length *N* we have *(N + (N + 1)) / 2* sub-strings.\\n\\nLet\\'s look at a few examples.\\n\\n* For the input `1` we have 1 sub-string: `[1]`\\n* For the input `11` we have 3 sub-strings: `[1, 1, 11]`\\n* For the input `111` we have 6 sub-string: `[1, 1, 1, 11, 11, 111]`\\n\\nIn general, for the input `1...11` of length N we have:\\n\\n* *N* sub-strings of length *1*\\n* *N-1* sub-strings of length *2*\\n* *N-2* sub-strings of length *3*\\n* ...\\n* *2* sub-strings of length *N-1*\\n* *1* sub-string of length *N*\\n\\nLooking carefully we see that the number of sub-strings are *1 + 2 + 3 + ... + N*. This is a well-known sum -- often referred to as \"the partial sum of the natural numbers\" or \"the triangle numbers\" [[1](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF)].\\n\\nThe formula to compute the sum is *(N + (N + 1)) / 2*.\\n\\nNow that we can count the number of sub-strings *inside* a string of `1`\\'s we just need a way to count how many there are in a row. This is quite easy.\\n\\nWe loop over the input string and as long as the current character is `1` we increment a *run length* counter. If we encounter a `0` (or the end of the input string) we just add the sub-strings using the formula above.\\n\\n```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      if S[i] == \"1\"\\n  \\t      run += 1\\n  \\t  else\\n\\t      sum += (run + (run + 1)) / 2\\n\\t      run = 0\\n  sum += (run + (run + 1)) / 2\\n  return sum % (1e9 + 7)\\n```\\n\\nThere\\'s a slight variant (maybe an optimization) that we can do here if we observe that the *run length* counter will be *1, 2, 3, ...* and if we want the sum of that added to the total why not just do that immediately?\\n\\n```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      if S[i] == \"1\"\\n  \\t      run += 1\\n\\t\\t  sum += run\\n  \\t  else\\n\\t      run = 0\\n  return sum % (1e9 + 7)\\n```\\n\\nAs a final optimization we can get rid of the branch altogether if we carefully update the *run length* counter depending on the current character in the input string. We need to do two things: 1) increment the counter if it\\'s a `1` and 2) reset the counter if it\\'s not a `1`.\\n\\n```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      run = run * (S[i] == \"1\") + (S[i] == \"1\")\\n\\t  sum += run\\n  return sum % (1e9 + 7)\\n```\\n\\nThis C++ solution uses 64-bit unsigned integers to avoid overflowing, but a more rigurous solution could do the modulo inside the loop.\\n\\n```\\n    int numSub(const string &s) {\\n        uint64_t count = 0;\\n        uint64_t run = 0;\\n        for (auto c : s) {\\n            run = run * (c == \\'1\\') + (c == \\'1\\');\\n            count += run;\\n        }\\n        return (int)(count % 1000000007);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      if S[i] == \"1\"\\n  \\t      run += 1\\n  \\t  else\\n\\t      sum += (run + (run + 1)) / 2\\n\\t      run = 0\\n  sum += (run + (run + 1)) / 2\\n  return sum % (1e9 + 7)\\n```\n```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      if S[i] == \"1\"\\n  \\t      run += 1\\n\\t\\t  sum += run\\n  \\t  else\\n\\t      run = 0\\n  return sum % (1e9 + 7)\\n```\n```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      run = run * (S[i] == \"1\") + (S[i] == \"1\")\\n\\t  sum += run\\n  return sum % (1e9 + 7)\\n```\n```\\n    int numSub(const string &s) {\\n        uint64_t count = 0;\\n        uint64_t run = 0;\\n        for (auto c : s) {\\n            run = run * (c == \\'1\\') + (c == \\'1\\');\\n            count += run;\\n        }\\n        return (int)(count % 1000000007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307772,
                "title": "c-sliding-window-commented-code-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/0d71b179-e6f6-4131-889e-537be2134a46_1658304703.3028126.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int i=0,j=0;\\n        int n = s.size();\\n        int res=0;\\n        for(;j<=n;j++){\\n            if(s[j]==\\'0\\' or j==n){ // the moment our window breaks we will do our caclulation.\\n                long long len =j-i;\\n                if(len>0){\\n                    long long sum = ((len*(len+1))%1000000007)/2; // as the contribution of the length is (n+1)*n/2;\\n                    res += sum%1000000007;\\n                }\\n                i=j+1;// set lower bound of window to the next of break point.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// TC - O(N)\\n// SC - O(1)\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int i=0,j=0;\\n        int n = s.size();\\n        int res=0;\\n        for(;j<=n;j++){\\n            if(s[j]==\\'0\\' or j==n){ // the moment our window breaks we will do our caclulation.\\n                long long len =j-i;\\n                if(len>0){\\n                    long long sum = ((len*(len+1))%1000000007)/2; // as the contribution of the length is (n+1)*n/2;\\n                    res += sum%1000000007;\\n                }\\n                i=j+1;// set lower bound of window to the next of break point.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// TC - O(N)\\n// SC - O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172856,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long count = 0;\\n        int n = 0;\\n        long mod = 1000000007;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                count = (count + ++n);\\n            }\\n            else{\\n                n = 0;\\n            }\\n        }\\n        return (int)(count % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long count = 0;\\n        int n = 0;\\n        long mod = 1000000007;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                count = (count + ++n);\\n            }\\n            else{\\n                n = 0;\\n            }\\n        }\\n        return (int)(count % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140473,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n=s.length();\\n        int c=1;\\n        ll ans=0;\\n        int cnt=0;\\n        for(char ch:s)\\n        {\\n            cnt+=(ch-\\'0\\');\\n        }\\n        if(cnt==0)\\n        return 0;\\n        s+=\\'0\\';\\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(s[i]==s[i-1]&&s[i]==\\'1\\')\\n            {\\n                c++;\\n            }\\n            else if(s[i]==\\'0\\'&&s[i-1]==\\'1\\')\\n            {\\n                ans+=c*(1ll)*(c+1)/2;\\n                ans=ans%mod;\\n                c=1;\\n            }\\n            \\n        }\\n        ans=ans%mod;\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n=s.length();\\n        int c=1;\\n        ll ans=0;\\n        int cnt=0;\\n        for(char ch:s)\\n        {\\n            cnt+=(ch-\\'0\\');\\n        }\\n        if(cnt==0)\\n        return 0;\\n        s+=\\'0\\';\\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(s[i]==s[i-1]&&s[i]==\\'1\\')\\n            {\\n                c++;\\n            }\\n            else if(s[i]==\\'0\\'&&s[i-1]==\\'1\\')\\n            {\\n                ans+=c*(1ll)*(c+1)/2;\\n                ans=ans%mod;\\n                c=1;\\n            }\\n            \\n        }\\n        ans=ans%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830061,
                "title": "number-of-substrings-with-only-1s-c-solution",
                "content": "class Solution {\\npublic:\\n    int numSub(string s) \\n    {\\n         int n=s.length();\\n         vector<int>dp(n+1,0);\\n         for(int i=0;i<n;i++)\\n         {\\n             if(s[i]==\\'1\\')\\n                 dp[i+1]=dp[i]+1;\\n         }\\n         long long int res=0;\\n         for(int i=0;i<=n;i++)\\n            res=(res+dp[i])%1000000007;\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int numSub(string s) \\n    {\\n         int n=s.length();\\n         vector<int>dp(n+1,0);\\n         for(int i=0;i<n;i++)\\n         {\\n             if(s[i]==\\'1\\')\\n                 dp[i+1]=dp[i]+1;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1814012,
                "title": "python-easy-to-read-and-understand",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        cnt, ans = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                cnt = 0\\n            else:\\n                cnt += 1\\n                ans += cnt\\n        return ans % ((10**9)+7)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        cnt, ans = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                cnt = 0\\n            else:\\n                cnt += 1\\n                ans += cnt\\n        return ans % ((10**9)+7)",
                "codeTag": "Java"
            },
            {
                "id": 1785368,
                "title": "c-o-n-time-simple-solution-with-explanation-count-no-math-formula",
                "content": "Just use `cnt` to count # of consecutive 1 and add into `res`\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.size(), cnt = 0, res = 0, mod = 1e9+7;\\n        for (int i = 0; i < n; ++i) {\\n            cnt = s[i] == \\'1\\' ? cnt+1 : 0;\\n            res = (res+cnt) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.size(), cnt = 0, res = 0, mod = 1e9+7;\\n        for (int i = 0; i < n; ++i) {\\n            cnt = s[i] == \\'1\\' ? cnt+1 : 0;\\n            res = (res+cnt) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600322,
                "title": "o-n-time-o-1-space-java-solution",
                "content": "Looking at strings of only 1s:\\n`1` should return 1, `11` should return 3, `111` should return 6, and so on.\\nObserve that for a chain of `k` `1s`, the expected result is `k(k+1)/2`.\\n\\nKeep track of the length of the current chain of `1s` as you iterate through the string. Suppose the current chain of `1s` is of length `k` and you now see a `0`. Add `k(k+1)/2` to the result and reset the chain length count to `0`.\\n\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        long val = 0;\\n        int result = 0;\\n        final int MOD = (int) (Math.pow(10, 9) + 7);\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                val = val * (val + 1) / 2;\\n                result = (int) ((result + val) % MOD);\\n                val = 0;\\n            } else {\\n                val++;\\n            }\\n        }\\n        val = val * (val + 1) / 2;\\n        result = (int) ((result + val) % MOD);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long val = 0;\\n        int result = 0;\\n        final int MOD = (int) (Math.pow(10, 9) + 7);\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                val = val * (val + 1) / 2;\\n                result = (int) ((result + val) % MOD);\\n                val = 0;\\n            } else {\\n                val++;\\n            }\\n        }\\n        val = val * (val + 1) / 2;\\n        result = (int) ((result + val) % MOD);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543983,
                "title": "o-n-monotonic-stack",
                "content": "For each possible index `i` of our string `s`, we can ask the simpler/local question of what is the number of substrings consisting exclusively of `1`\\'s that end at index `i`. If we sum these local counts over all possible indices `i = 0, ...,  n-1`, we will generate our desired answer.\\n\\nThere are two cases to consider, for each index `i`:\\n\\n* **character at `i` is `0`**: in this case, we know there are no substrings that end at index `i` consisting exclusively on `1`\\'s, so we obtain a local count of 0 for this index\\n* **character at `i` is `1`**: in this case, we need to determine the most recently encountered `0` in the string. Once we know such (should it exist), this will tell us how many substrings ending at `i` consist exclusively of `1`\\'s.\\n\\n**MONOTONIC STACK**\\nIn the second case above, the fact we want the most recent occurrence of something (in this case, a `0`) should immediately signal to us that we want to leverage a LIFO data structure. We can use a monotonic stack that is storing previously handled indexes. As we encounter a `1` at some index `i`, we keep popping indexes from the stack that correspond to prior occurrences of `1`\\'s until we finally arrive at either:\\n\\n* an empty stack\\n* the index `j` of the most recent `0`\\n\\nIn the first case, this means we only encountered `1`\\'s up to this point, so every substring ending at index `i` (there are precisely `i+1` of them) will consist of only `1`\\'s.\\n\\nIn the second case, there are precisely `i - j` substrings starting at index `j+1` and ending at index `i`.\\n\\n**CODE**\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        s = [int(c) for c in s]\\n        n = len(s)\\n        \\n        count = 0\\n        stack = []\\n        for i in range(n):\\n            if s[i] == 1:\\n                while len(stack) > 0 and s[stack[-1]] != 0:\\n                    stack.pop(-1)\\n                if len(stack) == 0:\\n                    count += i + 1\\n                else:\\n                    count += i - stack[-1]\\n            stack.append(i)\\n            \\n        return count % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        s = [int(c) for c in s]\\n        n = len(s)\\n        \\n        count = 0\\n        stack = []\\n        for i in range(n):\\n            if s[i] == 1:\\n                while len(stack) > 0 and s[stack[-1]] != 0:\\n                    stack.pop(-1)\\n                if len(stack) == 0:\\n                    count += i + 1\\n                else:\\n                    count += i - stack[-1]\\n            stack.append(i)\\n            \\n        return count % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531077,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int ans=0;\\n        int i=0;\\n        int x=1e9+7;\\n        while(i<s.size()){\\n            if(i<s.size() && s[i]==\\'1\\'){\\n                int no_of_ones=0;\\n                while(i<s.size() && s[i]!=\\'0\\')  {no_of_ones++; i++;}\\n                ans=(ans +(long long) no_of_ones * (no_of_ones+1) /2) % x; \\n            }\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSub(string s) {\\n        int ans=0;\\n        int i=0;\\n        int x=1e9+7;\\n        while(i<s.size()){\\n            if(i<s.size() && s[i]==\\'1\\'){\\n                int no_of_ones=0;\\n                while(i<s.size() && s[i]!=\\'0\\')  {no_of_ones++; i++;}",
                "codeTag": "Java"
            },
            {
                "id": 1502481,
                "title": "c-sol-with-comments",
                "content": "Idea--> find the length of the each substring which consists of 1\\'s and let that length be n and\\n\\t\\t\\twe add n*(n+1)/2 to the sum which we return at last\\n```\\nint numSub(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        long long sum=0,count=0;\\n        int mod=7+pow(10,9);\\n\\t\\t\\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\n            if(s[i]==\\'1\\') count++;  // if s[i] is 1 then increase count\\n\\t\\t\\t\\n            else sum+=((count+1)*count/2)%mod,count=0;\\n\\t\\t\\t// if s[i] is 0 it means the 1\\'s substring is broken so add that to the sum\\n        }\\n        sum+=((count+1)*count/2)%mod;  // if the last character in the string is also 1\\n\\t\\t//then we need to add that also\\n\\t\\t\\n        return sum;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint numSub(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        long long sum=0,count=0;\\n        int mod=7+pow(10,9);\\n\\t\\t\\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\n            if(s[i]==\\'1\\') count++;  // if s[i] is 1 then increase count\\n\\t\\t\\t\\n            else sum+=((count+1)*count/2)%mod,count=0;\\n\\t\\t\\t// if s[i] is 0 it means the 1\\'s substring is broken so add that to the sum\\n        }\\n        sum+=((count+1)*count/2)%mod;  // if the last character in the string is also 1\\n\\t\\t//then we need to add that also\\n\\t\\t\\n        return sum;\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1478372,
                "title": "c-simple-to-understand",
                "content": "```\\npublic class Solution {\\n    public int NumSub(string s) {\\n        var result = 0;\\n        var count = 0;\\n        var mod = (int)Math.Pow(10, 9) + 7;\\n        \\n        foreach (var item in s) {\\n            if (item == \\'1\\') {\\n                ++count;\\n            } else {\\n                count = 0;\\n            }            \\n            result = (result + count) % mod;\\n        }\\n        \\n        return result;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSub(string s) {\\n        var result = 0;\\n        var count = 0;\\n        var mod = (int)Math.Pow(10, 9) + 7;\\n        \\n        foreach (var item in s) {\\n            if (item == \\'1\\') {\\n                ++count;\\n            } else {\\n                count = 0;\\n            }            \\n            result = (result + count) % mod;\\n        }\\n        \\n        return result;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361689,
                "title": "c",
                "content": "```\\n\\n```public:\\n    int numSub(string s) {\\n        long long int i,f=0,sum=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            f=0;\\n            while(i<s.length()&&s[i]==\\'1\\')\\n            {\\n                f++;\\n                i++;\\n            }\\n            sum=sum+((f*(f+1))/2)%1000000007;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332960,
                "title": "java-easy-trick",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int mod=(int)1e9+7;\\n        int count=0,res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                count=(count+1)%mod;\\n            }\\n            else\\n            {\\n                count=0;\\n            }\\n            res=(res+count)%mod;\\n        }\\n        \\n        return res;        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSub(String s) {\\n        int mod=(int)1e9+7;\\n        int count=0,res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                count=(count+1)%mod;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1279892,
                "title": "python3-one-pass-30",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        #strategy: One Pass\\n        left = right = -1\\n        answer, mod = 0, 10 ** 9 + 7\\n        for i in range(len(s)):\\n            #create new interval\\n            if s[i] == \\'0\\':\\n                left = right = i\\n            #update right side to keep our interval running\\n            else:\\n                right = i\\n            #find the size of the interval which corresponds to the # of substrings up to pos right\\n            answer = (answer + right - left) % mod\\n        return answer % mod\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        #strategy: One Pass\\n        left = right = -1\\n        answer, mod = 0, 10 ** 9 + 7\\n        for i in range(len(s)):\\n            #create new interval\\n            if s[i] == \\'0\\':\\n                left = right = i\\n            #update right side to keep our interval running\\n            else:\\n                right = i\\n            #find the size of the interval which corresponds to the # of substrings up to pos right\\n            answer = (answer + right - left) % mod\\n        return answer % mod\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240872,
                "title": "simple-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int i = 0;\\n        int n = s.length();\\n        int result = 0;\\n        while(i<n)\\n        {\\n            int tot = 0;\\n            if(s[i] == \\'1\\')\\n            {\\n                while(s[i] == \\'1\\' and i<n)\\n                {\\n                    tot++;\\n                    result = (result+tot)%1000000007;\\n                    i++;\\n                }\\n            }\\n            tot = 0;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int i = 0;\\n        int n = s.length();\\n        int result = 0;\\n        while(i<n)\\n        {\\n            int tot = 0;\\n            if(s[i] == \\'1\\')\\n            {\\n                while(s[i] == \\'1\\' and i<n)\\n                {\\n                    tot++;\\n                    result = (result+tot)%1000000007;\\n                    i++;\\n                }\\n            }\\n            tot = 0;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232946,
                "title": "c-o-n-99-8-faster-with-comments",
                "content": "```\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        long long int sum=0;\\n        int n=s.size();\\n        long long int count = s[0]==\\'1\\'? 1: 0;\\n        \\n\\t\\t/*\\n\\t\\tSubstring of 1s start: s[0]==\\'1\\' || s[i-1]==\\'0\\'&&s[i]==\\'1\\'\\n\\t\\tSubstring of 1s end : s[n-1]==\\'1\\' || s[i-1]==\\'1\\'&&s[i]==\\'0\\'\\n\\t\\tNumber of permutations of substring of 1s with size count = (count*(count+1))/2\\n\\t\\t*/\\n\\t\\t\\n        for (int i=1; i<n; i++){\\n            if (s[i]==\\'1\\'){\\n                if (s[i-1]==\\'0\\')\\n                    count = 1;\\n                // s[i-1] == \\'1\\'\\n                else\\n                    count++;\\n            }\\n            // s[i] == \\'0\\'\\n            else{\\n                if (s[i-1]= \\'1\\'){\\n                    sum = (sum + (count*(count+1))/2)%MOD;\\n                    count = 0;\\n                }    \\n            }\\n        }\\n        sum = (sum + (count*(count+1))/2)%MOD;\\n        return sum%MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        long long int sum=0;\\n        int n=s.size();\\n        long long int count = s[0]==\\'1\\'? 1: 0;\\n        \\n\\t\\t/*\\n\\t\\tSubstring of 1s start: s[0]==\\'1\\' || s[i-1]==\\'0\\'&&s[i]==\\'1\\'\\n\\t\\tSubstring of 1s end : s[n-1]==\\'1\\' || s[i-1]==\\'1\\'&&s[i]==\\'0\\'\\n\\t\\tNumber of permutations of substring of 1s with size count = (count*(count+1))/2\\n\\t\\t*/\\n\\t\\t\\n        for (int i=1; i<n; i++){\\n            if (s[i]==\\'1\\'){\\n                if (s[i-1]==\\'0\\')\\n                    count = 1;\\n                // s[i-1] == \\'1\\'\\n                else\\n                    count++;\\n            }\\n            // s[i] == \\'0\\'\\n            else{\\n                if (s[i-1]= \\'1\\'){\\n                    sum = (sum + (count*(count+1))/2)%MOD;\\n                    count = 0;\\n                }    \\n            }\\n        }\\n        sum = (sum + (count*(count+1))/2)%MOD;\\n        return sum%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225495,
                "title": "javascript-easy-to-understand-solution-61-83",
                "content": "Runtime: 88 ms, faster than 61.70% of JavaScript online submissions for Number of Substrings With Only 1s.\\nMemory Usage: 40.2 MB, less than 87.23% of JavaScript online submissions for Number of Substrings With Only 1s.\\n```\\nvar numSub = function(s) {\\n    let res = 0;\\n    let one = 0;\\n    for(let num of s){\\n        if(num===\"1\") one++, res+=one;\\n        else one = 0;\\n    }\\n    return res%1000000007;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numSub = function(s) {\\n    let res = 0;\\n    let one = 0;\\n    for(let num of s){\\n        if(num===\"1\") one++, res+=one;\\n        else one = 0;\\n    }\\n    return res%1000000007;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1210007,
                "title": "simplest-java-solution-one-pass-no-formula-with-explanation",
                "content": "**Intuition:**  The bruteforce way is to generate all the substrings and count all the substrings will all Ones. Time complexity for this would be :- O(n^3), which could be optimised to O(n^2) if we count while creating substrings.\\n\\nBut from here we can observe that at each index we only want to know all the substrings with one ending there. So, basically we only want the count of strings ending at current index with all ones.\\nSo, now for each index we will have two options:- Either the character is \\'1\\' or \\'0\\'.\\n\\n**Case 1: When current character is one**\\nAssuming  our current index is \\'i\\' and count of substrings with all ones ending at \\'i\\' = count + 1( plus one for one at \\'i\\'). \\n\\n**Case : When current character is zero**\\nSo, if our character at \\'i\\' is \\'0\\' then all the substrings ending at this index would contain zero. And so we cannot add this character to our substrings. And hence because substrings need to be contiguous we can say now we have zero substrings with all one and so we will change the count to 0.\\n\\nFor the final answer at each position we will add the count of substrings ending at the current position to the ans.\\n\\n**Time Complexity = O(n)\\nSpace Complexity = O(1)**\\n\\n\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int ans = 0;\\n        int ones = 0;\\n        int MOD = 1000000007;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') ones = 0;\\n            else ones += 1;\\n            ans = (ans + ones) % MOD;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int ans = 0;\\n        int ones = 0;\\n        int MOD = 1000000007;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') ones = 0;\\n            else ones += 1;\\n            ans = (ans + ones) % MOD;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155014,
                "title": "java-clean-solution",
                "content": "**This solution is not mine but i found this solution very interesting as it is beginner friendly**\\n*Solution by : Nidhi_2125*\\n*The Idea is very simple you can count the number of ones and keep on checking the segment of one\\'s (arr[i]==arr[i+1] ) if it is equal you can add this substring into your original substring count*\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n      int count=0;\\n      \\n      char arr[]=s.toCharArray();\\n      int n=arr.length;\\n      for(int i=0;i<n;i++){\\n        if(arr[i]==\\'1\\') count++;\\n      }\\n      int substring=0;\\n      int mod=1000000007;\\n      for(int i=0;i<n-1;i++){\\n        if(arr[i]==\\'1\\' && arr[i]==arr[i+1]){\\n          substring++;\\n        }\\n        else{\\n          substring=0;\\n        }\\n        \\n        count=(count+substring)%mod;\\n        \\n      }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n      int count=0;\\n      \\n      char arr[]=s.toCharArray();\\n      int n=arr.length;\\n      for(int i=0;i<n;i++){\\n        if(arr[i]==\\'1\\') count++;\\n      }\\n      int substring=0;\\n      int mod=1000000007;\\n      for(int i=0;i<n-1;i++){\\n        if(arr[i]==\\'1\\' && arr[i]==arr[i+1]){\\n          substring++;\\n        }\\n        else{\\n          substring=0;\\n        }\\n        \\n        count=(count+substring)%mod;\\n        \\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134272,
                "title": "c-easy-solution-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int cv= 1e9+7;\\n        long long count_ones=0;\\n        long long ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                count_ones++;\\n                if(i+1==s.size() || s[i+1]!=\\'1\\')\\n                {\\n                    long long vc=((count_ones)*(count_ones+1))/2;\\n                    ans+=vc;\\n                    count_ones=0;\\n                    continue;\\n                }\\n            }\\n        }\\n        return (ans % cv);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int cv= 1e9+7;\\n        long long count_ones=0;\\n        long long ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                count_ones++;\\n                if(i+1==s.size() || s[i+1]!=\\'1\\')\\n                {\\n                    long long vc=((count_ones)*(count_ones+1))/2;\\n                    ans+=vc;\\n                    count_ones=0;\\n                    continue;\\n                }\\n            }\\n        }\\n        return (ans % cv);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116253,
                "title": "easiest-c-solution-4-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int m=1000000007;\\n    int numSub(string s,long long ans=0,long long c=0) {\\n        for(int i=0; i<s.size(); i++) {\\n             s[i]==\\'0\\'?ans+=((c*(c+1))/2)%m:c++; // add sum of length of substring in ans => (n*(n+1))/2\\n             c=s[i]==\\'0\\'?0:c;  // if a 0 occurs just set the substring \\'c\\' var to 0 \\n        }\\n        ans+=((c*(c+1))/2)%m; // for the suffix,if \\'0\\' is not present the last substring is not calculated , ...111 in for loop\\n        return (int) ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m=1000000007;\\n    int numSub(string s,long long ans=0,long long c=0) {\\n        for(int i=0; i<s.size(); i++) {\\n             s[i]==\\'0\\'?ans+=((c*(c+1))/2)%m:c++; // add sum of length of substring in ans => (n*(n+1))/2\\n             c=s[i]==\\'0\\'?0:c;  // if a 0 occurs just set the substring \\'c\\' var to 0 \\n        }\\n        ans+=((c*(c+1))/2)%m; // for the suffix,if \\'0\\' is not present the last substring is not calculated , ...111 in for loop\\n        return (int) ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074140,
                "title": "c-really-hate-the-extreme-test-samples",
                "content": "with 1 \\'1\\'  we got 1 substring\\nwith 2 \\'1\\'  we got 3 (2 + 1)\\nwith 3 \\'1\\'  we got 6 (3+ 2 + 1)\\n...\\nwith n \\'1\\' we got  n*(n+1)/2\\n```\\n    int numSub(string s) {\\n        long cnt = 0;       \\n        for(int i=0; i<s.size(); i++){\\n            long c1 = 0;\\n            while(s[i] == \\'1\\'){\\n                ++c1;\\n                ++i;\\n            }\\n            cnt += c1*(c1+1)/2;    \\n        }        \\n        return cnt%1000000007;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numSub(string s) {\\n        long cnt = 0;       \\n        for(int i=0; i<s.size(); i++){\\n            long c1 = 0;\\n            while(s[i] == \\'1\\'){\\n                ++c1;\\n                ++i;\\n            }\\n            cnt += c1*(c1+1)/2;    \\n        }        \\n        return cnt%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008052,
                "title": "python-o-n-time-o-1-space-straight-forward-solution",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res=0\\n        count=0\\n        for ch in s:\\n            if ch == \\'1\\':\\n                count+=1\\n                res+=count\\n            else:\\n                count=0\\n        \\n        return res % (10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res=0\\n        count=0\\n        for ch in s:\\n            if ch == \\'1\\':\\n                count+=1\\n                res+=count\\n            else:\\n                count=0\\n        \\n        return res % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998353,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public int numSub(String s) {\\n        long count = 0;\\n\\n        long result = 0;\\n        for(int i = 0; i< s.length() ; i++ ){\\n\\n            if(s.charAt(i) == \\'1\\'){\\n                count++;\\n            }\\n\\n            if(s.charAt(i) == \\'0\\' || i == s.length()-1){\\n                    result = result+find_num(count);\\n                    count = 0;\\n            }\\n\\n\\n\\n\\n        }\\n       int  result1 = (int)(result % ((int)Math.pow(10,9) + 7));\\n        return result1;\\n    }\\n\\n    public long find_num( long n){\\n        if(n == 0){\\n            return 0;\\n        }\\n        long val = 0;\\n        for(int i=1; i<=n ;i++){\\n            val = val + i;\\n        }\\n        return val;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSub(String s) {\\n        long count = 0;\\n\\n        long result = 0;\\n        for(int i = 0; i< s.length() ; i++ ){\\n\\n            if(s.charAt(i) == \\'1\\'){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 937689,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return sum(map(lambda i:(len(i)*(len(i)+1))//2,re.findall(\"[1]+\",s)))%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return sum(map(lambda i:(len(i)*(len(i)+1))//2,re.findall(\"[1]+\",s)))%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898862,
                "title": "cpp-8ms-reason-for-using-mod",
                "content": "**%(mod) 1000000007** is used because it prevents overflow and enables the problem setter to frame his problem for bigger ranges and hence demand a clever algorithm.\\n\\n```\\nclass Solution {\\npublic:\\n    long numSub(string s) {\\n        long i=0,temp = 0,total=0;\\n        while (i<s.length()){\\n            if (s[i]==\\'1\\'){\\n                temp = 0;\\n                while (s[i]==\\'1\\'){\\n                    temp++;\\n                    i++;\\n                }\\n                total += (temp*(temp+1))/2;\\n            }\\n            i++;\\n        }\\n        return total%1000000007; // to prevent overflow\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long numSub(string s) {\\n        long i=0,temp = 0,total=0;\\n        while (i<s.length()){\\n            if (s[i]==\\'1\\'){\\n                temp = 0;\\n                while (s[i]==\\'1\\'){\\n                    temp++;\\n                    i++;\\n                }\\n                total += (temp*(temp+1))/2;\\n            }\\n            i++;\\n        }\\n        return total%1000000007; // to prevent overflow\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862476,
                "title": "easy-peasy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long ans = 0;\\n        for(int i=0;i<s.length();i++)\\n        {   long c=0;\\n            while(s[i]==\\'1\\')\\n            {\\n                c++;\\n                i++;\\n            }\\n            ans += c*(c+1)/2;\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long ans = 0;\\n        for(int i=0;i<s.length();i++)\\n        {   long c=0;\\n            while(s[i]==\\'1\\')\\n            {\\n                c++;\\n                i++;\\n            }\\n            ans += c*(c+1)/2;\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776732,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0;\\n        String [] ones = s.split(\"0\");\\n        \\n        for(String one : ones){\\n            int n = one.length();\\n            count += (n * (n + 1.0) / 2) % 1000_000_007;\\n        }\\n      return count;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0;\\n        String [] ones = s.split(\"0\");\\n        \\n        for(String one : ones){\\n            int n = one.length();\\n            count += (n * (n + 1.0) / 2) % 1000_000_007;\\n        }\\n      return count;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760487,
                "title": "cpp-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long m=pow(10,9)+7;\\n    int numSub(string s) {\\n        long long i=0,j=0;\\n        int c=0;\\n        while(j<s.length()&&i<s.length()){\\n            while(i<s.length()&&s[i]==\\'0\\')\\n                i++;\\n            j=i;\\n            while(j<s.length()&&s[j]==\\'1\\')\\n                j++;\\n            c+=((j-i)*(j-i+1))%m/2;\\n            c%=m;\\n            i=j;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long m=pow(10,9)+7;\\n    int numSub(string s) {\\n        long long i=0,j=0;\\n        int c=0;\\n        while(j<s.length()&&i<s.length()){\\n            while(i<s.length()&&s[i]==\\'0\\')\\n                i++;\\n            j=i;\\n            while(j<s.length()&&s[j]==\\'1\\')\\n                j++;\\n            c+=((j-i)*(j-i+1))%m/2;\\n            c%=m;\\n            i=j;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760020,
                "title": "8ms-faster-than-80-submissions",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0;\\n        String[] ones = s.split(\"0\");\\n        for(String one : ones){\\n            int len = one.length();\\n            if(len >= 1)\\n                count += (len*(len+1.0)/2) % 1000000007;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0;\\n        String[] ones = s.split(\"0\");\\n        for(String one : ones){\\n            int len = one.length();\\n            if(len >= 1)\\n                count += (len*(len+1.0)/2) % 1000000007;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746651,
                "title": "easy-counting-python",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, MOD = 0, 10 ** 9 + 7\\n        for string in s.split(\\'0\\'):\\n            if string:\\n                num = len(string)\\n                res += (1 + num) * num // 2\\n        return res % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, MOD = 0, 10 ** 9 + 7\\n        for string in s.split(\\'0\\'):\\n            if string:\\n                num = len(string)\\n                res += (1 + num) * num // 2\\n        return res % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741782,
                "title": "python-o-n-by-sliding-window-w-comment",
                "content": "Python O(n) sol by sliding window\\n\\n---\\n\\n**Implementation**\\n\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n        # padding one dummy zero as ending symbol\\n        s = s + \\'0\\'\\n        \\n        idx, first_1_idx, last_1_idx = 0, None, None\\n        prev = None\\n        size = len(s)\\n        \\n        counter = 0\\n        \\n        while idx < size:\\n            \\n            if s[idx] == \\'1\\':\\n                if first_1_idx is None:\\n                    # head index of 1s\\n                    first_1_idx = idx\\n                    \\n            else:\\n                if prev == \\'1\\':\\n                    # tail index of 1s\\n                    last_1_idx = idx - 1\\n                    \\n                    # length of current contiguous 1s\\n                    len_of_1 = last_1_idx - first_1_idx + 1\\n                    \\n                    # update count of substrings with 1s\\n                    counter += len_of_1 * ( len_of_1 + 1 ) // 2 \\n                    \\n                    # clear index for new capture of 1s\\n                    first_1_idx, last_1_idx = None, None\\n                    \\n            prev = s[idx]\\n            idx = idx + 1\\n            \\n        return counter % (10**9 + 7)\\n```\\n\\n---\\n\\nShare another solution with counter of contiguous 1s\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n\\t\\t# record of previous digit\\n        prev = 0\\n        \\n        number_of_substrings_of_1 = 0\\n        \\n\\t\\t# linear scan\\n        for char in s:\\n            \\n\\t\\t\\t# type conversion to integer\\n            cur_num = int(char)\\n            \\n            if cur_num:\\n\\t\\t\\t\\t# current digit is 1\\n                \\n                cur_num = prev + 1\\n                \\n\\t\\t\\t\\t# add counter\\n                number_of_substrings_of_1 += cur_num\\n                    \\n            prev = cur_num\\n            \\n        return number_of_substrings_of_1 % (10**9 + 7)\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n        # padding one dummy zero as ending symbol\\n        s = s + \\'0\\'\\n        \\n        idx, first_1_idx, last_1_idx = 0, None, None\\n        prev = None\\n        size = len(s)\\n        \\n        counter = 0\\n        \\n        while idx < size:\\n            \\n            if s[idx] == \\'1\\':\\n                if first_1_idx is None:\\n                    # head index of 1s\\n                    first_1_idx = idx\\n                    \\n            else:\\n                if prev == \\'1\\':\\n                    # tail index of 1s\\n                    last_1_idx = idx - 1\\n                    \\n                    # length of current contiguous 1s\\n                    len_of_1 = last_1_idx - first_1_idx + 1\\n                    \\n                    # update count of substrings with 1s\\n                    counter += len_of_1 * ( len_of_1 + 1 ) // 2 \\n                    \\n                    # clear index for new capture of 1s\\n                    first_1_idx, last_1_idx = None, None\\n                    \\n            prev = s[idx]\\n            idx = idx + 1\\n            \\n        return counter % (10**9 + 7)\\n```\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n\\t\\t# record of previous digit\\n        prev = 0\\n        \\n        number_of_substrings_of_1 = 0\\n        \\n\\t\\t# linear scan\\n        for char in s:\\n            \\n\\t\\t\\t# type conversion to integer\\n            cur_num = int(char)\\n            \\n            if cur_num:\\n\\t\\t\\t\\t# current digit is 1\\n                \\n                cur_num = prev + 1\\n                \\n\\t\\t\\t\\t# add counter\\n                number_of_substrings_of_1 += cur_num\\n                    \\n            prev = cur_num\\n            \\n        return number_of_substrings_of_1 % (10**9 + 7)\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 738726,
                "title": "c-one-liner",
                "content": "```\\npublic int NumSub(string s) =>\\n\\t(int)(s.Split(\\'0\\')\\n\\t\\t.Select(x => (long)x.Length * (x.Length + 1) / 2)\\n\\t\\t.Sum() % (1_000_000_000 + 7));\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumSub(string s) =>\\n\\t(int)(s.Split(\\'0\\')\\n\\t\\t.Select(x => (long)x.Length * (x.Length + 1) / 2)\\n\\t\\t.Sum() % (1_000_000_000 + 7));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736191,
                "title": "c-simple-o-n-dp-solution",
                "content": "DP[i]=for every \\'1\\' encountered at **ith position, the number of substrings that can be formed will be equal to the number of substrings formed at (i-1)th position +1.** \\nAt last , the total number of substrings can be found by adding all the values of DP array.\\nPS:- I know , this problem can be done without dp approach, but still its better to visualize a problem thorugh it apart from n*(n+1)/2 method.. (pls upvote if you agree) :)\\n```\\nint numSub(string s) {\\n        long i=0,j=0,n=s.length();\\n        long dp[n];\\n        dp[0]=(s[0]==\\'0\\')?0:1;\\n        \\n        int sum=dp[0];\\n        for(long i=1;i<n;i++){\\n            if(s[i]==\\'1\\')\\n                dp[i]=1+dp[i-1];\\n            else\\n                dp[i]=0;\\n            \\n            sum=(sum+dp[i])%1000000007;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint numSub(string s) {\\n        long i=0,j=0,n=s.length();\\n        long dp[n];\\n        dp[0]=(s[0]==\\'0\\')?0:1;\\n        \\n        int sum=dp[0];\\n        for(long i=1;i<n;i++){\\n            if(s[i]==\\'1\\')\\n                dp[i]=1+dp[i-1];\\n            else\\n                dp[i]=0;\\n            \\n            sum=(sum+dp[i])%1000000007;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 734710,
                "title": "python-head-on-explained-with-some-tips",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        d,l = defaultdict(int),0\\n        for i,v in enumerate(s):\\n            if v==\\'1\\':\\n                l+=1\\n            else:\\n                d[l]+=1\\n                l=0\\n        d[l]+=1\\n\\n        return sum( v*((k+1)*k//2) for k,v in d.items() ) % (10**9 + 7)\\n```\\n\\nSo this is the most head-on approach. First, we count number of sequences of `1` for each length.\\n\\nThe dictionary `d` will look like: `length`:`number of occurencies`, `l` is the current lenght of `1`s. Basically if we see `1` - we increament `l` and when we see `0` - we updated our dictionary and reset the counter `l`.\\n\\n```\\n        for i,v in enumerate(s):\\n            if v==\\'1\\':\\n                l+=1\\n            else:\\n                d[l]+=1\\n                l=0\\n```\\n\\nUsing `defaultdict(int)` makes our life easier because we don\\'t need to worry about creating the first entry for a sequence of a particular lenght.\\n\\nThat `for` loop works great if we have a `0` after each seq of `1`s, but if `s` ends with a `1`, we need to add an extra line to handle that case:\\n\\n```\\n        d[l]+=1\\n```\\n\\nOk, now we know the number of sequences and we know that each sequence of lenght `v` will contribute `(k+1)*k//2)` to the end result. We just need to take care of a couple things:\\n\\n1. `sum( v*((k+1)*k//2) for k,v in d.items() )` - the `v*` part simply says multiply by number of sequences.\\n2. in Python the lenght of int is virtually unlimited, so we can apply ` % (10**9 + 7)` only ones to the final result. In other languages with limited int size, we might want to do it along the way.\\n\\nOne more thing. In this approach if we see something like `000` - we\\'ll be incrementing d[0]. Technically this is not needed since those zero lenght sequences will be ignored in the end. So we can add and extra `if` to make sure that we only count non-zero sequences. However, running tests shows that that extra `if` would make it run slower, so it\\'s not needed after all.\\n\\nThat\\'s it!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        d,l = defaultdict(int),0\\n        for i,v in enumerate(s):\\n            if v==\\'1\\':\\n                l+=1\\n            else:\\n                d[l]+=1\\n                l=0\\n        d[l]+=1\\n\\n        return sum( v*((k+1)*k//2) for k,v in d.items() ) % (10**9 + 7)\\n```\n```\\n        for i,v in enumerate(s):\\n            if v==\\'1\\':\\n                l+=1\\n            else:\\n                d[l]+=1\\n                l=0\\n```\n```\\n        d[l]+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734585,
                "title": "c-sliding-window",
                "content": "```\\nint numSub(string s) {\\n\\tint res = 0;\\n\\tlong long curOnes = 0;\\n\\tint mod = 1000000007;\\n\\tfor (char c : s) {\\n\\t\\tif (c == \\'1\\')\\n\\t\\t\\tcurOnes++;\\n\\t\\telse {\\n\\t\\t\\tres += (curOnes * (curOnes + 1) / 2) % mod;\\n\\t\\t\\tcurOnes = 0;\\n\\t\\t}\\n\\t}\\n\\tif (curOnes)\\n\\t\\tres += (curOnes * (curOnes + 1) / 2) % mod;\\n\\treturn res;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint numSub(string s) {\\n\\tint res = 0;\\n\\tlong long curOnes = 0;\\n\\tint mod = 1000000007;\\n\\tfor (char c : s) {\\n\\t\\tif (c == \\'1\\')\\n\\t\\t\\tcurOnes++;\\n\\t\\telse {\\n\\t\\t\\tres += (curOnes * (curOnes + 1) / 2) % mod;\\n\\t\\t\\tcurOnes = 0;\\n\\t\\t}\\n\\t}\\n\\tif (curOnes)\\n\\t\\tres += (curOnes * (curOnes + 1) / 2) % mod;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733710,
                "title": "c-o-n-simple-solution-40ms-time",
                "content": "```\\n int mod=1e9+7;\\n    int numSub(string s) {\\n        vector<long>ans;\\n        long count=0,sum=0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch =s[i];\\n            count=0;\\n            if(ch==\\'1\\')\\n            {\\n                count++;\\n                i++;\\n                while(s[i] != \\'0\\' && i<s.length())\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                ans.push_back(count);\\n            }\\n        }\\n        for(long &ele: ans)\\n        {\\n            sum+=(((ele + 1) * ele/2))%mod;\\n        }\\n        return sum%mod;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n int mod=1e9+7;\\n    int numSub(string s) {\\n        vector<long>ans;\\n        long count=0,sum=0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch =s[i];\\n            count=0;\\n            if(ch==\\'1\\')\\n            {\\n                count++;\\n                i++;\\n                while(s[i] != \\'0\\' && i<s.length())\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                ans.push_back(count);\\n            }\\n        }\\n        for(long &ele: ans)\\n        {\\n            sum+=(((ele + 1) * ele/2))%mod;\\n        }\\n        return sum%mod;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733563,
                "title": "c-with-some-math",
                "content": "```\\nlong res=0, n=0, len=s.length();\\n        for(int i=0; i<len; i++){\\n            if(s[i]==\\'1\\'){ \\n                n++;\\n                if(i==len-1 || s[i+1]==\\'0\\'){\\n                    res+=n*(n+1)/2;\\n                    n=0;\\n                }\\n            }\\n        }\\n        return res % 1000000007;\\n```",
                "solutionTags": [],
                "code": "```\\nlong res=0, n=0, len=s.length();\\n        for(int i=0; i<len; i++){\\n            if(s[i]==\\'1\\'){ \\n                n++;\\n                if(i==len-1 || s[i+1]==\\'0\\'){\\n                    res+=n*(n+1)/2;\\n                    n=0;\\n                }\\n            }\\n        }\\n        return res % 1000000007;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733052,
                "title": "python-sliding-window",
                "content": "```python\\ndef numSub(self, s: str) -> int:\\n        start = 0\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \"0\": start=i+1\\n            else: result += i-start+1 \\n        return result%(10**9+7)\\n\\n```",
                "solutionTags": [],
                "code": "```python\\ndef numSub(self, s: str) -> int:\\n        start = 0\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \"0\": start=i+1\\n            else: result += i-start+1 \\n        return result%(10**9+7)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 732779,
                "title": "java-dp-o-n-100",
                "content": "```\\nclass Solution {\\n    final int  MOD=1000000007;\\n    public int numSub(String s) {\\n      if(s==null || s.length()==0) return 0;\\n      int n = s.length();\\n      int[] dp = new int[n];\\n      dp[0] = Integer.parseInt(String.valueOf(s.charAt(0)));\\n      for(int i=1; i<n; i++){\\n          if(s.charAt(i)==\\'1\\'){\\n              dp[i] = dp[i-1] + 1;\\n          }else{\\n              dp[i] = 0;\\n          }\\n       }\\n       int res = 0;                         \\n      for(int i=0; i<n; i++){\\n          res = (res+dp[i])%MOD;\\n      }\\n      return res;                         \\n    }                 \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    final int  MOD=1000000007;\\n    public int numSub(String s) {\\n      if(s==null || s.length()==0) return 0;\\n      int n = s.length();\\n      int[] dp = new int[n];\\n      dp[0] = Integer.parseInt(String.valueOf(s.charAt(0)));\\n      for(int i=1; i<n; i++){\\n          if(s.charAt(i)==\\'1\\'){\\n              dp[i] = dp[i-1] + 1;\\n          }else{\\n              dp[i] = 0;\\n          }\\n       }\\n       int res = 0;                         \\n      for(int i=0; i<n; i++){\\n          res = (res+dp[i])%MOD;\\n      }\\n      return res;                         \\n    }                 \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732418,
                "title": "c-code-simple-one-loop",
                "content": "```\\n\\n\\nint numSub(char * s){\\n    size_t res=0;\\n    size_t k=0;\\n    for(size_t i=0;s[i];i++){\\n        if(s[i]==\\'1\\'){\\n            k++;\\n            res+=k;\\n        }\\n        else{\\n            k=0;\\n        }\\n    }\\n    return res%((size_t)(pow(10,9)+7));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nint numSub(char * s){\\n    size_t res=0;\\n    size_t k=0;\\n    for(size_t i=0;s[i];i++){\\n        if(s[i]==\\'1\\'){\\n            k++;\\n            res+=k;\\n        }\\n        else{\\n            k=0;\\n        }\\n    }\\n    return res%((size_t)(pow(10,9)+7));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732191,
                "title": "simple-c-with-left-and-right-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        int len=s.length();\\n        int left=-1,right=0,total=0;\\n        while(right<len)\\n        {\\n            if(s[right]==\\'0\\')\\n                left=right;\\n            else\\n            {\\n                total+=(right-left);\\n                total%=1000000000+7;\\n            }\\n            right=right+1;\\n        }\\n        return total%(1000000000+7);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        int len=s.length();\\n        int left=-1,right=0,total=0;\\n        while(right<len)\\n        {\\n            if(s[right]==\\'0\\')\\n                left=right;\\n            else\\n            {\\n                total+=(right-left);\\n                total%=1000000000+7;\\n            }\\n            right=right+1;\\n        }\\n        return total%(1000000000+7);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732008,
                "title": "wrong-answer-not-able-to-figure-out-why-8000x8001",
                "content": "Hello Community,\\n\\nI understand the approach here I am taking is not the most optimized but I am not able to understand why this program is giving wrong answer for one of the input. On debugging the program for input which has  has continuous count of 1 as 8000, the number of substring I am getting is 1052556352 instead of 32004000 (I am using sum of natural number approach). I have added my submitted snippet which gave me wrong answer. \\n\\nOn debugging more I found that somehow program is giving wrong answer for (8000*8001). Not able to understan why. But since it involves very basic misunderstanding from my side  help me out.\\n\\nThank you for the help.\\n\\n\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int result = 0;\\n        for(int i = 0; i < s.length();){\\n            if(s.charAt(i) == \\'0\\'){\\n                i++;\\n            }else{\\n                // find count of continious one\\n                int count = 1;\\n                for(int j = i+1; j < s.length(); j++){\\n                    if(s.charAt(j) != \\'1\\'){\\n                        break;\\n                    }\\n                    count++;\\n                }\\n                int numSubstring = (count * (count+1))/2;\\n                System.out.println(\"i:\"+i+\",numSubstring:\"+numSubstring+\",count:\"+count); // added for debug purpose\\n                result += numSubstring;\\n                result = result % 1000000007;\\n                i += count;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int result = 0;\\n        for(int i = 0; i < s.length();){\\n            if(s.charAt(i) == \\'0\\'){\\n                i++;\\n            }else{\\n                // find count of continious one\\n                int count = 1;\\n                for(int j = i+1; j < s.length(); j++){\\n                    if(s.charAt(j) != \\'1\\'){\\n                        break;\\n                    }\\n                    count++;\\n                }\\n                int numSubstring = (count * (count+1))/2;\\n                System.out.println(\"i:\"+i+\",numSubstring:\"+numSubstring+\",count:\"+count); // added for debug purpose\\n                result += numSubstring;\\n                result = result % 1000000007;\\n                i += count;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731997,
                "title": "simple-c-solution-using-memorization",
                "content": "class Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        long long f=s[0]-\\'0\\';\\n        \\n        long long mod=1000000007;\\n        \\n        long long prev=s[0]-\\'0\\';\\n        \\n        for(int i=1;i<s.length();i++){\\n            \\n            if((s[i]-\\'0\\')==1)\\n            {\\n                if(s[i-1]-\\'0\\'==1)\\n                {\\n                    prev=prev+1;\\n                    \\n                }\\n                \\n                else\\n                    prev=1;\\n                \\n            }\\n            \\n            else\\n            {\\n                prev=0;\\n            }\\n            \\n            \\n            \\n            f=(f%mod+(prev)%mod)%mod;\\n        \\n        }\\n        \\n        \\n        \\n        return f%mod;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        long long f=s[0]-\\'0\\';\\n        \\n        long long mod=1000000007;\\n        \\n        long long prev=s[0]-\\'0\\';\\n        \\n        for(int i=1;i<s.length();i++){\\n            \\n            if((s[i]-\\'0\\')==1)\\n            {\\n                if(s[i-1]-\\'0\\'==1)\\n                {\\n                    prev=prev+1;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 731947,
                "title": "c-step-by-step-explanation-o-n",
                "content": "Find length of each substring containing only 1\\'s.\\nOnce we find a substring of length l with only 1\\'s no. of substrings possible is given by l*(l+1)/2 (sum of numbers from 1 to l)\\nExample - 110111\\nThere are two substrings containing only 1\\'s..i.e., 11 of length 2 and 111 of length 3\\nFor 1st substring \"11\" -\\nNo. of substring which Contain \\'1\\' is - 2\\nNo. of substring which Contain \\'11\\' is - 1\\n\\nTotal No. of substring =2+1 = 2*(2+1)/2 = 3\\n\\nFor 1st substring \"111\" -\\nNo. of substring which Contain \\'1\\' is - 3\\nNo. of substring which Contain \\'11\\' is - 2\\nNo. of substring which Contain \\'111\\' is - 1\\n\\nTotal No. of substring =3+2+1 = 2=3*(3+1)/2 = 6\\n\\nSo. total no. of substrings aren 3+6 = 9\\n\\n```\\nclass Solution {\\npublic:\\n    long long int total(int n){\\n        long long int res=0;\\n        for(int i=1;i<=n;i++){\\n            res+=i;\\n        }\\n        return res;\\n    }\\n    int numSub(string s) {\\n        long long int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n            int l =0;\\n            if(s[i]==\\'1\\'){\\n                l++;\\n                while(i+1<s.length() && s[i+1]!=\\'0\\'){\\n                    l++;\\n                    i++;\\n                }\\n            }\\n            ans+=total(l);\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int total(int n){\\n        long long int res=0;\\n        for(int i=1;i<=n;i++){\\n            res+=i;\\n        }\\n        return res;\\n    }\\n    int numSub(string s) {\\n        long long int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n            int l =0;\\n            if(s[i]==\\'1\\'){\\n                l++;\\n                while(i+1<s.length() && s[i+1]!=\\'0\\'){\\n                    l++;\\n                    i++;\\n                }\\n            }\\n            ans+=total(l);\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731859,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        int n = s.length();\\n        int ans  = 0, c = 0;\\n        int MOD = 1000000007;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'1\\')\\n                c++;\\n            else\\n                c = 0;\\n            ans = (ans + c)%MOD;\\n        }\\n        \\n        return ans%MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        int n = s.length();\\n        int ans  = 0, c = 0;\\n        int MOD = 1000000007;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'1\\')\\n                c++;\\n            else\\n                c = 0;\\n            ans = (ans + c)%MOD;\\n        }\\n        \\n        return ans%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731822,
                "title": "python-easy-solution-o-n",
                "content": "Approach 1:\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, curr = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                curr += 1\\n            else:\\n                res += (curr * (curr + 1))//2\\n                curr = 0\\n        if curr > 0:\\n            res += (curr * (curr + 1))//2\\n        return res % 1000000007\\n```\\n\\nApproach 2:\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, curr = 0, 0\\n        for i in range(len(s)):\\n            curr = curr + 1 if s[i] == \\'1\\' else 0\\n            res += curr\\n        return res % 1000000007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, curr = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                curr += 1\\n            else:\\n                res += (curr * (curr + 1))//2\\n                curr = 0\\n        if curr > 0:\\n            res += (curr * (curr + 1))//2\\n        return res % 1000000007\\n```\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, curr = 0, 0\\n        for i in range(len(s)):\\n            curr = curr + 1 if s[i] == \\'1\\' else 0\\n            res += curr\\n        return res % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731814,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int NumSub(string s) \\n    {\\n        long prev = -1, result = 0, n = s.Length;;\\n        for(int i = 0; i <= n; i++)\\n            if(i == n || s[i] == \\'0\\')\\n            {\\n                long len = (i - prev - 1);\\n                result += (len * (len + 1)) / 2;\\n                result = result % 1_000_000_007;\\n                prev = i;\\n            }\\n        \\n        return (int) result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int NumSub(string s) \\n    {\\n        long prev = -1, result = 0, n = s.Length;;\\n        for(int i = 0; i <= n; i++)\\n            if(i == n || s[i] == \\'0\\')\\n            {\\n                long len = (i - prev - 1);\\n                result += (len * (len + 1)) / 2;\\n                result = result % 1_000_000_007;\\n                prev = i;\\n            }\\n        \\n        return (int) result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731811,
                "title": "python-o-n-simple-math-too-easy-i-don-t-like-this-question",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        l = len(s)\\n        arr = 0\\n        flag=0\\n        for i in range(l):\\n            if s[i]==\\'1\\':\\n                flag+=1\\n            else:\\n                arr+=flag*(flag+1)//2\\n                flag=0\\n        arr+=flag*(flag+1)//2\\n        return arr % (10**9 + 7)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        l = len(s)\\n        arr = 0\\n        flag=0\\n        for i in range(l):\\n            if s[i]==\\'1\\':\\n                flag+=1\\n            else:\\n                arr+=flag*(flag+1)//2\\n                flag=0\\n        arr+=flag*(flag+1)//2\\n        return arr % (10**9 + 7)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 731773,
                "title": "swift",
                "content": "```\\nfunc numSub(_ s: String) -> Int {\\n\\tif s.length == 0 { return 0 }\\n\\tvar currentIndex = 0\\n\\tvar currentLength = 0\\n\\tvar result = 0\\n\\tlet sArray = Array(s)\\n\\tlet modulus = Int(pow(Double(10), Double(9)) + 7)\\n\\twhile currentIndex < sArray.count {\\n\\t\\tlet char = sArray[currentIndex]\\n\\t\\tif char == \"1\" {\\n\\t\\t\\tcurrentLength += 1\\n\\t\\t} else if currentLength > 0 {\\n\\t\\t\\tresult += ((currentLength * (currentLength + 1)) / 2) % modulus\\n\\t\\t\\tcurrentLength = 0\\n\\t\\t}\\n\\t\\tcurrentIndex += 1\\n\\t}\\n\\n\\tif currentLength > 0 {\\n\\t\\tresult += (currentLength * (currentLength + 1)) / 2\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numSub(_ s: String) -> Int {\\n\\tif s.length == 0 { return 0 }\\n\\tvar currentIndex = 0\\n\\tvar currentLength = 0\\n\\tvar result = 0\\n\\tlet sArray = Array(s)\\n\\tlet modulus = Int(pow(Double(10), Double(9)) + 7)\\n\\twhile currentIndex < sArray.count {\\n\\t\\tlet char = sArray[currentIndex]\\n\\t\\tif char == \"1\" {\\n\\t\\t\\tcurrentLength += 1\\n\\t\\t} else if currentLength > 0 {\\n\\t\\t\\tresult += ((currentLength * (currentLength + 1)) / 2) % modulus\\n\\t\\t\\tcurrentLength = 0\\n\\t\\t}\\n\\t\\tcurrentIndex += 1\\n\\t}\\n\\n\\tif currentLength > 0 {\\n\\t\\tresult += (currentLength * (currentLength + 1)) / 2\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731772,
                "title": "easy-java-o-n",
                "content": "\\tpublic int numSub(String s) {\\n            long count = 0;\\n        long local = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                local++;\\n            }else{\\n                long cal = local*(local + 1)/2; \\n                count = count + cal;\\n                //count = count;\\n                local = 0;\\n            }\\n        }\\n        long cal = local*(local + 1)/2;\\n                count = count + cal;\\n\\n        count = count%1000000007;\\n\\n        return (int)count;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int numSub(String s) {\\n            long count = 0;\\n        long local = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                local++;\\n            }else{\\n                long cal = local*(local + 1)/2; \\n                count = count + cal;\\n                //count = count;\\n                local = 0;\\n            }\\n        }\\n        long cal = local*(local + 1)/2;\\n                count = count + cal;\\n\\n        count = count%1000000007;\\n\\n        return (int)count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 731680,
                "title": "python-3-number-of-substring-with-only-1s-easy",
                "content": "**Solution is slow but one of the ways to solve the problem**\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n        res=0\\n        one_rt = 0\\n        \\n        for c in s:\\n            if c == \\'0\\':\\n                one_rt=0\\n            else:\\n                one_rt+=1\\n                res+=one_rt\\n                \\n        return res % 1000000007",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "**Solution is slow but one of the ways to solve the problem**\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n        res=0\\n        one_rt = 0\\n        \\n        for c in s:\\n            if c == \\'0\\':\\n                one_rt=0\\n            else:\\n                one_rt+=1\\n                res+=one_rt\\n                \\n        return res % 1000000007",
                "codeTag": "Java"
            },
            {
                "id": 731654,
                "title": "c-use-previous-calculated-value-if-there-are-consecutive-1s",
                "content": "Example: If we have 1111\\nthen first time we calculate at index 0 we have string of length 1 + 2 + 3 + 4 , total 4\\nthen for index 1 we have strings of lengths 1 + 2 + 3 , total 3\\nthen total 2 and 1\\nThus if we have consecutive 1s then total number of substrings = one at previous index - 1, so we only need to calculate substrings if previous char is 0 and current char is 1.\\n\\n```csharp\\npublic int NumSub(string s)\\n{\\n\\tint MOD = (int)(1E9) + 7;\\n\\tlong count = 0;\\n\\tlong currentCount = 0;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tif (s[i] == \\'1\\')\\n\\t\\t{\\n\\t\\t\\tif (i > 0 && s[i - 1] == \\'1\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentCount--;\\n\\t\\t\\t\\tcount += currentCount;\\n\\t\\t\\t\\tif (count > MOD)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount -= MOD;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int j = i; j < s.Length && s[j] == \\'1\\'; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentCount++;\\n\\t\\t\\t\\tif (currentCount > MOD)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurrentCount -= MOD;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcount += currentCount;\\n\\t\\t\\tif (count > MOD)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount -= MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrentCount = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn (int)count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumSub(string s)\\n{\\n\\tint MOD = (int)(1E9) + 7;\\n\\tlong count = 0;\\n\\tlong currentCount = 0;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tif (s[i] == \\'1\\')\\n\\t\\t{\\n\\t\\t\\tif (i > 0 && s[i - 1] == \\'1\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentCount--;\\n\\t\\t\\t\\tcount += currentCount;\\n\\t\\t\\t\\tif (count > MOD)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount -= MOD;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int j = i; j < s.Length && s[j] == \\'1\\'; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentCount++;\\n\\t\\t\\t\\tif (currentCount > MOD)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurrentCount -= MOD;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcount += currentCount;\\n\\t\\t\\tif (count > MOD)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount -= MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrentCount = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn (int)count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731641,
                "title": "python-python3-number-of-substrings-with-only-1-s",
                "content": "![image](https://assets.leetcode.com/users/images/04d8842c-66d2-4fb1-97aa-182a43e50d85_1594526517.0796642.png)\\n\\nThis whole problem can be boiled down to finding the consecutive 1\\'s in the string. We need to first find the consecutive 1\\'s in the string. After we do that as shown in the figure, as we keep increase the length of substring in a string of consecutive 1\\'s, we keep getting less number of counts. As the length of substring increases by 1, the count decreaes by 1. This forms an AP and we can use the formula of counting sum of n consecutive numbers where here n would be the length of consecutive 1\\'s we find in the string.\\n\\ni. Using Split\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        j = s.split(\\'0\\')\\n        total = []\\n        for x in j:\\n            if x:\\n                k = len(x)\\n                total.append(((k)*(k+1))//2)\\n\\n        return sum(total)%(10**9+7)\\n```\\n\\nii Sliding Window\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        i, j, total, count_one = 0, 0, 0, 0\\n        \\n        while j < len(s):\\n            if s[j] == \\'1\\':\\n                count_one += 1\\n            elif count_one:\\n                i = j\\n                total += (((count_one)*(count_one+1))//2)\\n                count_one = 0\\n            \\n            j += 1\\n        \\n        total += (((count_one)*(count_one+1))//2)\\n        \\n        return total%(10**9+7)\\n```\\nTime complexity:  ```O(n)```\\nSpace Complexity: ```O(n)```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        j = s.split(\\'0\\')\\n        total = []\\n        for x in j:\\n            if x:\\n                k = len(x)\\n                total.append(((k)*(k+1))//2)\\n\\n        return sum(total)%(10**9+7)\\n```\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        i, j, total, count_one = 0, 0, 0, 0\\n        \\n        while j < len(s):\\n            if s[j] == \\'1\\':\\n                count_one += 1\\n            elif count_one:\\n                i = j\\n                total += (((count_one)*(count_one+1))//2)\\n                count_one = 0\\n            \\n            j += 1\\n        \\n        total += (((count_one)*(count_one+1))//2)\\n        \\n        return total%(10**9+7)\\n```\n```O(n)```\n```O(n)```",
                "codeTag": "Java"
            },
            {
                "id": 731636,
                "title": "using-the-trick-of-math",
                "content": "The basic idea here is, we can find **each longest continous \\'1\\' substring** in the given string and do a math calculation, finally add this math result to the final result to output. \\n\\nFor example, if we have \"111\", all we need to do here is find the length of longest \\'1\\' substring, which is 3 and do (3+1) * 3 / 2 = 6, and 6 is the answer for this \"111\" testcase. \\n\\nMath behind this question: if we have a longest continous \\'1\\' substring with length **n**, we can prove that total number of the \"1\" substring is (n + 1) * n / 2. \\n\\n    public int numSub(String s) {\\n        long res = 0, cnt = 0;\\n        char[] ch = s.toCharArray();\\n        int i = 0;\\n     \\n        while (i < ch.length) {\\n            if (ch[i] == \\'1\\') {\\n                cnt += 1;\\n                i++;\\n            } else {\\n                res += helper(cnt);\\n                cnt = 0;\\n                i++;\\n            }\\n        }\\n        if (cnt != 0) res += helper(cnt);\\n        return (int)(res % (1000000000 + 7));\\n    }\\n    \\n    public long helper(long num) {\\n        if (num == 0) return 0;\\n        return (num + 1) * num / 2;\\n    }",
                "solutionTags": [],
                "code": "The basic idea here is, we can find **each longest continous \\'1\\' substring** in the given string and do a math calculation, finally add this math result to the final result to output. \\n\\nFor example, if we have \"111\", all we need to do here is find the length of longest \\'1\\' substring, which is 3 and do (3+1) * 3 / 2 = 6, and 6 is the answer for this \"111\" testcase. \\n\\nMath behind this question: if we have a longest continous \\'1\\' substring with length **n**, we can prove that total number of the \"1\" substring is (n + 1) * n / 2. \\n\\n    public int numSub(String s) {\\n        long res = 0, cnt = 0;\\n        char[] ch = s.toCharArray();\\n        int i = 0;\\n     \\n        while (i < ch.length) {\\n            if (ch[i] == \\'1\\') {\\n                cnt += 1;\\n                i++;\\n            } else {\\n                res += helper(cnt);\\n                cnt = 0;\\n                i++;\\n            }\\n        }\\n        if (cnt != 0) res += helper(cnt);\\n        return (int)(res % (1000000000 + 7));\\n    }\\n    \\n    public long helper(long num) {\\n        if (num == 0) return 0;\\n        return (num + 1) * num / 2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 731618,
                "title": "java-count-o-n",
                "content": "```\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        long res = 0;\\n        int n = s.length();\\n        int len = 0;\\n        for(int i=0; i<n; i++){\\n            char c = s.charAt(i);\\n            if(c==\\'1\\'){\\n                len++;\\n                res = (res+len)%mod;\\n            }\\n            else{\\n                len = 0;\\n            }\\n        }\\n        return (int)res%mod;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        long res = 0;\\n        int n = s.length();\\n        int len = 0;\\n        for(int i=0; i<n; i++){\\n            char c = s.charAt(i);\\n            if(c==\\'1\\'){\\n                len++;\\n                res = (res+len)%mod;\\n            }\\n            else{\\n                len = 0;\\n            }\\n        }\\n        return (int)res%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731579,
                "title": "c-o-n-naive-to-optimized-version-with-full-explanation",
                "content": "```\\n/*\\n - (0) - 0\\n1 - (1) - 1\\n11- (2) - 3\\n111(3)  - 6\\n1111(4) - 10\\n11111(5) -15\\n111111(6)- 21\\n1111111(7)-28*/\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        //Idea is to calculate the number of substring beforhand for given string size\\n        vector<long long> v;\\n        v.push_back(0);      \\n        long long sum =0;\\n        for(int i=1; i<=s.size(); ++i)\\n        {\\n            sum += i;//as given above, we can calculate by just adding the current number with previous sum\\n            v.push_back(sum);\\n        }\\n      \\n        //Now find the contigious 1\\'s and add them into another array\\n        vector<int> contigiuous;\\n        int cnt =0;\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if( s[i] == \\'1\\')\\n                cnt++;\\n            else\\n            {\\n                if(cnt>0)\\n                    contigiuous.push_back(cnt);\\n                cnt = 0;\\n            }\\n        }\\n        \\n        //for the last substring. If cnt>0, add it\\n        if(cnt>0)\\n           contigiuous.push_back(cnt);\\n        \\n        //Now navigate through the contigiuous array, get the number of possilbe sumbstring and add it in final sum\\n        long long output=0;\\n        for(auto c:contigiuous)\\n            output += v[c];\\n        \\n        return output % 1000000007;\\n    }\\n};\\n```\\n\\n//Optimized version. \\n//TC-O(N) and SC-O(1)\\n```\\n/*\\n - (0) - 0\\n1 - (1) - 1\\n11- (2) - 3\\n111(3)  - 6\\n1111(4) - 10\\n11111(5) -15\\n111111(6)- 21\\n1111111(7)-28*/\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n      \\n        long long output=0, sum =0;//sum is to calcuate the accumulative value as given series. n(n+1)/2\\n        int cnt =0;\\n        for(char c:s)\\n        {\\n            if( c == \\'1\\')//if c is \"1\", then incremnt the count and update the sum  \\n            {\\n                cnt++;\\n                sum +=cnt;//this produces the same sequence as above\\n            }\\n            else//else reset sum and cnt to 0 and update the output\\n            {\\n                if(cnt>0)\\n                    output+= sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        //for the last substring. If cnt>0, add it\\n        if(cnt>0)\\n           output+= sum;\\n        \\n        return output % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n - (0) - 0\\n1 - (1) - 1\\n11- (2) - 3\\n111(3)  - 6\\n1111(4) - 10\\n11111(5) -15\\n111111(6)- 21\\n1111111(7)-28*/\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        //Idea is to calculate the number of substring beforhand for given string size\\n        vector<long long> v;\\n        v.push_back(0);      \\n        long long sum =0;\\n        for(int i=1; i<=s.size(); ++i)\\n        {\\n            sum += i;//as given above, we can calculate by just adding the current number with previous sum\\n            v.push_back(sum);\\n        }\\n      \\n        //Now find the contigious 1\\'s and add them into another array\\n        vector<int> contigiuous;\\n        int cnt =0;\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if( s[i] == \\'1\\')\\n                cnt++;\\n            else\\n            {\\n                if(cnt>0)\\n                    contigiuous.push_back(cnt);\\n                cnt = 0;\\n            }\\n        }\\n        \\n        //for the last substring. If cnt>0, add it\\n        if(cnt>0)\\n           contigiuous.push_back(cnt);\\n        \\n        //Now navigate through the contigiuous array, get the number of possilbe sumbstring and add it in final sum\\n        long long output=0;\\n        for(auto c:contigiuous)\\n            output += v[c];\\n        \\n        return output % 1000000007;\\n    }\\n};\\n```\n```\\n/*\\n - (0) - 0\\n1 - (1) - 1\\n11- (2) - 3\\n111(3)  - 6\\n1111(4) - 10\\n11111(5) -15\\n111111(6)- 21\\n1111111(7)-28*/\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n      \\n        long long output=0, sum =0;//sum is to calcuate the accumulative value as given series. n(n+1)/2\\n        int cnt =0;\\n        for(char c:s)\\n        {\\n            if( c == \\'1\\')//if c is \"1\", then incremnt the count and update the sum  \\n            {\\n                cnt++;\\n                sum +=cnt;//this produces the same sequence as above\\n            }\\n            else//else reset sum and cnt to 0 and update the output\\n            {\\n                if(cnt>0)\\n                    output+= sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        //for the last substring. If cnt>0, add it\\n        if(cnt>0)\\n           output+= sum;\\n        \\n        return output % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081584,
                "title": "easy-c-solution-using-subarray-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought of calcualting the number of continous zeros ,then finding the number of subaarys possible with that continuous zeroes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncalculate the running continuos count of zeroes,as we didnt find the zero ,add the c*(c+1)/2 to ans and make the c=0(for again calculating the runnning continuos count of zero).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//using the formula of subarrays->n*(n+1)/2;\\n    int mod=1e9+7;\\n    int numSub(string s) {\\n        int n=s.size();\\n        int c=0;\\n        long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c++;\\n            }\\n            else{\\n                ans+=(c*1LL*(c+1)/2);\\n                c=0;\\n            }\\n        }\\n        ans+=(c*1LL*(c+1)/2);\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//using the formula of subarrays->n*(n+1)/2;\\n    int mod=1e9+7;\\n    int numSub(string s) {\\n        int n=s.size();\\n        int c=0;\\n        long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c++;\\n            }\\n            else{\\n                ans+=(c*1LL*(c+1)/2);\\n                c=0;\\n            }\\n        }\\n        ans+=(c*1LL*(c+1)/2);\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067452,
                "title": "beginner-level-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef count_ones(s):\\n    one_sum = 0\\n    streak = 0\\n    memory = 0\\n    for char in s:\\n        if char == \\'1\\':\\n            streak += 1\\n            memory = streak\\n            \\n        elif char == \\'0\\':\\n            streak = 0\\n            if memory > 0:\\n                one_sum+=memory*(memory+1)/2\\n                memory = 0\\n    \\n    if memory > 0:\\n        one_sum+=memory*(memory+1)/2\\n        print(memory)\\n    return one_sum\\n\\n\\nclass Solution(object):\\n    def numSub(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        num = count_ones(s)\\n        return num%(10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef count_ones(s):\\n    one_sum = 0\\n    streak = 0\\n    memory = 0\\n    for char in s:\\n        if char == \\'1\\':\\n            streak += 1\\n            memory = streak\\n            \\n        elif char == \\'0\\':\\n            streak = 0\\n            if memory > 0:\\n                one_sum+=memory*(memory+1)/2\\n                memory = 0\\n    \\n    if memory > 0:\\n        one_sum+=memory*(memory+1)/2\\n        print(memory)\\n    return one_sum\\n\\n\\nclass Solution(object):\\n    def numSub(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        num = count_ones(s)\\n        return num%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065321,
                "title": "kotlin-one-liner",
                "content": "# Intuition\\nEach series of 1s forms the sum of natural up to number of ones in the series.\\n\\n# Approach\\nuse the formular for the sum of ap or natural numbers with common difference of 1 and first number 1.\\n\\n((it + 1) * it) / 2 \\n\\nI split the input by zeros then map the result list of strings using teh method described above.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun numSub(s: String) = (s.split(Regex(\"0+\")).map { it.length.toLong() }.map { ((it + 1) * it) / 2 }.sum() % (1000000000 + 7)).toInt()\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun numSub(s: String) = (s.split(Regex(\"0+\")).map { it.length.toLong() }.map { ((it + 1) * it) / 2 }.sum() % (1000000000 + 7)).toInt()\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054774,
                "title": "c-beats-100-tc-95-86-sc",
                "content": "![image.png](https://assets.leetcode.com/users/images/dceefcaf-1206-4a08-aad4-4ce184b2104f_1694935668.2804863.png)\\n# Idea\\nLook at each consecutive strings of 1. \\nThe constribution of each block to the final answer is given by the **Triangular Number** T(n) = n * (n + 1) / 2.\\n\\nThis is because, for example, if the length of such a block is five i.e. 11111,\\n- five 1 character strings: 1, 1, 1, 1, 1\\n- four 2 character strings: 11, 11, 11, 11\\n- three 3 character strings: 111, 111, 111\\n- two 4 character strings: 1111, 1111\\n- one 5 character string: 11111\\nfor a total of 1 + 2 + 3 + 4 + 5 = T(5) = 5 * 6 / 2 = 15.\\n\\n\\n# Code\\n**Important**: make sure to pass the string by reference, not by value.\\nBy default it is passed by value!\\n```\\nstatic const auto x = []() {\\n\\tstd::ios::sync_with_stdio(false);\\n\\tstd::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return 0;\\n}();\\nstatic const unsigned MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numSub(string& s) { // PASS BY REFERENCE!\\n        int total = 0;\\n        int j = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == \\'1\\') {\\n                j++;\\n                continue;\\n            } \\n            // 1ll is needed to ensure conversion to long long\\n            // mid-calculation and avoid inteeger overflow\\n            long long n = j * 1ll * (j + 1) / 2 % MOD;\\n            total = (total + n) % MOD;\\n            j = 0;\\n        }\\n        if (j) { // if there are trailing 1s\\n            long long n = j * 1ll * (j + 1) / 2 % MOD;\\n            total = (total + n) % MOD;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic const auto x = []() {\\n\\tstd::ios::sync_with_stdio(false);\\n\\tstd::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return 0;\\n}();\\nstatic const unsigned MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numSub(string& s) { // PASS BY REFERENCE!\\n        int total = 0;\\n        int j = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == \\'1\\') {\\n                j++;\\n                continue;\\n            } \\n            // 1ll is needed to ensure conversion to long long\\n            // mid-calculation and avoid inteeger overflow\\n            long long n = j * 1ll * (j + 1) / 2 % MOD;\\n            total = (total + n) % MOD;\\n            j = 0;\\n        }\\n        if (j) { // if there are trailing 1s\\n            long long n = j * 1ll * (j + 1) / 2 % MOD;\\n            total = (total + n) % MOD;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4047172,
                "title": "string",
                "content": "**Number of substrings with only 1s** \\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod= 1e9+7;\\n    int numSub(string s) {\\n        int n=s.size();\\n        int c=0;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c++;\\n            }else{\\n                c=0;\\n            }\\n            res=(res+c)%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod= 1e9+7;\\n    int numSub(string s) {\\n        int n=s.size();\\n        int c=0;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c++;\\n            }else{\\n                c=0;\\n            }\\n            res=(res+c)%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030530,
                "title": "simple-fast-solution-o-n",
                "content": "# Complexity\\n- **Time complexity: O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int m=pow(10,9)+7;\\n        s+=\\'0\\';\\n        long temp=0,ans=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') temp++;\\n            else{\\n                ans=(ans+(temp*(temp+1)/2)%m);\\n                temp=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int m=pow(10,9)+7;\\n        s+=\\'0\\';\\n        long temp=0,ans=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') temp++;\\n            else{\\n                ans=(ans+(temp*(temp+1)/2)%m);\\n                temp=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026395,
                "title": "nice-game-easy-play-easy-guide",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod = 1000000007;\\n        long long res = 0;\\n        int it = 0;\\n        int count = 0;\\n\\n        s.push_back(\\'0\\');\\n        vector<int> v;\\n\\n        while(it != s.length()){\\n            if(s[it] == \\'0\\'){\\n                v.push_back(count);\\n                res += (count)*1ll*(count+1)*0.5;\\n                res = res%mod;\\n                count = 0;\\n            }\\n\\n            else{\\n                count ++;\\n            }\\n            it++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod = 1000000007;\\n        long long res = 0;\\n        int it = 0;\\n        int count = 0;\\n\\n        s.push_back(\\'0\\');\\n        vector<int> v;\\n\\n        while(it != s.length()){\\n            if(s[it] == \\'0\\'){\\n                v.push_back(count);\\n                res += (count)*1ll*(count+1)*0.5;\\n                res = res%mod;\\n                count = 0;\\n            }\\n\\n            else{\\n                count ++;\\n            }\\n            it++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024510,
                "title": "java-100-faster",
                "content": "# Intuition\\nWe can use the triangular number formula ``n = l * (l + 1) / 2`` to find the number of substrings that can be generated from any string.\\n\\n# Approach\\nWe iterate through the input and count the length of each string of only 1s. For each string, we use the above formula to find the number of substrings. We then add it to the result while performing the appropriate modulus operations.\\n\\n# Complexity\\n- Time complexity : O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int numSub(String s)\\n    {\\n        long c = 0;\\n        int r = 0;\\n        int m = 1000000007;\\n\\n        for(int i=0, l=s.length(); i<l; i++)\\n            if(s.charAt(i)==\\'1\\')\\n                c++;\\n\\n            else\\n            {\\n                r = (r + (int)((c*(c+1)/2)%m))%m;\\n                c = 0;\\n            }\\n\\n        r = (r + (int)((c*(c+1)/2)%m))%m;\\n\\n        return r;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int numSub(String s)\\n    {\\n        long c = 0;\\n        int r = 0;\\n        int m = 1000000007;\\n\\n        for(int i=0, l=s.length(); i<l; i++)\\n            if(s.charAt(i)==\\'1\\')\\n                c++;\\n\\n            else\\n            {\\n                r = (r + (int)((c*(c+1)/2)%m))%m;\\n                c = 0;\\n            }\\n\\n        r = (r + (int)((c*(c+1)/2)%m))%m;\\n\\n        return r;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995718,
                "title": "python-solution-with-split",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        def number_of_substring(n):\\n            return n * (n + 1) // 2\\n        mod = 10 ** 9 + 7\\n        s_split = s.split(\\'0\\')\\n        ans = 0\\n        for substring in s_split:\\n            ans += number_of_substring(len(substring)) % mod\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        def number_of_substring(n):\\n            return n * (n + 1) // 2\\n        mod = 10 ** 9 + 7\\n        s_split = s.split(\\'0\\')\\n        ans = 0\\n        for substring in s_split:\\n            ans += number_of_substring(len(substring)) % mod\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995702,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        def number_of_substring(n):\\n            return n * (n + 1) // 2\\n        mod = 10**9 + 7\\n        ans = 0\\n        s += \\'0\\'\\n        start = 0\\n        flag = True\\n        s = s.lstrip(\\'0\\') # remove leading \\'0\\'\\n        if len(s) == 0:\\n            return 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\' and flag:\\n                start = i\\n                flag = False\\n            elif s[i] == \\'0\\' and not flag:\\n                ans += number_of_substring(i - start) % mod\\n                flag = True\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        def number_of_substring(n):\\n            return n * (n + 1) // 2\\n        mod = 10**9 + 7\\n        ans = 0\\n        s += \\'0\\'\\n        start = 0\\n        flag = True\\n        s = s.lstrip(\\'0\\') # remove leading \\'0\\'\\n        if len(s) == 0:\\n            return 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\' and flag:\\n                start = i\\n                flag = False\\n            elif s[i] == \\'0\\' and not flag:\\n                ans += number_of_substring(i - start) % mod\\n                flag = True\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993819,
                "title": "ruby-solution-with-triangle-numbers-explained-100-50",
                "content": "# Intuition\\nIt\\'s easy to find the number of substrings of a string.  Split the string into sequences that are all ones and find the number of substrings in each.\\n\\n# Approach\\n1. Initialize total and ones to be 0.  Total is the result we\\'ll return; ones is how many consecutive ones are in the current substring.\\n2. Iterate through the string.  For each character:\\n    - If it\\'s a 1, increment ones by 1.\\n    - If not, find how many substrings there are in the current substring of all ones and add that to total.  Then reset ones.\\n3. Find how many substrings there are in the current substring of all ones and add to total.\\n4. Return total mod 10**9+7\\n\\nHelper function:\\nThis function calculates how many substrings there are in a string of length n.  Basically, there are n of length 1, n-1 of length 2, n-2 of length 3, ... and 1 of length n.  So we add the numbers 1 through n.  This formula adds them efficiently (look up \"triangle numbers\" for explanation).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef num_sub(s)\\n    total = 0\\n    ones = 0\\n\\n    s.each_char do |char|\\n        if char == \\'1\\'\\n            ones += 1\\n        else\\n            total += tri(ones)\\n            ones = 0\\n        end\\n    end\\n\\n    total += tri(ones)\\n    \\n    total % 1000000007\\nend\\n\\ndef tri(n)\\n    (n * (n + 1)) / 2\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef num_sub(s)\\n    total = 0\\n    ones = 0\\n\\n    s.each_char do |char|\\n        if char == \\'1\\'\\n            ones += 1\\n        else\\n            total += tri(ones)\\n            ones = 0\\n        end\\n    end\\n\\n    total += tri(ones)\\n    \\n    total % 1000000007\\nend\\n\\ndef tri(n)\\n    (n * (n + 1)) / 2\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3976748,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.size();\\n        int right = 0, left = 0, ans=0;\\n        while(right<n){\\n            if(s[right]==\\'1\\'){\\n                left = right;\\n                while(right<n){\\n                    if(s[right]==\\'1\\'){\\n                        ans= (ans)%1000000007 + (right-left+1)%1000000007;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                    right++;\\n                }\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.size();\\n        int right = 0, left = 0, ans=0;\\n        while(right<n){\\n            if(s[right]==\\'1\\'){\\n                left = right;\\n                while(right<n){\\n                    if(s[right]==\\'1\\'){\\n                        ans= (ans)%1000000007 + (right-left+1)%1000000007;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                    right++;\\n                }\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946601,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    int numSub(string s) {\\n        int n = s.size(),i = 0,j = 0,oneCt = 0,ans = 0;\\n        while(j < n){\\n            if(s[j] == \\'1\\') oneCt++;\\n            while(oneCt < j-i+1)\\n                if(s[i++] == \\'1\\') oneCt--;\\n            ans = (ans + (j++) - i + 1)%M;\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    int numSub(string s) {\\n        int n = s.size(),i = 0,j = 0,oneCt = 0,ans = 0;\\n        while(j < n){\\n            if(s[j] == \\'1\\') oneCt++;\\n            while(oneCt < j-i+1)\\n                if(s[i++] == \\'1\\') oneCt--;\\n            ans = (ans + (j++) - i + 1)%M;\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945521,
                "title": "super-easy-accumulator-approach",
                "content": "# Approach\\nWe iterate over all chars in string.\\nIf character is 1, we increment our accuumulator by 1.\\nThen we add accumulator to total result amount.\\nThats beacuse in `1` there is 1 variant, then in `11` there are 3 variants (1, 1, 11), but the first `1` we already  count on previous step. So just increment accumulator and add it to result (+2).\\nIn case of 0 we only reset accumulator to 0.\\n\\n# Code\\n```\\n\\tfunction numSub(s: string): number {\\n\\t\\tlet amount = 0;\\n\\t\\tlet count = 0;\\n\\n\\t\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\t\\tif (s[i] === \"0\" && amount > 0) {\\n\\t\\t\\t\\tamount = 0;\\n\\t\\t\\t}\\n\\t\\t\\tif (s[i] === \"1\") {\\n\\t\\t\\t\\tamount++;\\n\\t\\t\\t\\tcount += amount;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count % (10 ** 9 + 7);\\n\\t}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n\\tfunction numSub(s: string): number {\\n\\t\\tlet amount = 0;\\n\\t\\tlet count = 0;\\n\\n\\t\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\t\\tif (s[i] === \"0\" && amount > 0) {\\n\\t\\t\\t\\tamount = 0;\\n\\t\\t\\t}\\n\\t\\t\\tif (s[i] === \"1\") {\\n\\t\\t\\t\\tamount++;\\n\\t\\t\\t\\tcount += amount;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count % (10 ** 9 + 7);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932813,
                "title": "easy-java-solution-beats-85-with-explanations-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        long result = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                count++;\\n            } else {\\n                result += (long) count * (count + 1) / 2;\\n                result %= mod;\\n                count = 0;\\n            }\\n        }\\n\\n        result += (long) count * (count + 1) / 2;\\n        result %= mod;\\n\\n        return (int) result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        long result = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                count++;\\n            } else {\\n                result += (long) count * (count + 1) / 2;\\n                result %= mod;\\n                count = 0;\\n            }\\n        }\\n\\n        result += (long) count * (count + 1) / 2;\\n        result %= mod;\\n\\n        return (int) result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917569,
                "title": "typescript-math",
                "content": "# Code\\n```\\nfunction numSub(s) {\\n    let count = 0;\\n    let permuSum = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] == \\'1\\') {\\n            count = count + 1;\\n        } else {\\n            permuSum = (permuSum + permutation(count)) % (10 ** 9 + 7);\\n            count = 0;\\n        }\\n    }\\n    permuSum = (permuSum + permutation(count)) % (10 ** 9 + 7);\\n    return permuSum;\\n}\\n\\nfunction permutation(n) {\\n    return (n * (n + 1) / 2) % (10 ** 9 + 7);\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Math"
                ],
                "code": "```\\nfunction numSub(s) {\\n    let count = 0;\\n    let permuSum = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] == \\'1\\') {\\n            count = count + 1;\\n        } else {\\n            permuSum = (permuSum + permutation(count)) % (10 ** 9 + 7);\\n            count = 0;\\n        }\\n    }\\n    permuSum = (permuSum + permutation(count)) % (10 ** 9 + 7);\\n    return permuSum;\\n}\\n\\nfunction permutation(n) {\\n    return (n * (n + 1) / 2) % (10 ** 9 + 7);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914009,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    int numSub(string s) {\\n        int n = s.size(),i=0,j=0,sum=0,ans=0;\\n        while(j < n){\\n            sum += (s[j]-\\'0\\');\\n            if(sum == j-i+1){\\n                ans = (ans+j-i+1)%M;\\n                j++;\\n            }else{\\n                while(sum < j-i+1 && i <= j){\\n                    sum -= (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    int numSub(string s) {\\n        int n = s.size(),i=0,j=0,sum=0,ans=0;\\n        while(j < n){\\n            sum += (s[j]-\\'0\\');\\n            if(sum == j-i+1){\\n                ans = (ans+j-i+1)%M;\\n                j++;\\n            }else{\\n                while(sum < j-i+1 && i <= j){\\n                    sum -= (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902557,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int numSub(String s) {\\n    var cur = 0;\\n    var ans = 0;\\n    for (var i in s.split(\\'\\')) {\\n        if (i == \\'1\\') {\\n            cur += 1;\\n            ans += cur;\\n        } else {\\n            cur = 0;\\n        }\\n    }\\n    return ans % (pow(10, 9).toInt() + 7);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int numSub(String s) {\\n    var cur = 0;\\n    var ans = 0;\\n    for (var i in s.split(\\'\\')) {\\n        if (i == \\'1\\') {\\n            cur += 1;\\n            ans += cur;\\n        } else {\\n            cur = 0;\\n        }\\n    }\\n    return ans % (pow(10, 9).toInt() + 7);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885933,
                "title": "easy-python-o-n-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Increment count as you find 1s. Be sure to add this to result.\\n2. Reset count to 0 whenever you encounter 0\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: k\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        count = 0\\n        res = 0\\n\\n        for char in s:\\n            if char == \"1\":\\n                count += 1\\n                res += count\\n            else:\\n                count = 0\\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        count = 0\\n        res = 0\\n\\n        for char in s:\\n            if char == \"1\":\\n                count += 1\\n                res += count\\n            else:\\n                count = 0\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871036,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar numSub = function(s) {\\n    const MODULO = 10 ** 9 + 7;\\n    let current = result = 0;\\n\\n    for (let index = 0; index <= s.length; index++) {\\n        const value = s[index];\\n\\n        if (value === \\'1\\') current += 1;\\n        else {\\n            result = (result + (current + 1) * current / 2) % MODULO;\\n            current = 0;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numSub = function(s) {\\n    const MODULO = 10 ** 9 + 7;\\n    let current = result = 0;\\n\\n    for (let index = 0; index <= s.length; index++) {\\n        const value = s[index];\\n\\n        if (value === \\'1\\') current += 1;\\n        else {\\n            result = (result + (current + 1) * current / 2) % MODULO;\\n            current = 0;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3865950,
                "title": "python-3-clean-codes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numSub(self, s):\\n        count = 0\\n        temp = 0\\n        for i in range(len(s)):\\n            if s[i] == \"1\":\\n                temp = temp + 1\\n            else:\\n                count = count + ((temp*(temp+1))//2)\\n                temp = 0\\n        count = count + ((temp*(temp+1))//2)\\n        return count % (10**9 + 7)\\n\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSub(self, s):\\n        count = 0\\n        temp = 0\\n        for i in range(len(s)):\\n            if s[i] == \"1\":\\n                temp = temp + 1\\n            else:\\n                count = count + ((temp*(temp+1))//2)\\n                temp = 0\\n        count = count + ((temp*(temp+1))//2)\\n        return count % (10**9 + 7)\\n\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865668,
                "title": "tc-o-n-sc-o-1-java-easy-7-line-solution",
                "content": "# Intuition\\nIn a series of 1\\'s the position of the respective 1 can make substrings with only 1\\'s\\n\\nE.g\\n101111011\\nthere are threee sets(series) of 1s\\n1) 1\\n2) 1111\\n3) 11\\n\\nfor instance in 2nd series 1111 postions of 1s are 1 , 2 , 3 , 4.\\nHence they will make exactly that many substrings.\\nWe just need to add 1+2+3+4 = 10 , and we get max 1s substring for the given series.\\n\\nDo this for every series and add them together you get the ans.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n) one pass\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n           int count = 0 , ones = 0;\\n           for(int i = 0; i < s.length(); i++){\\n               while(i < s.length() && s.charAt(i)==\\'1\\'){\\n                   ones++;\\n                   count= (count%(1000000007))+ones;\\n                   i++;\\n               }\\n               ones=0;\\n    }\\nreturn count;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n           int count = 0 , ones = 0;\\n           for(int i = 0; i < s.length(); i++){\\n               while(i < s.length() && s.charAt(i)==\\'1\\'){\\n                   ones++;\\n                   count= (count%(1000000007))+ones;\\n                   i++;\\n               }\\n               ones=0;\\n    }\\nreturn count;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864783,
                "title": "c-detailed-solution",
                "content": "# Intuition\\nTo find all required substrings we can just find all possible substrings in every group of 1\\'s between zeros\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLet\\'s look at our possible input string. \\n<h7>000<b>1111</b>000000<b>11</b>0<b>1</b>0000<b>11</b></h7>\\nEvery group of ones is surrounded by zeros. To find number of all substrings with 1\\'s we need just find number of all possible substrings inside those groups of 1\\'s and add them up. Now let\\'s take a look at possible group of ones\\n<h7>11111</h7>\\nWe can have:\\n- 5 substring of \"1\"\\n- 4 substring of \"11\"\\n- 3 substring of \"111\"\\n\\nand so on.\\nSee the pattern? For substring of 1\\'s with length of N we can have\\n1 + 2 + 3 + ... + N = N(N+1)/2 possible substrings.\\n\\nNow we need just find lengthes of all such groups of 1\\'s in our input string, find number of substrings inside each one using our formula and add these numbers up. To do so we need:\\n- create variable to store total number of substrings\\n- create variable to store length of current substring(if you don\\'t understand just look below)\\n- iterate through input string and do following:\\n    - if current character is 1 increment length of current substring(thats why we created this variable before)\\n    - if current character is 0 it means that we iterater through group of 1\\'s and it\\'s time to calculate number of possible substrings, add this number to total number of substrings and set length of current substring of 1\\'s to zero\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    constexpr size_t getNumberOfSubstrings(size_t length) {\\n        return length * (length + 1) / 2;\\n    }\\n\\n    int numSub(const std::string& s) {\\n        size_t total_substrings = 0;\\n        size_t current_substr_len = 0;\\n\\n        // here we just look for each substring of 1\\'s\\n        // we just look through every character\\n        // and just count 1\\'s until we reach 0\\n        for (char c : s) {\\n            if (c == \\'1\\') {\\n                // here we iterating through group of 1\\'s\\n                ++current_substr_len;\\n            } else {\\n                // we reached 0, therefore substring ended and it\\'s time to measure\\n                // number of all possible substrings inside that one group\\n                total_substrings += getNumberOfSubstrings(current_substr_len);\\n                current_substr_len = 0;\\n            }\\n        }\\n\\n        // we add number of substrings in case we have input like \"......0111111...1111\"\\n        // In that case loop above will end before including substrings inside this last group of 1\\'s\\n        return (total_substrings + getNumberOfSubstrings(current_substr_len)) % 1000000007; // don\\'t forget to get modulo as stated in the description\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    constexpr size_t getNumberOfSubstrings(size_t length) {\\n        return length * (length + 1) / 2;\\n    }\\n\\n    int numSub(const std::string& s) {\\n        size_t total_substrings = 0;\\n        size_t current_substr_len = 0;\\n\\n        // here we just look for each substring of 1\\'s\\n        // we just look through every character\\n        // and just count 1\\'s until we reach 0\\n        for (char c : s) {\\n            if (c == \\'1\\') {\\n                // here we iterating through group of 1\\'s\\n                ++current_substr_len;\\n            } else {\\n                // we reached 0, therefore substring ended and it\\'s time to measure\\n                // number of all possible substrings inside that one group\\n                total_substrings += getNumberOfSubstrings(current_substr_len);\\n                current_substr_len = 0;\\n            }\\n        }\\n\\n        // we add number of substrings in case we have input like \"......0111111...1111\"\\n        // In that case loop above will end before including substrings inside this last group of 1\\'s\\n        return (total_substrings + getNumberOfSubstrings(current_substr_len)) % 1000000007; // don\\'t forget to get modulo as stated in the description\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861630,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n = s.length();\\n\\n        int ans = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'1\\') count++;\\n            else count = 0;\\n\\n            ans = (ans+count)%1000000007;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n = s.length();\\n\\n        int ans = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'1\\') count++;\\n            else count = 0;\\n\\n            ans = (ans+count)%1000000007;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854676,
                "title": "c-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int l=0,r=0,sum=0,M=(1e9+7);\\n        \\n        while(r<s.size()){\\n            while(r<s.size() && s[r]==\\'1\\' && s[l]==s[r]){\\n                sum=(sum+(r-l+1))%M;\\n                r++;\\n            }\\n            r++;\\n            l=r;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int l=0,r=0,sum=0,M=(1e9+7);\\n        \\n        while(r<s.size()){\\n            while(r<s.size() && s[r]==\\'1\\' && s[l]==s[r]){\\n                sum=(sum+(r-l+1))%M;\\n                r++;\\n            }\\n            r++;\\n            l=r;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833848,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0, total  = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'1\\'){\\n                count++;\\n            }\\n            else{\\n                count  = 0;\\n            }\\n            total = (total+count) % 1000000007;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0, total  = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'1\\'){\\n                count++;\\n            }\\n            else{\\n                count  = 0;\\n            }\\n            total = (total+count) % 1000000007;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824772,
                "title": "easy-math-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nconst long long MOD=1000000007;\\n    int numSub(string s) {\\n        \\n        int n=s.size();\\n        long long ans=0,count=0;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                ans+=(count*(count+1))/2;\\n                ans%=MOD;\\n                count=0;\\n            }\\n        }\\n        ans+=(count*(count+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst long long MOD=1000000007;\\n    int numSub(string s) {\\n        \\n        int n=s.size();\\n        long long ans=0,count=0;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                ans+=(count*(count+1))/2;\\n                ans%=MOD;\\n                count=0;\\n            }\\n        }\\n        ans+=(count*(count+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822593,
                "title": "number-of-substrings-with-only-1s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        long count =1;\\n        long max = 0;\\n        long count0 = 0;\\n        ArrayList<Character> arr = new ArrayList<Character>();\\n        arr.add(s.charAt(0));\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\'&&s.charAt(i-1)!=\\'0\\')\\n            arr.add(s.charAt(i));\\n            else if(s.charAt(i)==\\'1\\')\\n            arr.add(s.charAt(i));\\n        }\\n        String s1 = new String();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            s1=s1+arr.get(i);\\n        }\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)==\\'0\\')\\n            count0++;\\n        }\\n        for(int i=1;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)==s1.charAt(i-1))\\n            count++;\\n            else\\n            {\\n                max = max+(count*(count+1)/2);\\n                count =1;\\n            }\\n        }\\n        System.out.println(count0);\\n        if(count>=1)\\n        max = max+(count*(count+1))/2;\\n        return (int)(max%(Math.pow(10,9)+7))-(int)count0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long count =1;\\n        long max = 0;\\n        long count0 = 0;\\n        ArrayList<Character> arr = new ArrayList<Character>();\\n        arr.add(s.charAt(0));\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\'&&s.charAt(i-1)!=\\'0\\')\\n            arr.add(s.charAt(i));\\n            else if(s.charAt(i)==\\'1\\')\\n            arr.add(s.charAt(i));\\n        }\\n        String s1 = new String();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            s1=s1+arr.get(i);\\n        }\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)==\\'0\\')\\n            count0++;\\n        }\\n        for(int i=1;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)==s1.charAt(i-1))\\n            count++;\\n            else\\n            {\\n                max = max+(count*(count+1)/2);\\n                count =1;\\n            }\\n        }\\n        System.out.println(count0);\\n        if(count>=1)\\n        max = max+(count*(count+1))/2;\\n        return (int)(max%(Math.pow(10,9)+7))-(int)count0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806758,
                "title": "line-sweep-solution-different-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This solution is completely different from any other solution from the solution forum. I used line sweep to store the count of each type of substring count in a array.\\n- Though this solution is not efficient, we should try to implement different algorithms.\\n- My idea is when we get a substring --> \"1\" we need to increment its count by 1.\\n- When we get a substr --> \"11\" we need to increment \"11\" count by 1 as well as \"1\" count by one.\\n- When we get a substr --> \"111\" we do incrementation to counts of \"11\" and \"1\".\\n- So, by observation I made a arr of len s.length()+1 as the substr cant exceed the str len.\\n- We keep a count variable to count the consecutive one\\'s. But we encounter a zero we reset it to 0;\\n- This count variable acts as our upper bound in the line_sweep but the lower bound is always fixed to 0.\\n- Ex: When we have count=3, we increment line_sweep[0]++ and decrement line_sweep[count]--. In this way we can increment the range of sizes of substrings of one\\'s. \\n- Comment for further questions. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        long ans=0;\\n        int mod=(int)(1e9+7);\\n        int n=s.length();\\n        int count=0;\\n        int[] line_sweep=new int[n+1];\\n        for(char ch:s.toCharArray()){\\n            if(ch==\\'0\\'){\\n                count=0;\\n                continue;\\n            }\\n            count++;\\n            line_sweep[0]++;\\n            line_sweep[count]--;\\n        }\\n        ans=line_sweep[0];\\n        for(int i=1;i<line_sweep.length;i++)\\n        {\\n            line_sweep[i]+=line_sweep[i-1];\\n            ans+=line_sweep[i];\\n        }\\n        \\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long ans=0;\\n        int mod=(int)(1e9+7);\\n        int n=s.length();\\n        int count=0;\\n        int[] line_sweep=new int[n+1];\\n        for(char ch:s.toCharArray()){\\n            if(ch==\\'0\\'){\\n                count=0;\\n                continue;\\n            }\\n            count++;\\n            line_sweep[0]++;\\n            line_sweep[count]--;\\n        }\\n        ans=line_sweep[0];\\n        for(int i=1;i<line_sweep.length;i++)\\n        {\\n            line_sweep[i]+=line_sweep[i-1];\\n            ans+=line_sweep[i];\\n        }\\n        \\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787330,
                "title": "python-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe needed number of substrings is the sum of the number of substrings in the contunuous chunks of 1\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSplit s into chunks of adjacent 1\\'s. For each such chunk of length k the number of substrings is 1+2+...+k = (k+1) * k // 2. Calculate the sum over all chunks and return it mod 10^9+7.\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return sum([(len(w)+1) * len(w) // 2 for w in s.split(\\'0\\')]) % 1000000007\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return sum([(len(w)+1) * len(w) // 2 for w in s.split(\\'0\\')]) % 1000000007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783079,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n      int i=0;\\n      int j=0;\\n      int ans=0;\\n      int mod=1000000007;\\n      while(j<s.length()){\\nif(s.charAt(j)==\\'0\\'){\\n  i=j+1;\\n  j++;\\n}else{\\n  ans=(ans+j-i+1)%mod;\\nj++;\\n}\\n      }\\n       \\n        return ans%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n      int i=0;\\n      int j=0;\\n      int ans=0;\\n      int mod=1000000007;\\n      while(j<s.length()){\\nif(s.charAt(j)==\\'0\\'){\\n  i=j+1;\\n  j++;\\n}else{\\n  ans=(ans+j-i+1)%mod;\\nj++;\\n}\\n      }\\n       \\n        return ans%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782959,
                "title": "o-n-solution-using-java-and-some-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to iterate through the input string s and count the number of substrings with all characters as 1\\'s. The approach keeps track of the count of consecutive 1\\'s encountered and adds it to the total count. When a \\'0\\' is encountered, the count is reset to 0 since consecutive 1\\'s have been interrupted. The modulo operation is performed to keep the total count within the specified range.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize totalCount to keep track of the total count of substrings with all characters as 1\\'s.\\nInitialize count to track the count of consecutive 1\\'s encountered.\\nIterate through each character in the input string s.\\nIf the character is \\'1\\', increment count by 1 and add it to totalCount.\\nPerform the modulo operation totalCount %= MOD to keep the value of totalCount within the range.\\nIf the character is \\'0\\', reset count to 0 since consecutive 1\\'s have been interrupted.\\nReturn the final value of totalCount casted to an int as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through each character of the input string once, resulting in a time complexity of O(n), where n is the length of the input string.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a fixed amount of additional space for the totalCount and count variables, resulting in a space complexity of O(1), constant space.\\nOverall, the code has a time complexity of O(n) and a space complexity of O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        final int MOD = 1000000007;\\n        long totalCount = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                count++;\\n                totalCount += count;\\n                totalCount %= MOD;\\n            } else {\\n                count = 0;\\n            }\\n        }\\n\\n        return (int) totalCount;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        final int MOD = 1000000007;\\n        long totalCount = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                count++;\\n                totalCount += count;\\n                totalCount %= MOD;\\n            } else {\\n                count = 0;\\n            }\\n        }\\n\\n        return (int) totalCount;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782043,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod=1e9+7;\\n        int ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(j<s.size()){\\n            \\n            if(s[j]==\\'1\\'){\\n                ans=(ans%mod+(j-i)+1)%mod;\\n            }\\n            \\n            else{\\n                i=j+1;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod=1e9+7;\\n        int ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(j<s.size()){\\n            \\n            if(s[j]==\\'1\\'){\\n                ans=(ans%mod+(j-i)+1)%mod;\\n            }\\n            \\n            else{\\n                i=j+1;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768292,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod = 1000000007;\\n        int count = 0;\\n        long long ans = 0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'1\\'){\\n                count++;\\n                ans += count;\\n                ans = ans % mod;\\n            }\\n            else count = 0;\\n        }\\n        return ans % mod;\\n        \\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/bc642078-9fda-4441-a03e-86790e86fc72_1694616297.536215.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod = 1000000007;\\n        int count = 0;\\n        long long ans = 0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'1\\'){\\n                count++;\\n                ans += count;\\n                ans = ans % mod;\\n            }\\n            else count = 0;\\n        }\\n        return ans % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760120,
                "title": "sliding-window-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n        int mod = 1000000007;\\n        while(j<s.length()){\\n            if(s.charAt(j) == \\'0\\'){\\n                i = j+1;\\n                j++;\\n            }else{\\n                ans = (ans + j-i+1)%mod;\\n                j++;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n        int mod = 1000000007;\\n        while(j<s.length()){\\n            if(s.charAt(j) == \\'0\\'){\\n                i = j+1;\\n                j++;\\n            }else{\\n                ans = (ans + j-i+1)%mod;\\n                j++;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749094,
                "title": "solution-explained-for-all-languages-implementation-in-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        count = 0\\n        for n in map(len, s.split(\\'0\\')):\\n            count += n * (n + 1) // 2\\n        return count % (10**9 + 7)\\n```\\n\\nThe number of substrings with all ones *in the input string* $S$ is sum of the number of substrings with all ones *in each group of ones* $OS$\\n\\n$$\\n\\\\text{SubstrOfOnesCount}(S)\\n= \\\\sum\\\\limits_{OS} \\\\text{SubstrOfOnesCount}(OS)\\n.$$\\n> E.g. in a string `10111011`\\n> $$\\n> \\\\begin{align}\\n> \\\\text{SubstrOfOnesCount}(\"10111011\")\\n> &= \\\\text{SubstrOfOnesCount}(\"1\")\\n> \\\\\\\\ &+ \\\\text{SubstrOfOnesCount}(\"111\")\\n> \\\\\\\\ &+ \\\\text{SubstrOfOnesCount}(\"11\")\\n> \\\\end{align}\\n> $$\\n\\nSo, we have to find $\\\\text{SubstrOfOnesCount}(x)$, where $x$ is string of ones with length $n \\\\ge 1$, $x = n \\\\times \"1\"$. \\n\\nLet\\'s denote the length of a substring by $m$. In a string of length $n$ there are\\n$$\\nn - m + 1\\n$$\\nsubstrings of length $m$.\\n> E.g. in a string `abcd` there are 4 substrings of length 1, 3 substrings of length 2, 2 substrings of length 3 and 1 substring of length 4.\\n\\nIn a string of length $n$ substrings may have length from 1 to $n$, so\\n$$\\n\\\\text{SubstrOfOnesCount}(n \\\\times \"1\")\\n= \\\\sum\\\\limits_{m = 1}^{n} (n - m + 1)\\n= \\\\sum\\\\limits_{m = 1}^{n} n\\n- \\\\sum\\\\limits_{m = 1}^{n} m\\n+ \\\\sum\\\\limits_{m = 1}^{n} 1\\n\\\\\\\\ = n^2 - \\\\dfrac{n (n+1)}{2} + n\\n= \\\\dfrac{n^2}{2} + \\\\dfrac{n}{2}\\n= \\\\dfrac{n(n+1)}{2}.\\n$$\\n\\n# Complexity\\n- Time complexity: $O(|S| + \\\\text{number of groups})$\\n\\n# Consider further\\n- Cache $\\\\text{SubstrOfOnesCount}$. Also, you may use\\n$$\\n\\\\text{SubstrOfOnesCount}((n+1) \\\\times \"1\")\\n= \\\\\\\\ \\\\text{SubstrOfOnesCount}(n \\\\times \"1\") + (n + 1)\\n$$\\n- For Python, replace for cycle with a reducing operation, e.g. `sum`.\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        count = 0\\n        for n in map(len, s.split(\\'0\\')):\\n            count += n * (n + 1) // 2\\n        return count % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735388,
                "title": "q-1513-number-of-substrings-with-only-1s-easy-implementation-code-just-an-obseravation",
                "content": "Approach : Just an observation that using n number of consecutive 1\\'s you can form n*(n+1)/2 combinations.\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int MOD=1e9+7;\\n        long res=0;\\n        long cnt=0;\\n        for(auto i:s){\\n            if(i==\\'1\\'){\\n                cnt++;\\n            }\\n            else{\\n                res=(res+(cnt*(cnt+1))/2)%MOD;\\n                cnt=0;\\n            }\\n        }\\n        return (res+(cnt*(cnt+1))/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int MOD=1e9+7;\\n        long res=0;\\n        long cnt=0;\\n        for(auto i:s){\\n            if(i==\\'1\\'){\\n                cnt++;\\n            }\\n            else{\\n                res=(res+(cnt*(cnt+1))/2)%MOD;\\n                cnt=0;\\n            }\\n        }\\n        return (res+(cnt*(cnt+1))/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682642,
                "title": "java-simple-and-clean-code",
                "content": "# Approach\\n1. Determine the length of each continous 1 segment. Once you have it (eg:next char is 0) calculate the natural sum of 1 ..l of that segment.\\n    - EG: 111 can form 1 segment of 3 1s, 2 segments of 2 and 3 segments of 1 => 1 + 2 + 3.\\n    - Thus, l * (l+1) / 2. As an optimization, you can actually add each step (1,2,3) to the total length while traversing the string\\n2. Traverse s and keep track of the lengths of a continuous 1s segment.\\n3. If current char is 0, reset length to 0, else incremenent it\\n4. After each char, add the current length to the totalLength\\n    - EG: \"111\"\\n    - i = 0 => total += 1;\\n    - i = 1 => total += 2;\\n    - i = 2 => total += 3\\n    - => total = 6. (3 segments of 1, 2 of 2 and 1 of 3 elements)\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        long total = 0L; \\n        int sequenceLength = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                sequenceLength++;\\n            } else {\\n                sequenceLength = 0;\\n            }\\n            total += sequenceLength;\\n        }\\n        return  (int)(total % 1_000_000_007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long total = 0L; \\n        int sequenceLength = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                sequenceLength++;\\n            } else {\\n                sequenceLength = 0;\\n            }\\n            total += sequenceLength;\\n        }\\n        return  (int)(total % 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676514,
                "title": "java-solution-two-approaches-count-and-sliding-window",
                "content": "# code using sliding window\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        int l=0;\\n        int mod=1000_000_007;\\n        while(j<n)\\n        {\\n            \\n            if(s.charAt(j)==\\'0\\')\\n            {\\n                i=j;\\n            }\\n            while(i<n && s.charAt(i)==\\'0\\')\\n            {\\n                i++;\\n                l++;\\n            }\\n            if(j<n && s.charAt(j)!=\\'0\\')\\n            {res=(res%mod+(j-i+1)%mod);\\n             //System.out.println(i+\" \"+j);\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n# code using count \\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        int cnt=0;\\n        int mod=1000_000_007;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n                cnt++;\\n            else \\n                cnt=0;\\n            res=(res+cnt)%mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        int l=0;\\n        int mod=1000_000_007;\\n        while(j<n)\\n        {\\n            \\n            if(s.charAt(j)==\\'0\\')\\n            {\\n                i=j;\\n            }\\n            while(i<n && s.charAt(i)==\\'0\\')\\n            {\\n                i++;\\n                l++;\\n            }\\n            if(j<n && s.charAt(j)!=\\'0\\')\\n            {res=(res%mod+(j-i+1)%mod);\\n             //System.out.println(i+\" \"+j);\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        int cnt=0;\\n        int mod=1000_000_007;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n                cnt++;\\n            else \\n                cnt=0;\\n            res=(res+cnt)%mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671327,
                "title": "solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmy Approach is too simple am loop through the string and increment +1\\nwhen we get 1 in string otherwise reset the count 0 .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numSub = function(s) {\\n    let count =0;\\n    let mod = 1e9 + 7;\\n    let result = 0    \\n    for(let i=0;i<s.length;i++){\\n        if(s[i] === \"1\"){\\n            count++;\\n            result =( result + count) % mod;\\n        }else{\\n            count = 0;\\n        }\\n    }\\n        \\n\\n   \\n    \\nreturn result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numSub = function(s) {\\n    let count =0;\\n    let mod = 1e9 + 7;\\n    let result = 0    \\n    for(let i=0;i<s.length;i++){\\n        if(s[i] === \"1\"){\\n            count++;\\n            result =( result + count) % mod;\\n        }else{\\n            count = 0;\\n        }\\n    }\\n        \\n\\n   \\n    \\nreturn result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663830,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint numSub(string s) {\\n\\t\\tlong count = 0;\\n\\t\\tlong ans = 0;\\n\\t\\tfor(int i  = 0; i < s.size(); i++){\\n\\t\\t\\tif(s[i] == \\'1\\'){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tans += (count * (count + 1)) / 2;\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (ans + (count * (count + 1)) / 2) % 1000000007;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint numSub(string s) {\\n\\t\\tlong count = 0;\\n\\t\\tlong ans = 0;\\n\\t\\tfor(int i  = 0; i < s.size(); i++){\\n\\t\\t\\tif(s[i] == \\'1\\'){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tans += (count * (count + 1)) / 2;\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (ans + (count * (count + 1)) / 2) % 1000000007;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657024,
                "title": "beginner-friendly-number-of-substrings-with-only-1s-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = 1000000007;\\npublic:\\n    int numSub(string s) {\\n        int n = s.size();\\n        long long ans=0, curr=0;\\n        for(int i=0; i<n; ++i){\\n            if(s[i]==\\'0\\'){\\n                ans = (ans + (curr*(curr+1))/2) % MOD;\\n                curr=0;\\n                continue;\\n            }\\n            curr++;\\n        }\\n        ans = (ans + (curr*(curr+1))/2) % MOD;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\npublic:\\n    int numSub(string s) {\\n        int n = s.size();\\n        long long ans=0, curr=0;\\n        for(int i=0; i<n; ++i){\\n            if(s[i]==\\'0\\'){\\n                ans = (ans + (curr*(curr+1))/2) % MOD;\\n                curr=0;\\n                continue;\\n            }\\n            curr++;\\n        }\\n        ans = (ans + (curr*(curr+1))/2) % MOD;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654309,
                "title": "c-super-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int x = 0, ans = 0, m = 1e9 + 7;\\n        for (auto& c : s)\\n            ans = (ans + (x = c == \\'1\\' ? x + 1 : 0)) % m;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int x = 0, ans = 0, m = 1e9 + 7;\\n        for (auto& c : s)\\n            ans = (ans + (x = c == \\'1\\' ? x + 1 : 0)) % m;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606467,
                "title": "two-pointers-python-math",
                "content": "This is with string, so don\\'t forget \"\" in s[i] == \"1\"\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        # same with 1759, 1) add counter of 1\\'s or \\n        # 2) sum(range(1, n+1)); n = length of same numbers\\n\\n        \\n        counter = 0 \\n        res = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"1\":\\n                counter += 1\\n                res += counter\\n            else:\\n                counter = 0\\n            \\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        # same with 1759, 1) add counter of 1\\'s or \\n        # 2) sum(range(1, n+1)); n = length of same numbers\\n\\n        \\n        counter = 0 \\n        res = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"1\":\\n                counter += 1\\n                res += counter\\n            else:\\n                counter = 0\\n            \\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601847,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        HashMap<Character, Integer> lst = new HashMap<>();\\n        int left = 0;\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); i++){\\n            char letter = s.charAt(i);\\n            if (letter == \\'0\\') {\\n                while (left <= i){\\n                    char let = s.charAt(left);\\n                    lst.put(let, lst.getOrDefault(let, 0) - 1);\\n                    if (lst.get(let) == 0) {\\n                        lst.remove(let);\\n                    }\\n                    left++;\\n                }\\n            }\\n            else if (letter == \\'1\\'){\\n                lst.put(letter, lst.getOrDefault(letter, 0) + 1);\\n                //System.out.print(i + \" \" + left + \"\\\\n\");\\n                ans += i - left + 1;\\n                ans %= 1_000_000_007;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        HashMap<Character, Integer> lst = new HashMap<>();\\n        int left = 0;\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); i++){\\n            char letter = s.charAt(i);\\n            if (letter == \\'0\\') {\\n                while (left <= i){\\n                    char let = s.charAt(left);\\n                    lst.put(let, lst.getOrDefault(let, 0) - 1);\\n                    if (lst.get(let) == 0) {\\n                        lst.remove(let);\\n                    }\\n                    left++;\\n                }\\n            }\\n            else if (letter == \\'1\\'){\\n                lst.put(letter, lst.getOrDefault(letter, 0) + 1);\\n                //System.out.print(i + \" \" + left + \"\\\\n\");\\n                ans += i - left + 1;\\n                ans %= 1_000_000_007;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588501,
                "title": "shortest-code-beats-89-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count =0 , total = 0 , mod = 1_000_000_007;\\n        for(char c : s.toCharArray()){\\n            count = c ==\\'1\\' ? count +1 : 0;\\n            total = (total + count) % mod;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count =0 , total = 0 , mod = 1_000_000_007;\\n        for(char c : s.toCharArray()){\\n            count = c ==\\'1\\' ? count +1 : 0;\\n            total = (total + count) % mod;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585937,
                "title": "golang-simple-and-quick-beats-87",
                "content": "\\n# Code\\n```\\nconst modulo = 1000000007\\n\\nfunc numSub(s string) int {\\n    var sum int64\\n\\n    prev := int64(0)\\n    for i := 0; i < len(s); i ++ {\\n        if prev > 1 {\\n            prev --\\n            sum += prev\\n        } else {\\n            j := i\\n            for ; j < len(s); j ++ {\\n                if s[j] != \\'1\\' {\\n                    break;\\n                }\\n            }\\n            cnt := int64(j - i)\\n            prev = cnt\\n            sum += cnt\\n        }\\n    }\\n\\n    return int(sum % modulo)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst modulo = 1000000007\\n\\nfunc numSub(s string) int {\\n    var sum int64\\n\\n    prev := int64(0)\\n    for i := 0; i < len(s); i ++ {\\n        if prev > 1 {\\n            prev --\\n            sum += prev\\n        } else {\\n            j := i\\n            for ; j < len(s); j ++ {\\n                if s[j] != \\'1\\' {\\n                    break;\\n                }\\n            }\\n            cnt := int64(j - i)\\n            prev = cnt\\n            sum += cnt\\n        }\\n    }\\n\\n    return int(sum % modulo)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580497,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long i=0,j=0,n = s.length(),mod = 1e9+7;\\n        long long int ans = 0;\\n        long long x;\\n        while(i < n)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                j = i + 1;\\n                while(j < n && s[j] == \\'1\\')\\n                {\\n                    j++;\\n                }\\n                x = (j - i + 1) * (j - i) / 2;\\n                ans = (ans + x) % mod;\\n                i = j;\\n            }\\n            else{i++;}\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long i=0,j=0,n = s.length(),mod = 1e9+7;\\n        long long int ans = 0;\\n        long long x;\\n        while(i < n)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                j = i + 1;\\n                while(j < n && s[j] == \\'1\\')\\n                {\\n                    j++;\\n                }\\n                x = (j - i + 1) * (j - i) / 2;\\n                ans = (ans + x) % mod;\\n                i = j;\\n            }\\n            else{i++;}\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552365,
                "title": "easy-way-to-solve-find-substring-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        s  = s + \"0\"\\n        i, res = 0,0\\n        for ch in s:\\n            if ch == \"1\": i+=1\\n            else:\\n                res += int((i+1)*i/2)\\n                i = 0\\n        return res % (10**9+7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        s  = s + \"0\"\\n        i, res = 0,0\\n        for ch in s:\\n            if ch == \"1\": i+=1\\n            else:\\n                res += int((i+1)*i/2)\\n                i = 0\\n        return res % (10**9+7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508550,
                "title": "java-easy-understanding",
                "content": "```\\nclass Solution {\\n\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        int count = 1;\\n        int ans = 0;\\n        for(int i = 0 ; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                ans= (ans + (count%mod))%mod;\\n                count++;\\n            }else{\\n                count = 1;\\n            }    \\n        }\\n        return ans%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        int count = 1;\\n        int ans = 0;\\n        for(int i = 0 ; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                ans= (ans + (count%mod))%mod;\\n                count++;\\n            }else{\\n                count = 1;\\n            }    \\n        }\\n        return ans%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504448,
                "title": "kotlin-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    val mod = 1_000_000_007\\n\\n    fun numSub(s: String): Int {\\n        var result = 0\\n\\n        var left = -1\\n        for (right in 0 until s.length) {\\n            if (s[right] == \\'0\\') {\\n                left = -1\\n                continue\\n            }\\n\\n            if (left == -1) left = right\\n            result += right - left + 1\\n            result %= mod\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    val mod = 1_000_000_007\\n\\n    fun numSub(s: String): Int {\\n        var result = 0\\n\\n        var left = -1\\n        for (right in 0 until s.length) {\\n            if (s[right] == \\'0\\') {\\n                left = -1\\n                continue\\n            }\\n\\n            if (left == -1) left = right\\n            result += right - left + 1\\n            result %= mod\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502485,
                "title": "java-4-lines-sliding-window",
                "content": "```\\npublic int numSub(String s) {\\n\\tint res=0, conseq=0; \\n\\tfor (int i=0;i<s.length();i++)\\n\\t\\tif (s.charAt(i)==\\'1\\') { conseq++; res=(res+conseq)%1_000_000_007; } else conseq=0; \\n\\treturn res;\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int numSub(String s) {\\n\\tint res=0, conseq=0; \\n\\tfor (int i=0;i<s.length();i++)\\n\\t\\tif (s.charAt(i)==\\'1\\') { conseq++; res=(res+conseq)%1_000_000_007; } else conseq=0; \\n\\treturn res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3500234,
                "title": "easy-java-solution-2-approach",
                "content": "```\\nTC: O(N)\\nSC: O(1)\\n\\n**Approach 1:- **\\n\\n\\t public int numSub(String s) {\\n        long count = 0;\\n        int mod = 1000_000_007;\\n        int N = s.length();\\n\\t\\tint res = 0;\\n        for(int i=0; i<N; i++) {\\n            if(s.charAt(i)==\\'1\\') {\\n                res++;\\n                count = (count+res)%mod;\\n            } else {\\n                res=0;\\n            }\\n        }\\n        return (int)count;\\n    }\\n\\t\\n**Approach 2:-**\\n\\npublic int numSub(String s) {\\n        long count = 0;\\n        int mod = 1000_000_007;\\n        int N = s.length();\\n        int i = 0;\\n        int j = 0;;\\n        while(i<N) {\\n            if(s.charAt(i)==\\'1\\') {\\n                j = i;\\n                while(j<N) {\\n                    if(s.charAt(j)==\\'1\\') {\\n                        j++;\\n                    } else {\\n                        break;\\n                    }  \\n                }\\n                j--;\\n                int len = j-i+1;\\n                count = count + ((1l* (len)) * (len+1)/2)%mod;\\n                i = j;\\n            }\\n            i++;\\n        }\\n\\t\\treturn (int)count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nTC: O(N)\\nSC: O(1)\\n\\n**Approach 1:- **\\n\\n\\t public int numSub(String s) {\\n        long count = 0;\\n        int mod = 1000_000_007;\\n        int N = s.length();\\n\\t\\tint res = 0;\\n        for(int i=0; i<N; i++) {\\n            if(s.charAt(i)==\\'1\\') {\\n                res++;\\n                count = (count+res)%mod;\\n            } else {\\n                res=0;\\n            }\\n        }\\n        return (int)count;\\n    }\\n\\t\\n**Approach 2:-**\\n\\npublic int numSub(String s) {\\n        long count = 0;\\n        int mod = 1000_000_007;\\n        int N = s.length();\\n        int i = 0;\\n        int j = 0;;\\n        while(i<N) {\\n            if(s.charAt(i)==\\'1\\') {\\n                j = i;\\n                while(j<N) {\\n                    if(s.charAt(j)==\\'1\\') {\\n                        j++;\\n                    } else {\\n                        break;\\n                    }  \\n                }\\n                j--;\\n                int len = j-i+1;\\n                count = count + ((1l* (len)) * (len+1)/2)%mod;\\n                i = j;\\n            }\\n            i++;\\n        }\\n\\t\\treturn (int)count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475124,
                "title": "easy-math-solution-mod",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n       long long cnt=0;\\n      long long ans=0;\\n       for(long long i=0;i<s.length();i++){\\n           if(s[i]==\\'0\\') cnt=0;\\n           else {\\n               cnt++;\\n               ans+=cnt% 1000000007;\\n           }\\n       }\\n       return ans% 1000000007; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n       long long cnt=0;\\n      long long ans=0;\\n       for(long long i=0;i<s.length();i++){\\n           if(s[i]==\\'0\\') cnt=0;\\n           else {\\n               cnt++;\\n               ans+=cnt% 1000000007;\\n           }\\n       }\\n       return ans% 1000000007; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456212,
                "title": "very-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int numSub(string s) \\n    {\\n        int mod=1e9+7;\\n        int ans=0;\\n        for(int x=0; x<s.size(); x++)\\n        {\\n            if(s[x]==\\'1\\')\\n            {\\n                int st=x;\\n                int en=st;\\n                while(s[en]==\\'1\\')\\n                {\\n                    ans=(ans+en-st+1)%mod;\\n                    en++;\\n                }\\n                x=en;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int numSub(string s) \\n    {\\n        int mod=1e9+7;\\n        int ans=0;\\n        for(int x=0; x<s.size(); x++)\\n        {\\n            if(s[x]==\\'1\\')\\n            {\\n                int st=x;\\n                int en=st;\\n                while(s[en]==\\'1\\')\\n                {\\n                    ans=(ans+en-st+1)%mod;\\n                    en++;\\n                }\\n                x=en;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1689109,
                "content": [
                    {
                        "username": "kinetic_dev",
                        "content": "how you mod in this case\\n"
                    },
                    {
                        "username": "vixeyfox",
                        "content": " answer_sum += how_many_substrings_of_1s\\n                                \\n                        # use modulo to prevent overflow\\n                        answer_sum = answer_sum % (10**9 + 7)\\nThis is because it is a large prime number that is easily expressed\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "This could possibly be moved to easy. I solved this in fewer than five minutes while distracted. "
                    },
                    {
                        "username": "khe1154",
                        "content": "almost same as: https://leetcode.com/problems/number-of-zero-filled-subarrays/"
                    }
                ]
            },
            {
                "id": 1794920,
                "content": [
                    {
                        "username": "kinetic_dev",
                        "content": "how you mod in this case\\n"
                    },
                    {
                        "username": "vixeyfox",
                        "content": " answer_sum += how_many_substrings_of_1s\\n                                \\n                        # use modulo to prevent overflow\\n                        answer_sum = answer_sum % (10**9 + 7)\\nThis is because it is a large prime number that is easily expressed\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "This could possibly be moved to easy. I solved this in fewer than five minutes while distracted. "
                    },
                    {
                        "username": "khe1154",
                        "content": "almost same as: https://leetcode.com/problems/number-of-zero-filled-subarrays/"
                    }
                ]
            },
            {
                "id": 2043166,
                "content": [
                    {
                        "username": "kinetic_dev",
                        "content": "how you mod in this case\\n"
                    },
                    {
                        "username": "vixeyfox",
                        "content": " answer_sum += how_many_substrings_of_1s\\n                                \\n                        # use modulo to prevent overflow\\n                        answer_sum = answer_sum % (10**9 + 7)\\nThis is because it is a large prime number that is easily expressed\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "This could possibly be moved to easy. I solved this in fewer than five minutes while distracted. "
                    },
                    {
                        "username": "khe1154",
                        "content": "almost same as: https://leetcode.com/problems/number-of-zero-filled-subarrays/"
                    }
                ]
            }
        ]
    }
]