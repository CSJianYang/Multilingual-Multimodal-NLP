[
    {
        "title": "Using a Robot to Print the Lexicographically Smallest String",
        "question_content": "You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:\n\n\tRemove the first character of a string s and give it to the robot. The robot will append this character to the string t.\n\tRemove the last character of a string t and give it to the robot. The robot will write this character on paper.\n\nReturn the lexicographically smallest string that can be written on the paper.\n&nbsp;\nExample 1:\n\nInput: s = \"zza\"\nOutput: \"azz\"\nExplanation: Let p denote the written string.\nInitially p=\"\", s=\"zza\", t=\"\".\nPerform first operation three times p=\"\", s=\"\", t=\"zza\".\nPerform second operation three times p=\"azz\", s=\"\", t=\"\".\n\nExample 2:\n\nInput: s = \"bac\"\nOutput: \"abc\"\nExplanation: Let p denote the written string.\nPerform first operation twice p=\"\", s=\"c\", t=\"ba\". \nPerform second operation twice p=\"ab\", s=\"c\", t=\"\". \nPerform first operation p=\"ab\", s=\"\", t=\"c\". \nPerform second operation p=\"abc\", s=\"\", t=\"\".\n\nExample 3:\n\nInput: s = \"bdda\"\nOutput: \"addb\"\nExplanation: Let p denote the written string.\nInitially p=\"\", s=\"bdda\", t=\"\".\nPerform first operation four times p=\"\", s=\"\", t=\"bdda\".\nPerform second operation four times p=\"addb\", s=\"\", t=\"\".\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts consists of only English lowercase letters.",
        "solutions": [
            {
                "id": 2678848,
                "title": "stack-it-up-easy-to-understand-c",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust keep count of the frequency of every char to go in lexicographic order. Now add char one by one to the stack , if the lowest lexicgraphic char is greater than equal to element on top of stack , add the top of stack to ans.\\nAt last if the stack isn\\'t empty after traversing all elements, add all elemrnts to the ans.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- **Time complexity: O(n)**  (every char goes in stack atmost once)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(n)**  (stack size can go upto n if smallest char is at last index)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    char low(vector<int> & freq){    // this function return the smallest char present\\n        \\n        for(int i=0;i<26;i++){\\n            if(freq[i]!=0)return \\'a\\'+i;\\n        } \\n        return \\'a\\';   \\n    }\\n    \\n    string robotWithString(string s) {\\n        \\n        stack<char> t;\\n        string ans=\"\";  \\n        vector<int> freq(26,0);\\n        for(char c:s){\\n            freq[c-\\'a\\']++;\\n        }\\n        \\n        //  *********** main logic \\n        for(char c:s){\\n            t.push(c);\\n             freq[c-\\'a\\']--; \\n            while(t.size()>0 && t.top()<=low(freq)){\\n                char x = t.top(); \\n                ans+= x;\\n                t.pop();  \\n            }    \\n        }\\n        \\n         while(t.size()>0){\\n             ans+= t.top();\\n             t.pop();   \\n        }\\n      //**********************\\n        return ans;\\n      \\n    }\\n};\\n```\\n* Also checkout the first comment.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    char low(vector<int> & freq){    // this function return the smallest char present\\n        \\n        for(int i=0;i<26;i++){\\n            if(freq[i]!=0)return \\'a\\'+i;\\n        } \\n        return \\'a\\';   \\n    }\\n    \\n    string robotWithString(string s) {\\n        \\n        stack<char> t;\\n        string ans=\"\";  \\n        vector<int> freq(26,0);\\n        for(char c:s){\\n            freq[c-\\'a\\']++;\\n        }\\n        \\n        //  *********** main logic \\n        for(char c:s){\\n            t.push(c);\\n             freq[c-\\'a\\']--; \\n            while(t.size()>0 && t.top()<=low(freq)){\\n                char x = t.top(); \\n                ans+= x;\\n                t.pop();  \\n            }    \\n        }\\n        \\n         while(t.size()>0){\\n             ans+= t.top();\\n             t.pop();   \\n        }\\n      //**********************\\n        return ans;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678810,
                "title": "counter",
                "content": "**Intuition:** we print a character at the end of `t` if it\\'s smaller or equal any remaining characters in `s`.\\n\\nWe can use a counter to track remaining characters. We reduce the counter as we move a character from `s` to `t`.\\n\\nSince we only care about the smallest among remaining characters, we track it using `lo`.\\n\\nPlease note that we may need to update `lo` when we move a character from `s` to `t`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        cnt, lo, p, t = Counter(s), \\'a\\', [], []\\n        for ch in s:\\n            t += ch\\n            cnt[ch] -= 1\\n            while lo < \\'z\\' and cnt[lo] == 0:\\n                lo = chr(ord(lo) + 1)\\n            while t and t[-1] <= lo:\\n                p += t.pop()\\n        return \"\".join(p) \\n```\\n\\n**C++**\\n```cpp\\nstring robotWithString(string s) {\\n    string p, t;\\n    int cnt[26] = {}, lo = 0;\\n    for(auto ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    for (auto ch : s) {\\n        t += ch;\\n        --cnt[ch - \\'a\\'];\\n        while(lo < 25 && cnt[lo] == 0)\\n            ++lo;\\n        while(!t.empty() && t.back() - \\'a\\' <= lo) {\\n            p += t.back();\\n            t.pop_back();\\n        }\\n    }\\n    return p;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        cnt, lo, p, t = Counter(s), \\'a\\', [], []\\n        for ch in s:\\n            t += ch\\n            cnt[ch] -= 1\\n            while lo < \\'z\\' and cnt[lo] == 0:\\n                lo = chr(ord(lo) + 1)\\n            while t and t[-1] <= lo:\\n                p += t.pop()\\n        return \"\".join(p) \\n```\n```cpp\\nstring robotWithString(string s) {\\n    string p, t;\\n    int cnt[26] = {}, lo = 0;\\n    for(auto ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    for (auto ch : s) {\\n        t += ch;\\n        --cnt[ch - \\'a\\'];\\n        while(lo < 25 && cnt[lo] == 0)\\n            ++lo;\\n        while(!t.empty() && t.back() - \\'a\\' <= lo) {\\n            p += t.back();\\n            t.pop_back();\\n        }\\n    }\\n    return p;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678792,
                "title": "python3-stack-counter-o-n-clean-concise",
                "content": "**Implementation**\\nWe use a stack (`t` defined in the question) to maintain the temporary string, and use a counter (hashmap) `dic` to maintain the count of all letters in the suffix string. For each character `char` in `s`, we first append it to `t` and remove its count from `dic`. Then, while top element of `t` is smaller of equal to the lexicographically smallest character in the remaining suffix string (excluding `char`), we keep popping it from the stack and appending it to the final answer.\\n\\n**Complexity**\\nTime Complexity: `O(26 * N)`\\nSpace Complexity: `O(N)`, for the use of stack `t`\\n \\n **Solution**\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        dic, t, ans = Counter(s), [], []\\n        for char in s:\\n            t.append(char)\\n            if dic[char] == 1:\\n                del dic[char]\\n            else:\\n                dic[char] -= 1\\n            while dic and t and min(dic) >= t[-1]:\\n                ans += t.pop()\\n        ans += t[::-1]\\n        return \\'\\'.join(ans)\\n```\\n**Remark:** We can further improve the time complexity by replacing `dic` with an array `min_suffix` to pre-record the lexicographically smallest character in the suffix string.\\n\\n**Complexity**\\nTime Complexity: `O(N)`\\nSpace Complexity: `O(N)`, for the use of stack `t` and suffix array `min_suffix`\\n\\n **Solution**\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        min_suffix, t, ans = [s[-1]] * n, [], []\\n        for i in range(n - 2, -1, -1):\\n            min_suffix[i] = min(s[i], min_suffix[i + 1])\\n        for i, char in enumerate(s):\\n            t.append(char)\\n            while i + 1 < n and t and min_suffix[i + 1] >= t[-1]:\\n                ans += t.pop()\\n        ans += t[::-1]\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        dic, t, ans = Counter(s), [], []\\n        for char in s:\\n            t.append(char)\\n            if dic[char] == 1:\\n                del dic[char]\\n            else:\\n                dic[char] -= 1\\n            while dic and t and min(dic) >= t[-1]:\\n                ans += t.pop()\\n        ans += t[::-1]\\n        return \\'\\'.join(ans)\\n```\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        min_suffix, t, ans = [s[-1]] * n, [], []\\n        for i in range(n - 2, -1, -1):\\n            min_suffix[i] = min(s[i], min_suffix[i + 1])\\n        for i, char in enumerate(s):\\n            t.append(char)\\n            while i + 1 < n and t and min_suffix[i + 1] >= t[-1]:\\n                ans += t.pop()\\n        ans += t[::-1]\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679080,
                "title": "java-greedy-o-n-solution",
                "content": "The first loop is to record the frequence of every character, the array freq, the second loop is to add every character into a stack, when adding the character into the stack, decreate the frequency of the character by one in the array freq, then the array freq is the frequency of every character in the rest of string. When adding one character from the top of the stack to the result, we check if there is one smaller character in the rest of the string, if there is, keep pushing the character of the rest of the string into the stack, if there is not, then add the top character into the result. \\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        if (s == null || s.length() < 1) return \"\";\\n        int[] freq = new int[26];\\n        for (char c: s.toCharArray()) { // first loop\\n            freq[c - \\'a\\']++;\\n        }\\n        Stack<Character> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder(); // the final result\\n        for (char c: s.toCharArray()) { // second loop\\n            stack.add(c);\\n            freq[c - \\'a\\']--;\\n            while (!stack.isEmpty()) {\\n                char temp = stack.peek();\\n                if (hasSmaller(temp, freq)) break; // check if there is a smaller character in the rest of the string compared to top character of the stack\\n                sb.append(stack.pop());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private boolean hasSmaller(char c, int[] freq) {\\n        int ind = (int)(c - \\'a\\');\\n        for (int i = 0; i < ind; i++) {\\n            if (freq[i] > 0) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        if (s == null || s.length() < 1) return \"\";\\n        int[] freq = new int[26];\\n        for (char c: s.toCharArray()) { // first loop\\n            freq[c - \\'a\\']++;\\n        }\\n        Stack<Character> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder(); // the final result\\n        for (char c: s.toCharArray()) { // second loop\\n            stack.add(c);\\n            freq[c - \\'a\\']--;\\n            while (!stack.isEmpty()) {\\n                char temp = stack.peek();\\n                if (hasSmaller(temp, freq)) break; // check if there is a smaller character in the rest of the string compared to top character of the stack\\n                sb.append(stack.pop());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private boolean hasSmaller(char c, int[] freq) {\\n        int ind = (int)(c - \\'a\\');\\n        for (int i = 0; i < ind; i++) {\\n            if (freq[i] > 0) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678856,
                "title": "smallest-character-to-right-easy-to-understand",
                "content": "**Please upvote if find helpful :)**\\n\\n**LOGIC** : We need to store minimum character present to right side of each index\\nNow there are two operations available\\n1. Remove the first character of a string s and give it to the robot. The robot will append this character to the string t.\\n2. Remove the last character of a string t and give it to the robot. The robot will write this character on paper.\\n\\nas we need lexicographically smallest string , **our main focus would be on to make MSB character minimum**\\n\\nso while writing on paper , check if there are any minimum elements present on right side of i compared with last element of t\\n**If present -> don\\'t write on paper , continue**\\n**If not present -> write last character on paper**\\n\\n```\\n\\n        int n=s.size();\\n        // smaller char to the right\\n        vector<char>v(n);\\n        v[n-1]=s.back();\\n        for(int i=n-2;i>=0;i--)\\n            if(s[i]<v[i+1]) v[i]=s[i];\\n            else v[i]=v[i+1];\\n        \\n        string p=\"\",t=\"\";\\n        \\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            \\n            // if there are not any mini char in s to right of i than t\\'s last\\n\\t\\t\\t  while(t.size()>0 and v[i]>=t.back()){\\n                p+=t.back() ;    // write last char on paper\\n                t.pop_back(); \\n            }\\n    \\n            t+=c;\\n        }\\n        \\n        while(t.size()) {\\n            p+=t.back() ; \\n            t.pop_back();\\n        }\\n        return p;\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n        int n=s.size();\\n        // smaller char to the right\\n        vector<char>v(n);\\n        v[n-1]=s.back();\\n        for(int i=n-2;i>=0;i--)\\n            if(s[i]<v[i+1]) v[i]=s[i];\\n            else v[i]=v[i+1];\\n        \\n        string p=\"\",t=\"\";\\n        \\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            \\n            // if there are not any mini char in s to right of i than t\\'s last\\n\\t\\t\\t  while(t.size()>0 and v[i]>=t.back()){\\n                p+=t.back() ;    // write last char on paper\\n                t.pop_back(); \\n            }\\n    \\n            t+=c;\\n        }\\n        \\n        while(t.size()) {\\n            p+=t.back() ; \\n            t.pop_back();\\n        }\\n        return p;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683046,
                "title": "detailed-explanation-with-pictures",
                "content": "According to question,\\nwe can remove the last character from the substrig of the given string s, and from that we have to return  \\n*lexicographically smallest string*\\nExamples given as test cases are sufficient, but lets take another eg for better understanding,\\n\\n![image](https://assets.leetcode.com/users/images/52fcd6b7-b08d-45fd-bc88-51634efc1725_1665343609.310718.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/215ade06-8cff-4040-8343-5e38c6bb390d_1665343609.415.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/1ac633c8-e9f1-4e86-8c55-6c86436bade1_1665343609.2757468.jpeg)\\n\\n\\n**[C++ code]**\\n\\n```\\nclass Solution {\\npublic:\\n    char lower(vector<int> &freq){\\n        for(int i=0;i<26;i++){\\n            if(freq[i]!=0)return \\'a\\'+i;\\n        }\\n        return \\'a\\';\\n    }\\n    string robotWithString(string s) {\\n        vector<int> freq(26);\\n        for(auto a:s){\\n            freq[a-\\'a\\']++;\\n        }\\n        string ans=\"\";\\n        stack<char> st;\\n        for(auto a:s){\\n            st.push(a);\\n            freq[a-\\'a\\']--;\\n            while(st.size() && st.top()<=lower(freq)){\\n                auto x=st.top();\\n                ans+=x;\\n                st.pop();\\n            }\\n        }\\n        while(st.size()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char lower(vector<int> &freq){\\n        for(int i=0;i<26;i++){\\n            if(freq[i]!=0)return \\'a\\'+i;\\n        }\\n        return \\'a\\';\\n    }\\n    string robotWithString(string s) {\\n        vector<int> freq(26);\\n        for(auto a:s){\\n            freq[a-\\'a\\']++;\\n        }\\n        string ans=\"\";\\n        stack<char> st;\\n        for(auto a:s){\\n            st.push(a);\\n            freq[a-\\'a\\']--;\\n            while(st.size() && st.top()<=lower(freq)){\\n                auto x=st.top();\\n                ans+=x;\\n                st.pop();\\n            }\\n        }\\n        while(st.size()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680344,
                "title": "c-simple-solution-using-stack-detailed-explanation",
                "content": "**Intuition:**\\nFor each character, we add it to the paper if there is no smaller character to the right of the current character.\\n\\n**Ex:** s = \"beach\", ans = \"acebh\" \\n(solve this example using pen and paper to understand the intuition more)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// Returns the smaller element to the right of the current character\\n    char smaller(vector<int> &freq){\\n        for(int i=0; i<26; i++){\\n            if(freq[i] > 0){\\n                return (\\'a\\'+i);\\n            }\\n        }\\n        return (\\'a\\'+26);\\n    }\\n    \\n    string robotWithString(string s) {\\n\\t\\t// Store the frequencies, which help in finding the smaller char to the right of the current char\\n        vector<int> freq(26, 0);\\n        for(char ch: s){\\n            freq[ch-\\'a\\']++;\\n        }\\n        \\n        string ans = \"\";\\n        stack<int> st;\\n        \\n        for(int i=0; i<s.size(); i++){\\n\\t\\t\\t// If there is no smaller character to the right of the top, then it should be added to the ans\\n            while(!st.empty() && s[st.top()] <= smaller(freq)){\\n                ans += s[st.top()];\\n                st.pop();\\n            }\\n            st.push(i);\\n            freq[s[i]-\\'a\\']--;\\n        }\\n        \\n        while(!st.empty()){\\n            ans += s[st.top()];\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Returns the smaller element to the right of the current character\\n    char smaller(vector<int> &freq){\\n        for(int i=0; i<26; i++){\\n            if(freq[i] > 0){\\n                return (\\'a\\'+i);\\n            }\\n        }\\n        return (\\'a\\'+26);\\n    }\\n    \\n    string robotWithString(string s) {\\n\\t\\t// Store the frequencies, which help in finding the smaller char to the right of the current char\\n        vector<int> freq(26, 0);\\n        for(char ch: s){\\n            freq[ch-\\'a\\']++;\\n        }\\n        \\n        string ans = \"\";\\n        stack<int> st;\\n        \\n        for(int i=0; i<s.size(); i++){\\n\\t\\t\\t// If there is no smaller character to the right of the top, then it should be added to the ans\\n            while(!st.empty() && s[st.top()] <= smaller(freq)){\\n                ans += s[st.top()];\\n                st.pop();\\n            }\\n            st.push(i);\\n            freq[s[i]-\\'a\\']--;\\n        }\\n        \\n        while(!st.empty()){\\n            ans += s[st.top()];\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2679885,
                "title": "python-solution-o-n",
                "content": "```python\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        stack = []\\n        result = []\\n        smallest_from_right = [\"\"] * len(s)\\n        smallest_from_right[-1] = s[-1]\\n        \\n        for i in range(len(smallest_from_right) - 2, -1, -1):\\n            smallest_from_right[i] = min(s[i], smallest_from_right[i + 1])\\n        \\n        for i in range(len(s)):\\n            while stack and stack[-1] <= smallest_from_right[i]:\\n                result.append(stack.pop())\\n            stack.append(s[i])\\n        \\n        while stack:\\n            result.append(stack.pop())\\n        \\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        stack = []\\n        result = []\\n        smallest_from_right = [\"\"] * len(s)\\n        smallest_from_right[-1] = s[-1]\\n        \\n        for i in range(len(smallest_from_right) - 2, -1, -1):\\n            smallest_from_right[i] = min(s[i], smallest_from_right[i + 1])\\n        \\n        for i in range(len(s)):\\n            while stack and stack[-1] <= smallest_from_right[i]:\\n                result.append(stack.pop())\\n            stack.append(s[i])\\n        \\n        while stack:\\n            result.append(stack.pop())\\n        \\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679390,
                "title": "simple-c-solution",
                "content": "**Step 1-** First of all we create a vector mn to store the rightmost min. of every character of string (so that we get the idea that in future minimum character will be present or not).\\n\\n**Step2-** Add 1st character in empty string t and then traverse the string s.  \\n There will be 2 cases:\\n   1.  If the current character of s is less than equal to last character of t then we simple append that into t.\\n   2.  If the current character greater than last character of t then there can be 2 possiblities:\\n       *    if mn[i]<t.back() means in future we get the character less than t.back() then we simply add that in t.\\n       *    we pop_back() from t and add into our string ans \\n                 if( t.length()!=0 && mn[i]<t.back()) \\n\\t\\t\\t\\t**** and also check for the condition****\\n                  if(t.length()!=0 && mn[i]<t.back())\\n                     {\\n                         t+=s[i];\\n                         break;\\n                     }\\n\\t\\t\\t\\twe do this task iteratively.\\n**Step3-** In last we simply add string of t from backwards in our answer and return it.\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n=s.length();\\n        vector<char>mn(n);\\n        mn[n-1]=s[n-1];\\n        char m=s[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]<m)\\n            {\\n                m=s[i];\\n            }\\n            mn[i]=m;\\n        }\\n        string t=\"\";\\n        string ans=\"\";\\n        t+=s[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(t.length()==0 || s[i]<=t.back() )\\n            {\\n                t+=s[i];\\n            }\\n            else\\n            {\\n                while(true)\\n                {\\n                     if(t.length()!=0 && mn[i]<t.back())\\n                     {\\n                         t+=s[i];\\n                         break;\\n                     }\\n                    else\\n                    {\\n                         if(t.length()==0 || t.back()>s[i])\\n                         {\\n                             i--;\\n                             break;\\n                         }\\n                         ans+=t.back();\\n                         t.pop_back();\\n                    }    \\n                 }   \\n            }       \\n         }\\n        \\n        for(int i=t.length()-1;i>=0;i--)\\n        {\\n            ans+=t[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote it if you like the solution:)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n=s.length();\\n        vector<char>mn(n);\\n        mn[n-1]=s[n-1];\\n        char m=s[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]<m)\\n            {\\n                m=s[i];\\n            }\\n            mn[i]=m;\\n        }\\n        string t=\"\";\\n        string ans=\"\";\\n        t+=s[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(t.length()==0 || s[i]<=t.back() )\\n            {\\n                t+=s[i];\\n            }\\n            else\\n            {\\n                while(true)\\n                {\\n                     if(t.length()!=0 && mn[i]<t.back())\\n                     {\\n                         t+=s[i];\\n                         break;\\n                     }\\n                    else\\n                    {\\n                         if(t.length()==0 || t.back()>s[i])\\n                         {\\n                             i--;\\n                             break;\\n                         }\\n                         ans+=t.back();\\n                         t.pop_back();\\n                    }    \\n                 }   \\n            }       \\n         }\\n        \\n        for(int i=t.length()-1;i>=0;i--)\\n        {\\n            ans+=t[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694921,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/WY4SG5Pa/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/WY4SG5Pa/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2681246,
                "title": "min-suffix-stack",
                "content": "# Intuition\\nAccording to the algorithm we need to compute lexicographically samllest string and to get that we need to get the min character that we can get at first.\\nSo it follows a greedy solution.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe first pre-compute the min characters position at or after the given index. So we compute the suffix array of the min characters position.\\n\\n`res = \"\"` to store the resultant string.\\n\\nUsing the suffix array we get the position of the min character and add it to `res`.\\n\\nIf we use a particular character then the un-used characters before it are stacked in a stack `t`.\\n\\nAs we are getting the min character for out index if there are chacters in the stack that is less that or equal to the min we use them first.\\n\\nAnd at the end we add the `t` to the `res`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.length(), m = n - 1;\\n        vector<int> suffix(n);\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(s[i] <= s[m])\\n                m = i;\\n            suffix[i] = m;\\n        }\\n        string res = \"\";\\n        stack<char> t;\\n        int i, st = 0;\\n        while(st < n) {\\n            m = suffix[st];\\n            while(!t.empty() && s[m] >= t.top()) {\\n                res += t.top();\\n                t.pop();\\n            }\\n            res += s[m];\\n            for(i = st; i < m; i++)\\n                t.push(s[i]);\\n            st = m + 1;\\n        }\\n        while(!t.empty()) {\\n            res += t.top();\\n            t.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.length(), m = n - 1;\\n        vector<int> suffix(n);\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(s[i] <= s[m])\\n                m = i;\\n            suffix[i] = m;\\n        }\\n        string res = \"\";\\n        stack<char> t;\\n        int i, st = 0;\\n        while(st < n) {\\n            m = suffix[st];\\n            while(!t.empty() && s[m] >= t.top()) {\\n                res += t.top();\\n                t.pop();\\n            }\\n            res += s[m];\\n            for(i = st; i < m; i++)\\n                t.push(s[i]);\\n            st = m + 1;\\n        }\\n        while(!t.empty()) {\\n            res += t.top();\\n            t.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679726,
                "title": "very-short-kotlin-solution-using-sortedmap",
                "content": "```\\nclass Solution {\\n    fun robotWithString(s: String): String {\\n        val count = s.toList().groupingBy { it }.eachCount().toSortedMap()\\n        val result = StringBuilder()\\n        val t = StringBuilder()\\n        for (i in s) {\\n            t.append(i)\\n            if (count[i] == 1) count.remove(i)\\n            else count[i] = count[i]!! - 1\\n            fun notEmpty() = t.isNotEmpty() && count.isNotEmpty()\\n            while (notEmpty() && t.last() <= count.firstKey()) {\\n                result.append(t.last())\\n                t.deleteCharAt(t.length - 1)\\n            }\\n        }\\n        \\n        return result.append(t.reversed()).toString()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun robotWithString(s: String): String {\\n        val count = s.toList().groupingBy { it }.eachCount().toSortedMap()\\n        val result = StringBuilder()\\n        val t = StringBuilder()\\n        for (i in s) {\\n            t.append(i)\\n            if (count[i] == 1) count.remove(i)\\n            else count[i] = count[i]!! - 1\\n            fun notEmpty() = t.isNotEmpty() && count.isNotEmpty()\\n            while (notEmpty() && t.last() <= count.firstKey()) {\\n                result.append(t.last())\\n                t.deleteCharAt(t.length - 1)\\n            }\\n        }\\n        \\n        return result.append(t.reversed()).toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679848,
                "title": "java-stack-simulate-with-comments-easy-and-straightforward",
                "content": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        Stack<Character> t = new Stack<>();\\n        char[] schar = s.toCharArray();\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int i = 0; i < s.length(); i++) map.put(schar[i], i);\\n        Arrays.sort(schar);\\n        \\n        int cur = -1;\\n        int i = 0;\\n        while(i < s.length()){\\n            char curch = schar[i];//Check current minimum character            \\n            if(map.get(curch) > cur){//Current char is not in stack  \\n                while(!t.isEmpty() && t.peek() <= curch) ans.append(t.pop());//Char in stack is smaller than current char, then we add it to answer first\\n                ans.append(curch);\\n                for(int j = cur + 1; j < map.get(curch); j++){\\n                    if(s.charAt(j) == curch){\\n                        ans.append(curch);\\n                        i++;\\n                    }\\n                    else t.push(s.charAt(j)); //Put in stack\\n                }\\n                cur = map.get(curch);\\n            }\\n            i++;\\n        }\\n         \\n        //Add left nums in stack to answer\\n        while(!t.isEmpty()) ans.append(t.pop());        \\n        return ans.toString();\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/876519f2-dc1b-4753-b537-61f2716863f8_1665297398.8158514.png)\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        Stack<Character> t = new Stack<>();\\n        char[] schar = s.toCharArray();\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int i = 0; i < s.length(); i++) map.put(schar[i], i);\\n        Arrays.sort(schar);\\n        \\n        int cur = -1;\\n        int i = 0;\\n        while(i < s.length()){\\n            char curch = schar[i];//Check current minimum character            \\n            if(map.get(curch) > cur){//Current char is not in stack  \\n                while(!t.isEmpty() && t.peek() <= curch) ans.append(t.pop());//Char in stack is smaller than current char, then we add it to answer first\\n                ans.append(curch);\\n                for(int j = cur + 1; j < map.get(curch); j++){\\n                    if(s.charAt(j) == curch){\\n                        ans.append(curch);\\n                        i++;\\n                    }\\n                    else t.push(s.charAt(j)); //Put in stack\\n                }\\n                cur = map.get(curch);\\n            }\\n            i++;\\n        }\\n         \\n        //Add left nums in stack to answer\\n        while(!t.isEmpty()) ans.append(t.pop());        \\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679201,
                "title": "clean-java",
                "content": "1. If there are some character \\u201Ca\\u201D \\u2019 s in the string, they can be written on paper before anything else.\\n2. Every character in the string before the last \\u201Ca\\u201D should be written in reversed order.\\n3. After the robot writes every \\u201Ca\\u201D on paper, the same holds for other characters \\u201Cb\\u201D, \\u201Dc\\u201D, \\u2026etc.\\n\\nBe careful when we do a later character for example \\'b\\', we should start after lastSeenOf \\u2018a\\', due to all the character before a has already put into stack.\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        Map<Character, Integer> lastSeen = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++)\\n            lastSeen.put(s.charAt(i), i);\\n        Set<Integer> used = new HashSet<>();\\n        Stack<Character> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        int preEnd = 0;\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            while (!stack.isEmpty() && stack.peek() <= c) sb.append(stack.pop());\\n            if (!lastSeen.containsKey(c)) continue;\\n            int last = lastSeen.get(c);\\n            for (int i = preEnd; i <= last; i++) {\\n                char cur = s.charAt(i);\\n                if (used.add(i)) {\\n                    if (cur == c) sb.append(cur);\\n                    else stack.add(cur);\\n                }\\n            }\\n            preEnd = last + 1;\\n        }\\n        while (!stack.isEmpty()) {\\n            sb.append(stack.pop());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        Map<Character, Integer> lastSeen = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++)\\n            lastSeen.put(s.charAt(i), i);\\n        Set<Integer> used = new HashSet<>();\\n        Stack<Character> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        int preEnd = 0;\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            while (!stack.isEmpty() && stack.peek() <= c) sb.append(stack.pop());\\n            if (!lastSeen.containsKey(c)) continue;\\n            int last = lastSeen.get(c);\\n            for (int i = preEnd; i <= last; i++) {\\n                char cur = s.charAt(i);\\n                if (used.add(i)) {\\n                    if (cur == c) sb.append(cur);\\n                    else stack.add(cur);\\n                }\\n            }\\n            preEnd = last + 1;\\n        }\\n        while (!stack.isEmpty()) {\\n            sb.append(stack.pop());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691770,
                "title": "python-3-8-lines-counter-and-stack-t-m-65-61",
                "content": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        \\n        d, stack, ans = Counter(s), [], []\\n\\n        for ch in s:\\n            \\n            d[ch]-= 1\\n            stack.append(ch)\\n            if not d[ch]: d.pop(ch)\\n                \\n            while d and stack and min(d) >= stack[-1]:\\n                ans += stack.pop()\\n\\n        return \\'\\'.join(ans + stack[::-1])\\n```\\n[https://leetcode.com/submissions/detail/820302098/](http://)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        \\n        d, stack, ans = Counter(s), [], []\\n\\n        for ch in s:\\n            \\n            d[ch]-= 1\\n            stack.append(ch)\\n            if not d[ch]: d.pop(ch)\\n                \\n            while d and stack and min(d) >= stack[-1]:\\n                ans += stack.pop()\\n\\n        return \\'\\'.join(ans + stack[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683179,
                "title": "intuition-and-step-by-step-detailed-approach-with-pictures",
                "content": "# Intuition\\nSimulate the process, as we would actually do it in the real world. The string `t` can be represented by a stack.\\n\\nWhile writing things on paper, we can only pop it off from stack. We can either pop the top of the stack, or we can add a new item in the stack. We remove the top of the stack (and write it down) when it is smaller than (or equal to) the smallest available element in the string. Only the element to the right of the current position are available for writing at any point.\\n\\nIn case we have a smaller element available to the right of the current location in the string, we push the current element on top of the stack. And follow the same process again. \\n\\nFor finding the smallest element toward the right, we preprocess the given string. We iterate from right to left, and make a note of the index of the minimum element found so far in another array called `minimums`.\\n\\n![robot-writer.jpeg](https://assets.leetcode.com/users/images/826cc127-8fe3-4fe2-b3b5-d614701f4898_1665345317.6294024.jpeg)\\n\\n\\n# Approach\\n\\n1. Create an array called `minimums` with length equal to the length of the string.\\n2. Iterate through the string starting from the last element to the first element. Make a note of the minimum element seen so far, and store its index in the corresponding position in `minimums` array.\\n3. Create a new `stack`, and another array `result`. `result` represents the letters writte on a paper.\\n3. Do the following for each index $i$ in the string `s`.\\n    * If the stack isn\\'t empty, compare the top of the stack with `minimums[i]` element. Pop the top of the stack, and add it to the result until `minimums[i]` element is smaller than the stack top.\\n    * If `minimums[i]` is smaller, push it on top of the stack.\\n4. When the loop ends, pop all the elements from the stack, and add them to `answer` one by one.\\n5. Join all characters of `answer` to form a string and return it.\\n\\n# Complexity\\n\\nLet $n$ be the total number of characters in the given string:\\n\\n* Time complexity: $O(n)$. We iterate through each character of `s` while building `minimums` array. Then as we build `answer` array, we iterate through `s` one more time. Each character is accessed two times, once when it is being pushed on top of the stack, and again when it is being popped from the stack. So the total time complexity remains $O(n)$.\\n* Space complexity: $O(n)$. We make use of two auxiliary data structures, one is the `minimums` array and the other one is `stack` which can be filled with all the characters in the worst case. So $O(n)$ is the maximum space we use here.\\n\\n\\n# Code\\n```javascript\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar robotWithString = function(s) {\\n  console.log(s);\\n  // compute minimum toward the right\\n  let minimums = new Array(s.length);\\n  let minimum = \\'{\\';\\n  let minIndex = -1;\\n  for (let i = s.length - 1; i >= 0; i--) {\\n    // if the minimum element is equal, we pick\\n    // the one with lower index\\n    if (s[i] <= minimum) {\\n      minimum = s[i];\\n      minIndex = i;\\n    }\\n    minimums[i] = minIndex;\\n  }\\n  let result = [];\\n  let stack = [];\\n  for (let i = 0; i < s.length; i++) {\\n    // compare s[minimums[i]] with top of stack\\n    while (stack.length && s[minimums[i]] >= stack.at(-1)) {\\n      result.push(stack.pop());\\n    }\\n    stack.push(s[i]);\\n  }\\n\\n  // the remaining characters in the stack are also popped\\n  // and added to the answer\\n  while (stack.length) {\\n    result.push(stack.pop());\\n  }\\n\\n  // return the string made after joining all the characters\\n  return result.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar robotWithString = function(s) {\\n  console.log(s);\\n  // compute minimum toward the right\\n  let minimums = new Array(s.length);\\n  let minimum = \\'{\\';\\n  let minIndex = -1;\\n  for (let i = s.length - 1; i >= 0; i--) {\\n    // if the minimum element is equal, we pick\\n    // the one with lower index\\n    if (s[i] <= minimum) {\\n      minimum = s[i];\\n      minIndex = i;\\n    }\\n    minimums[i] = minIndex;\\n  }\\n  let result = [];\\n  let stack = [];\\n  for (let i = 0; i < s.length; i++) {\\n    // compare s[minimums[i]] with top of stack\\n    while (stack.length && s[minimums[i]] >= stack.at(-1)) {\\n      result.push(stack.pop());\\n    }\\n    stack.push(s[i]);\\n  }\\n\\n  // the remaining characters in the stack are also popped\\n  // and added to the answer\\n  while (stack.length) {\\n    result.push(stack.pop());\\n  }\\n\\n  // return the string made after joining all the characters\\n  return result.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682667,
                "title": "java-stack",
                "content": "```\\n    //Runtime: 245 ms, faster than 100.00% of Java online submissions for Using a Robot to Print the Lexicographically Smallest String.\\n    //Memory Usage: 118.7 MB, less than 100.00% of Java online submissions for Using a Robot to Print the Lexicographically Smallest String.\\n    //Time: O(N + N) Space:O(26 + N + N)\\n    //Time: O(N) Space:O(N)\\n    public String robotWithString(String s) {\\n        int[] counter = new int[26];\\n        for (char c: s.toCharArray()) counter[c -\\'a\\']++;\\n\\n        int idx = 0;\\n        while (counter[idx] == 0) idx++;\\n\\n        StringBuffer sb = new StringBuffer();\\n        Deque<Character> stack = new ArrayDeque<>();\\n\\n        for (char c: s.toCharArray()) {\\n            while (!stack.isEmpty() && stack.peek() - \\'a\\' <= idx)\\n                sb.append(stack.pop());\\n\\n            if (c - \\'a\\' <= idx) sb.append(c);\\n            else stack.push(c);\\n\\n            counter[c - \\'a\\']--;\\n            while (idx < 26 && counter[idx] == 0) idx++;\\n        }\\n        while (!stack.isEmpty()) sb.append(stack.pop());\\n        return sb.toString();\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n    //Runtime: 245 ms, faster than 100.00% of Java online submissions for Using a Robot to Print the Lexicographically Smallest String.\\n    //Memory Usage: 118.7 MB, less than 100.00% of Java online submissions for Using a Robot to Print the Lexicographically Smallest String.\\n    //Time: O(N + N) Space:O(26 + N + N)\\n    //Time: O(N) Space:O(N)\\n    public String robotWithString(String s) {\\n        int[] counter = new int[26];\\n        for (char c: s.toCharArray()) counter[c -\\'a\\']++;\\n\\n        int idx = 0;\\n        while (counter[idx] == 0) idx++;\\n\\n        StringBuffer sb = new StringBuffer();\\n        Deque<Character> stack = new ArrayDeque<>();\\n\\n        for (char c: s.toCharArray()) {\\n            while (!stack.isEmpty() && stack.peek() - \\'a\\' <= idx)\\n                sb.append(stack.pop());\\n\\n            if (c - \\'a\\' <= idx) sb.append(c);\\n            else stack.push(c);\\n\\n            counter[c - \\'a\\']--;\\n            while (idx < 26 && counter[idx] == 0) idx++;\\n        }\\n        while (!stack.isEmpty()) sb.append(stack.pop());\\n        return sb.toString();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680024,
                "title": "c-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<int> last(26,-1);\\n        for(int i=0;i<s.size();i++){\\n            last[s[i] - \\'a\\'] = i;\\n        }\\n        \\n        string ans;\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            st.push(s[i]);\\n            while(st.size()){\\n                bool exist = false;\\n                for(int ch = 0;ch < st.top()-\\'a\\';ch++){\\n                    if(i < last[ch])\\n                    {\\n                        exist = true;\\n                        break;\\n                    }\\n                    }\\n                    if(exist){\\n                        break;\\n                    }\\n                    ans.push_back(st.top());\\n                    st.pop();\\n            }\\n        }\\n                    while(st.size())\\n                    {\\n                        ans.push_back(st.top());\\n                        st.pop();\\n                    }\\n                    return ans;\\n        \\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<int> last(26,-1);\\n        for(int i=0;i<s.size();i++){\\n            last[s[i] - \\'a\\'] = i;\\n        }\\n        \\n        string ans;\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            st.push(s[i]);\\n            while(st.size()){\\n                bool exist = false;\\n                for(int ch = 0;ch < st.top()-\\'a\\';ch++){\\n                    if(i < last[ch])\\n                    {\\n                        exist = true;\\n                        break;\\n                    }\\n                    }\\n                    if(exist){\\n                        break;\\n                    }\\n                    ans.push_back(st.top());\\n                    st.pop();\\n            }\\n        }\\n                    while(st.size())\\n                    {\\n                        ans.push_back(st.top());\\n                        st.pop();\\n                    }\\n                    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679020,
                "title": "python-stack-clean-explained-and-easy-to-understand",
                "content": "# Approach\\nWe loop through the string, keeping track of the next smallest character.\\nIf the current index is equal to it, append it to the final answer.\\nElse, append it to a stack.\\n\\nThen update the next smallest character, and while the top of the stack is less than it, pop it and append it to the final answer.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        st = []\\n        g = Counter(s)\\n        f = sorted(list(set(s)))\\n        f.append(\\'z\\')\\n        cur = 0\\n        re = []\\n        for i in s:\\n            if i != f[cur]:\\n                st.append(i)\\n                g[i] -= 1\\n                while(g[f[cur]] == 0) and cur < len(f) - 1: cur+=1\\n            else:\\n                re.append(i)\\n                g[i] -= 1\\n                while(g[f[cur]] == 0) and cur < len(f) - 1: cur+=1\\n                while(st and st[-1] <= f[cur]):\\n                    re.append(st.pop())\\n                    \\n        while st: re.append(st.pop())\\n        # print(cur, f, g, re)\\n        return \\'\\'.join(re)\\n            \\n                \\n                \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        st = []\\n        g = Counter(s)\\n        f = sorted(list(set(s)))\\n        f.append(\\'z\\')\\n        cur = 0\\n        re = []\\n        for i in s:\\n            if i != f[cur]:\\n                st.append(i)\\n                g[i] -= 1\\n                while(g[f[cur]] == 0) and cur < len(f) - 1: cur+=1\\n            else:\\n                re.append(i)\\n                g[i] -= 1\\n                while(g[f[cur]] == 0) and cur < len(f) - 1: cur+=1\\n                while(st and st[-1] <= f[cur]):\\n                    re.append(st.pop())\\n                    \\n        while st: re.append(st.pop())\\n        # print(cur, f, g, re)\\n        return \\'\\'.join(re)\\n            \\n                \\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678867,
                "title": "python-3-o-n-solution-with-intuition-and-explanation",
                "content": "#### Intuition:\\nFor this problem, we can easily put all the smallest character at the beginning of the result string. E.g. for string \"eadab\", \\nwe do the operations below:\\n| s |t | p|\\n| -- | -- | -- |\\n| eadab | | |\\n| adab| e| |\\n|dab | ea| |\\n| dab | e | a |\\n| ab | ed | a |\\n| b| eda| a |\\n| b| ed | aa|\\nFrom this point, we have one string t, and the remaining part of s. We can repeat the previous step to move the samllest characters in the remaining part of s to the result string and remember to append all smaller characters at the end of string t.\\n\\n#### Steps:\\n1. Find out the last occurrence of each character in string s.\\n2. Loop through s, whenever we encounter the smallest character in the remaining part of s: \\n\\ta. Move it to t and then p; \\n\\tb. Add all characters in the end of t that is smaller or equal to the smallest character in the reamining part of s.\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n       \\tlast_occurrence = dict()\\n       \\tfor i in range(len(s)-1, -1, -1):\\n       \\t\\tif s[i] not in last_occurrence:\\n       \\t\\t\\tlast_occurrence[s[i]] = i\\n\\n       \\tchars = sorted(last_occurrence.keys())[::-1]\\n\\n       \\tt, p = [], []\\n       \\ti = 0\\n       \\tch = chars.pop()\\n       \\tidx = 0\\n       \\twhile idx < len(s):\\n       \\t\\tprint(t, p)\\n       \\t\\tif s[idx] == ch:\\n       \\t\\t\\tp.append(ch)\\n       \\t\\t\\twhile chars and idx >= last_occurrence[ch]:\\n       \\t\\t\\t\\tch = chars.pop()\\n       \\t\\t\\twhile t and t[-1] <= ch:\\n       \\t\\t\\t\\tp.append(t.pop())\\n       \\t\\telse:\\n       \\t\\t\\tt.append(s[idx])\\n       \\t\\tidx += 1\\n       \\treturn \"\".join(p) + \"\".join(t[::-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n       \\tlast_occurrence = dict()\\n       \\tfor i in range(len(s)-1, -1, -1):\\n       \\t\\tif s[i] not in last_occurrence:\\n       \\t\\t\\tlast_occurrence[s[i]] = i\\n\\n       \\tchars = sorted(last_occurrence.keys())[::-1]\\n\\n       \\tt, p = [], []\\n       \\ti = 0\\n       \\tch = chars.pop()\\n       \\tidx = 0\\n       \\twhile idx < len(s):\\n       \\t\\tprint(t, p)\\n       \\t\\tif s[idx] == ch:\\n       \\t\\t\\tp.append(ch)\\n       \\t\\t\\twhile chars and idx >= last_occurrence[ch]:\\n       \\t\\t\\t\\tch = chars.pop()\\n       \\t\\t\\twhile t and t[-1] <= ch:\\n       \\t\\t\\t\\tp.append(t.pop())\\n       \\t\\telse:\\n       \\t\\t\\tt.append(s[idx])\\n       \\t\\tidx += 1\\n       \\treturn \"\".join(p) + \"\".join(t[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678862,
                "title": "easy",
                "content": "```\\n string robotWithString(string s) {\\n        int n = s.size();\\n        string temp = s;\\n        vector<char> rightmin(n, \\'z\\');\\n        rightmin[n-1] = s[n-1];\\n        for(int i = n-2; i>=0; i--)\\n        {\\n            rightmin[i] = min(s[i], rightmin[i+1]);\\n        }\\n        \\n        string t = \"\", p = \"\";\\n        for(int i = 0; i<n; i++)\\n        {\\n            while(t.size() && t.back() <= s[i] && t.back() <= rightmin[i])\\n                {\\n                    p += t.back();\\n                    t.pop_back();\\n                }\\n                t += s[i];\\n        }\\n        while(t.size()){\\n            p += t.back();\\n            t.pop_back();\\n        }\\n        return p;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n string robotWithString(string s) {\\n        int n = s.size();\\n        string temp = s;\\n        vector<char> rightmin(n, \\'z\\');\\n        rightmin[n-1] = s[n-1];\\n        for(int i = n-2; i>=0; i--)\\n        {\\n            rightmin[i] = min(s[i], rightmin[i+1]);\\n        }\\n        \\n        string t = \"\", p = \"\";\\n        for(int i = 0; i<n; i++)\\n        {\\n            while(t.size() && t.back() <= s[i] && t.back() <= rightmin[i])\\n                {\\n                    p += t.back();\\n                    t.pop_back();\\n                }\\n                t += s[i];\\n        }\\n        while(t.size()){\\n            p += t.back();\\n            t.pop_back();\\n        }\\n        return p;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680206,
                "title": "cpp-simple-solution-multiset-and-stack",
                "content": "Initally we are inserting all the characters in multiset\\n and traversing from start till end, begining of multiset tells the smallest character in right side (that is yet to be traversed).\\n if smallest character in right half is greater or equal to current element then we are adding this in our and while traversing we are removing from multiset (logn) and adding character in stack.\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        multiset<char>mst;\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n            mst.insert(s[i]);\\n        }\\n        string ans;\\n         int i=0;\\n         while(i<s.size()){\\n                 while(st.size()&&*mst.begin()>=st.top()){\\n                     ans+=st.top();\\n                     st.pop();\\n                 }\\n             st.push(s[i]);\\n             mst.erase(mst.find(s[i]));\\n             i++;\\n         }\\n        \\n        while(st.size()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string robotWithString(string s) {\\n        multiset<char>mst;\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n            mst.insert(s[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2679754,
                "title": "python3-suffix-minimum",
                "content": "Loop through the string and at each index i, determine whether to take the second operation or not by comparing the last character of string t with the suffix min at index i+1 (the smallest character among all characters on the right side of index i).\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        ret, n = \"\", len(s)\\n        suffixMin = [None]*n\\n\\t\\t\\n\\t\\t# construct suffix minimum array\\n        for i in range(n-1, -1, -1):\\n            if i == n-1: suffixMin[i] = s[i]\\n            else: suffixMin[i] = min(s[i], suffixMin[i+1])\\n\\t\\t\\n        t = []\\n        for i in range(n):\\n\\t\\t\\t# append character at current index i to string t\\n            t.append(s[i])\\n\\t\\t\\t\\n\\t\\t\\t# check whether the last character of string t is not larger than the suffix min at index i+1,\\n\\t\\t\\t# if so, it means we cannot find a smaller character from the characters on the right side of current index i,\\n\\t\\t\\t# and we should print out the last character of string t\\n            while t and (i == n-1 or t[-1] <= suffixMin[i+1]): ret += t.pop()\\n        return ret\\n```\\nTime complexity:\\nn: len(s); O(n)\\n\\nSpace complexity:\\nn: len(s); O(n)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        ret, n = \"\", len(s)\\n        suffixMin = [None]*n\\n\\t\\t\\n\\t\\t# construct suffix minimum array\\n        for i in range(n-1, -1, -1):\\n            if i == n-1: suffixMin[i] = s[i]\\n            else: suffixMin[i] = min(s[i], suffixMin[i+1])\\n\\t\\t\\n        t = []\\n        for i in range(n):\\n\\t\\t\\t# append character at current index i to string t\\n            t.append(s[i])\\n\\t\\t\\t\\n\\t\\t\\t# check whether the last character of string t is not larger than the suffix min at index i+1,\\n\\t\\t\\t# if so, it means we cannot find a smaller character from the characters on the right side of current index i,\\n\\t\\t\\t# and we should print out the last character of string t\\n            while t and (i == n-1 or t[-1] <= suffixMin[i+1]): ret += t.pop()\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678983,
                "title": "a-greedy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) \\n    {\\n       map<char,int>mp;\\n        \\n       for(auto x:s)  // store frequency of each character\\n           mp[x]++;\\n        char c=\\'a\\'; \\n        \\n        while(!mp[c]&&c<=\\'z\\') // search for smallest element present in string  \\n            c++;\\n        string ans=\"\";\\n        string rem=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            auto x = s[i];\\n            if(x==c) // if x is smallest in right , write it on paper immediately\\n            {\\n                ans+=c;\\n            }\\n            else\\n                rem+=x; // otherwise just append it to string rem (which is string t in question)\\n            mp[x]--;\\n            \\n            while(!mp[c]&&c<=\\'z\\') // if frequency of smallest character in right becomes zero , look for next smallest element ahead\\n                c++;\\n            \\n            while(rem.length()>0&&c>=rem.back()) // if i can get element smaller than c from last of rem, pop it and write it on paper\\n                ans+=rem.back(),rem.pop_back();\\n        }\\n        \\n        reverse(rem.begin(),rem.end()); // Eventually , we have to write rem on paper by removing last char, so reverse it and append to answer\\n        \\n        ans+=rem;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) \\n    {\\n       map<char,int>mp;\\n        \\n       for(auto x:s)  // store frequency of each character\\n           mp[x]++;\\n        char c=\\'a\\'; \\n        \\n        while(!mp[c]&&c<=\\'z\\') // search for smallest element present in string  \\n            c++;\\n        string ans=\"\";\\n        string rem=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            auto x = s[i];\\n            if(x==c) // if x is smallest in right , write it on paper immediately\\n            {\\n                ans+=c;\\n            }\\n            else\\n                rem+=x; // otherwise just append it to string rem (which is string t in question)\\n            mp[x]--;\\n            \\n            while(!mp[c]&&c<=\\'z\\') // if frequency of smallest character in right becomes zero , look for next smallest element ahead\\n                c++;\\n            \\n            while(rem.length()>0&&c>=rem.back()) // if i can get element smaller than c from last of rem, pop it and write it on paper\\n                ans+=rem.back(),rem.pop_back();\\n        }\\n        \\n        reverse(rem.begin(),rem.end()); // Eventually , we have to write rem on paper by removing last char, so reverse it and append to answer\\n        \\n        ans+=rem;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678934,
                "title": "java-o-n-solution",
                "content": "```java\\n\\tpublic String robotWithString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Deque<Character> t = new ArrayDeque<>();\\n        char[] dp = new char[s.length()];\\n        int min = s.length() - 1;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) < s.charAt(min)) {\\n                min = i;\\n            }\\n            dp[i] = s.charAt(min);\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == dp[i]) {\\n                sb.append(c);\\n                while (!t.isEmpty() && i + 1 < s.length() && t.peekLast().compareTo(dp[i + 1]) <= 0) {\\n                    sb.append(t.pollLast());\\n                }\\n            } else {\\n                t.offerLast(c);\\n            }\\n        }\\n        while (!t.isEmpty()) {\\n            sb.append(t.pollLast());\\n        }\\n        return sb.toString();\\n    }\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n\\tpublic String robotWithString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Deque<Character> t = new ArrayDeque<>();\\n        char[] dp = new char[s.length()];\\n        int min = s.length() - 1;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) < s.charAt(min)) {\\n                min = i;\\n            }\\n            dp[i] = s.charAt(min);\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == dp[i]) {\\n                sb.append(c);\\n                while (!t.isEmpty() && i + 1 < s.length() && t.peekLast().compareTo(dp[i + 1]) <= 0) {\\n                    sb.append(t.pollLast());\\n                }\\n            } else {\\n                t.offerLast(c);\\n            }\\n        }\\n        while (!t.isEmpty()) {\\n            sb.append(t.pollLast());\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2688079,
                "title": "c-stack-solution-with-explanation",
                "content": "**Intuition:**\\nIn order to get the lexicographically smallest string, we can make following observations:\\n1. Letters inside `s` would only be processed once, and the order is from left to right. i.e., if we removed some letters in `s`, we cannot put it back into `s`.\\nTherefore, we would like to process `s` sequentially and decide what to do with the letters we met.\\n2. We first consider an input which contains some `a`, we would like to and we are able to get those `a` to form the prefix of our output.\\nE.g., `s = bacaadd` => `p = aaa####`\\nThis gives us a direction to think about, we can try to **iterate from the smallest alphabet to the largest alphabet, for each alphabet, we would like to get rest of letters of it inside `s`.**\\n3. When we try to get all of the current alphabet in `s`, we may put some letters other than current alphabet into `t`. When we deal with next alphabet, we would like to **check whether we can use letters in `t` to form a smaller output.** i.e. if the letter on top of `t` is smaller or equal to current alphabet.\\n\\n**Approach:**\\n```cpp\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        // get the last appearance, since we want to get all of current alphabet in `s`\\n        vector<int> lastAppear(26, -1);\\n        for (int i = 0; i < size(s); ++i)\\n            lastAppear[s[i] - \\'a\\'] = i;\\n        \\n\\t\\tstring res;\\n        string t; // a stack as question described\\n        int idx = 0; // index of current position in s\\n        for (char ch = \\'a\\'; ch <= \\'z\\'; ++ch) {\\n            // try to construct `res` by letter on top of `t` with smaller order\\n            while (size(t) && t.back() <= ch) {\\n                res += t.back();\\n                t.pop_back();\\n            }\\n            \\n            // try to construct `res` by letter the same as current alphabet\\n            while (idx < size(s) && idx <= lastAppear[ch - \\'a\\']) {\\n                if (s[idx] == ch) res += s[idx];\\n                else t += s[idx];\\n                \\n                idx++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Complexity:**\\n* Time complexity: O(N)\\nFor each letter, we either add it directly to the `res`, or add it to the `t` then add it to the `res` later.\\nIf we take the outer alphabet iteration into account, the time complexity becomes O(26 + N), still O(N).\\n* Space complexity: O(N)\\nSpace for the `res` and intermediate `t`.",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        // get the last appearance, since we want to get all of current alphabet in `s`\\n        vector<int> lastAppear(26, -1);\\n        for (int i = 0; i < size(s); ++i)\\n            lastAppear[s[i] - \\'a\\'] = i;\\n        \\n\\t\\tstring res;\\n        string t; // a stack as question described\\n        int idx = 0; // index of current position in s\\n        for (char ch = \\'a\\'; ch <= \\'z\\'; ++ch) {\\n            // try to construct `res` by letter on top of `t` with smaller order\\n            while (size(t) && t.back() <= ch) {\\n                res += t.back();\\n                t.pop_back();\\n            }\\n            \\n            // try to construct `res` by letter the same as current alphabet\\n            while (idx < size(s) && idx <= lastAppear[ch - \\'a\\']) {\\n                if (s[idx] == ch) res += s[idx];\\n                else t += s[idx];\\n                \\n                idx++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687026,
                "title": "c-using-stack-easy-solution",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    char smallestChar(vector<int> &freq)\\n    {\\n        for(int i=0; i<26; i++)\\n        {\\n            if(freq[i] != 0)\\n                return i + \\'a\\';\\n        }\\n        return \\'z\\';\\n    }\\n    \\n    string robotWithString(string s) {\\n        vector<int> freq(26,0);\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n        string ans = \"\";\\n        stack<char> st;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            st.push(s[i]);\\n            freq[s[i]-\\'a\\']--;\\n            \\n            while(st.size()>0 && st.top() <= smallestChar(freq))\\n            {\\n                char ch = st.top();\\n                ans += ch;\\n                st.pop();\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char smallestChar(vector<int> &freq)\\n    {\\n        for(int i=0; i<26; i++)\\n        {\\n            if(freq[i] != 0)\\n                return i + \\'a\\';\\n        }\\n        return \\'z\\';\\n    }\\n    \\n    string robotWithString(string s) {\\n        vector<int> freq(26,0);\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n        string ans = \"\";\\n        stack<char> st;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            st.push(s[i]);\\n            freq[s[i]-\\'a\\']--;\\n            \\n            while(st.size()>0 && st.top() <= smallestChar(freq))\\n            {\\n                char ch = st.top();\\n                ans += ch;\\n                st.pop();\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683099,
                "title": "java-dp-stack-real-o-n-beats-100",
                "content": "*no need to check smallest element left through the frequency array, we could use dynamic programming to save us some time.*\\n\\n**dp[i]**: the index of smallest element in [i, n)\\n\\n**code explaination**: the next element to write would either be the top element in the stack or one of the elements that hasn\\'t been pushed to stack.\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        dp[n-1] = n-1;\\n        for (int i = n-2; i >= 0; i--) {\\n\\t\\t\\tdp[i] = s.charAt(i)<=s.charAt(dp[i+1]) ? i : dp[i+1];\\n        }\\n        Deque<Character> stack = new ArrayDeque<>();\\n        int i = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<n){\\n            if(!stack.isEmpty()) sb.append(stack.pop());\\n            if(stack.isEmpty() || s.charAt(dp[i])<stack.peek()){\\n                int smallestIndex = dp[i];\\n                for (; i <= smallestIndex; i++) {\\n                    stack.push(s.charAt(i));\\n                }\\n            }\\n        }\\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        dp[n-1] = n-1;\\n        for (int i = n-2; i >= 0; i--) {\\n\\t\\t\\tdp[i] = s.charAt(i)<=s.charAt(dp[i+1]) ? i : dp[i+1];\\n        }\\n        Deque<Character> stack = new ArrayDeque<>();\\n        int i = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<n){\\n            if(!stack.isEmpty()) sb.append(stack.pop());\\n            if(stack.isEmpty() || s.charAt(dp[i])<stack.peek()){\\n                int smallestIndex = dp[i];\\n                for (; i <= smallestIndex; i++) {\\n                    stack.push(s.charAt(i));\\n                }\\n            }\\n        }\\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680177,
                "title": "easy-c-without-using-stack-easy-understand",
                "content": "In this problem we need to see these things.\\n1-> to make the lexigrapically shortest string we need to take the first smallest char of string s.\\n2-> all char coming before the  smallest char index will be in our robot\\n3-> Now to chose the next  char which will come in our ans string we will see is there any smaller char persent in our string s which can come first . Because now we have only two option take the last char in robot string or take the smaller char than the last elemnt of robot string.\\n4->We will create a suffix array which will tell the smallest  char in string s from last.\\n\\nother things explained  in code below.\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s)\\n    {\\n      string t=\"\";  // robot string\\n      string ans=\"\";   // answer string\\n      int n=s.size();\\n      vector<char>mn(n);  // creating the suffix array\\n      mn[n-1]=s[n-1];\\n      for(int i=n-2;i>=0;i--)\\n      {\\n        if(s[i]<mn[i+1])\\n          mn[i]=s[i];\\n        else\\n          mn[i]=mn[i+1];\\n      }\\n      for(int i=0;i<n;i++)\\n      {\\n      //  cout<<t<<\" \"<<ans<<endl;\\n        if(t.length()==0  || t.back()>mn[i]) // if our t is empty or last elemnt of t is larger then minimu char in s we will add it to robot string because they are of no use we need the smallest from front of robot string or string s.\\n          t+=s[i];\\n        else\\n        {\\n          while(t.size()>0 && t.back()<=mn[i]) //until our smallest no. is in our robot string we will add it to ans\\n          {\\n            ans+=t.back();\\n            t.pop_back();\\n          }\\n          t+=s[i]; \\n        }\\n      }\\n      while(t.size()>0 )\\n          {\\n            ans+=t.back();\\n            t.pop_back();\\n          }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s)\\n    {\\n      string t=\"\";  // robot string\\n      string ans=\"\";   // answer string\\n      int n=s.size();\\n      vector<char>mn(n);  // creating the suffix array\\n      mn[n-1]=s[n-1];\\n      for(int i=n-2;i>=0;i--)\\n      {\\n        if(s[i]<mn[i+1])\\n          mn[i]=s[i];\\n        else\\n          mn[i]=mn[i+1];\\n      }\\n      for(int i=0;i<n;i++)\\n      {\\n      //  cout<<t<<\" \"<<ans<<endl;\\n        if(t.length()==0  || t.back()>mn[i]) // if our t is empty or last elemnt of t is larger then minimu char in s we will add it to robot string because they are of no use we need the smallest from front of robot string or string s.\\n          t+=s[i];\\n        else\\n        {\\n          while(t.size()>0 && t.back()<=mn[i]) //until our smallest no. is in our robot string we will add it to ans\\n          {\\n            ans+=t.back();\\n            t.pop_back();\\n          }\\n          t+=s[i]; \\n        }\\n      }\\n      while(t.size()>0 )\\n          {\\n            ans+=t.back();\\n            t.pop_back();\\n          }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2679987,
                "title": "stack",
                "content": "TC:O(n)\\nSC:O(n)+O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n=s.size();\\n        \\n        vector<int>freq(26,0);\\n        for(int i=0;i<n;i++)  freq[s[i]-\\'a\\']++;\\n        \\n        // stack for robot to hold the t string as in first operation of problem\\n        stack<char>st;\\n        // store the pattern written by robot\\n        string ans=\"\";\\n        \\n        for(int i=0;i<n;i++){\\n            // give char to array\\n            st.push(s[i]);\\n            // reduce curr char frequency\\n            freq[s[i]-\\'a\\']--;\\n            // get the min freq element in vector\\n            char _min=getMin(freq);\\n            // write all elements which are lexicographically smaller than _min\\n            while(!st.empty()&&st.top()<=_min){\\n                ans+=st.top();\\n                st.pop();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    char getMin(vector<int>&freq){\\n        for(int i=0;i<26;i++){\\n            if(freq[i]){\\n                return (i+\\'a\\');\\n            }\\n        } \\n        return \\'z\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n=s.size();\\n        \\n        vector<int>freq(26,0);\\n        for(int i=0;i<n;i++)  freq[s[i]-\\'a\\']++;\\n        \\n        // stack for robot to hold the t string as in first operation of problem\\n        stack<char>st;\\n        // store the pattern written by robot\\n        string ans=\"\";\\n        \\n        for(int i=0;i<n;i++){\\n            // give char to array\\n            st.push(s[i]);\\n            // reduce curr char frequency\\n            freq[s[i]-\\'a\\']--;\\n            // get the min freq element in vector\\n            char _min=getMin(freq);\\n            // write all elements which are lexicographically smaller than _min\\n            while(!st.empty()&&st.top()<=_min){\\n                ans+=st.top();\\n                st.pop();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    char getMin(vector<int>&freq){\\n        for(int i=0;i<26;i++){\\n            if(freq[i]){\\n                return (i+\\'a\\');\\n            }\\n        } \\n        return \\'z\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679777,
                "title": "smallest-ordinal-character-to-the-right",
                "content": "Create a `min_right` array that tells you the minimum character (using ordinality) available to right of the current character in array `s`. \\n\\nExample: If `s` = `\"vzhofnpo\"`, `min_right` will be: ```[\"f\", \"f\", \"f\", \"f\", \"n\", \"o\", \"o\", \"z\"]```. (here `z` is just a default value)\\n\\nThen add characters to the `stack` from `s` until the current character is smaller or equal to the minimum character to its right (we use `min_right` to check).\\n\\n```\\ndef robotWithString(self, s: str) -> str:\\n        min_right = [\\'z\\']*len(s)\\n        min_character = \\'z\\'\\n        for idx in range(len(s)-1, -1, -1):\\n            min_right[idx] = min_character\\n            min_character = min(min_character, s[idx])\\n        \\n        res = []\\n        stack = []\\n        for idx, c in enumerate(s):\\n            stack.append(c)\\n            while stack and ord(stack[-1]) <= ord(min_right[idx]):\\n                res.append(stack.pop())\\n            \\n        return \"\".join(res)\\n```\\n\\n`Time Complexity - O(n)`\\n`Space Complexity - O(n)`\\n\\nWhere `n` is the number of characters in `s`.",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```[\"f\", \"f\", \"f\", \"f\", \"n\", \"o\", \"o\", \"z\"]```\n```\\ndef robotWithString(self, s: str) -> str:\\n        min_right = [\\'z\\']*len(s)\\n        min_character = \\'z\\'\\n        for idx in range(len(s)-1, -1, -1):\\n            min_right[idx] = min_character\\n            min_character = min(min_character, s[idx])\\n        \\n        res = []\\n        stack = []\\n        for idx, c in enumerate(s):\\n            stack.append(c)\\n            while stack and ord(stack[-1]) <= ord(min_right[idx]):\\n                res.append(stack.pop())\\n            \\n        return \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2679458,
                "title": "c-stack-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ -> `n` is the length of string `s`.\\n\\n- Space complexity:\\n$$O(n)$$ -> `n` is the length of string `s`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static string robotWithString(const string& s) {\\n        const int n = size(s);\\n        stack <char> st;\\n        string ret, minimum = s;\\n        for (int i = n - 2; i >= 0; --i)\\n            minimum[i] = min(minimum[i + 1], s[i]);\\n        for (int i = 0; i < n; ++i) {\\n            while (!st.empty() && st.top() <= minimum[i]) {\\n                ret.push_back(st.top());\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n        }\\n        while (!st.empty()) {\\n            ret.push_back(st.top());\\n            st.pop();\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static string robotWithString(const string& s) {\\n        const int n = size(s);\\n        stack <char> st;\\n        string ret, minimum = s;\\n        for (int i = n - 2; i >= 0; --i)\\n            minimum[i] = min(minimum[i + 1], s[i]);\\n        for (int i = 0; i < n; ++i) {\\n            while (!st.empty() && st.top() <= minimum[i]) {\\n                ret.push_back(st.top());\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n        }\\n        while (!st.empty()) {\\n            ret.push_back(st.top());\\n            st.pop();\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679302,
                "title": "stack-and-priority-queue-intuition-java",
                "content": "**Intuition:**\\nSince we need smallest string we need to have smaller character first. Hence used queue to get smallest one. But if we choose smallest ,then the characters below that index can only be used in reverse manner. Hence dumped all the characters in stack . Now whenever i choose smallest from queue i compare it with stack top. Since we have 2 options take from stack top or from queue\\'s smallest.I keep a pointer i,since once we choose smallest the chars below that index still be in queue. hence if i get a index from queue which is smaller than my pointer, i pop it.\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        char[] a=s.toCharArray();\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((x,y)->{\\n            if(a[x]==a[y])\\n                return x-y;\\n            return a[x]-a[y];\\n        });\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<a.length;i++){\\n            pq.add(i);\\n        }\\n        int i=-1;\\n        while(!pq.isEmpty()){\\n            while(!pq.isEmpty() && pq.peek()<i){\\n                pq.remove();  \\n            }\\n            \\n            if(!pq.isEmpty()){\\n                int j=pq.remove();\\n                if(!st.isEmpty()){\\n                    while(!st.isEmpty() && st.peek()<=a[j]){\\n                        sb.append(st.pop());\\n                    }\\n                }\\n                for(int k=i+1;k<=j;k++)\\n                    st.add(a[k]);\\n                i=j;\\n            }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        char[] a=s.toCharArray();\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((x,y)->{\\n            if(a[x]==a[y])\\n                return x-y;\\n            return a[x]-a[y];\\n        });\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<a.length;i++){\\n            pq.add(i);\\n        }\\n        int i=-1;\\n        while(!pq.isEmpty()){\\n            while(!pq.isEmpty() && pq.peek()<i){\\n                pq.remove();  \\n            }\\n            \\n            if(!pq.isEmpty()){\\n                int j=pq.remove();\\n                if(!st.isEmpty()){\\n                    while(!st.isEmpty() && st.peek()<=a[j]){\\n                        sb.append(st.pop());\\n                    }\\n                }\\n                for(int k=i+1;k<=j;k++)\\n                    st.add(a[k]);\\n                i=j;\\n            }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679278,
                "title": "java-stack-logic-dp-with-explaination",
                "content": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        Character[] ch = new Character[s.length()];\\n        int n = s.length();\\n        ch[n-1] = s.charAt(n-1);\\n        //pre calculating min element will occur at index i from right side\\n        for(int i = n-2; i >= 0; i--){\\n            ch[i] = (s.charAt(i) > ch[i+1]) ? ch[i+1] : s.charAt(i);\\n            \\n        }\\n\\t\\t\\n        int i = 0;\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t//referring t from question to stack.\\n        Stack<Character> st = new Stack();\\n        while(i < n){\\n            char c = s.charAt(i);\\n            //we will just add  minimum character from t(stack) in our ans \\n\\t\\t\\t//when our precalculated min element is bigger then at index i \\n            while(!st.isEmpty() && st.peek() <= ch[i]){\\n                sb.append(st.pop());\\n            }\\n            st.push(c);\\n            i++;\\n        }\\n\\t\\t//checking whether stack (t) contains element and then just doing operation no . 2 from que\\n        while(!st.isEmpty()){\\n         sb.append(st.pop());   \\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        Character[] ch = new Character[s.length()];\\n        int n = s.length();\\n        ch[n-1] = s.charAt(n-1);\\n        //pre calculating min element will occur at index i from right side\\n        for(int i = n-2; i >= 0; i--){\\n            ch[i] = (s.charAt(i) > ch[i+1]) ? ch[i+1] : s.charAt(i);\\n            \\n        }\\n\\t\\t\\n        int i = 0;\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t//referring t from question to stack.\\n        Stack<Character> st = new Stack();\\n        while(i < n){\\n            char c = s.charAt(i);\\n            //we will just add  minimum character from t(stack) in our ans \\n\\t\\t\\t//when our precalculated min element is bigger then at index i \\n            while(!st.isEmpty() && st.peek() <= ch[i]){\\n                sb.append(st.pop());\\n            }\\n            st.push(c);\\n            i++;\\n        }\\n\\t\\t//checking whether stack (t) contains element and then just doing operation no . 2 from que\\n        while(!st.isEmpty()){\\n         sb.append(st.pop());   \\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679211,
                "title": "o-n-with-two-linkedlist-solution",
                "content": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        LinkedList<Character> sList = new LinkedList();\\n        LinkedList<Character> tList = new LinkedList();\\n        \\n        int[] cnt = new int[26];\\n        \\n        for(char c : s.toCharArray()){\\n            cnt[c - \\'a\\']++;\\n            sList.add(c);\\n        }\\n        int i = 0;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(sList.size() > 0){\\n            while(cnt[i] == 0) i++;\\n            if(tList.size() == 0){\\n                char cur = sList.pollFirst();\\n                cnt[cur - \\'a\\']--;\\n                tList.addFirst(cur);\\n            }\\n            else{\\n                if((char)(i + \\'a\\') < tList.peekFirst()){\\n                    char cur = sList.pollFirst();\\n                    cnt[cur - \\'a\\']--;\\n                    tList.addFirst(cur);\\n                }\\n                else{\\n                    char cur = tList.pollFirst();\\n                    sb.append(cur);\\n                }\\n            }\\n        }\\n        \\n        while(tList.size() > 0){\\n            sb.append(tList.pollFirst());\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        LinkedList<Character> sList = new LinkedList();\\n        LinkedList<Character> tList = new LinkedList();\\n        \\n        int[] cnt = new int[26];\\n        \\n        for(char c : s.toCharArray()){\\n            cnt[c - \\'a\\']++;\\n            sList.add(c);\\n        }\\n        int i = 0;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(sList.size() > 0){\\n            while(cnt[i] == 0) i++;\\n            if(tList.size() == 0){\\n                char cur = sList.pollFirst();\\n                cnt[cur - \\'a\\']--;\\n                tList.addFirst(cur);\\n            }\\n            else{\\n                if((char)(i + \\'a\\') < tList.peekFirst()){\\n                    char cur = sList.pollFirst();\\n                    cnt[cur - \\'a\\']--;\\n                    tList.addFirst(cur);\\n                }\\n                else{\\n                    char cur = tList.pollFirst();\\n                    sb.append(cur);\\n                }\\n            }\\n        }\\n        \\n        while(tList.size() > 0){\\n            sb.append(tList.pollFirst());\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679049,
                "title": "java-simple-count-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int[] cnt = new int[\\'z\\' + 1];\\n        char[] arr = s.toCharArray();\\n        \\n        for(char ch : arr) {\\n            cnt[ch]++;    \\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Deque<Character> dq = new ArrayDeque<>();\\n        \\n        for(char ch : arr) {\\n            dq.offer(ch);\\n            cnt[dq.peekLast()]--;\\n            \\n            boolean flag = true;\\n            \\n            while(flag && !dq.isEmpty()) {\\n                char top = dq.peekLast();\\n                for(int cur=\\'a\\'; cur<top; cur++) {\\n                    if(cnt[cur] > 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) {\\n                    sb.append(top);\\n                    dq.pollLast();\\n                }\\n            }\\n        }\\n        \\n        while(!dq.isEmpty()) {\\n            sb.append(dq.pollLast());\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int[] cnt = new int[\\'z\\' + 1];\\n        char[] arr = s.toCharArray();\\n        \\n        for(char ch : arr) {\\n            cnt[ch]++;    \\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Deque<Character> dq = new ArrayDeque<>();\\n        \\n        for(char ch : arr) {\\n            dq.offer(ch);\\n            cnt[dq.peekLast()]--;\\n            \\n            boolean flag = true;\\n            \\n            while(flag && !dq.isEmpty()) {\\n                char top = dq.peekLast();\\n                for(int cur=\\'a\\'; cur<top; cur++) {\\n                    if(cnt[cur] > 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) {\\n                    sb.append(top);\\n                    dq.pollLast();\\n                }\\n            }\\n        }\\n        \\n        while(!dq.isEmpty()) {\\n            sb.append(dq.pollLast());\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679041,
                "title": "java-two-pointers-preprocess-with-rightmin-array",
                "content": "### Idea\\n+ Preprocess to get right smallest char index array\\n+ Iterate : For each pos `curr` : One pointer is at `t[-1]` (in my code is `left`), another is at `rightMin[curr]`. Compare two chars.\\n\\t+ If `t[-1]` wins, append it\\n\\t+ else, append `s[rightMin[curr]]` and append `s[curr, rightMin[curr]]` into `t`\\n\\n### Code\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        char[] arr = s.toCharArray();\\n        int[] rightMin = new int[arr.length]; // index \\n        int n = arr.length;\\n        rightMin[n - 1] = n - 1;\\n        \\n        for (int i = n - 2; i >= 0; i--){\\n            char curr = arr[i];\\n\\n            if(curr > arr[rightMin[i + 1]]) {\\n                rightMin[i] = rightMin[i + 1];\\n            } else {\\n                rightMin[i] = i;\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\n        int start = 0;\\n        StringBuilder left = new StringBuilder();\\n        while (start < n) {\\n            int end = rightMin[start];\\n            if(left.length() != 0 && left.charAt(left.length() - 1) <= arr[end]) {\\n                sb.append(left.charAt(left.length() - 1));\\n                left.deleteCharAt(left.length() - 1);\\n            } else {\\n                sb.append(arr[end]);\\n                left.append(s.substring(start, end));\\n                start = end + 1;\\n            }\\n        }\\n        \\n        sb.append(left.reverse());\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        char[] arr = s.toCharArray();\\n        int[] rightMin = new int[arr.length]; // index \\n        int n = arr.length;\\n        rightMin[n - 1] = n - 1;\\n        \\n        for (int i = n - 2; i >= 0; i--){\\n            char curr = arr[i];\\n\\n            if(curr > arr[rightMin[i + 1]]) {\\n                rightMin[i] = rightMin[i + 1];\\n            } else {\\n                rightMin[i] = i;\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\n        int start = 0;\\n        StringBuilder left = new StringBuilder();\\n        while (start < n) {\\n            int end = rightMin[start];\\n            if(left.length() != 0 && left.charAt(left.length() - 1) <= arr[end]) {\\n                sb.append(left.charAt(left.length() - 1));\\n                left.deleteCharAt(left.length() - 1);\\n            } else {\\n                sb.append(arr[end]);\\n                left.append(s.substring(start, end));\\n                start = end + 1;\\n            }\\n        }\\n        \\n        sb.append(left.reverse());\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678855,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        string mins=s;\\n        mins[s.length()-1]=s[s.length()-1];\\n        for(int i=s.length()-2;i>=0;i--){\\n            char c;\\n            if(mins[i+1]<s[i])c=mins[i+1];\\n            else c=s[i];\\n            mins[i]=c;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=mins[i]){\\n                while(!st.empty() and st.top()<=mins[i]){\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.push(s[i]);\\n            }else{\\n               while(!st.empty() and st.top()<=s[i]){\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n                ans.push_back(s[i]);\\n            }\\n        }\\n         while(!st.empty()){\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        string mins=s;\\n        mins[s.length()-1]=s[s.length()-1];\\n        for(int i=s.length()-2;i>=0;i--){\\n            char c;\\n            if(mins[i+1]<s[i])c=mins[i+1];\\n            else c=s[i];\\n            mins[i]=c;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=mins[i]){\\n                while(!st.empty() and st.top()<=mins[i]){\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.push(s[i]);\\n            }else{\\n               while(!st.empty() and st.top()<=s[i]){\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n                ans.push_back(s[i]);\\n            }\\n        }\\n         while(!st.empty()){\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678837,
                "title": "c-assign-priority-then-use-stack-greedy-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        \\n        //Assign priority\\n        \\n        vector<int> p(n),mp(n);\\n        \\n        map<char,vector<int>> um;\\n        \\n        for(int i=0;i<n;i++){\\n            um[s[i]].push_back(i);\\n        }\\n        \\n        int cnt = 1;\\n        \\n        for(auto &x : um){\\n            char ch = x.first;\\n            for(auto y : x.second){\\n                p[y] = cnt++;\\n            }\\n        }\\n        \\n        mp[n-1] = p[n-1];\\n        \\n        for(int i=n-2;i>=0;i--){\\n            mp[i] = min(p[i],mp[i+1]);\\n        }\\n        \\n        \\n        \\n        stack<int> st;\\n        \\n        unordered_set<int> us;\\n        string ans;\\n        \\n        // for(int i=0;i<n;i++){\\n        //     cout << p[i] << \" \";\\n        // }\\n        // cout << endl;\\n        \\n        for(int i=0;i<n;i++){\\n            if(us.find(p[i]-1) != us.end() || p[i] == 1){\\n                us.insert(p[i]);\\n                ans.push_back(s[i]);\\n                // int cur = i;\\n                while(!st.empty()){\\n                    if(p[st.top()] == p[i]+1){\\n                        ans.push_back(s[st.top()]);\\n                        st.pop();\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }else{\\n                // cout << i << \" \" << st.size() << endl;\\n    \\n                while(!st.empty()){\\n                    if(p[st.top()] < mp[i]){\\n                        ans.push_back(s[st.top()]);\\n                        st.pop();\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                \\n                st.push(i);\\n            }\\n        }\\n        \\n        \\n        while(!st.empty()){\\n            ans.push_back(s[st.top()]);\\n            st.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Greedy",
                    "Simulation"
                ],
                "code": "class Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        \\n        //Assign priority\\n        \\n        vector<int> p(n),mp(n);\\n        \\n        map<char,vector<int>> um;\\n        \\n        for(int i=0;i<n;i++){\\n            um[s[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2678818,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic String robotWithString(String s) {\\n\\t\\t\\tint startingIndex = 0;\\n\\t\\t\\tStack<Character> stack = new Stack<>();\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\t\\tchar curr = (char)(\\'a\\'+i);\\n\\t\\t\\t\\twhile(stack.size()>0 && stack.peek()<=curr){\\n\\t\\t\\t\\t\\tsb.append(stack.pop());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int j=startingIndex;j<s.length();j++){\\n\\t\\t\\t\\t\\tif(s.charAt(j)==curr){\\n\\t\\t\\t\\t\\t\\tfor(int k=startingIndex;k<=j;k++){\\n\\t\\t\\t\\t\\t\\t\\tstack.add(s.charAt(k));\\n\\t\\t\\t\\t\\t\\t}                   \\n\\t\\t\\t\\t\\t\\tsb.append(stack.pop());\\n\\t\\t\\t\\t\\t\\tstartingIndex = j+1;;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sb.toString();\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic String robotWithString(String s) {\\n\\t\\t\\tint startingIndex = 0;\\n\\t\\t\\tStack<Character> stack = new Stack<>();\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\t\\tchar curr = (char)(\\'a\\'+i);\\n\\t\\t\\t\\twhile(stack.size()>0 && stack.peek()<=curr){\\n\\t\\t\\t\\t\\tsb.append(stack.pop());\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3384474,
                "title": "python-answer-that-beats-95-of-the-submitted-answers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBased on the description of the problem we know the robot is basically using a stack, where it can only, either push characters to it, or pop characters from it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe most important thing in the problem is first find the smallest characters in the string. To accomplish this we can use an increasing monotonic queue. We know the left most character in the queue is our smallest character, so it has to be the first character in our answer. To get to that character we need to push the characters before it to a stack. After adding our first character to our answer, we then check the stack to see if the top character is smaller than the next character in the monotonic queue, if it is, we can pop it from the stack and include it in our answer, if it is not then we continue iterating through the string and repeat the process.\\n\\nOnce we have added to our answer all the values that we had in our monotonic queue, we just need to pop everything that is left in the stack and add it to our answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n\\n        stack = []\\n        increasing = deque()\\n        ans = []\\n\\n        # use a monotonic queue to find the smallest characters in\\n        # the string s (ignoring those characters that come before\\n        # the smallest character), since we are going to be adding\\n        # and removin elements from the right side of the queue, as\\n        # well as removing elements from the left side of the queue\\n        # we need to use a double ended queue (deque) to do this\\n        # efficiently\\n        for letter in s:\\n          while increasing and increasing[-1] > letter:\\n            increasing.pop()\\n          increasing.append(letter)\\n\\n        # we know the left most character in the monotonic deque has to be\\n        # the first character in our answer, since is the smallest one,\\n        # however the second character in the deque is not necesarilly the\\n        # next smallest character in the whole string s, it is the only the\\n        # next smallest character in the string after our very smallest\\n        # character, but there might be other characters in between already\\n        # in the stack, so we need to pop them from our stack if they are there\\n        for letter in s:\\n          if increasing and letter == increasing[0]:\\n            increasing.popleft()\\n            ans.append(letter)\\n            while stack and increasing and stack[-1] <= increasing[0]:\\n              ans.append(stack.pop())\\n          else:\\n            stack.append(letter)\\n        \\n        # at this point we just need to pop all remaining elements from the\\n        # stack and add them to our answer\\n        while stack:\\n          ans.append(stack.pop())\\n\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n\\n        stack = []\\n        increasing = deque()\\n        ans = []\\n\\n        # use a monotonic queue to find the smallest characters in\\n        # the string s (ignoring those characters that come before\\n        # the smallest character), since we are going to be adding\\n        # and removin elements from the right side of the queue, as\\n        # well as removing elements from the left side of the queue\\n        # we need to use a double ended queue (deque) to do this\\n        # efficiently\\n        for letter in s:\\n          while increasing and increasing[-1] > letter:\\n            increasing.pop()\\n          increasing.append(letter)\\n\\n        # we know the left most character in the monotonic deque has to be\\n        # the first character in our answer, since is the smallest one,\\n        # however the second character in the deque is not necesarilly the\\n        # next smallest character in the whole string s, it is the only the\\n        # next smallest character in the string after our very smallest\\n        # character, but there might be other characters in between already\\n        # in the stack, so we need to pop them from our stack if they are there\\n        for letter in s:\\n          if increasing and letter == increasing[0]:\\n            increasing.popleft()\\n            ans.append(letter)\\n            while stack and increasing and stack[-1] <= increasing[0]:\\n              ans.append(stack.pop())\\n          else:\\n            stack.append(letter)\\n        \\n        # at this point we just need to pop all remaining elements from the\\n        # stack and add them to our answer\\n        while stack:\\n          ans.append(stack.pop())\\n\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284194,
                "title": "smallest-character-should-be-in-front-anduse-push-back-and-pop-back-functions-to-avoid-tle",
                "content": "# Intuition\\nBasically the smallest character of the string should always be in front and for that upto that index lets say id, we are supposed to add every character before it in string t and then now again greedily we should use characters of string t upto the point , till they are less than the smallest character of the string after id that is substring (s-(id+1,s.size()-1)).\\n\\n# Approach\\npost array basically stores the index of the minimum character from that index , so post[index] stores the index of the minimum character of the suffix from index to end of original string and now as long as the end character of t is less than minimum character of that suffix and thereafter we add all characters till post[index] in string t.\\nusing push_back and pop_back() instead of append or erase functions to avoid tle. we should deque when erasing or adding in front of the string is required.\\n# Complexity\\n- Time complexity:\\nn (every character is removed and added twice)\\n\\n- Space complexity:\\nn\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        \\n        int n=s.size();\\n        string ans;\\n         vector<int> post(n);\\n         int i;\\n         post[n-1]=n-1;\\n         int c=n-1;\\n         for(i=n-2;i>=0;i--){\\n             \\n             if(s[i]<=s[c]){\\n                 c=i;\\n             }\\n             post[i]=c;\\n           \\n         }\\n\\n         int curr=0;\\n            string t;\\n\\n            while(curr<n){\\n            \\n             int c=post[curr];\\n             while(t.size()>0&&t[t.size()-1]<=s[c]){\\n                ans.push_back(t[t.size()-1]);\\n                t.pop_back();\\n\\n             }\\n             for(int i=curr;i<=c;i++){\\n                 t.push_back(s[i]);\\n             }\\n             if(c==n-1){\\n                 break;\\n             }\\n             curr=c+1;\\n\\n            }\\n            for(int i=t.size()-1;i>=0;i--){\\n               ans.push_back(t[i]);\\n            }\\n\\n         return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        \\n        int n=s.size();\\n        string ans;\\n         vector<int> post(n);\\n         int i;\\n         post[n-1]=n-1;\\n         int c=n-1;\\n         for(i=n-2;i>=0;i--){\\n             \\n             if(s[i]<=s[c]){\\n                 c=i;\\n             }\\n             post[i]=c;\\n           \\n         }\\n\\n         int curr=0;\\n            string t;\\n\\n            while(curr<n){\\n            \\n             int c=post[curr];\\n             while(t.size()>0&&t[t.size()-1]<=s[c]){\\n                ans.push_back(t[t.size()-1]);\\n                t.pop_back();\\n\\n             }\\n             for(int i=curr;i<=c;i++){\\n                 t.push_back(s[i]);\\n             }\\n             if(c==n-1){\\n                 break;\\n             }\\n             curr=c+1;\\n\\n            }\\n            for(int i=t.size()-1;i>=0;i--){\\n               ans.push_back(t[i]);\\n            }\\n\\n         return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692045,
                "title": "rust-2-ms-fastest-100-overoptimized-solution-bonus-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/820395021/) employs a variety of optimizations to improve performance. It demonstrated **2 ms runtime (100.00%)** and used **2.4 MB memory (83.33%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(N)**. Detailed comments are provided.\\n\\nPlease check the analogous solution in [**Python**](https://leetcode.com/problems/using-a-robot-to-print-the-lexicographically-smallest-string/discuss/2687735/Python-463-ms-fastest-(100)-solution-using-stack-(with-detailed-comments)).\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn robot_with_string(s: String) -> String \\n    {\\n        let mut paper: Vec<u8> = Vec::with_capacity(s.len());\\n        let mut stack: Vec<u8> = Vec::with_capacity(s.len());\\n        let mut bytes = s.as_bytes();\\n        \\n        // [1] determine the position of last occurence for each letter;\\n        //     for absent letters, the value is usize::MAX\\n        let mut last_pos: [usize;26] = [usize::MAX;26];\\n        let mut letters: u32 = 0b00000000_00000000_00000000_00000000;\\n        for (pos, ch) in s.bytes().enumerate().rev()\\n        {\\n            let ch = (ch - b\\'a\\') as usize;\\n            if last_pos[ch] == usize::MAX \\n            {\\n                last_pos[ch] = pos;\\n                letters |= (1<<ch);\\n            }\\n            if letters == 0b00000011_11111111_11111111_11111111 { break; }\\n        }\\n\\n        // [2] to obtain the lexicographically smallest string,\\n        //     we always have to print the smallest possible letter;\\n        //     thus, we first try to print all instances of each\\n        //     unique letter (see [4]) in the alphabetic order\\n        let mut lp: usize = 0;\\n        for (ch, &pos) in last_pos.iter().enumerate().filter(|&(_, pos)| *pos < usize::MAX)\\n        {\\n            let ch  = ch as u8 + b\\'a\\';\\n            \\n            // [3] if on some iteration there are letters on top\\n            //     of the stack that are smaller than the currently\\n            //     considered letter, move them to the paper\\n            while !stack.is_empty() && stack[stack.len()-1] <= ch\\n            {\\n                paper.push(stack.pop().unwrap());\\n            }\\n\\n            // [4] main block where we move all instances of each \\n            //     unique letter to the paper and push all encountered \\n            //     characters (before the last instance) to the stack\\n            if lp <= pos\\n            {\\n                bytes[lp..=pos as usize]\\n                    .iter()\\n                    .for_each(|&c| if c == ch { paper.push(c); } else { stack.push(c); });\\n                lp = pos + 1;\\n            }\\n        }\\n        \\n        return String::from_utf8(paper).unwrap();\\n    }\\n}\\n```\\nAs a bonus, I provide another (somewhat slower) [**solution**](https://leetcode.com/submissions/detail/820207916/) with **3 ms runtime** that follows a different logic.\\n```\\nimpl Solution \\n{\\n    pub fn robot_with_string(s: String) -> String \\n    {\\n        let mut paper = String::with_capacity(s.len());\\n        let mut stack = Vec::<char>::with_capacity(s.len());\\n        \\n        // [1] in this solution, we keep track of remaining letters;\\n        //     first, we obtain counts of all letters in the string\\n        let mut count: [u32;26] = [0;26];\\n        s.bytes().for_each(|b| count[(b - b\\'a\\') as usize] += 1);\\n\\n        // [2] second, we iterate over all characters and wait for the\\n        //     last occurence of each letter (in the alphabetic orer)\\n        let mut idx: usize = 0;\\n        for c in s.chars()\\n        {\\n            stack.push(c);\\n            count[(c as u8 - b\\'a\\') as usize] -= 1;\\n\\n            // [3] update currently considered letter (i.e., \\'idx\\' from 0 to 25)\\n            while idx < 26 && count[idx] == 0 { idx += 1; }\\n            \\n            // [4] print to paper all letters that are not greater than \\n            //     the currently considered \\'idx\\'\\n            while stack.is_empty() == false && ((stack[stack.len()-1] as u8) - b\\'a\\') as usize <= idx\\n            {\\n                paper.push(stack.pop().unwrap());\\n            }\\n        }\\n        \\n        return paper;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn robot_with_string(s: String) -> String \\n    {\\n        let mut paper: Vec<u8> = Vec::with_capacity(s.len());\\n        let mut stack: Vec<u8> = Vec::with_capacity(s.len());\\n        let mut bytes = s.as_bytes();\\n        \\n        // [1] determine the position of last occurence for each letter;\\n        //     for absent letters, the value is usize::MAX\\n        let mut last_pos: [usize;26] = [usize::MAX;26];\\n        let mut letters: u32 = 0b00000000_00000000_00000000_00000000;\\n        for (pos, ch) in s.bytes().enumerate().rev()\\n        {\\n            let ch = (ch - b\\'a\\') as usize;\\n            if last_pos[ch] == usize::MAX \\n            {\\n                last_pos[ch] = pos;\\n                letters |= (1<<ch);\\n            }\\n            if letters == 0b00000011_11111111_11111111_11111111 { break; }\\n        }\\n\\n        // [2] to obtain the lexicographically smallest string,\\n        //     we always have to print the smallest possible letter;\\n        //     thus, we first try to print all instances of each\\n        //     unique letter (see [4]) in the alphabetic order\\n        let mut lp: usize = 0;\\n        for (ch, &pos) in last_pos.iter().enumerate().filter(|&(_, pos)| *pos < usize::MAX)\\n        {\\n            let ch  = ch as u8 + b\\'a\\';\\n            \\n            // [3] if on some iteration there are letters on top\\n            //     of the stack that are smaller than the currently\\n            //     considered letter, move them to the paper\\n            while !stack.is_empty() && stack[stack.len()-1] <= ch\\n            {\\n                paper.push(stack.pop().unwrap());\\n            }\\n\\n            // [4] main block where we move all instances of each \\n            //     unique letter to the paper and push all encountered \\n            //     characters (before the last instance) to the stack\\n            if lp <= pos\\n            {\\n                bytes[lp..=pos as usize]\\n                    .iter()\\n                    .for_each(|&c| if c == ch { paper.push(c); } else { stack.push(c); });\\n                lp = pos + 1;\\n            }\\n        }\\n        \\n        return String::from_utf8(paper).unwrap();\\n    }\\n}\\n```\n```\\nimpl Solution \\n{\\n    pub fn robot_with_string(s: String) -> String \\n    {\\n        let mut paper = String::with_capacity(s.len());\\n        let mut stack = Vec::<char>::with_capacity(s.len());\\n        \\n        // [1] in this solution, we keep track of remaining letters;\\n        //     first, we obtain counts of all letters in the string\\n        let mut count: [u32;26] = [0;26];\\n        s.bytes().for_each(|b| count[(b - b\\'a\\') as usize] += 1);\\n\\n        // [2] second, we iterate over all characters and wait for the\\n        //     last occurence of each letter (in the alphabetic orer)\\n        let mut idx: usize = 0;\\n        for c in s.chars()\\n        {\\n            stack.push(c);\\n            count[(c as u8 - b\\'a\\') as usize] -= 1;\\n\\n            // [3] update currently considered letter (i.e., \\'idx\\' from 0 to 25)\\n            while idx < 26 && count[idx] == 0 { idx += 1; }\\n            \\n            // [4] print to paper all letters that are not greater than \\n            //     the currently considered \\'idx\\'\\n            while stack.is_empty() == false && ((stack[stack.len()-1] as u8) - b\\'a\\') as usize <= idx\\n            {\\n                paper.push(stack.pop().unwrap());\\n            }\\n        }\\n        \\n        return paper;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690343,
                "title": "simple-c-solution-using-mutiset-and-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n=s.size();\\n        multiset<char>mst;\\n        stack<char>st;\\n        for(auto it:s){\\n            mst.insert(it);\\n        }\\n        int i=0;\\n        string ans=\"\";\\n        while(i<n){\\n            while(!st.empty() and *mst.begin()>=st.top()){\\n                ans+=st.top();\\n                st.pop();\\n                // cout<<\"ans\"<<endl;\\n            }\\n            st.push(s[i]);\\n            mst.erase(mst.find(s[i]));\\n            i++;\\n            \\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n=s.size();\\n        multiset<char>mst;\\n        stack<char>st;\\n        for(auto it:s){\\n            mst.insert(it);\\n        }\\n        int i=0;\\n        string ans=\"\";\\n        while(i<n){\\n            while(!st.empty() and *mst.begin()>=st.top()){\\n                ans+=st.top();\\n                st.pop();\\n                // cout<<\"ans\"<<endl;\\n            }\\n            st.push(s[i]);\\n            mst.erase(mst.find(s[i]));\\n            i++;\\n            \\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2687070,
                "title": "fastest-java-solution-and-least-space-complexity-100",
                "content": "sorry it was my first upload\\n**use test case like\\n1.bdiyevfz\\n2.adcaaz**\\n\\n![image](https://assets.leetcode.com/users/images/d4660ef4-4ba5-4fb9-a29d-d9f0ff2c3e59_1665420882.5438426.png)\\n\\n\\n\\n     public String robotWithString(String s) {\\n        \\n        StringBuilder t = new StringBuilder();\\n        StringBuilder ans = new StringBuilder(); \\n       Stack<Integer> st = fun(sb);\\n         int x = 0;\\n        while(!st.isEmpty()){\\n            while(t.length() != 0 && t.charAt(t.length()-1)<= s.charAt(st.peek())){\\n                ans.append(t.charAt(t.length()-1));\\n                t.delete(t.length()-1, t.length());\\n            }\\n            t.append(s.substring(x, st.peek()));\\n\\n            ans.append(s.charAt(st.peek()));\\n            \\n\\n           x = st.pop()+1;\\n\\t\\t   \\n            if(x == s.length()-1&& st.isEmpty() )break;\\n        } \\n         if(t.length() != 0){\\n             \\n             ans.append(t.reverse());\\n         }\\n         \\n        return ans.toString();\\n         \\n    }    \\n\\t public Stack<Integer> fun(StringBuilder s){\\n        Stack<Integer> st = new Stack<>();\\n        st.push(s.length()-1);\\n        for(int i = s.length()-2 ;i>= 0; i--){\\n            if(s.charAt(st.peek())<s.charAt(i))continue;\\n            st.push(i);\\n        }\\n        return st;\\n    }\\n    \\n",
                "solutionTags": [],
                "code": "sorry it was my first upload\\n**use test case like\\n1.bdiyevfz\\n2.adcaaz**\\n\\n![image](https://assets.leetcode.com/users/images/d4660ef4-4ba5-4fb9-a29d-d9f0ff2c3e59_1665420882.5438426.png)\\n\\n\\n\\n     public String robotWithString(String s) {\\n        \\n        StringBuilder t = new StringBuilder();\\n        StringBuilder ans = new StringBuilder(); \\n       Stack<Integer> st = fun(sb);\\n         int x = 0;\\n        while(!st.isEmpty()){\\n            while(t.length() != 0 && t.charAt(t.length()-1)<= s.charAt(st.peek())){\\n                ans.append(t.charAt(t.length()-1));\\n                t.delete(t.length()-1, t.length());\\n            }\\n            t.append(s.substring(x, st.peek()));\\n\\n            ans.append(s.charAt(st.peek()));\\n            \\n\\n           x = st.pop()+1;\\n\\t\\t   \\n            if(x == s.length()-1&& st.isEmpty() )break;\\n        } \\n         if(t.length() != 0){\\n             \\n             ans.append(t.reverse());\\n         }\\n         \\n        return ans.toString();\\n         \\n    }    \\n\\t public Stack<Integer> fun(StringBuilder s){\\n        Stack<Integer> st = new Stack<>();\\n        st.push(s.length()-1);\\n        for(int i = s.length()-2 ;i>= 0; i--){\\n            if(s.charAt(st.peek())<s.charAt(i))continue;\\n            st.push(i);\\n        }\\n        return st;\\n    }\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2686943,
                "title": "python-easy-solution-hashmap-stack",
                "content": "# Code\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        # Count the Occurence of characters in the String.\\n        charMap = Counter(s)\\n        p = \"\"        # Final Output or Operation 2.\\n        t = []        # Auxillary or Operation 1.\\n        \"---------Next--Minimum--Character---------\"\\n        def minInCharMap():\\n            for char in string.ascii_lowercase:\\n                if charMap[char] > 0:\\n                    return char\\n            return \"#\"\\n        \"------------------------------------------\"\\n        # main body\\n        i = 0\\n        while (i < len(s)):\\n            next_min_ch_St = minInCharMap()  #next minimum Character from charMap.\\n            if (len(t) == 0):       # Mandatory when t is empty.\\n                t.append(s[i])\\n                charMap[s[i]] -= 1\\n                i += 1\\n            elif (next_min_ch_St < t[-1]):  # if next minimum element after ith character is smaller than last element in then perform Operation 1. \\n                t.append(s[i])\\n                charMap[s[i]] -= 1\\n                i += 1\\n            else:     # if next minimum element after ith character is greater than last element in then perform Operation 2. \\n                p += t.pop()\\n        while(len(t) > 0):\\n            p += t.pop()\\n        \\n        return p\\n         \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        # Count the Occurence of characters in the String.\\n        charMap = Counter(s)\\n        p = \"\"        # Final Output or Operation 2.\\n        t = []        # Auxillary or Operation 1.\\n        \"---------Next--Minimum--Character---------\"\\n        def minInCharMap():\\n            for char in string.ascii_lowercase:\\n                if charMap[char] > 0:\\n                    return char\\n            return \"#\"\\n        \"------------------------------------------\"\\n        # main body\\n        i = 0\\n        while (i < len(s)):\\n            next_min_ch_St = minInCharMap()  #next minimum Character from charMap.\\n            if (len(t) == 0):       # Mandatory when t is empty.\\n                t.append(s[i])\\n                charMap[s[i]] -= 1\\n                i += 1\\n            elif (next_min_ch_St < t[-1]):  # if next minimum element after ith character is smaller than last element in then perform Operation 1. \\n                t.append(s[i])\\n                charMap[s[i]] -= 1\\n                i += 1\\n            else:     # if next minimum element after ith character is greater than last element in then perform Operation 2. \\n                p += t.pop()\\n        while(len(t) > 0):\\n            p += t.pop()\\n        \\n        return p\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685240,
                "title": "short-easy-to-read-java-solution-with-o-n-time-and-space-using-stack-and-letter-indicies",
                "content": "This solution is very similar to many other ones that are using stack, counters and processing string with taking letters one by one from \\'a\\' to \\'z\\'.\\nBut instead of counters we can memorize the last position of each character.\\nIn this way we don\\'t need to count \"how many characters has left\" during processing.\\nInstead, for each letter (iteration) we process a string starting from the last processed position (exclusive) till the last occurence of the letter (inclusive).\\nAnd we also add one more character into processing (\\'z\\'+1) that will never appear in the input string and which is greater than any letter in the string. This additional iteration helps us to free up our stack, so that we don\\'t need to write addition while loop at the end.\\n\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        char[] t = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int[] p = new int[27];\\n        for (int i = 0; i < t.length; i++) p[t[i]-\\'a\\'] = i;\\n        Stack<Character> st = new Stack<>();\\n        int i = 0;\\n        for (char c = \\'a\\'; c <= \\'z\\'+1; c++) {\\n            while (!st.isEmpty() && st.peek() <= c) sb.append(st.pop());\\n            while (i <= p[c-\\'a\\'])\\n                if (t[i] == c) sb.append(t[i++]);\\n                else st.push(t[i++]);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        char[] t = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int[] p = new int[27];\\n        for (int i = 0; i < t.length; i++) p[t[i]-\\'a\\'] = i;\\n        Stack<Character> st = new Stack<>();\\n        int i = 0;\\n        for (char c = \\'a\\'; c <= \\'z\\'+1; c++) {\\n            while (!st.isEmpty() && st.peek() <= c) sb.append(st.pop());\\n            while (i <= p[c-\\'a\\'])\\n                if (t[i] == c) sb.append(t[i++]);\\n                else st.push(t[i++]);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684431,
                "title": "c-stack",
                "content": "**Please upvote if you like this solution**\\n\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string ans=\"\";\\n        vector<int> freq(26);\\n        stack<char> st;\\n        for(auto& ch:s)freq[ch-\\'a\\']++;\\n        for(auto& ch:s){\\n            st.push(ch);\\n            freq[ch-\\'a\\']--;\\n            while(st.size() && st.top()<=getFrequency(freq)){\\n                ans+=st.top();\\n                st.pop();\\n            }\\n        }\\n        while(st.size()){\\n                ans+=st.top();\\n                st.pop();\\n         }\\n        \\n        return ans;\\n    }\\n    \\n    char getFrequency(vector<int> freq){\\n       for(int i=0;i<26;i++){\\n           if(freq[i]) return \\'a\\'+i;\\n       }\\n        \\n        return \\'A\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string ans=\"\";\\n        vector<int> freq(26);\\n        stack<char> st;\\n        for(auto& ch:s)freq[ch-\\'a\\']++;\\n        for(auto& ch:s){\\n            st.push(ch);\\n            freq[ch-\\'a\\']--;\\n            while(st.size() && st.top()<=getFrequency(freq)){\\n                ans+=st.top();\\n                st.pop();\\n            }\\n        }\\n        while(st.size()){\\n                ans+=st.top();\\n                st.pop();\\n         }\\n        \\n        return ans;\\n    }\\n    \\n    char getFrequency(vector<int> freq){\\n       for(int i=0;i<26;i++){\\n           if(freq[i]) return \\'a\\'+i;\\n       }\\n        \\n        return \\'A\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684008,
                "title": "c",
                "content": "**Intuition:**\\nUse **counter** to count letters from \\'s\\'.\\nWhen writing letter from **\\'s\\'** to **\\'t\\'** decrease counter.\\nIf the last element from \\'t\\' is smaller or equal to remaining letters in \\'s\\'(checking from counter, lo), then we need append this letter to **result (p).** If it is exist smaller lex. character in remaining \\'s\\' than last element in \\'t\\', we cannot pop from t, because smaller char in \\'s\\' make result smaller.\\n\\n**Stack** structure is best fit for using as t.:\\n\\n```\\nusing System.Text;\\n\\npublic class Solution {\\n    public string RobotWithString(string s) {\\n        int[] letters = new int[26];\\n        Stack<char> t = new();\\n        StringBuilder p = new();\\n        int lo = 0;\\n\\n        for (int i = 0; i < s.Length; i++) {\\n            letters[s[i] - \\'a\\']++;\\n        }\\n\\n        for (int i = 0; i < s.Length; i++) {\\n            t.Push(s[i]);\\n            letters[s[i] - \\'a\\']--;\\n\\n            while (lo < 26 && letters[lo] == 0) {\\n                lo++;\\n            }\\n\\n            while (t.Count > 0 && t.Peek() - \\'a\\' <= lo) {\\n                p.Append(t.Pop());\\n            }\\n        }\\n\\n        return p.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nusing System.Text;\\n\\npublic class Solution {\\n    public string RobotWithString(string s) {\\n        int[] letters = new int[26];\\n        Stack<char> t = new();\\n        StringBuilder p = new();\\n        int lo = 0;\\n\\n        for (int i = 0; i < s.Length; i++) {\\n            letters[s[i] - \\'a\\']++;\\n        }\\n\\n        for (int i = 0; i < s.Length; i++) {\\n            t.Push(s[i]);\\n            letters[s[i] - \\'a\\']--;\\n\\n            while (lo < 26 && letters[lo] == 0) {\\n                lo++;\\n            }\\n\\n            while (t.Count > 0 && t.Peek() - \\'a\\' <= lo) {\\n                p.Append(t.Pop());\\n            }\\n        }\\n\\n        return p.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683413,
                "title": "c-simple-easy-to-understand",
                "content": "```c++\\nclass Solution\\n{\\npublic:\\n    string robotWithString(string s)\\n    {\\n        vector<int> freq(26, 0);\\n\\n        // keep track of frequency of each character\\n        for (char c : s)\\n            freq[c - \\'a\\']++;\\n\\n        stack<int> pile;\\n        string ans = \"\";\\n\\n        // for each character\\n        for (char c : s)\\n        {\\n            // push it onto the stack\\n            pile.push(c);\\n            freq[c - \\'a\\']--;\\n\\n            // pop out of stack as long as it is not empty and the top of the stack is lexicographically smaller than smallest remaining character\\n            while (pile.size() && pile.top() <= get_current_min_char(freq))\\n            {\\n                ans += pile.top();\\n                pile.pop();\\n            }\\n        }\\n\\n        // add remaining to the answer\\n        while (pile.size())\\n        {\\n            ans += pile.top();\\n            pile.pop();\\n        }\\n\\n        return ans;\\n    }\\n\\n    // get the smallest remaining character (frequency > 0)\\n    char get_current_min_char(vector<int> &freq)\\n    {\\n        for (int i = 0; i < 26; i++)\\n            if (freq[i])\\n                return \\'a\\' + i;\\n\\n        return \\'a\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```c++\\nclass Solution\\n{\\npublic:\\n    string robotWithString(string s)\\n    {\\n        vector<int> freq(26, 0);\\n\\n        // keep track of frequency of each character\\n        for (char c : s)\\n            freq[c - \\'a\\']++;\\n\\n        stack<int> pile;\\n        string ans = \"\";\\n\\n        // for each character\\n        for (char c : s)\\n        {\\n            // push it onto the stack\\n            pile.push(c);\\n            freq[c - \\'a\\']--;\\n\\n            // pop out of stack as long as it is not empty and the top of the stack is lexicographically smaller than smallest remaining character\\n            while (pile.size() && pile.top() <= get_current_min_char(freq))\\n            {\\n                ans += pile.top();\\n                pile.pop();\\n            }\\n        }\\n\\n        // add remaining to the answer\\n        while (pile.size())\\n        {\\n            ans += pile.top();\\n            pile.pop();\\n        }\\n\\n        return ans;\\n    }\\n\\n    // get the smallest remaining character (frequency > 0)\\n    char get_current_min_char(vector<int> &freq)\\n    {\\n        for (int i = 0; i < 26; i++)\\n            if (freq[i])\\n                return \\'a\\' + i;\\n\\n        return \\'a\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682646,
                "title": "amazing-question",
                "content": ">In this problem we have to find the order in which we are going to print from the back of `t`.\\n>From `s` we are going to insert to `t` in back. we have to decide carefully when we should print or add to our answer.\\n\\n* \\tLet suppose we give with S = bac \\n* \\tSo when we remove `b` from `S` and insert to t. T will be `T = \"b\"`\\n* \\tIn next step we will add `a` to `T` now `T = ba` and we will look ahead from `a` is there any `character` which is Lexicographically smaller or not. if not we will add that element to our ans. after `a` we checked for `b` also only `b` < `c` so b is also added to answer. \\n* \\tFor `c` it is last character lookup array will return `z` . `c` < `z`\\n\\n**Note : In simple words we have to check from every index `i` weather any character from i + 1 to end which give smaller character than ith character.**\\n```c++\\nclass Solution {\\npublic:\\n    char lookup(vector<int> &hash){\\n        for(int i = 0; i < 26; i++){\\n            if(hash[i] != 0)return (char)i + \\'a\\';\\n        }\\n        \\n        return \\'z\\';\\n    }\\n    string robotWithString(string s) {\\n        \\n        vector<int> hash(26,0);\\n        for(char ch : s)hash[ch-\\'a\\']++;\\n        string ans = \"\";\\n        stack<char> st;\\n        for(char ch : s){\\n            st.push(ch);\\n            hash[ch-\\'a\\']--;\\n            \\n            while(st.empty()==false and st.top() <= lookup(hash)){\\n                ans += st.top();\\n                st.pop();\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    char lookup(vector<int> &hash){\\n        for(int i = 0; i < 26; i++){\\n            if(hash[i] != 0)return (char)i + \\'a\\';\\n        }\\n        \\n        return \\'z\\';\\n    }\\n    string robotWithString(string s) {\\n        \\n        vector<int> hash(26,0);\\n        for(char ch : s)hash[ch-\\'a\\']++;\\n        string ans = \"\";\\n        stack<char> st;\\n        for(char ch : s){\\n            st.push(ch);\\n            hash[ch-\\'a\\']--;\\n            \\n            while(st.empty()==false and st.top() <= lookup(hash)){\\n                ans += st.top();\\n                st.pop();\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682559,
                "title": "multiset",
                "content": "class Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n      stack<pair<char,int>> st;\\n      multiset<pair<char,int>> ml;\\n      for(int i=0;i<n;i++){\\n        ml.insert({s[i],i});\\n      }\\n      \\n      string ans = \"\";\\n      for(int i=0;i<n;i++){\\n        auto x = ml.begin();\\n        if(x->first==s[i]){\\n          \\n            ans+=s[i];\\n            ml.erase({s[i],i});\\n          x = ml.begin();\\n         \\n          while(!st.empty() and st.top().first<=x->first){\\n          ans+=st.top().first;\\n            ml.erase({st.top().first,st.top().second});\\n            st.pop();\\n            }\\n          \\n        }\\n        else{\\n          st.push({s[i],i});\\n          ml.erase({s[i],i});\\n        }\\n        \\n        \\n        \\n      }\\n      \\n      \\n       while(!st.empty()){\\n          ans+=st.top().first;\\n           \\n            st.pop();\\n            }\\n      \\n      \\n      return ans;\\n      \\n      \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n      stack<pair<char,int>> st;\\n      multiset<pair<char,int>> ml;\\n      for(int i=0;i<n;i++){\\n        ml.insert({s[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 2682458,
                "title": "short-and-easy-to-understand-python-also-beats-100-using-cumulative-min",
                "content": "Start by making a reversed cumulative min (will call this **cm** from now).\\n\\nFor examle\\n`dcacb` would give us: cm = `aaabb` (during the last two characters, the minimum character is **b**, and later the minimum is **a**)\\n\\n\\n\\nBecause we actually don\\'t need the first calue in the cummulative min, we can skip making it\\nas such we actually get cm = `aabb`\\n\\nThen we just iterate over the the charaters in the string and the next cummulative min value\\nfor example:\\n**d** and **a**\\n**c** and **a**\\n**a** and **b**\\n**c** and **b**\\n**b** will be skipped because cm only have 4 chars\\n\\nby default we always add the character from the string to a stack t.\\nthen we check if the item on the top of the stack (which first time will be the char we just added),\\nif this is less than the current cummulative min value, we know that we must write it to our final result\\n\\nrepeat...\\n\\nin the end, the last character should have been on the stack, but we can instead just add it directly to our result, followed by the values from the stack (which will be in reversed because it\\'s a stack...)\\n\\n\\nHope this helps understanding, please comment if not, or if you find anything that can be improved..\\nalso upvote!\\n\\n```\\nfrom itertools import accumulate\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        #calculate reverse cumulative min (skip first character as it\\'s not needed)\\n        cm = reversed(list(accumulate(reversed(s[1:]), min)))\\n\\n        t = []\\n        ret = []\\n        \\n\\t\\t# iterate in pairs of s and the cumulative min for next char (s[i], cm[i+1] (+1 not needed as we skip first above))\\n        for char, curr_min in zip(s, cm):\\n            t.append(char)\\n            while t and t[-1] <= curr_min: \\n                ret += t.pop()\\n\\n\\t\\t# Join result together, because we skipped the last s[-1] above (cm is one shorter than s), we need to add it inbetween ret and t \\n        return \"\".join(ret + [s[-1]] + t[::-1])\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nfrom itertools import accumulate\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        #calculate reverse cumulative min (skip first character as it\\'s not needed)\\n        cm = reversed(list(accumulate(reversed(s[1:]), min)))\\n\\n        t = []\\n        ret = []\\n        \\n\\t\\t# iterate in pairs of s and the cumulative min for next char (s[i], cm[i+1] (+1 not needed as we skip first above))\\n        for char, curr_min in zip(s, cm):\\n            t.append(char)\\n            while t and t[-1] <= curr_min: \\n                ret += t.pop()\\n\\n\\t\\t# Join result together, because we skipped the last s[-1] above (cm is one shorter than s), we need to add it inbetween ret and t \\n        return \"\".join(ret + [s[-1]] + t[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682367,
                "title": "c-monotonic-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        \\n        int n = s.length();\\n        \\n        stack<char> minStack;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            if(!minStack.empty() && minStack.top()<s[i]){\\n                minStack.push(minStack.top());\\n            }else{\\n                minStack.push(s[i]);\\n            }\\n        }\\n        \\n        string finalString = \"\";\\n        \\n        stack<char> charStack;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            string currentString = \"\";\\n            while(!charStack.empty() && charStack.top() <= minStack.top()){\\n                currentString += charStack.top();\\n                charStack.pop();\\n            }\\n            finalString += currentString;\\n            \\n            charStack.push(s[i]);\\n            minStack.pop();\\n        }\\n        \\n        while(!charStack.empty()){\\n            finalString += charStack.top();\\n            charStack.pop();\\n        }\\n        \\n        \\n        return finalString;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        \\n        int n = s.length();\\n        \\n        stack<char> minStack;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            if(!minStack.empty() && minStack.top()<s[i]){\\n                minStack.push(minStack.top());\\n            }else{\\n                minStack.push(s[i]);\\n            }\\n        }\\n        \\n        string finalString = \"\";\\n        \\n        stack<char> charStack;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            string currentString = \"\";\\n            while(!charStack.empty() && charStack.top() <= minStack.top()){\\n                currentString += charStack.top();\\n                charStack.pop();\\n            }\\n            finalString += currentString;\\n            \\n            charStack.push(s[i]);\\n            minStack.pop();\\n        }\\n        \\n        while(!charStack.empty()){\\n            finalString += charStack.top();\\n            charStack.pop();\\n        }\\n        \\n        \\n        return finalString;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682349,
                "title": "easiest-best-solution-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int size=s.size(),i=0;\\n        string t=\"\",ans=\"\";\\n        vector<char> vec(size);\\n        vec[size-1]=s[size-1];\\n        for(int i=size-2;i>=0;i--)\\n            vec[i]=min(s[i],vec[i+1]);\\n        while(i<size || t.size()){\\n            if(t.size()==0){\\n                t.push_back(s[i++]);\\n                continue;\\n            }\\n            if(i==size){\\n                while(t.size()){\\n                    ans+=t[t.size()-1];\\n                    t.pop_back();\\n                }\\n                break;\\n            }\\n            int t_ind=t.size()-1;\\n            if(t[t_ind]>s[i])\\n                t.push_back(s[i++]);\\n            else{\\n                if(vec[i]<t[t_ind])\\n                    t.push_back(s[i++]);\\n                else{\\n                    ans+=t[t_ind];\\n                    t.pop_back();\\n                }   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int size=s.size(),i=0;\\n        string t=\"\",ans=\"\";\\n        vector<char> vec(size);\\n        vec[size-1]=s[size-1];\\n        for(int i=size-2;i>=0;i--)\\n            vec[i]=min(s[i],vec[i+1]);\\n        while(i<size || t.size()){\\n            if(t.size()==0){\\n                t.push_back(s[i++]);\\n                continue;\\n            }\\n            if(i==size){\\n                while(t.size()){\\n                    ans+=t[t.size()-1];\\n                    t.pop_back();\\n                }\\n                break;\\n            }\\n            int t_ind=t.size()-1;\\n            if(t[t_ind]>s[i])\\n                t.push_back(s[i++]);\\n            else{\\n                if(vec[i]<t[t_ind])\\n                    t.push_back(s[i++]);\\n                else{\\n                    ans+=t[t_ind];\\n                    t.pop_back();\\n                }   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682183,
                "title": "swift-solution-o-n",
                "content": "# Approach\\nFor getting the lexicographically smallest string we should take a minimum element eather from the rest of the string or from stack.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func robotWithString(_ s: String) -> String {\\n        let s: [Character] = Array(s)\\n        \\n        var res: String = \"\"\\n        var stack: [Character] = []\\n        var rightMins: [Character] = .init(repeating: s.last!, count: s.count + 1)\\n        for i in (0..<s.count).reversed() {\\n            rightMins[i] = min(rightMins[i + 1], s[i])\\n        }\\n        \\n        var i = 0\\n        while i < s.count {\\n            defer {\\n                i += 1\\n            }\\n            \\n            while s[i] != rightMins[i] {\\n                defer {\\n                    i += 1\\n                }\\n                stack.append(s[i])\\n            }\\n            \\n            res.append(s[i])\\n            \\n            while !stack.isEmpty, stack.last! <= rightMins[i + 1] {\\n                res.append(stack.removeLast())\\n            }\\n        }\\n        \\n        while !stack.isEmpty {\\n            res.append(stack.removeLast())\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func robotWithString(_ s: String) -> String {\\n        let s: [Character] = Array(s)\\n        \\n        var res: String = \"\"\\n        var stack: [Character] = []\\n        var rightMins: [Character] = .init(repeating: s.last!, count: s.count + 1)\\n        for i in (0..<s.count).reversed() {\\n            rightMins[i] = min(rightMins[i + 1], s[i])\\n        }\\n        \\n        var i = 0\\n        while i < s.count {\\n            defer {\\n                i += 1\\n            }\\n            \\n            while s[i] != rightMins[i] {\\n                defer {\\n                    i += 1\\n                }\\n                stack.append(s[i])\\n            }\\n            \\n            res.append(s[i])\\n            \\n            while !stack.isEmpty, stack.last! <= rightMins[i + 1] {\\n                res.append(stack.removeLast())\\n            }\\n        }\\n        \\n        while !stack.isEmpty {\\n            res.append(stack.removeLast())\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682053,
                "title": "rust-stack-with-comments",
                "content": "The idea here is to greedily take the smallest letter available in the remaining part of `s`, or the last letter in `t`, whichever is smallest. Build an array (`better`) with the highest index in `s` of a \"better\" letter, if possible, i.e. a lexicographically smaller letter, w.r.t. a given letter. This way we can quickly determine if we should take the last letter of `t`, or if we should continue taking letters from `s`. Once we have no characters left in `s`, the only option that remains is to add the reversed `t` to the return value.\\n\\n```\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\n\\nimpl Solution {\\n    pub fn robot_with_string(s: String) -> String {\\n        let mut better = [None; N_LETTERS + 1];\\n        for (i, c) in s.bytes().enumerate() {\\n            better[(c - b\\'a\\') as usize + 1] = Some(i);\\n        }\\n        for i in 1..N_LETTERS {\\n            better[i] = match (better[i-1], better[i]) {\\n                (None, None) => None,\\n                (None, Some(m)) => Some(m),\\n                (Some(m), None) => Some(m),\\n                (Some(m1), Some(m2)) => Some(m1.max(m2)),\\n            };\\n        }\\n        let mut t = vec![];\\n        let mut rez = vec![];\\n        for (i, c) in s.bytes().enumerate() {\\n            t.push(c);\\n            while let Some(top) = t.last() {\\n                match better[(*top - b\\'a\\') as usize] {\\n                    Some(j) if j > i => break,\\n                    _ => rez.push(t.pop().unwrap()),\\n                }\\n            }\\n        }\\n        rez.extend(t.into_iter().rev());\\n        rez.into_iter().map(|b| b as char).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\n\\nimpl Solution {\\n    pub fn robot_with_string(s: String) -> String {\\n        let mut better = [None; N_LETTERS + 1];\\n        for (i, c) in s.bytes().enumerate() {\\n            better[(c - b\\'a\\') as usize + 1] = Some(i);\\n        }\\n        for i in 1..N_LETTERS {\\n            better[i] = match (better[i-1], better[i]) {\\n                (None, None) => None,\\n                (None, Some(m)) => Some(m),\\n                (Some(m), None) => Some(m),\\n                (Some(m1), Some(m2)) => Some(m1.max(m2)),\\n            };\\n        }\\n        let mut t = vec![];\\n        let mut rez = vec![];\\n        for (i, c) in s.bytes().enumerate() {\\n            t.push(c);\\n            while let Some(top) = t.last() {\\n                match better[(*top - b\\'a\\') as usize] {\\n                    Some(j) if j > i => break,\\n                    _ => rez.push(t.pop().unwrap()),\\n                }\\n            }\\n        }\\n        rez.extend(t.into_iter().rev());\\n        rez.into_iter().map(|b| b as char).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681969,
                "title": "easy-to-understand-cpp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring robotWithString(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tpriority_queue<pair<char,int>,vector<pair<char,int>>,greater<pair<char,int>>>pq;\\n\\t\\t\\tfor(int i =0;i<n;i++){\\n\\t\\t\\t\\tpq.push({s[i],i});\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring t = \"\";\\n\\t\\t\\tstring ans = \"\";\\n\\n\\n\\t\\t\\tpair<char,int> idx = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t\\tfor(int i =0;i<n;i++){\\n\\t\\t\\t\\tif(i == idx.second){\\n\\t\\t\\t\\t\\tans += s[i];\\n\\t\\t\\t\\t\\twhile(idx.second <= i && !pq.empty()){\\n\\t\\t\\t\\t\\t\\tidx = pq.top();\\n\\t\\t\\t\\t\\t\\tpq.pop(); \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint k = t.size();\\n\\t\\t\\t\\t\\twhile(k != 0 && idx.first >= t[k-1]){\\n\\t\\t\\t\\t\\t\\tans += t[k-1];\\n\\t\\t\\t\\t\\t\\tt.pop_back();\\n\\t\\t\\t\\t\\t\\tk--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tt += s[i];\\n\\t\\t\\t\\t}  \\n\\t\\t\\t}\\n\\n\\t\\t\\treverse(t.begin(),t.end());\\n\\t\\t\\tans += t;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n# \\t*please upvote if you like the solution*",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring robotWithString(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tpriority_queue<pair<char,int>,vector<pair<char,int>>,greater<pair<char,int>>>pq;\\n\\t\\t\\tfor(int i =0;i<n;i++){\\n\\t\\t\\t\\tpq.push({s[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 2681681,
                "title": "c-greedy-stack",
                "content": "**Approach** :-\\n1.] Our first concern is to choose which elm we have to first insert into string\\n2.] So for making smallest string only we are going to put char in the ans if we dosent have any lesser elm in string which have greater elm\\n\\n**C++ code** \\n```\\t \\n    //going to find a lesser possible elm present\\n    int find(int freq[]){\\n        for(int i=0;i<26;i++){\\n            if(freq[i]!=0){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    string robotWithString(string s) {\\n        int freq[26]={0};\\n        for(auto &c:s){\\n            freq[c-\\'a\\']++;\\n        }\\n        \\n        stack<int> se;\\n        string ans=\"\";\\n        for(auto &c:s){\\n            se.push(c-\\'a\\');\\n            freq[c-\\'a\\']--;\\n            while(!se.empty() && se.top()<=find(freq)){\\n                ans+=se.top()+\\'a\\';\\n                se.pop();\\n            }\\n        }\\n        \\n        while(!se.empty()){\\n            ans+=se.top()+\\'a\\';\\n            se.pop();\\n        }\\n        return ans;\\n    }\\n\\t//code by sachin\\n```\\n**Upvote if solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\t \\n    //going to find a lesser possible elm present\\n    int find(int freq[]){\\n        for(int i=0;i<26;i++){\\n            if(freq[i]!=0){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    string robotWithString(string s) {\\n        int freq[26]={0};\\n        for(auto &c:s){\\n            freq[c-\\'a\\']++;\\n        }\\n        \\n        stack<int> se;\\n        string ans=\"\";\\n        for(auto &c:s){\\n            se.push(c-\\'a\\');\\n            freq[c-\\'a\\']--;\\n            while(!se.empty() && se.top()<=find(freq)){\\n                ans+=se.top()+\\'a\\';\\n                se.pop();\\n            }\\n        }\\n        \\n        while(!se.empty()){\\n            ans+=se.top()+\\'a\\';\\n            se.pop();\\n        }\\n        return ans;\\n    }\\n\\t//code by sachin\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681320,
                "title": "c-easy-stack-solution",
                "content": "* Intution: **Before popping** any character from **stack t** we will **see in s that whether there is any smaller character in s** \\n* If t.top()<=minchar in s then this means **curr top element of stack is lexicographically smallest** add it to ans \\n* **add characters from stack to ans until above condition holds true**\\n* finally **add all the remaining elements from stack if there**\\n\\n```\\nclass Solution {\\npublic:\\n    char minchar(map<char,int>&m)\\n    {\\n        for(auto i:m)\\n        {\\n            if(i.second>0) return i.first;\\n        }\\n        return \\'a\\';\\n    }\\n    string robotWithString(string s) {\\n        map<char,int>m;\\n        for(auto &i:s)\\n        {\\n            m[i]++;\\n        }\\n        stack<int>t;\\n        string ans=\"\";\\n        for(auto &i:s)\\n        {\\n            t.push(i);\\n            m[i]--;\\n            while(!t.empty() && t.top()<=minchar(m))\\n            {\\n                ans+=t.top();\\n                t.pop();\\n            }\\n        }\\n        while(!t.empty())\\n        {\\n            ans+=t.top();\\n            t.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char minchar(map<char,int>&m)\\n    {\\n        for(auto i:m)\\n        {\\n            if(i.second>0) return i.first;\\n        }\\n        return \\'a\\';\\n    }\\n    string robotWithString(string s) {\\n        map<char,int>m;\\n        for(auto &i:s)\\n        {\\n            m[i]++;\\n        }\\n        stack<int>t;\\n        string ans=\"\";\\n        for(auto &i:s)\\n        {\\n            t.push(i);\\n            m[i]--;\\n            while(!t.empty() && t.top()<=minchar(m))\\n            {\\n                ans+=t.top();\\n                t.pop();\\n            }\\n        }\\n        while(!t.empty())\\n        {\\n            ans+=t.top();\\n            t.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680352,
                "title": "c-short-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string ans, t, mn = s;\\n        for(int i=s.size()-2; i>=0; i--) mn[i] = min(s[i], mn[i + 1]);\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            while(t.size() && t.back() <= mn[i]) ans += t.back(), t.pop_back();\\n            t += s[i];\\n        }\\n        reverse(t.begin(), t.end());\\n        return ans + t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string ans, t, mn = s;\\n        for(int i=s.size()-2; i>=0; i--) mn[i] = min(s[i], mn[i + 1]);\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            while(t.size() && t.back() <= mn[i]) ans += t.back(), t.pop_back();\\n            t += s[i];\\n        }\\n        reverse(t.begin(), t.end());\\n        return ans + t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680331,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int exist(vector<int> &v,char c)\\n    {\\n        int x = c -\\'a\\';\\n        for(int i = 0;i<x;i++)\\n            if(v[i]>0)return 1;\\n        return 0;\\n    }\\n    string robotWithString(string s) {\\n        stack<char> st;\\n        int n = s.size();\\n        vector<int> v(26,0);\\n        for(auto it:s)\\n            v[it-\\'a\\']++;\\n        \\n        string ans = \"\";\\n        for(int i = 0;i<n;i++)\\n        {\\n            v[s[i]-\\'a\\']--;\\n            \\n            st.push(s[i]);\\n            while(st.size() and exist(v,st.top())==0)\\n            {\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        \\n        while(st.size())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int exist(vector<int> &v,char c)\\n    {\\n        int x = c -\\'a\\';\\n        for(int i = 0;i<x;i++)\\n            if(v[i]>0)return 1;\\n        return 0;\\n    }\\n    string robotWithString(string s) {\\n        stack<char> st;\\n        int n = s.size();\\n        vector<int> v(26,0);\\n        for(auto it:s)\\n            v[it-\\'a\\']++;\\n        \\n        string ans = \"\";\\n        for(int i = 0;i<n;i++)\\n        {\\n            v[s[i]-\\'a\\']--;\\n            \\n            st.push(s[i]);\\n            while(st.size() and exist(v,st.top())==0)\\n            {\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        \\n        while(st.size())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680182,
                "title": "c-clean-solution-with-stack",
                "content": "Push character into the stack when iterating through the string. The condition to pop out the stack top is when there is no more character on the right with smaller lexicographical rank than the top. This condition is wrapped inside the isGood function, which I personally believe is a more readable and clean approach. \\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string ans = \"\";    \\n        vector<int> freq(26,0);\\n        for( char c : s){\\n            freq[c-\\'a\\']++;\\n        }\\n        stack<char> fStack;\\n        for(char c : s){\\n            fStack.push(c); \\n            freq[c-\\'a\\']--;\\n            \\n            while(isGood(fStack, freq)){\\n                ans+=fStack.top();\\n                fStack.pop();\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n    bool isGood(const stack<char> &fStack, const vector<int>& freq){\\n        if(fStack.empty()){\\n            return false;\\n        } \\n        for(char c=\\'a\\'; c<fStack.top();c++){\\n            if(freq[c-\\'a\\']!=0){\\n                return false;\\n            }\\n        } \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string ans = \"\";    \\n        vector<int> freq(26,0);\\n        for( char c : s){\\n            freq[c-\\'a\\']++;\\n        }\\n        stack<char> fStack;\\n        for(char c : s){\\n            fStack.push(c); \\n            freq[c-\\'a\\']--;\\n            \\n            while(isGood(fStack, freq)){\\n                ans+=fStack.top();\\n                fStack.pop();\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n    bool isGood(const stack<char> &fStack, const vector<int>& freq){\\n        if(fStack.empty()){\\n            return false;\\n        } \\n        for(char c=\\'a\\'; c<fStack.top();c++){\\n            if(freq[c-\\'a\\']!=0){\\n                return false;\\n            }\\n        } \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680121,
                "title": "stack-easy-to-understand-inline-comments",
                "content": "* ***Using Stack***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string str) {\\n        \\n        int n = str.size();\\n        \\n        // right_min[i] will store the minimum character till ith from right side\\n        \\n        string right_min(n, str[n - 1]);\\n        \\n        // fill right_min array\\n        \\n        right_min[n - 1] = str[n - 1];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            right_min[i] = min(right_min[i + 1], str[i]);\\n        }\\n        \\n        string res = \"\";\\n        \\n        stack<char> st;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if we are not having character less than st.top() on right side, then simply include into res\\n            \\n            while(st.empty() == false && right_min[i] >= st.top())\\n            {\\n                res.push_back(st.top());\\n                \\n                st.pop();\\n            }\\n            \\n            // push the curr character into stack\\n            \\n            st.push(str[i]);\\n        }\\n        \\n        // at the end take out all the characters from the stack and include into res\\n        \\n        while(st.empty() == false)\\n        {\\n            res.push_back(st.top());\\n            \\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string str) {\\n        \\n        int n = str.size();\\n        \\n        // right_min[i] will store the minimum character till ith from right side\\n        \\n        string right_min(n, str[n - 1]);\\n        \\n        // fill right_min array\\n        \\n        right_min[n - 1] = str[n - 1];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            right_min[i] = min(right_min[i + 1], str[i]);\\n        }\\n        \\n        string res = \"\";\\n        \\n        stack<char> st;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if we are not having character less than st.top() on right side, then simply include into res\\n            \\n            while(st.empty() == false && right_min[i] >= st.top())\\n            {\\n                res.push_back(st.top());\\n                \\n                st.pop();\\n            }\\n            \\n            // push the curr character into stack\\n            \\n            st.push(str[i]);\\n        }\\n        \\n        // at the end take out all the characters from the stack and include into res\\n        \\n        while(st.empty() == false)\\n        {\\n            res.push_back(st.top());\\n            \\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680073,
                "title": "100-faster-java-solution",
                "content": "**IDEA** : check whether we can encounter a smaller character than the current character in the later part of the string . \\n**upvote if you find this solution useful**\\n\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        char[] ch = s.toCharArray();\\n        char[] next = s.toCharArray();\\n        StringBuilder ans = new StringBuilder();\\n        int l = s.length();\\n        int i = l-2;\\n        while(i>=0){\\n            next[i] = next[i+1]>next[i]?next[i]:next[i+1];\\n            i--;\\n        }\\n        i  = 0;\\n        Stack<Character> stack = new Stack<Character>();\\n        while(i<l){\\n            char curr = ch[i];\\n            while(!stack.isEmpty() && stack.peek()<=next[i]){\\n                ans.append(stack.pop());\\n            }\\n            stack.push(curr);\\n            i++;\\n        }\\n        while(!stack.isEmpty()) ans.append(stack.pop());\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        char[] ch = s.toCharArray();\\n        char[] next = s.toCharArray();\\n        StringBuilder ans = new StringBuilder();\\n        int l = s.length();\\n        int i = l-2;\\n        while(i>=0){\\n            next[i] = next[i+1]>next[i]?next[i]:next[i+1];\\n            i--;\\n        }\\n        i  = 0;\\n        Stack<Character> stack = new Stack<Character>();\\n        while(i<l){\\n            char curr = ch[i];\\n            while(!stack.isEmpty() && stack.peek()<=next[i]){\\n                ans.append(stack.pop());\\n            }\\n            stack.push(curr);\\n            i++;\\n        }\\n        while(!stack.isEmpty()) ans.append(stack.pop());\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680031,
                "title": "c-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        string re;\\n        map<char,int> mp;\\n\\t\\tfor(int i = 0; i<n;++i) mp[s[i]]++;\\n\\t\\tauto it = mp.begin();\\n\\t\\tstack<char> st;\\n\\t\\tint i = 0;\\n\\t\\twhile(i<n){\\n\\t\\t\\tmp[s[i]]--;\\n\\t\\t    st.push(s[i]);\\n\\t\\t\\twhile(it!=mp.end() && it->second<=0) it++;\\n\\t\\t\\twhile(it!=mp.end() && st.size() && it->first>=st.top()){\\n\\t\\t\\t\\tre+=string(1,st.top()); st.pop();\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\twhile(st.size()){\\n\\t\\t\\tre+=string(1,st.top()); st.pop();\\n\\t\\t}\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        string re;\\n        map<char,int> mp;\\n\\t\\tfor(int i = 0; i<n;++i) mp[s[i]]++;\\n\\t\\tauto it = mp.begin();\\n\\t\\tstack<char> st;\\n\\t\\tint i = 0;\\n\\t\\twhile(i<n){\\n\\t\\t\\tmp[s[i]]--;\\n\\t\\t    st.push(s[i]);\\n\\t\\t\\twhile(it!=mp.end() && it->second<=0) it++;\\n\\t\\t\\twhile(it!=mp.end() && st.size() && it->first>=st.top()){\\n\\t\\t\\t\\tre+=string(1,st.top()); st.pop();\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\twhile(st.size()){\\n\\t\\t\\tre+=string(1,st.top()); st.pop();\\n\\t\\t}\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679737,
                "title": "greedy-hashmap-solution",
                "content": "Algorithm: \\nStep-1. Take Two empty strings t and p as described in the question. \\n            t-string will serve as a stack because we will take out the char from its end.\\nStep-2. Create a hashmap to store frequency of every element.\\nStep-3. Iterate through the string and stop whenever you sees a char which is the smallest left out char in the freq array.\\nStep-4. Add that char into our p-string and also do check for other prev char which have been stored till now into our t-string.  \\nStep-5 Add the left out t-string into our p-string from backside \\n\\nLets take a test case \"bbazza\" , dry run the given testcase for more clarity of code.\\nAns for the testcase is \"aazzbb\"\\n\\n``` \\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n\\n        string t=\"\",p=\"\";          //Step-1\\n        int freq[26]={0};\\n        for(char ch : s) freq[ch-\\'a\\']++;     //Step-2\\n        \\n        for(char ch : s){\\n            t+=ch;\\n            freq[ch-\\'a\\']--;\\n            bool flg=false;\\n            for(int i=0;i<26;i++){\\n                if(i < ch-\\'a\\' && freq[i]){\\n                    flg=true;                   //Step-3\\n                    break;\\n                }\\n            }\\n            if(!flg){\\n                bool newFlag=false;\\n                while(!flg && t.size()){         //Step-4\\n                    char c=t[t.size()-1];\\n                     for(int i=0;i<26;i++){\\n                        if(i < c-\\'a\\' && freq[i] > 0){\\n                        newFlag=true;\\n                        break;\\n                        }\\n                     }  \\n                     if(!newFlag){\\n                        t.erase(--t.end());\\n                        p+=c;\\n                     }\\n                     flg=newFlag;\\n                }\\n            }    \\n        }\\n        while(t.size()){           //Step-5\\n                    char c=t[t.size()-1];\\n                    t.erase(--t.end());\\n                    p+=c;\\n        }\\n        return p;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string robotWithString(string s) {\\n\\n        string t=\"\",p=\"\";          //Step-1\\n        int freq[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2679696,
                "title": "java-solution-o-n-stack-char-count",
                "content": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        // Stack + Count\\n        int[] charCnt = new int[26];\\n        for (char c : s.toCharArray()) charCnt[c-\\'a\\']++;\\n        \\n        StringBuilder strB = new StringBuilder();\\n        Deque<Character> stack = new LinkedList<>();\\n        for (char c : s.toCharArray()) {\\n            charCnt[c-\\'a\\']--;\\n            stack.push(c);\\n            while (!stack.isEmpty() && !hasSmallerRight(stack.peek()-\\'a\\', charCnt)) {\\n                strB.append(stack.poll());\\n            }\\n        }\\n        \\n        return strB.toString();\\n    }\\n    \\n    public boolean hasSmallerRight(int c, int[] charCnt) {\\n        for (int i=0; i<c; i++) {\\n            if (charCnt[i] > 0) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        // Stack + Count\\n        int[] charCnt = new int[26];\\n        for (char c : s.toCharArray()) charCnt[c-\\'a\\']++;\\n        \\n        StringBuilder strB = new StringBuilder();\\n        Deque<Character> stack = new LinkedList<>();\\n        for (char c : s.toCharArray()) {\\n            charCnt[c-\\'a\\']--;\\n            stack.push(c);\\n            while (!stack.isEmpty() && !hasSmallerRight(stack.peek()-\\'a\\', charCnt)) {\\n                strB.append(stack.poll());\\n            }\\n        }\\n        \\n        return strB.toString();\\n    }\\n    \\n    public boolean hasSmallerRight(int c, int[] charCnt) {\\n        for (int i=0; i<c; i++) {\\n            if (charCnt[i] > 0) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679568,
                "title": "simple-c-solution-greedy-o-n",
                "content": "class Solution {\\npublic:\\n\\n\\n\\n    string robotWithString(string s) {\\n        int n=s.size();\\n        vector<char> prefMin(n);\\n        \\n        prefMin[n-1]=s[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            prefMin[i]=min(s[i],prefMin[i+1]);\\n        }\\n        \\n        string ans=\"\",t=\"\";\\n        \\n        for(int i=0;i<n;i++){\\n            while(t.size() && t.back()<=prefMin[i]){\\n                ans.push_back(t.back());\\n                t.pop_back();\\n            }\\n            \\n            t.push_back(s[i]);\\n        }\\n        \\n        while(t.size()){\\n            ans.push_back(t.back());\\n            t.pop_back();\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n\\n    string robotWithString(string s) {\\n        int n=s.size();\\n        vector<char> prefMin(n);\\n        \\n        prefMin[n-1]=s[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            prefMin[i]=min(s[i],prefMin[i+1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2679552,
                "title": "python-solution-tricky-string-question",
                "content": "I found the examples given being too simplistic which guided me in the wrong way during the contest. Overall it\\'s a good string question!\\n```\\nclass Solution:\\n    # As prescribed, let t be the stack holding the characters temporarily\\n    # We first count all appearance of characters within s\\n    # Then iterate from left to right\\n    # For each character, we append it to t and reduce the count of the characters\\n    # We write t[-1] to the result when there are no more characters larger than t[-1] in the remainder of the string\\n    \\n    def robotWithString(self, s: str) -> str:\\n        result, t, counts, remain = \"\", [], [0]*26, set()\\n        # Build count table and remaining characters present\\n        for c in s:\\n            counts[ord(c)-ord(\\'a\\')] += 1\\n            remain.add(c)\\n            \\n        # For each character, push into the stack and pop from stack when there are no smaller characters in the remaining string\\n        for c in s:\\n            t.append(c)\\n            counts[ord(c)-ord(\\'a\\')] -= 1\\n            if counts[ord(c)-ord(\\'a\\')] == 0:\\n                remain.remove(c)\\n            while t and remain and t[-1] <= min(remain):\\n                result += t.pop()\\n        while t:\\n            result += t.pop()\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # As prescribed, let t be the stack holding the characters temporarily\\n    # We first count all appearance of characters within s\\n    # Then iterate from left to right\\n    # For each character, we append it to t and reduce the count of the characters\\n    # We write t[-1] to the result when there are no more characters larger than t[-1] in the remainder of the string\\n    \\n    def robotWithString(self, s: str) -> str:\\n        result, t, counts, remain = \"\", [], [0]*26, set()\\n        # Build count table and remaining characters present\\n        for c in s:\\n            counts[ord(c)-ord(\\'a\\')] += 1\\n            remain.add(c)\\n            \\n        # For each character, push into the stack and pop from stack when there are no smaller characters in the remaining string\\n        for c in s:\\n            t.append(c)\\n            counts[ord(c)-ord(\\'a\\')] -= 1\\n            if counts[ord(c)-ord(\\'a\\')] == 0:\\n                remain.remove(c)\\n            while t and remain and t[-1] <= min(remain):\\n                result += t.pop()\\n        while t:\\n            result += t.pop()\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679547,
                "title": "easy-stack-solution-greedy-clean-code",
                "content": "**Intuition** : We have to greedily find the lexicographically lowest character occuring in the string and push the elements before it into the stack and continue the same while traversing the entire string.\\n\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.length();\\n        vector<int> v(26, 0);\\n        \\n        for(auto c : s) v[c - \\'a\\']++; // Storing the frequencies of each character\\n        \\n        stack<char> st;\\n        string res = \"\";\\n        int i = 0;\\n        int curr = 0; // Pointer to the current lexicographically lowest char present in the string\\n        \\n        while(i < n){\\n            while(v[curr] == 0) curr++;\\n            // This is when we encounter higher char when lower char are already present in the stack, we push the in result before current char.\\n            while(!st.empty() && st.top() <= curr + \\'a\\'){\\n                res.push_back(st.top());\\n                st.pop();\\n            }\\n            // Found eaxct match, append to result.\\n            if(s[i] == curr + \\'a\\'){\\n                res.push_back(s[i]);\\n                v[curr]--;\\n            }\\n            // If not a match, push the char into the stack, decrease the frequency.\\n            else{\\n                st.push(s[i]);\\n                v[s[i] - \\'a\\']--;\\n            }\\n            \\n            i++;\\n        }\\n        // If stack is not empty, append remaining characters to result.\\n        while(!st.empty()){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.length();\\n        vector<int> v(26, 0);\\n        \\n        for(auto c : s) v[c - \\'a\\']++; // Storing the frequencies of each character\\n        \\n        stack<char> st;\\n        string res = \"\";\\n        int i = 0;\\n        int curr = 0; // Pointer to the current lexicographically lowest char present in the string\\n        \\n        while(i < n){\\n            while(v[curr] == 0) curr++;\\n            // This is when we encounter higher char when lower char are already present in the stack, we push the in result before current char.\\n            while(!st.empty() && st.top() <= curr + \\'a\\'){\\n                res.push_back(st.top());\\n                st.pop();\\n            }\\n            // Found eaxct match, append to result.\\n            if(s[i] == curr + \\'a\\'){\\n                res.push_back(s[i]);\\n                v[curr]--;\\n            }\\n            // If not a match, push the char into the stack, decrease the frequency.\\n            else{\\n                st.push(s[i]);\\n                v[s[i] - \\'a\\']--;\\n            }\\n            \\n            i++;\\n        }\\n        // If stack is not empty, append remaining characters to result.\\n        while(!st.empty()){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679508,
                "title": "greedy-simple-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string robotWithString(string s) {\\n        int n=s.size();\\n        vector<int>idx(26,-1);\\n        vector<int>cnt(26,0);\\n        for(int i=0;i<n;i++)idx[s[i]-\\'a\\']=i;\\n        for(int i=0;i<n;i++)cnt[s[i]-\\'a\\']++;\\n        string ans=\"\";\\n        string tmp=\"\";\\n        int prv=-1;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(tmp.size()>0&&(i+\\'a\\')>=tmp.back())\\n            {\\n                ans.push_back(tmp.back());\\n                tmp.pop_back();\\n                i--;\\n            }\\n            else if(cnt[i]>0&&idx[i]>prv)\\n            {\\n                while(cnt[i]>0)\\n                {\\n                    ans.push_back(i+\\'a\\');\\n                    cnt[i]--;\\n                }\\n                for(int j=prv+1;j<=idx[i];j++)\\n                {\\n                    if(s[j]!=(i+\\'a\\'))tmp.push_back(s[j]);\\n                    cnt[s[j]-\\'a\\']--;\\n                }\\n                prv=idx[i];\\n            }\\n\\n        }\\n        reverse(tmp.begin(),tmp.end());\\n        return ans+tmp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string robotWithString(string s) {\\n        int n=s.size();\\n        vector<int>idx(26,-1);\\n        vector<int>cnt(26,0);\\n        for(int i=0;i<n;i++)idx[s[i]-\\'a\\']=i;\\n        for(int i=0;i<n;i++)cnt[s[i]-\\'a\\']++;\\n        string ans=\"\";\\n        string tmp=\"\";\\n        int prv=-1;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(tmp.size()>0&&(i+\\'a\\')>=tmp.back())\\n            {\\n                ans.push_back(tmp.back());\\n                tmp.pop_back();\\n                i--;\\n            }\\n            else if(cnt[i]>0&&idx[i]>prv)\\n            {\\n                while(cnt[i]>0)\\n                {\\n                    ans.push_back(i+\\'a\\');\\n                    cnt[i]--;\\n                }\\n                for(int j=prv+1;j<=idx[i];j++)\\n                {\\n                    if(s[j]!=(i+\\'a\\'))tmp.push_back(s[j]);\\n                    cnt[s[j]-\\'a\\']--;\\n                }\\n                prv=idx[i];\\n            }\\n\\n        }\\n        reverse(tmp.begin(),tmp.end());\\n        return ans+tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679400,
                "title": "python-stack-easy-to-understand",
                "content": "```\\n\"\"\"\\nAlgorithm:\\nstep1: keep a counter of s\\n        -> everytime we pop from s, we should decrease the element by 1\\n        -> if the element cnt is 0, remove from the counter\\nstep2: start an iteration, in each iteration, we need to decide wheter we should pop from t and print it\\n       as a result, here is the rules:\\n        -> if there is still one element smaller than t[-1], then we cannot pop\\n        -> if there is not elements smaller than t[-1], then we pop until the condition does not meet\\nstep3: check the conor case, if the s is completely reversed, t will never pop,\\n       at that time, just return the t[::-1]\\n\"\"\"\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        s_counter = Counter(s)\\n        t = []\\n        res = []\\n        for char in s:\\n            t.append(char)\\n            s_counter[char] -= 1\\n            # delete it, because this character does not exist anymore\\n            if s_counter[char] == 0:\\n                del s_counter[char]\\n            # start the printing process\\n            while t and s_counter and t[-1] <= min(s_counter):\\n                res.append(t.pop())\\n        # base case when s is empty and t is full, ex.[cba], t will be [a,b,c], never have a chance to pop\\n        res += t[::-1]\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n\"\"\"\\nAlgorithm:\\nstep1: keep a counter of s\\n        -> everytime we pop from s, we should decrease the element by 1\\n        -> if the element cnt is 0, remove from the counter\\nstep2: start an iteration, in each iteration, we need to decide wheter we should pop from t and print it\\n       as a result, here is the rules:\\n        -> if there is still one element smaller than t[-1], then we cannot pop\\n        -> if there is not elements smaller than t[-1], then we pop until the condition does not meet\\nstep3: check the conor case, if the s is completely reversed, t will never pop,\\n       at that time, just return the t[::-1]\\n\"\"\"\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        s_counter = Counter(s)\\n        t = []\\n        res = []\\n        for char in s:\\n            t.append(char)\\n            s_counter[char] -= 1\\n            # delete it, because this character does not exist anymore\\n            if s_counter[char] == 0:\\n                del s_counter[char]\\n            # start the printing process\\n            while t and s_counter and t[-1] <= min(s_counter):\\n                res.append(t.pop())\\n        # base case when s is empty and t is full, ex.[cba], t will be [a,b,c], never have a chance to pop\\n        res += t[::-1]\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679393,
                "title": "map-and-stack-c-o-n",
                "content": "**Logic**\\n1. Push all element into ordered map.\\n2. Make an iterator of map and store 1st element in char c.\\n3. Now traverse string s and store ans in string p\\n\\ti. stack top is less than current min (ch) than push in ans \\n\\tii. else if current char(ch) != c , push ch in stack \\n\\tiii. else if current element is equal to c than push and decrement in map if mp[c] == 0,  itr++ and update c = itr->first\\n4. Add all element from stack into and p\\n\\t\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size(),i=0;\\n        string p = \"\";\\n        \\n        map<char,int> mp;\\n        stack<char> t;\\n        \\n        for(auto i : s) mp[i]++;\\n\\n        auto itr = mp.begin();\\n        char c = itr->first;\\n        \\n        while(i<n){\\n            char ch = s[i];\\n            if(t.size() && t.top() <= c){\\n                p+=t.top();\\n                t.pop();\\n            }else if(ch != c){\\n                t.push(ch);\\n                mp[ch]--;\\n                if(mp[ch] == 0 ) mp.erase(ch);\\n                i++;\\n            }else if(ch == c){\\n                p+=c;\\n                mp[ch]--;\\n                if(mp[ch] == 0){\\n                    itr++;\\n                    c = itr->first;\\n                }\\n                i++;\\n            }    \\n        }\\n        while(!t.empty()){\\n            p+=t.top();\\n            t.pop();\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size(),i=0;\\n        string p = \"\";\\n        \\n        map<char,int> mp;\\n        stack<char> t;\\n        \\n        for(auto i : s) mp[i]++;\\n\\n        auto itr = mp.begin();\\n        char c = itr->first;\\n        \\n        while(i<n){\\n            char ch = s[i];\\n            if(t.size() && t.top() <= c){\\n                p+=t.top();\\n                t.pop();\\n            }else if(ch != c){\\n                t.push(ch);\\n                mp[ch]--;\\n                if(mp[ch] == 0 ) mp.erase(ch);\\n                i++;\\n            }else if(ch == c){\\n                p+=c;\\n                mp[ch]--;\\n                if(mp[ch] == 0){\\n                    itr++;\\n                    c = itr->first;\\n                }\\n                i++;\\n            }    \\n        }\\n        while(!t.empty()){\\n            p+=t.top();\\n            t.pop();\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679350,
                "title": "c-working-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string paper = \"\", robot = \"\";\\n        char ch = \\'a\\';\\n        \\n        while (s.length()) {\\n           int smallestIndex = -1;\\n           for (size_t i = 0; i < s.length(); i++) {\\n               if (s[i] == ch) {\\n                   smallestIndex = i;\\n                   break;\\n                }\\n            }\\n            \\n            if (smallestIndex == -1) {\\n                ++ch;\\n                continue;\\n            }\\n            \\n            //check if robot contains the next smallest\\n            while (robot.length() && robot.back() <= s[smallestIndex]) {\\n                paper += robot.back();\\n                robot.pop_back();\\n            } \\n            \\n            robot += s.substr(0, smallestIndex + 1);\\n            s.erase(0, smallestIndex + 1);\\n            paper += robot.back(); \\n            robot.pop_back();    \\n        }\\n        \\n        while (robot.size()) {\\n            paper += robot.back();\\n            robot.pop_back();\\n        }\\n        \\n        return paper;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string paper = \"\", robot = \"\";\\n        char ch = \\'a\\';\\n        \\n        while (s.length()) {\\n           int smallestIndex = -1;\\n           for (size_t i = 0; i < s.length(); i++) {\\n               if (s[i] == ch) {\\n                   smallestIndex = i;\\n                   break;\\n                }\\n            }\\n            \\n            if (smallestIndex == -1) {\\n                ++ch;\\n                continue;\\n            }\\n            \\n            //check if robot contains the next smallest\\n            while (robot.length() && robot.back() <= s[smallestIndex]) {\\n                paper += robot.back();\\n                robot.pop_back();\\n            } \\n            \\n            robot += s.substr(0, smallestIndex + 1);\\n            s.erase(0, smallestIndex + 1);\\n            paper += robot.back(); \\n            robot.pop_back();    \\n        }\\n        \\n        while (robot.size()) {\\n            paper += robot.back();\\n            robot.pop_back();\\n        }\\n        \\n        return paper;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679346,
                "title": "java-solution-100-faster-and-100-efficient",
                "content": "```\\n\\n```class Solution {\\n    public String robotWithString(String s) {\\n        \\n        int[] min = new int[s.length()];\\n\\t\\tfor (int i = s.length() - 1; i > 0; i--) {\\n\\t\\t\\tmin[i - 1] = Math.min(s.charAt(i), (i < s.length() - 1 ? min[i] : \\'z\\'));\\n\\t\\t}\\n        \\n\\t\\tStringBuilder sb = new StringBuilder();\\n        \\n\\t\\tArrayDeque<Character> deque = new ArrayDeque<>();\\n        \\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n            deque.push(s.charAt(i));\\n            while(!deque.isEmpty() && deque.peek() <= min[i]){\\n                sb.append(deque.pop());\\n            }\\n            \\n\\t\\t}\\n        \\n\\t\\twhile (!deque.isEmpty()) {\\n\\t\\t\\tsb.append(deque.pop());\\n\\t\\t}\\n        \\n\\t\\treturn sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679327,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define pb push_back\\npublic:\\n    string robotWithString(const string&s) {\\n        ll n=s.size();\\n        list<char>l;\\n        string ans, mn=s;\\n        for(ll i=n-2;i>-1;--i){\\n            mn[i]=min(s[i], mn[i+1]);\\n        }\\n        for(ll i=0;i<n;++i){\\n            l.pb(s[i]);\\n            while(i+1<n && !l.empty() && l.back()<=mn[i+1]){\\n                ans.pb(l.back());\\n                l.pop_back();\\n            }\\n        }\\n        while(!l.empty()){\\n            ans.pb(l.back());\\n            l.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define pb push_back\\npublic:\\n    string robotWithString(const string&s) {\\n        ll n=s.size();\\n        list<char>l;\\n        string ans, mn=s;\\n        for(ll i=n-2;i>-1;--i){\\n            mn[i]=min(s[i], mn[i+1]);\\n        }\\n        for(ll i=0;i<n;++i){\\n            l.pb(s[i]);\\n            while(i+1<n && !l.empty() && l.back()<=mn[i+1]){\\n                ans.pb(l.back());\\n                l.pop_back();\\n            }\\n        }\\n        while(!l.empty()){\\n            ans.pb(l.back());\\n            l.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679244,
                "title": "easy-c-solution-without-using-stack-with-comments",
                "content": "\\n```cpp\\nclass Solution {\\npublic:\\n\\t//find the minimum character\\n    char findMin(vector<int> &ch){\\n        for(int i=0; i<25; i++){\\n            if(ch[i] > 0){\\n                return (char) \\'a\\' + i;\\n            }\\n        }\\n        return \\'z\\';\\n    }\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        vector<int> ch(26);\\n        for(int i=0; i<n; i++){\\n            ++ch[s[i] - \\'a\\'];\\n        }\\n        char minC = findMin(ch);\\n        string ans = \"\", t = \"\";\\n        int i = 0;\\n        while(i<n){\\n\\t\\t\\t/*Here minC is the minimum character ahead of the current character s[i]. \\n\\t\\t\\tSo we append all the lesser characters than minC from t\\'s end to ans \\n\\t\\t\\tbecause we are not gonna find character lesser than minC ahead.*/\\n            while(t.size() && t.back() <= minC){\\n                ans += t.back();\\n                t.pop_back();\\n            }\\n\\t\\t\\t//after adding character to t we decrease the count of s[i] in the array and update minC which is minimum character ahead of s[i]\\n            --ch[s[i] - \\'a\\'];\\n            minC = findMin(ch);\\n            t += s[i++];\\n        }\\n\\t\\t//append all the remaining characters from t\\n        for(int j=t.size()-1; j>=0; j--){\\n            ans += t[j];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\t//find the minimum character\\n    char findMin(vector<int> &ch){\\n        for(int i=0; i<25; i++){\\n            if(ch[i] > 0){\\n                return (char) \\'a\\' + i;\\n            }\\n        }\\n        return \\'z\\';\\n    }\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        vector<int> ch(26);\\n        for(int i=0; i<n; i++){\\n            ++ch[s[i] - \\'a\\'];\\n        }\\n        char minC = findMin(ch);\\n        string ans = \"\", t = \"\";\\n        int i = 0;\\n        while(i<n){\\n\\t\\t\\t/*Here minC is the minimum character ahead of the current character s[i]. \\n\\t\\t\\tSo we append all the lesser characters than minC from t\\'s end to ans \\n\\t\\t\\tbecause we are not gonna find character lesser than minC ahead.*/\\n            while(t.size() && t.back() <= minC){\\n                ans += t.back();\\n                t.pop_back();\\n            }\\n\\t\\t\\t//after adding character to t we decrease the count of s[i] in the array and update minC which is minimum character ahead of s[i]\\n            --ch[s[i] - \\'a\\'];\\n            minC = findMin(ch);\\n            t += s[i++];\\n        }\\n\\t\\t//append all the remaining characters from t\\n        for(int j=t.size()-1; j>=0; j--){\\n            ans += t[j];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679143,
                "title": "c-stack-prefix-array-clean-concies",
                "content": "First you have to create a string which will contain the smallest element from the back.\\nThen while traversing the main string build a running stack.\\n\\nwheneven string and prefix string have same element start poping the stack until stack\\'s top <= next element in prefix string.\\n\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.length();\\n        string temp=\"\";\\n        temp += s[n-1];\\n        \\n        string ans = \"\", running=\"\";\\n        char prev = s[n-1];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i] < prev)\\n                temp += s[i],prev = s[i];\\n            else\\n                temp += prev;\\n        }\\n        \\n        reverse(temp.begin(),temp.end());\\n\\t\\t\\n        int ind = 0,next=0;\\n        stack<char> st;\\n        \\n        while(ind < n)\\n        {\\n            st.push(s[ind]);\\n            \\n            if(s[ind] == temp[ind])\\n            {\\n                int next = (ind+1 < n) ? (ind+1) : n; \\n                while(!st.empty() && st.top() <= temp[next])\\n                {\\n                    ans += st.top();\\n                    st.pop();\\n                }\\n            }\\n            ind++;\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE IF YOU LIKE THE APPROACH.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.length();\\n        string temp=\"\";\\n        temp += s[n-1];\\n        \\n        string ans = \"\", running=\"\";\\n        char prev = s[n-1];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i] < prev)\\n                temp += s[i],prev = s[i];\\n            else\\n                temp += prev;\\n        }\\n        \\n        reverse(temp.begin(),temp.end());\\n\\t\\t\\n        int ind = 0,next=0;\\n        stack<char> st;\\n        \\n        while(ind < n)\\n        {\\n            st.push(s[ind]);\\n            \\n            if(s[ind] == temp[ind])\\n            {\\n                int next = (ind+1 < n) ? (ind+1) : n; \\n                while(!st.empty() && st.top() <= temp[next])\\n                {\\n                    ans += st.top();\\n                    st.pop();\\n                }\\n            }\\n            ind++;\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679123,
                "title": "python-solution-with-explanation",
                "content": "Imagine this as the algorithm\\n\\n- Find all of the \\'`a`s. For each instance of an `a`:\\n    - Take everything before it off `s` and push it onto `t`\\n    - Add an `a` to the result\\n- Find all of the `b`s in `s`.:\\n     - First, are there any `b`s at the end of \\'t\\'? Take them off\\n     - For each instance of `b`:\\n          - Take everything before it off `s` and push it onto `t`\\n          - Add a `b` to the result\\n- Find all of the `c`s.....\\n\\n````\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        result = []\\n        t = []\\n        while s:\\n\\n            # Work out the minimum character in s, and the indexes of this character\\n            indexes = [0]\\n            minChar = s[0]\\n            for i in range(1, len(s)):\\n                thisChar = s[i]\\n                if thisChar < minChar:\\n                    minChar = thisChar\\n                    indexes = [i]\\n                elif thisChar == minChar:\\n                    indexes.append(i)\\n\\n            # Are there smaller characters at the end of t? \\n            # Use them!\\n            while t and t[-1] <= minChar:\\n                result.append(t.pop())\\n\\n            # Now take all the minimum characters\\n            # (Pushing their predecessors onto t)\\n            prev = 0\\n            for i in indexes:\\n                t.extend(s[prev:i])\\n                result.append(minChar)\\n                prev = i + 1\\n            s = s[indexes[-1]+1:]\\n\\n        #  Nothing left on s\\n        # Just take everything off t and we\\'re done!\\n        result.extend(t[::-1])\\n\\n       # Finally, convert the list into a string\\n        return \"\".join(result)\\n````",
                "solutionTags": [
                    "Python"
                ],
                "code": "````\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        result = []\\n        t = []\\n        while s:\\n\\n            # Work out the minimum character in s, and the indexes of this character\\n            indexes = [0]\\n            minChar = s[0]\\n            for i in range(1, len(s)):\\n                thisChar = s[i]\\n                if thisChar < minChar:\\n                    minChar = thisChar\\n                    indexes = [i]\\n                elif thisChar == minChar:\\n                    indexes.append(i)\\n\\n            # Are there smaller characters at the end of t? \\n            # Use them!\\n            while t and t[-1] <= minChar:\\n                result.append(t.pop())\\n\\n            # Now take all the minimum characters\\n            # (Pushing their predecessors onto t)\\n            prev = 0\\n            for i in indexes:\\n                t.extend(s[prev:i])\\n                result.append(minChar)\\n                prev = i + 1\\n            s = s[indexes[-1]+1:]\\n\\n        #  Nothing left on s\\n        # Just take everything off t and we\\'re done!\\n        result.extend(t[::-1])\\n\\n       # Finally, convert the list into a string\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679052,
                "title": "c-counter-stack-set",
                "content": "1. Follow the rule to append character from ```s``` to ```t```.\\n2. Append the last character of ```t``` to `result` if that character is the smallest one to the rest of ```s```. We can use a counter and a `set` to achieve this.\\n\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int cnt[26] = {};\\n        for (auto c : s) {\\n            cnt[c-\\'a\\']++;\\n        }\\n        set<char> m;\\n        for (int i = 25; i >= 0; i--) {\\n            if (cnt[i]) m.insert(\\'a\\'+i);\\n        }\\n        \\n        string res;\\n        string q;\\n        for (auto c : s) {\\n            q.push_back(c);\\n            cnt[c-\\'a\\']--;\\n            if (!cnt[c-\\'a\\']) m.erase(c);\\n            \\n            while (q.size() && (m.empty() || q.back() <= *m.begin())) {\\n                res.push_back(q.back());\\n                q.pop_back();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```s```\n```t```\n```t```\n```s```\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int cnt[26] = {};\\n        for (auto c : s) {\\n            cnt[c-\\'a\\']++;\\n        }\\n        set<char> m;\\n        for (int i = 25; i >= 0; i--) {\\n            if (cnt[i]) m.insert(\\'a\\'+i);\\n        }\\n        \\n        string res;\\n        string q;\\n        for (auto c : s) {\\n            q.push_back(c);\\n            cnt[c-\\'a\\']--;\\n            if (!cnt[c-\\'a\\']) m.erase(c);\\n            \\n            while (q.size() && (m.empty() || q.back() <= *m.begin())) {\\n                res.push_back(q.back());\\n                q.pop_back();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679044,
                "title": "python-java-minumum-from-right-with-stack",
                "content": "\\tclass Solution:\\n\\t\\tdef robotWithString(self, s: str) -> str:\\n\\t\\t\\tt = []\\n\\t\\t\\tp = \"\"\\n\\t\\t\\tminFromRight = [\"z\"] * len(s)\\n\\t\\t\\tcurMin = s[-1]\\n\\t\\t\\tfor i in range(len(s) - 1, -1, -1):\\n\\t\\t\\t\\tcurMin = min(curMin, s[i])\\n\\t\\t\\t\\tminFromRight[i] = curMin\\n\\t\\t\\tfor i, c in enumerate(s):\\n\\t\\t\\t\\tt.append(c)\\n\\t\\t\\t\\twhile i < len(s) - 1 and t and t[-1] <= minFromRight[i + 1]:\\n\\t\\t\\t\\t\\tp += t.pop()\\n\\t\\t\\treturn p + \"\".join(t[::-1])\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic String robotWithString(String s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tStack<Character> t = new Stack<>();\\n\\t\\t\\tStringBuilder p = new StringBuilder();\\n\\t\\t\\tchar[] minFromRight = new char[n];\\n\\t\\t\\tchar curMin = s.charAt(n - 1);\\n\\t\\t\\tfor (int i = n - 1; i > -1; i --) {\\n\\t\\t\\t\\tif (s.charAt(i) < curMin) {\\n\\t\\t\\t\\t\\tcurMin = s.charAt(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminFromRight[i] = curMin;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < n; i ++) {\\n\\t\\t\\t\\tt.push(s.charAt(i));\\n\\t\\t\\t\\twhile (i < n - 1 && !t.isEmpty() && t.peek() <= minFromRight[i + 1]) {\\n\\t\\t\\t\\t\\tp.append(t.pop());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile (!t.isEmpty()) {\\n\\t\\t\\t\\tp.append(t.pop());\\n\\t\\t\\t}\\n\\t\\t\\treturn p.toString();\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef robotWithString(self, s: str) -> str:\\n\\t\\t\\tt = []\\n\\t\\t\\tp = \"\"\\n\\t\\t\\tminFromRight = [\"z\"] * len(s)\\n\\t\\t\\tcurMin = s[-1]\\n\\t\\t\\tfor i in range(len(s) - 1, -1, -1):\\n\\t\\t\\t\\tcurMin = min(curMin, s[i])\\n\\t\\t\\t\\tminFromRight[i] = curMin\\n\\t\\t\\tfor i, c in enumerate(s):\\n\\t\\t\\t\\tt.append(c)\\n\\t\\t\\t\\twhile i < len(s) - 1 and t and t[-1] <= minFromRight[i + 1]:\\n\\t\\t\\t\\t\\tp += t.pop()\\n\\t\\t\\treturn p + \"\".join(t[::-1])\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic String robotWithString(String s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tStack<Character> t = new Stack<>();\\n\\t\\t\\tStringBuilder p = new StringBuilder();\\n\\t\\t\\tchar[] minFromRight = new char[n];\\n\\t\\t\\tchar curMin = s.charAt(n - 1);\\n\\t\\t\\tfor (int i = n - 1; i > -1; i --) {\\n\\t\\t\\t\\tif (s.charAt(i) < curMin) {\\n\\t\\t\\t\\t\\tcurMin = s.charAt(i);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2678917,
                "title": "java-using-stack-with-commentary",
                "content": "\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        ArrayDeque<Character> stack = new ArrayDeque<>();\\n        int[] latestSmaller = new int[26];\\n       \\n\\t   // find the last index for each char\\n        for (int i = 0; i < s.length(); i++) {\\n            latestSmaller[s.charAt(i) - \\'a\\'] = i;\\n        }\\n        \\n        // find the last index for all chars smaller than current char\\n        int max = -1, tmp;\\n        for (int i = 0; i < latestSmaller.length; i++) {\\n            tmp = latestSmaller[i];\\n            latestSmaller[i] = max;\\n            max = Math.max(max, tmp);\\n        }\\n        \\n        // write from t to p when the last char in t is not smaller than the current char to be added to t, and when there is no later char smaller than the last char in t\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            while (stack.size() > 0 && stack.peekLast() <= c && i > latestSmaller[stack.peekLast() - \\'a\\']) {\\n                sb.append(stack.pollLast());\\n            }\\n            stack.addLast(c);\\n        }\\n        while (stack.size() > 0) {\\n            sb.append(stack.pollLast());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        ArrayDeque<Character> stack = new ArrayDeque<>();\\n        int[] latestSmaller = new int[26];\\n       \\n\\t   // find the last index for each char\\n        for (int i = 0; i < s.length(); i++) {\\n            latestSmaller[s.charAt(i) - \\'a\\'] = i;\\n        }\\n        \\n        // find the last index for all chars smaller than current char\\n        int max = -1, tmp;\\n        for (int i = 0; i < latestSmaller.length; i++) {\\n            tmp = latestSmaller[i];\\n            latestSmaller[i] = max;\\n            max = Math.max(max, tmp);\\n        }\\n        \\n        // write from t to p when the last char in t is not smaller than the current char to be added to t, and when there is no later char smaller than the last char in t\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            while (stack.size() > 0 && stack.peekLast() <= c && i > latestSmaller[stack.peekLast() - \\'a\\']) {\\n                sb.append(stack.pollLast());\\n            }\\n            stack.addLast(c);\\n        }\\n        while (stack.size() > 0) {\\n            sb.append(stack.pollLast());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678906,
                "title": "c-stack-easy-to-understand-o-n",
                "content": "# Explaination\\nWe can observe from the statement that the characters are being pushed into a stack from the beginning of the string, and being popped into the paper. \\n\\nAt any given index, \\n1. If the stack is empty, push the current character.\\n2. If there exists a character ahead or at the current position that is smaller then the top of the stack, we may push the current character to stack and go to that character to get lexicographically smallest string.\\n3. If there exists no character ahead or at the current position that is smaller then the top of the stack, we may pop the top of the stack and append it to the ans and check the top of the stack again for the current character.\\n\\nWe use suffix array to check if there exists a character smaller then top of the stack\\n\\n# Code\\n```\\nstring robotWithString(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        vector<char> suf(n);\\n        suf[n-1] = s[n-1];\\n        for(int i = n-2;i>=0;i--){\\n            suf[i] = min(suf[i+1], s[i]);\\n        }\\n        string ans;\\n        st.push(s[0]);\\n        for(int i = 1;i<n;i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }else{\\n                if(suf[i] < st.top()){\\n                    st.push(s[i]);\\n                }else{\\n                    ans += st.top();\\n                    st.pop();\\n                    i--;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n```\\n\\nTime: `O(n)`\\nSpace: `O(n)`",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy",
                    "Suffix Array"
                ],
                "code": "```\\nstring robotWithString(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        vector<char> suf(n);\\n        suf[n-1] = s[n-1];\\n        for(int i = n-2;i>=0;i--){\\n            suf[i] = min(suf[i+1], s[i]);\\n        }\\n        string ans;\\n        st.push(s[0]);\\n        for(int i = 1;i<n;i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }else{\\n                if(suf[i] < st.top()){\\n                    st.push(s[i]);\\n                }else{\\n                    ans += st.top();\\n                    st.pop();\\n                    i--;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678894,
                "title": "c-basic-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) \\n    {\\n         int n=s.size();\\n         vector<char> v(n);\\n        \\n         v[n-1]=s[n-1];\\n        \\n         for(int i=n-2;i>=0;i--)\\n              v[i]=min(v[i+1],s[i]);\\n        \\n        string ans=\"\";\\n        \\n        stack<char> q;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n             while((q.size()) and (q.top()<=v[i]))\\n                {\\n                     ans+=q.top();\\n                    q.pop();\\n                }\\n             if(v[i]==s[i])\\n             {\\n                while((q.size()) and (q.top()<=v[i]))\\n                {\\n                     ans+=q.top();\\n                    q.pop();\\n                }\\n                     ans+=s[i];\\n             }\\n            else\\n            {\\n                 q.push(s[i]);\\n            }\\n        }\\n        \\n        while(q.size())\\n        {\\n             ans+=q.top();\\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nHope it helps!!",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) \\n    {\\n         int n=s.size();\\n         vector<char> v(n);\\n        \\n         v[n-1]=s[n-1];\\n        \\n         for(int i=n-2;i>=0;i--)\\n              v[i]=min(v[i+1],s[i]);\\n        \\n        string ans=\"\";\\n        \\n        stack<char> q;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n             while((q.size()) and (q.top()<=v[i]))\\n                {\\n                     ans+=q.top();\\n                    q.pop();\\n                }\\n             if(v[i]==s[i])\\n             {\\n                while((q.size()) and (q.top()<=v[i]))\\n                {\\n                     ans+=q.top();\\n                    q.pop();\\n                }\\n                     ans+=s[i];\\n             }\\n            else\\n            {\\n                 q.push(s[i]);\\n            }\\n        }\\n        \\n        while(q.size())\\n        {\\n             ans+=q.top();\\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678884,
                "title": "java-greedy-simulation-o-n-runtime-o-n-space",
                "content": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        //output\\n        StringBuilder out = new StringBuilder();\\n        \\n        //store indexes for each letter\\n        List<List<Integer>> indexes = new ArrayList<>();\\n        \\n        for(int i = 0; i < 26; i++) {\\n            indexes.add(new ArrayList<>());\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int index = c - \\'a\\';\\n            \\n            indexes.get(index).add(i);\\n        }\\n        \\n        //use deque to simulate t for faster runtime\\n        Deque<Character> t = new LinkedList<>();\\n        \\n        int currIndex = 0;\\n        \\n        for(int i = 0; i < 26; i++) {\\n            char currLetter = (char)(\\'a\\' + i);\\n            \\n            for(int indx : indexes.get(i)) {\\n                //we see if any letter at the end of t can be written to the paper (output)\\n                while(!t.isEmpty() && t.peekLast() <= currLetter) {\\n                    out.append(t.removeLast());\\n                }\\n                \\n                //put reach the next lexicographically smallest letter and put everything on its way to the end of t\\n                while(currIndex <= indx) {\\n                    t.addLast(s.charAt(currIndex));\\n                    currIndex++;\\n                }\\n            }\\n        }\\n        \\n        //write the rest of t to output\\n        while(!t.isEmpty()) {\\n            out.append(t.removeLast());\\n        }\\n        \\n        return out.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        //output\\n        StringBuilder out = new StringBuilder();\\n        \\n        //store indexes for each letter\\n        List<List<Integer>> indexes = new ArrayList<>();\\n        \\n        for(int i = 0; i < 26; i++) {\\n            indexes.add(new ArrayList<>());\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int index = c - \\'a\\';\\n            \\n            indexes.get(index).add(i);\\n        }\\n        \\n        //use deque to simulate t for faster runtime\\n        Deque<Character> t = new LinkedList<>();\\n        \\n        int currIndex = 0;\\n        \\n        for(int i = 0; i < 26; i++) {\\n            char currLetter = (char)(\\'a\\' + i);\\n            \\n            for(int indx : indexes.get(i)) {\\n                //we see if any letter at the end of t can be written to the paper (output)\\n                while(!t.isEmpty() && t.peekLast() <= currLetter) {\\n                    out.append(t.removeLast());\\n                }\\n                \\n                //put reach the next lexicographically smallest letter and put everything on its way to the end of t\\n                while(currIndex <= indx) {\\n                    t.addLast(s.charAt(currIndex));\\n                    currIndex++;\\n                }\\n            }\\n        }\\n        \\n        //write the rest of t to output\\n        while(!t.isEmpty()) {\\n            out.append(t.removeLast());\\n        }\\n        \\n        return out.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678838,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        char[] smallest = new char[s.length()];\\n        smallest[s.length()-1] = s.charAt(s.length()-1);\\n        for(int i=n-2; i>=0; i--) {\\n            smallest[i] = s.charAt(i) < smallest[i+1] ? s.charAt(i) : smallest[i+1];\\n        }\\n        \\n        Stack<Character> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<n; i++) {\\n            if(smallest[i] == s.charAt(i) && (stack.isEmpty() || stack.peek() > s.charAt(i))) {\\n                sb.append(s.charAt(i));\\n            } else if(stack.isEmpty() || smallest[i] < stack.peek()) {\\n                stack.push(s.charAt(i));\\n            } else {\\n                while(!stack.isEmpty() && stack.peek() <= smallest[i]) {\\n                    sb.append(stack.pop());\\n                }\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        \\n        while(!stack.isEmpty()) {\\n            sb.append(stack.pop());\\n        }\\n        \\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        char[] smallest = new char[s.length()];\\n        smallest[s.length()-1] = s.charAt(s.length()-1);\\n        for(int i=n-2; i>=0; i--) {\\n            smallest[i] = s.charAt(i) < smallest[i+1] ? s.charAt(i) : smallest[i+1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2678826,
                "title": "python-on-stack",
                "content": "```\\n    def robotWithString(self, s: str) -> str:\\n        m = [[] for _ in range(26)]\\n        for i, c in enumerate(s):\\n            m[ord(c) - ord(\\'a\\')].append(i)\\n\\n        res = []\\n        stack = []\\n        curSIndex = 0\\n\\n        for i in range(26):\\n            if m[i]:\\n                # Check there is any existing ones that are better than current one\\n                while stack and stack[-1] <= chr(97 + i):\\n                    res.append(stack.pop())\\n\\n                # Check forward\\n                while m[i][-1] >= curSIndex:\\n                    c = s[curSIndex]\\n                    if c == chr(97 + i):\\n                        res.append(c)\\n                    else:\\n                        stack.append(c)\\n                    curSIndex += 1\\n        while stack:\\n            res.append(stack.pop())\\n        return \\'\\'.join(res)",
                "solutionTags": [],
                "code": "```\\n    def robotWithString(self, s: str) -> str:\\n        m = [[] for _ in range(26)]\\n        for i, c in enumerate(s):\\n            m[ord(c) - ord(\\'a\\')].append(i)\\n\\n        res = []\\n        stack = []\\n        curSIndex = 0\\n\\n        for i in range(26):\\n            if m[i]:\\n                # Check there is any existing ones that are better than current one\\n                while stack and stack[-1] <= chr(97 + i):\\n                    res.append(stack.pop())\\n\\n                # Check forward\\n                while m[i][-1] >= curSIndex:\\n                    c = s[curSIndex]\\n                    if c == chr(97 + i):\\n                        res.append(c)\\n                    else:\\n                        stack.append(c)\\n                    curSIndex += 1\\n        while stack:\\n            res.append(stack.pop())\\n        return \\'\\'.join(res)",
                "codeTag": "Python3"
            },
            {
                "id": 2678798,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def robotWithString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = list(s)\\n        s2 = sorted([(s[i], i) for i in range(len(s))], reverse = True)\\n        t = []\\n        ans = \"\"\\n        cur_min = s2[-1][0]\\n        for i in range(len(s)):\\n            # print(\"t\", t, \"ans\", ans, \"cur_min\", cur_min, \"s2\", s2)\\n            if s[i] > cur_min:\\n                t.append(s[i])\\n            else:\\n                ans += s[i]\\n                s2.pop()\\n                while len(s2) > 0 and s2[-1][1] <= i:\\n                    s2.pop()\\n                while len(t) > 0 and len(s2) > 0 and s2[-1][0] >= t[-1]:\\n                    ans += t.pop()\\n                    \\n                    \\n                if len(s2) == 0:\\n                    break\\n                cur_min = s2[-1][0]\\n        return ans + \"\".join(t[::-1])    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def robotWithString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = list(s)\\n        s2 = sorted([(s[i], i) for i in range(len(s))], reverse = True)\\n        t = []\\n        ans = \"\"\\n        cur_min = s2[-1][0]\\n        for i in range(len(s)):\\n            # print(\"t\", t, \"ans\", ans, \"cur_min\", cur_min, \"s2\", s2)\\n            if s[i] > cur_min:\\n                t.append(s[i])\\n            else:\\n                ans += s[i]\\n                s2.pop()\\n                while len(s2) > 0 and s2[-1][1] <= i:\\n                    s2.pop()\\n                while len(t) > 0 and len(s2) > 0 and s2[-1][0] >= t[-1]:\\n                    ans += t.pop()\\n                    \\n                    \\n                if len(s2) == 0:\\n                    break\\n                cur_min = s2[-1][0]\\n        return ans + \"\".join(t[::-1])    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678789,
                "title": "c-check-best-letter-ahead",
                "content": "Code is a little messy but the idea is to check if there\\'s a smaller letter ahead of current index and use another string like a queue.\\n\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<int> best(26, 0);\\n        for(int i = 0; i < s.length(); i++){\\n            best[s[i]-97] = max(best[s[i]-97], i);\\n        }\\n        string q = \"\";\\n        string ans = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            bool ahead = false;\\n            char bestahead = \\'~\\';\\n            char minahead = \\'~\\';\\n            for(int j = 0; j < best.size(); j++){\\n                if(j < s[i]-97 && best[j] > i){\\n                    ahead = true;\\n                    if(bestahead == \\'~\\') bestahead = j+97;\\n                }\\n                if(best[j] >= i && minahead == \\'~\\') minahead = j+97;\\n            }\\n            while(q.size() && q[q.size()-1] <= minahead){\\n                ans += q[q.size()-1];\\n                q.pop_back();\\n            }\\n            if(ahead) q += s[i];\\n            else ans += s[i];\\n        }\\n        reverse(q.begin(), q.end());\\n        ans += q;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<int> best(26, 0);\\n        for(int i = 0; i < s.length(); i++){\\n            best[s[i]-97] = max(best[s[i]-97], i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2678784,
                "title": "java-deque-solution-explained-o-n-2-k",
                "content": "*Intuition*:\\nSince you are trying to create the lexicographically smallest string, you should prioritise having the **smallest possible character** in the front of the generated string.\\n\\nAt any point in time, you have only two choices.\\n1. To pick the last character of string `t`.\\n2. To continue searching in string `s`.\\n\\n*Task*:\\nIf there is still a character remaining in `s` that is smaller that your last character in `t`, continue searching in `s` as your goal is to have the **smallest possible character** furthest to the **front** of the generated string.\\n\\nElse, you can simply append **last** character of `t` as you can be assured it is the **smallest** possible character you can possibly obtain.\\n\\n*Implementation*:\\nI created a freq array with frequency of characters. Then at each point, I check the freq array if there are any smaller characters remaining in string `s`.\\n\\n*Time/Space Complexity*\\nTime: O(N)\\nSpace: O(1)\\nNote: 26 is a constant so it does not count.\\n\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        Deque<Character> dq = new ArrayDeque<>();\\n        char[] arr = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        int n = arr.length;\\n        \\n        int[] freq = new int[26];\\n        for (int i = 0; i < arr.length; i++) {\\n            freq[arr[i] - \\'a\\']++;\\n        }\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            // add current character to string t\\n            dq.addLast(arr[i]);\\n            // remove current character from frequency array\\n            freq[arr[i] - \\'a\\']--;\\n    \\n            // Check if there is a smaller character ahead in string s\\n            while (!dq.isEmpty()) {\\n                // if there are no better characters left in s\\n                if (!hasBetter(dq.peekLast(), freq)) {\\n                    // append last character in t\\n                    sb.append(dq.removeLast());\\n                } else {\\n                    // keep searching for better character in s\\n                    break;\\n                }                \\n            }\\n\\n        }\\n        \\n        // when string s is empty, only choice left is to append string t\\n        while (!dq.isEmpty()) {\\n            sb.append(dq.removeLast());\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    public boolean hasBetter(char c, int[] freq) {\\n        int val = c - \\'a\\';\\n        boolean hasBetter = false;\\n        for (int j = 0; j < val; j++) {\\n            if (freq[j] != 0) {\\n                hasBetter = true;\\n            }\\n        }\\n        return hasBetter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        Deque<Character> dq = new ArrayDeque<>();\\n        char[] arr = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        int n = arr.length;\\n        \\n        int[] freq = new int[26];\\n        for (int i = 0; i < arr.length; i++) {\\n            freq[arr[i] - \\'a\\']++;\\n        }\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            // add current character to string t\\n            dq.addLast(arr[i]);\\n            // remove current character from frequency array\\n            freq[arr[i] - \\'a\\']--;\\n    \\n            // Check if there is a smaller character ahead in string s\\n            while (!dq.isEmpty()) {\\n                // if there are no better characters left in s\\n                if (!hasBetter(dq.peekLast(), freq)) {\\n                    // append last character in t\\n                    sb.append(dq.removeLast());\\n                } else {\\n                    // keep searching for better character in s\\n                    break;\\n                }                \\n            }\\n\\n        }\\n        \\n        // when string s is empty, only choice left is to append string t\\n        while (!dq.isEmpty()) {\\n            sb.append(dq.removeLast());\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    public boolean hasBetter(char c, int[] freq) {\\n        int val = c - \\'a\\';\\n        boolean hasBetter = false;\\n        for (int j = 0; j < val; j++) {\\n            if (freq[j] != 0) {\\n                hasBetter = true;\\n            }\\n        }\\n        return hasBetter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077284,
                "title": "just-ordinary-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$.\\n\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        CHAR, LASTIND = 0, 1\\n\\n        lastInds = {}\\n        for i, ch in enumerate(s):\\n            lastInds[ch] = i\\n        \\n        chars = sorted(lastInds.items())\\n        curChar = 0\\n        result = []\\n        stack = []\\n        i = 0\\n        while True:\\n            while stack and stack[-1] <= chars[curChar][CHAR]:\\n                result.append(stack.pop())\\n            \\n            while i <= chars[curChar][LASTIND]:\\n                if s[i] == chars[curChar][CHAR]:\\n                    result.append(s[i])\\n                else:\\n                    stack.append(s[i])\\n                \\n                i += 1\\n            \\n            if curChar == len(chars)-1:\\n                return \\'\\'.join(itertools.chain(result, reversed(stack)))\\n            \\n            curChar += 1\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        CHAR, LASTIND = 0, 1\\n\\n        lastInds = {}\\n        for i, ch in enumerate(s):\\n            lastInds[ch] = i\\n        \\n        chars = sorted(lastInds.items())\\n        curChar = 0\\n        result = []\\n        stack = []\\n        i = 0\\n        while True:\\n            while stack and stack[-1] <= chars[curChar][CHAR]:\\n                result.append(stack.pop())\\n            \\n            while i <= chars[curChar][LASTIND]:\\n                if s[i] == chars[curChar][CHAR]:\\n                    result.append(s[i])\\n                else:\\n                    stack.append(s[i])\\n                \\n                i += 1\\n            \\n            if curChar == len(chars)-1:\\n                return \\'\\'.join(itertools.chain(result, reversed(stack)))\\n            \\n            curChar += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075415,
                "title": "easy-stack-and-suffix-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        \\n        vector<char> suf(n);\\n        suf[n-1] = s[n-1];\\n        \\n        // to know whether the small alphabet exist ahead\\n        for(int i = n-2; i >= 0; i--){ \\n            suf[i] = min(s[i], suf[i+1]);\\n        }\\n        \\n        // stack as \"t\" string\\n        stack<char> st;\\n        string res;\\n\\t\\t\\n        for(int i=0;i<n;i++){  \\n\\t\\t\\n        // remove the current top element if there is no smaller element ahead of it and it is smaller/equal to current index , and add to result string \\n\\t\\t\\n            while(!st.empty() && st.top() <= s[i] && suf[i] >= st.top()){\\n                res.push_back(st.top());\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n        }\\n\\t\\t\\n\\t\\t// add the remaining characters in string\\n\\t\\t\\n        while(!st.empty()){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        \\n        vector<char> suf(n);\\n        suf[n-1] = s[n-1];\\n        \\n        // to know whether the small alphabet exist ahead\\n        for(int i = n-2; i >= 0; i--){ \\n            suf[i] = min(s[i], suf[i+1]);\\n        }\\n        \\n        // stack as \"t\" string\\n        stack<char> st;\\n        string res;\\n\\t\\t\\n        for(int i=0;i<n;i++){  \\n\\t\\t\\n        // remove the current top element if there is no smaller element ahead of it and it is smaller/equal to current index , and add to result string \\n\\t\\t\\n            while(!st.empty() && st.top() <= s[i] && suf[i] >= st.top()){\\n                res.push_back(st.top());\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n        }\\n\\t\\t\\n\\t\\t// add the remaining characters in string\\n\\t\\t\\n        while(!st.empty()){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978481,
                "title": "kotlin-stack-o-n",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun robotWithString(s: String): String {\\n        val n = s.length\\n        val minArray = CharArray(n)\\n        \\n        // initialize the min array where i-th element is the smallest char in [i,n]\\n        minArray[n - 1] = s[n - 1]\\n        for (i in s.lastIndex - 1 downTo 0) {\\n            minArray[i] = minOf(s[i], minArray[i + 1])\\n        }\\n\\n        val answer = StringBuilder()\\n        val stack = Stack<Char>()\\n\\n        // add chars to stack and pop the stack to the answer \\n        // if the top is less or equal to the current minimum to the right\\n        for (i in s.indices) {\\n            while (!stack.empty() && stack.peek() <= minArray[i]) {\\n                answer.append(stack.pop())\\n            }\\n            \\n            stack.push(s[i])\\n        }\\n\\n        // add the rest of the stack to the answer\\n        while (!stack.empty()) {\\n            answer.append(stack.pop())\\n        }\\n\\n        return answer.toString()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun robotWithString(s: String): String {\\n        val n = s.length\\n        val minArray = CharArray(n)\\n        \\n        // initialize the min array where i-th element is the smallest char in [i,n]\\n        minArray[n - 1] = s[n - 1]\\n        for (i in s.lastIndex - 1 downTo 0) {\\n            minArray[i] = minOf(s[i], minArray[i + 1])\\n        }\\n\\n        val answer = StringBuilder()\\n        val stack = Stack<Char>()\\n\\n        // add chars to stack and pop the stack to the answer \\n        // if the top is less or equal to the current minimum to the right\\n        for (i in s.indices) {\\n            while (!stack.empty() && stack.peek() <= minArray[i]) {\\n                answer.append(stack.pop())\\n            }\\n            \\n            stack.push(s[i])\\n        }\\n\\n        // add the rest of the stack to the answer\\n        while (!stack.empty()) {\\n            answer.append(stack.pop())\\n        }\\n\\n        return answer.toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855843,
                "title": "python-is-my-solution-easy-to-understand",
                "content": "We scan the string and find the last index of each alphabeta. Keep comparing the last character of the temp string `t` and the next larger character in the rest of the original string `s`. Based on the comparison results, we can have the following options: (1) append characters in the sting s to the temp string `t`. (2) pop out the last character in the temp string and write it down to the paper.\\n\\n\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        len_s = len(s)\\n        char_loc = dict()\\n        for idx, c in enumerate(s):\\n            char_loc[c] = idx\\n        \\n        char_sorted = sorted(list(char_loc.keys()))\\n        len_char_sorted = len(char_sorted) - 1\\n\\n        ans, t = \"\", []\\n        idx, sorted_cidx = 0, 0\\n        cur_min_c = char_sorted[sorted_cidx]\\n        cur_min_loc = char_loc[cur_min_c]\\n        \\n        while idx < len_s:\\n            while idx <= cur_min_loc:\\n                if s[idx] == cur_min_c:\\n                    ans += s[idx]\\n                else:\\n                    t.append(s[idx])\\n                idx += 1\\n\\n            while cur_min_loc < idx and sorted_cidx < len_char_sorted:\\n                sorted_cidx += 1\\n                cur_min_c = char_sorted[sorted_cidx]\\n                cur_min_loc = char_loc[cur_min_c]\\n\\n                while len(t) and t[-1] <= cur_min_c:\\n                    tc = t.pop()\\n                    ans += tc\\n        \\n        while len(t):\\n            tc = t.pop()\\n            ans += tc\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        len_s = len(s)\\n        char_loc = dict()\\n        for idx, c in enumerate(s):\\n            char_loc[c] = idx\\n        \\n        char_sorted = sorted(list(char_loc.keys()))\\n        len_char_sorted = len(char_sorted) - 1\\n\\n        ans, t = \"\", []\\n        idx, sorted_cidx = 0, 0\\n        cur_min_c = char_sorted[sorted_cidx]\\n        cur_min_loc = char_loc[cur_min_c]\\n        \\n        while idx < len_s:\\n            while idx <= cur_min_loc:\\n                if s[idx] == cur_min_c:\\n                    ans += s[idx]\\n                else:\\n                    t.append(s[idx])\\n                idx += 1\\n\\n            while cur_min_loc < idx and sorted_cidx < len_char_sorted:\\n                sorted_cidx += 1\\n                cur_min_c = char_sorted[sorted_cidx]\\n                cur_min_loc = char_loc[cur_min_c]\\n\\n                while len(t) and t[-1] <= cur_min_c:\\n                    tc = t.pop()\\n                    ans += tc\\n        \\n        while len(t):\\n            tc = t.pop()\\n            ans += tc\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839674,
                "title": "o-n-stack-based-solution-in-python",
                "content": "### Outline of the algorithm:\\n1. Find the rightmost min element **M** and its index **mi** in **s**. The resulting printed string will start with **M** (we can do that as we can put all elements up to **M** to stack and then print **M**). So we are now ready to print **M**. \\n2. Now put all elements from 0 to **mi** to stack except the elements equal to **M**, which we can directly append to the output. Now we have a stack of elements less than **M** which used to occupy indices from 0 to **mi**. \\n3. Now we can set current index to **mi**+1 and repeat the procedure with one caveat: now the stack potentially has some elements on top, which can be less that the next rightmost minimum, they should be printed before the next rightmost minimum.\\n4.  Repeat this until we reach the end of s string. At the end there might be some elements left in the stack, print them. \\n\\nO(n) time, O(n) space.\\n\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        # find rightmost min element in s starting from start\\n        def rightmostmin(s, start):\\n            # current min element\\n            m = s[start]\\n            # current min index\\n            i = start\\n            \\n            for j in range(start+1, len(s)):\\n                if s[j] <= m:\\n                    # update min element and index\\n                    m = s[j]\\n                    i = j\\n            \\n            return i, m\\n        \\n        stack = []\\n        result = []\\n        \\n        # current index in the string\\n        curr = 0\\n        while curr < len(s):\\n            # find rightmost min element in s staring from curr\\n            j, ch = rightmostmin(s, curr)\\n            \\n            # if there are elements in the stack which are smaller than \\n\\t\\t\\t# the element just found, print them\\n            while stack and stack[-1] <= ch:\\n                result.append(stack.pop())\\n\\n            # print min element itself\\n            result.append(ch)\\n            \\n            # now iterate up to the position of the min element just found putting everyting to stack\\n            # there might be other min elements on our way: print them right away\\n            for i in range(curr, j):\\n                if s[i] == ch:\\n                    # print the element if it is equal to the rightmost min\\n                    result.append(ch)\\n                else:\\n                    # put the rest to stack\\n                    stack.append(s[i])\\n\\n            # set current index to the one after the rightmost min\\n            curr = j+1\\n\\n            \\n        # there might be something left in the stack, print\\n        while stack:\\n            result.append(stack.pop())\\n            \\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        # find rightmost min element in s starting from start\\n        def rightmostmin(s, start):\\n            # current min element\\n            m = s[start]\\n            # current min index\\n            i = start\\n            \\n            for j in range(start+1, len(s)):\\n                if s[j] <= m:\\n                    # update min element and index\\n                    m = s[j]\\n                    i = j\\n            \\n            return i, m\\n        \\n        stack = []\\n        result = []\\n        \\n        # current index in the string\\n        curr = 0\\n        while curr < len(s):\\n            # find rightmost min element in s staring from curr\\n            j, ch = rightmostmin(s, curr)\\n            \\n            # if there are elements in the stack which are smaller than \\n\\t\\t\\t# the element just found, print them\\n            while stack and stack[-1] <= ch:\\n                result.append(stack.pop())\\n\\n            # print min element itself\\n            result.append(ch)\\n            \\n            # now iterate up to the position of the min element just found putting everyting to stack\\n            # there might be other min elements on our way: print them right away\\n            for i in range(curr, j):\\n                if s[i] == ch:\\n                    # print the element if it is equal to the rightmost min\\n                    result.append(ch)\\n                else:\\n                    # put the rest to stack\\n                    stack.append(s[i])\\n\\n            # set current index to the one after the rightmost min\\n            curr = j+1\\n\\n            \\n        # there might be something left in the stack, print\\n        while stack:\\n            result.append(stack.pop())\\n            \\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720662,
                "title": "easy-java-solution-only-for-beginners-stack-upvote",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        int[] cnt = new int[26];\\n\\n        for(int i = 0; i < n; i++){\\n            cnt[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        Stack<Character> st = new Stack<>();\\n\\n        StringBuilder ans = new StringBuilder();\\n\\n        for(int i = 0; i < n; i++){\\n            st.add(s.charAt(i));\\n            cnt[s.charAt(i) - \\'a\\']--;\\n            \\n            while(!st.isEmpty() && st.peek() <= getMin(cnt)){\\n                ans.append(st.pop());\\n            }\\n        }\\n\\n        while(!st.isEmpty()){\\n            ans.append(st.pop());\\n        }\\n\\n        return ans.toString();\\n    }\\n\\n    Character getMin(int[] cnt){\\n        for(int i = 0; i < 26; i++){\\n            if(cnt[i] != 0){\\n                return (char)(i + \\'a\\');\\n            }\\n        }\\n        return \\'A\\';\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        int[] cnt = new int[26];\\n\\n        for(int i = 0; i < n; i++){\\n            cnt[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        Stack<Character> st = new Stack<>();\\n\\n        StringBuilder ans = new StringBuilder();\\n\\n        for(int i = 0; i < n; i++){\\n            st.add(s.charAt(i));\\n            cnt[s.charAt(i) - \\'a\\']--;\\n            \\n            while(!st.isEmpty() && st.peek() <= getMin(cnt)){\\n                ans.append(st.pop());\\n            }\\n        }\\n\\n        while(!st.isEmpty()){\\n            ans.append(st.pop());\\n        }\\n\\n        return ans.toString();\\n    }\\n\\n    Character getMin(int[] cnt){\\n        for(int i = 0; i < 26; i++){\\n            if(cnt[i] != 0){\\n                return (char)(i + \\'a\\');\\n            }\\n        }\\n        return \\'A\\';\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713735,
                "title": "python-3-solution-using-stack-and-char-frequency-array",
                "content": "# Intuition\\nEven though the implementation does not restrict this but the problem description restricts us to use only two operations:\\n- Remove the first character of a string `s` and give it to the robot. The robot will append this character to the string `t`.\\n- Remove the last character of a string `t` and give it to the robot. The robot will write this character on `paper`.\\n\\nUsing above two operations and the knowledge of count of available letters in remaining `s`, we can pick the smallest letter first to write on the `paper` and process the remaning part of `s` with same logic. Also, need to keep in mind the edge case where top letter on `t` is smaller than the letter we are looking for.\\n\\n# Approach\\nIn simple logic we can think the solution as set of below steps:\\n- To make the string written on `paper` lexicographically smallest, we need to start from the smallest letter in the string and until we reach to this letter we can\\'t write anything on `paper` so we add it into `t`. To start with the smallest letter in `s` we have counted fequency of each letter and stored in an array of size 26, where value at index 0 indicates how many times $$a$$ is present in `s`.\\n- Now that we have reached to the smallest letter in `s` we can write it on `paper` using the two operations mentioned in problem statment.\\n- Again we check for the next smallest letter in the remaining string right side from current position and follow the first and second step.\\n- As an edge case, it is possible that the the letter we are looking for in the string `s` is actually bigger than the letter present at the top of `t`, so in this case we will keep on writing onto `paper` from top of `t` until `t` is empty or letter at top of `t` is bigger than the letter we are looking for. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nSince the outer loop always runs for 26 iterations and the inner while loops are all iterating over the same given string `s` covering each char in `s` only once.\\n\\n- Space complexity:\\n$$O(1)$$\\nSince `paper`, `t` and `s` are all considered part of the problem, their space consumption is not considered here (if considered the space complexity would be $$O(n)$$). Now, the only extra space we have consumed is for few variables and an array of size 26 which does not increase with input string length, so the space complexity is counted as $$O(1)$$ in worst case complexity analysis. \\n\\n# Code\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        ord_a = ord(\\'a\\')\\n        freqs = self.count_freqs(s)\\n        paper = []\\n        t = []\\n\\n        i = 0\\n        ci = 0\\n        while i < len(freqs):\\n            if freqs[i] <= 0:\\n                i += 1\\n            else:\\n                while t and ord(t[-1]) - ord_a <= i:\\n                    paper.append(t.pop())\\n\\n                while ord(s[ci]) - ord_a != i:\\n                    freqs[ord(s[ci]) - ord_a] -= 1\\n                    t.append(s[ci])\\n                    ci += 1\\n                \\n                freqs[ord(s[ci]) - ord_a] -= 1\\n                t.append(s[ci])\\n                ci += 1\\n\\n                paper.append(t.pop())\\n                \\n        while t:\\n            paper.append(t.pop())\\n        return \"\".join(paper)\\n\\n    def count_freqs(self, s: str) -> list:\\n        freqs = [0 for _ in range(26)]\\n        ord_a = ord(\\'a\\')\\n        for c in s:\\n            freqs[ord(c)-ord_a] += 1\\n        return freqs \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        ord_a = ord(\\'a\\')\\n        freqs = self.count_freqs(s)\\n        paper = []\\n        t = []\\n\\n        i = 0\\n        ci = 0\\n        while i < len(freqs):\\n            if freqs[i] <= 0:\\n                i += 1\\n            else:\\n                while t and ord(t[-1]) - ord_a <= i:\\n                    paper.append(t.pop())\\n\\n                while ord(s[ci]) - ord_a != i:\\n                    freqs[ord(s[ci]) - ord_a] -= 1\\n                    t.append(s[ci])\\n                    ci += 1\\n                \\n                freqs[ord(s[ci]) - ord_a] -= 1\\n                t.append(s[ci])\\n                ci += 1\\n\\n                paper.append(t.pop())\\n                \\n        while t:\\n            paper.append(t.pop())\\n        return \"\".join(paper)\\n\\n    def count_freqs(self, s: str) -> list:\\n        freqs = [0 for _ in range(26)]\\n        ord_a = ord(\\'a\\')\\n        for c in s:\\n            freqs[ord(c)-ord_a] += 1\\n        return freqs \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598517,
                "title": "c-stack",
                "content": "```\\npublic class Solution {\\n    public string RobotWithString(string s) {\\n        var res = new StringBuilder();\\n        var n = s.Length;\\n        var min = \\'a\\';\\n        var max = \\'z\\';\\n        var last = 0;\\n        var stack = new Stack<char>(n);\\n        for (int cur = min; cur <= max; cur++) {\\n            while(stack.Count > 0 && stack.Peek() <= cur) {\\n                var c = stack.Pop();\\n                res.Append(c);\\n            }\\n            for (var i = last; i < n; i++) {\\n                if (s[i] == cur) {\\n                    for (int j = last; j < i; j++) {\\n                        stack.Push(s[j]);\\n                    }\\n                    res.Append(s[i]);\\n                    last = i + 1;\\n                }\\n            }\\n        }\\n\\n        while(stack.Count > 0) {\\n            var c = stack.Pop();\\n            res.Append(c);\\n        }\\n\\n        return res.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RobotWithString(string s) {\\n        var res = new StringBuilder();\\n        var n = s.Length;\\n        var min = \\'a\\';\\n        var max = \\'z\\';\\n        var last = 0;\\n        var stack = new Stack<char>(n);\\n        for (int cur = min; cur <= max; cur++) {\\n            while(stack.Count > 0 && stack.Peek() <= cur) {\\n                var c = stack.Pop();\\n                res.Append(c);\\n            }\\n            for (var i = last; i < n; i++) {\\n                if (s[i] == cur) {\\n                    for (int j = last; j < i; j++) {\\n                        stack.Push(s[j]);\\n                    }\\n                    res.Append(s[i]);\\n                    last = i + 1;\\n                }\\n            }\\n        }\\n\\n        while(stack.Count > 0) {\\n            var c = stack.Pop();\\n            res.Append(c);\\n        }\\n\\n        return res.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507783,
                "title": "js-simple-and-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar robotWithString = function(s) {\\n    // Get the smallest key from counts\\n    const getMin = map => {\\n        let min = \\'z\\';\\n        for (const [key, val] of map) {\\n            if (val > 0 && key < min) {\\n                min = key;\\n            } \\n        }\\n\\n        return min;\\n    };\\n\\n    // Count ocurrences of every character\\n    const counts = new Map();\\n    for (const char of s) {\\n        counts.set(char, (counts.get(char) || 0) + 1);\\n    }\\n\\n    const output = [];\\n    const stack = [];\\n\\n    for (const char of s) {\\n        stack.push(char);\\n        counts.set(char, (counts.get(char) || 0) - 1);\\n\\n        // If there\\'s no smaller character than the current stack-top,\\n        // put the stack-top to the output\\n        while (stack.length && stack[stack.length - 1] <= getMin(counts)) {\\n            output.push(stack.pop());\\n        }\\n    }\\n\\n    // Process remainder of the stack\\n    while (stack.length) {\\n        output.push(stack.pop());\\n    }\\n\\n    return output.join(\\'\\');\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar robotWithString = function(s) {\\n    // Get the smallest key from counts\\n    const getMin = map => {\\n        let min = \\'z\\';\\n        for (const [key, val] of map) {\\n            if (val > 0 && key < min) {\\n                min = key;\\n            } \\n        }\\n\\n        return min;\\n    };\\n\\n    // Count ocurrences of every character\\n    const counts = new Map();\\n    for (const char of s) {\\n        counts.set(char, (counts.get(char) || 0) + 1);\\n    }\\n\\n    const output = [];\\n    const stack = [];\\n\\n    for (const char of s) {\\n        stack.push(char);\\n        counts.set(char, (counts.get(char) || 0) - 1);\\n\\n        // If there\\'s no smaller character than the current stack-top,\\n        // put the stack-top to the output\\n        while (stack.length && stack[stack.length - 1] <= getMin(counts)) {\\n            output.push(stack.pop());\\n        }\\n    }\\n\\n    // Process remainder of the stack\\n    while (stack.length) {\\n        output.push(stack.pop());\\n    }\\n\\n    return output.join(\\'\\');\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449834,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<int>v(26,0);\\n        stack<char>st;\\n        for (auto it:s)\\n        {\\n            v[it-\\'a\\']++;\\n        }\\n        int ind=0;\\n        string ans=\"\";\\n        for (int i=0;i<s.size();i++)\\n        {\\n            while(ind<26 && v[ind]==0)\\n            {\\n               ind++;\\n            }\\n            while(!st.empty() &&st.top()-\\'a\\'<=ind)\\n            {\\n                ans+=st.top();\\n                st.pop();\\n            }\\n\\n        if (s[i]==(ind+\\'a\\')) {v[ind]--;\\n        ans+=s[i];}\\n            else{\\n                v[s[i]-\\'a\\']--;\\n                st.push(s[i]);\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<int>v(26,0);\\n        stack<char>st;\\n        for (auto it:s)\\n        {\\n            v[it-\\'a\\']++;\\n        }\\n        int ind=0;\\n        string ans=\"\";\\n        for (int i=0;i<s.size();i++)\\n        {\\n            while(ind<26 && v[ind]==0)\\n            {\\n               ind++;\\n            }\\n            while(!st.empty() &&st.top()-\\'a\\'<=ind)\\n            {\\n                ans+=st.top();\\n                st.pop();\\n            }\\n\\n        if (s[i]==(ind+\\'a\\')) {v[ind]--;\\n        ans+=s[i];}\\n            else{\\n                v[s[i]-\\'a\\']--;\\n                st.push(s[i]);\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400943,
                "title": "stack-solution",
                "content": "```\\n//function to check curr smaller element  \\nchar check(vector<int>&alpha){\\n       \\n        for(int i=0;i<26;i++){\\n            if(alpha[i] > 0){\\n                return char(i+\\'a\\');\\n            }\\n        }\\n        return \\'a\\';\\n    }\\n    string robotWithString(string s) {\\n\\t//we  maintain a alpha arr which is freq of chars in string s.\\n        vector<int>alpha(26,0);\\n        for(char c:s){\\n            alpha[c-\\'a\\']++;\\n        }\\n      \\n        stack<char>st;\\n        string ans=\"\";\\n\\t\\t//we will push the char into stack & decrease the freq & check if stack\\'s top char is smaller than curr smaller chatr from remaining elements we add it to the string.\\n        for(int i=0;i<s.size();i++){\\n        \\n               st.push(s[i]);\\n             alpha[s[i]-\\'a\\']--;\\n           while(!st.empty() && st.top() <= check(alpha)){\\n             \\n                ans+=st.top();\\n              st.pop();\\n           }\\n            \\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n//function to check curr smaller element  \\nchar check(vector<int>&alpha){\\n       \\n        for(int i=0;i<26;i++){\\n            if(alpha[i] > 0){\\n                return char(i+\\'a\\');\\n            }\\n        }\\n        return \\'a\\';\\n    }\\n    string robotWithString(string s) {\\n\\t//we  maintain a alpha arr which is freq of chars in string s.\\n        vector<int>alpha(26,0);\\n        for(char c:s){\\n            alpha[c-\\'a\\']++;\\n        }\\n      \\n        stack<char>st;\\n        string ans=\"\";\\n\\t\\t//we will push the char into stack & decrease the freq & check if stack\\'s top char is smaller than curr smaller chatr from remaining elements we add it to the string.\\n        for(int i=0;i<s.size();i++){\\n        \\n               st.push(s[i]);\\n             alpha[s[i]-\\'a\\']--;\\n           while(!st.empty() && st.top() <= check(alpha)){\\n             \\n                ans+=st.top();\\n              st.pop();\\n           }\\n            \\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3400170,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn robot_with_string(s: String) -> String {\\n        fn has_smaller(c: char, freq: &[i32]) -> bool {\\n            let bound = c as usize - \\'a\\' as usize;\\n            for i in 0..bound {\\n                if freq[i] > 0 {\\n                    return true;\\n                }\\n            }\\n            false\\n        }\\n\\n        let s = s.chars().collect::<Vec<_>>();\\n        let mut freq = vec![0; 26];\\n        for i in 0..s.len() {\\n            freq[s[i] as usize - \\'a\\' as usize] += 1;\\n        }\\n\\n        let mut res = String::new();\\n        let mut stack = vec![];\\n\\n        for i in 0..s.len() {\\n            freq[s[i] as usize - \\'a\\' as usize] -= 1;\\n            stack.push(s[i]);\\n            while !stack.is_empty() && !has_smaller(*stack.last().unwrap(), &freq) {\\n                res.push(stack.pop().unwrap());\\n            }\\n        }\\n        while let Some(c) = stack.pop() {\\n            res.push(c);\\n        }\\n        res     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn robot_with_string(s: String) -> String {\\n        fn has_smaller(c: char, freq: &[i32]) -> bool {\\n            let bound = c as usize - \\'a\\' as usize;\\n            for i in 0..bound {\\n                if freq[i] > 0 {\\n                    return true;\\n                }\\n            }\\n            false\\n        }\\n\\n        let s = s.chars().collect::<Vec<_>>();\\n        let mut freq = vec![0; 26];\\n        for i in 0..s.len() {\\n            freq[s[i] as usize - \\'a\\' as usize] += 1;\\n        }\\n\\n        let mut res = String::new();\\n        let mut stack = vec![];\\n\\n        for i in 0..s.len() {\\n            freq[s[i] as usize - \\'a\\' as usize] -= 1;\\n            stack.push(s[i]);\\n            while !stack.is_empty() && !has_smaller(*stack.last().unwrap(), &freq) {\\n                res.push(stack.pop().unwrap());\\n            }\\n        }\\n        while let Some(c) = stack.pop() {\\n            res.push(c);\\n        }\\n        res     \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3287278,
                "title": "python-two-approaches",
                "content": "# **1. USING A DICTIONARY**\\n\\nOne thing that we can understand from the examples is that, we can only move any character from the end of \"t\" to the paper, if we are sure that there is no smaller character after it in \"s\".\\n\\nAnd that\\'s the whole idea of using a dictionary. \\n\\nWe can keep a count of each character in the string \"s\" such that at any time, we can check whether there are any smaller characters on the right of any particular character in \"s\". If not, we can safely move that character to the paper. Otherwise, it makes sense to hold that character in \"t\" and first push the smaller character to paper which is on the right.\\n\\nSo this is a greedy approach where at any point, we want to make sure current character is the smallest among all the characters on the right side. This will ensure that the final output is the Lexicographically smallest string.\\n\\n\\n```\\ndef robotWithString(self, s: str) -> str:\\n        t = []\\n        output = []\\n        \\n        # To keep the count of each character in the string \"s\"\\n        # So that, as we push a chracter to stack \"t\", we will also reduce its count\\n        # This way, at any time, we can check if there is a smaller character present after any character in \"s\"\\n        freq = {}\\n        for c in s: freq[c] = freq.get(c,0) + 1\\n\\n        for c in s:\\n            # Push the current character to the stack\\n            t.append(c)\\n            \\n            # Also reduce its count\\n            freq[c] -= 1\\n            \\n            # If the count becomes 0\\n            if freq[c]== 0: freq.pop(c)\\n                \\n            # We can push the current character to output string\\n            # If we are sure there is no smaller character left in the dictonary\\n            while t and freq and min(freq) >= t[-1]: output.append(t.pop())\\n                \\n        # IF \"t\" is not yet empty\\n        while t: output.append(t.pop()) \\n            \\n        return \"\".join(output)\\n```\\n\\n# **2. PRE-COMPUTE SMALLEST CHARACTER ON RIGHT**\\n\\nTo improve the code, we can pre compute the smallest character on the right side of each character. \\n\\n\\tFor Example, take \"bac\"\\n\\t\\n\\tIf we take smallest on right, our array will be like -> [\"a\", \"c\", \"z\"]\\n\\t\\n\\tIt simply means, the smallest on right of \"b\" is \"a\". \\n\\t\\n\\tThe smallest on the right of \"a\" is \"c\" (since c is the only character on right of \"a\") \\n\\t\\n\\tAnd since c is the last character, for it, the smallest on right is set as \"z\".\\n\\t\\n\\tNow, we iterate over our string \"bac\" and in each iteration, we push the current string to the stack \"t\"\\n\\t\\n\\tSo first, we push \"b\". t becomes [\"b\"]\\n\\t\\n\\tNow, before we move on to next character, \\n\\twe will check if we can safely write this character or any characters before on the paper.\\n\\t\\n\\tAnd as we saw in first approach, we can do so only if we are sure that there are no smaller characters than it on right side.\\n\\t\\n\\tAnd here, we will make use of our pre-computed data. \\n\\t\\n\\tWe can only move current character to paper if the smallest character on its right is >= to it. \\n\\tOr basically, if there is no smaller character on right.\\n\\n\\n```\\ndef robotWithString(self, s: str) -> str:\\n        # Output string that we have to return\\n        output = []\\n        \\n        # First, find the smallest character on right of each character\\n        # If there is no smaller character on right of any character, \"z\" will be the default value for that\\n        # This will be the case with the last character since there are no characters to its right\\n        smallestOnRight = [\"z\"] * len(s) \\n        \\n        smallest = \"z\"\\n        n = len(s)\\n        \\n        for i in range(n - 1, -1, -1):\\n            smallestOnRight[i] = smallest\\n            smallest = min(smallest, s[i])\\n        \\n        # Now once we get the smallest character on right of each character\\n        # We can start with the main logic of pushing the character to \"t\" and from \"t\" to paper\\n        t = []\\n        for i in range(n):\\n            # Push current character\\'s index to \"t\"\\n            t.append(i)\\n            \\n            # Now, if there is no smaller character on right\\n            # We can safely write it on the paper\\n            while t and smallestOnRight[i] >= s[t[-1]]: \\n                output.append(s[t.pop()])\\n            \\n        # If t is not yet empty\\n        while t: output.append(s[t.pop()])\\n        \\n        return \"\".join(output)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef robotWithString(self, s: str) -> str:\\n        t = []\\n        output = []\\n        \\n        # To keep the count of each character in the string \"s\"\\n        # So that, as we push a chracter to stack \"t\", we will also reduce its count\\n        # This way, at any time, we can check if there is a smaller character present after any character in \"s\"\\n        freq = {}\\n        for c in s: freq[c] = freq.get(c,0) + 1\\n\\n        for c in s:\\n            # Push the current character to the stack\\n            t.append(c)\\n            \\n            # Also reduce its count\\n            freq[c] -= 1\\n            \\n            # If the count becomes 0\\n            if freq[c]== 0: freq.pop(c)\\n                \\n            # We can push the current character to output string\\n            # If we are sure there is no smaller character left in the dictonary\\n            while t and freq and min(freq) >= t[-1]: output.append(t.pop())\\n                \\n        # IF \"t\" is not yet empty\\n        while t: output.append(t.pop()) \\n            \\n        return \"\".join(output)\\n```\n```\\ndef robotWithString(self, s: str) -> str:\\n        # Output string that we have to return\\n        output = []\\n        \\n        # First, find the smallest character on right of each character\\n        # If there is no smaller character on right of any character, \"z\" will be the default value for that\\n        # This will be the case with the last character since there are no characters to its right\\n        smallestOnRight = [\"z\"] * len(s) \\n        \\n        smallest = \"z\"\\n        n = len(s)\\n        \\n        for i in range(n - 1, -1, -1):\\n            smallestOnRight[i] = smallest\\n            smallest = min(smallest, s[i])\\n        \\n        # Now once we get the smallest character on right of each character\\n        # We can start with the main logic of pushing the character to \"t\" and from \"t\" to paper\\n        t = []\\n        for i in range(n):\\n            # Push current character\\'s index to \"t\"\\n            t.append(i)\\n            \\n            # Now, if there is no smaller character on right\\n            # We can safely write it on the paper\\n            while t and smallestOnRight[i] >= s[t[-1]]: \\n                output.append(s[t.pop()])\\n            \\n        # If t is not yet empty\\n        while t: output.append(s[t.pop()])\\n        \\n        return \"\".join(output)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3283129,
                "title": "c-monotonic-stack-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        map<char, int> m;\\n        for (auto& c : s) ++m[c];\\n        string ans = \"\";\\n        string storage = \"\";\\n        // monotonic stack\\n        for (auto& c : s){\\n            char smallest = m.begin()->first;\\n            if (c == smallest) ans += c;\\n            else storage += c;\\n            if (--m[c] == 0) m.erase(c);\\n            if (!m.empty()){\\n                smallest = m.begin()->first;\\n                while (!storage.empty() && storage.back() <= smallest){\\n                    ans += storage.back();\\n                    storage.pop_back();\\n                }\\n            }\\n        }\\n        reverse(storage.begin(), storage.end());\\n        return ans + storage;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        map<char, int> m;\\n        for (auto& c : s) ++m[c];\\n        string ans = \"\";\\n        string storage = \"\";\\n        // monotonic stack\\n        for (auto& c : s){\\n            char smallest = m.begin()->first;\\n            if (c == smallest) ans += c;\\n            else storage += c;\\n            if (--m[c] == 0) m.erase(c);\\n            if (!m.empty()){\\n                smallest = m.begin()->first;\\n                while (!storage.empty() && storage.back() <= smallest){\\n                    ans += storage.back();\\n                    storage.pop_back();\\n                }\\n            }\\n        }\\n        reverse(storage.begin(), storage.end());\\n        return ans + storage;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270904,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n=s.length();\\n        vector<char>mn(n);\\n        mn[n-1]=s[n-1];\\n        char m=s[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]<m)\\n            {\\n                m=s[i];\\n            }\\n            mn[i]=m;\\n        }\\n        string t=\"\";\\n        string ans=\"\";\\n        t+=s[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(t.length()==0 || s[i]<=t.back() )\\n            {\\n                t+=s[i];\\n            }\\n            else\\n            {\\n                while(true)\\n                {\\n                     if(t.length()!=0 && mn[i]<t.back())\\n                     {\\n                         t+=s[i];\\n                         break;\\n                     }\\n                    else\\n                    {\\n                         if(t.length()==0 || t.back()>s[i])\\n                         {\\n                             i--;\\n                             break;\\n                         }\\n                         ans+=t.back();\\n                         t.pop_back();\\n                    }    \\n                 }   \\n            }       \\n         }\\n        \\n        for(int i=t.length()-1;i>=0;i--)\\n        {\\n            ans+=t[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n=s.length();\\n        vector<char>mn(n);\\n        mn[n-1]=s[n-1];\\n        char m=s[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]<m)\\n            {\\n                m=s[i];\\n            }\\n            mn[i]=m;\\n        }\\n        string t=\"\";\\n        string ans=\"\";\\n        t+=s[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(t.length()==0 || s[i]<=t.back() )\\n            {\\n                t+=s[i];\\n            }\\n            else\\n            {\\n                while(true)\\n                {\\n                     if(t.length()!=0 && mn[i]<t.back())\\n                     {\\n                         t+=s[i];\\n                         break;\\n                     }\\n                    else\\n                    {\\n                         if(t.length()==0 || t.back()>s[i])\\n                         {\\n                             i--;\\n                             break;\\n                         }\\n                         ans+=t.back();\\n                         t.pop_back();\\n                    }    \\n                 }   \\n            }       \\n         }\\n        \\n        for(int i=t.length()-1;i>=0;i--)\\n        {\\n            ans+=t[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241800,
                "title": "stack-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.length();\\n        vector<char> suffix(n);\\n        suffix[n-1] = s[n-1];\\n        for(int i = n-2; i>=0; i--){\\n            suffix[i] = min(s[i], suffix[i+1]);\\n        }\\n\\n        string paper;\\n        stack<char> st;\\n        int i = 0;\\n        while(i < n){\\n            if(st.size() == 0){\\n                st.push(s[i]);\\n                i++;\\n                continue;\\n            }\\n\\n            if(st.top() <= suffix[i]){\\n                paper+=st.top();\\n                st.pop();\\n            } else{\\n                st.push(s[i]);\\n                i++;\\n            }\\n        }\\n\\n        while(st.size() > 0){\\n            paper += st.top();\\n            st.pop();\\n        }\\n\\n        return paper;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.length();\\n        vector<char> suffix(n);\\n        suffix[n-1] = s[n-1];\\n        for(int i = n-2; i>=0; i--){\\n            suffix[i] = min(s[i], suffix[i+1]);\\n        }\\n\\n        string paper;\\n        stack<char> st;\\n        int i = 0;\\n        while(i < n){\\n            if(st.size() == 0){\\n                st.push(s[i]);\\n                i++;\\n                continue;\\n            }\\n\\n            if(st.top() <= suffix[i]){\\n                paper+=st.top();\\n                st.pop();\\n            } else{\\n                st.push(s[i]);\\n                i++;\\n            }\\n        }\\n\\n        while(st.size() > 0){\\n            paper += st.top();\\n            st.pop();\\n        }\\n\\n        return paper;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210404,
                "title": "2434-funcoding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrefer to https://leetcode.com/problems/using-a-robot-to-print-the-lexicographically-smallest-string/solutions/2678810/counter/ and the 1st comment\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        p = []\\n        t = []\\n        counts = Counter(s)\\n        low = \\'a\\'\\n\\n        for char in s:\\n            t += char\\n            counts[char] -= 1\\n\\n            while low < \\'z\\' and counts[low] == 0:\\n                low = chr(ord(low) + 1)\\n            while t and t[-1] <= low:\\n                p += t.pop()\\n\\n        return \\'\\'.join(p)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        p = []\\n        t = []\\n        counts = Counter(s)\\n        low = \\'a\\'\\n\\n        for char in s:\\n            t += char\\n            counts[char] -= 1\\n\\n            while low < \\'z\\' and counts[low] == 0:\\n                low = chr(ord(low) + 1)\\n            while t and t[-1] <= low:\\n                p += t.pop()\\n\\n        return \\'\\'.join(p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203470,
                "title": "c-o-n-record-smallest-index-start-from-i-to-s-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RobotWithString(string s) {\\n        int[] f = new int[s.Length];\\n        for(int i=s.Length-1; i >= 0; i--)\\n        {\\n            if(i == s.Length - 1)\\n            {\\n                f[i] = s.Length - 1;\\n            }\\n            else\\n            {\\n                if(s[i] <= s[f[i+1]])\\n                {\\n                    f[i] = i;\\n                }\\n                else\\n                {\\n                    f[i] = f[i+1];\\n                }\\n            }\\n        }\\n\\n        Stack<char> t = new Stack<char>();\\n        var builder = new StringBuilder();\\n        int lowPos = f[0];\\n        for(int i=0; i < s.Length; i++)\\n        {\\n            if(i > lowPos)\\n            {\\n                lowPos = f[i];\\n                while(t.Count > 0 && t.Peek() <= s[lowPos])\\n                {\\n                    char c = t.Pop();\\n                    builder.Append(c);\\n                }\\n            }\\n            t.Push(s[i]);\\n        }\\n\\n        while (t.Count > 0)\\n        {\\n            builder.Append(t.Pop());\\n        }\\n        return builder.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RobotWithString(string s) {\\n        int[] f = new int[s.Length];\\n        for(int i=s.Length-1; i >= 0; i--)\\n        {\\n            if(i == s.Length - 1)\\n            {\\n                f[i] = s.Length - 1;\\n            }\\n            else\\n            {\\n                if(s[i] <= s[f[i+1]])\\n                {\\n                    f[i] = i;\\n                }\\n                else\\n                {\\n                    f[i] = f[i+1];\\n                }\\n            }\\n        }\\n\\n        Stack<char> t = new Stack<char>();\\n        var builder = new StringBuilder();\\n        int lowPos = f[0];\\n        for(int i=0; i < s.Length; i++)\\n        {\\n            if(i > lowPos)\\n            {\\n                lowPos = f[i];\\n                while(t.Count > 0 && t.Peek() <= s[lowPos])\\n                {\\n                    char c = t.Pop();\\n                    builder.Append(c);\\n                }\\n            }\\n            t.Push(s[i]);\\n        }\\n\\n        while (t.Count > 0)\\n        {\\n            builder.Append(t.Pop());\\n        }\\n        return builder.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163825,
                "title": "c-easy-soln-adding-lexo-smallest",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain two strings keep adding lexo smallest with the help of map.\\nMap will have lexo smallest at the top.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n $$O(n)+O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string v=\"\", a=\"\";\\n        map<char, int> mp;\\n        for(auto i : s) mp[i]++;\\n        for(int i=0;i<s.size();i++){\\n            while(a.size() and a.back() <= mp.begin()->first){\\n                v+=a.back();\\n                a.pop_back();\\n            }\\n            if(mp.begin()->first==s[i]) v+=s[i];\\n            else a+=s[i];\\n            mp[s[i]]--;\\n            if(mp[s[i]]==0) mp.erase(s[i]);\\n        }\\n        reverse(begin(a), end(a));\\n        return v+a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string v=\"\", a=\"\";\\n        map<char, int> mp;\\n        for(auto i : s) mp[i]++;\\n        for(int i=0;i<s.size();i++){\\n            while(a.size() and a.back() <= mp.begin()->first){\\n                v+=a.back();\\n                a.pop_back();\\n            }\\n            if(mp.begin()->first==s[i]) v+=s[i];\\n            else a+=s[i];\\n            mp[s[i]]--;\\n            if(mp[s[i]]==0) mp.erase(s[i]);\\n        }\\n        reverse(begin(a), end(a));\\n        return v+a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037870,
                "title": "python3-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n\\n        my_dict = {}\\n        for i in range(len(s)):\\n            if s[i] not in my_dict:\\n                my_dict[s[i]] = []\\n            my_dict[s[i]].append(i)\\n        \\n        res = []\\n        pre = 0\\n        stack = []\\n        for i in range(26):\\n            cur_char = chr(ord(\\'a\\') + i)\\n            if cur_char not in my_dict:\\n                continue\\n            \\n            for p_index in my_dict[cur_char]:\\n                if p_index < pre:\\n                    continue\\n                while len(stack) != 0 and ord(stack[len(stack)-1]) <= ord(cur_char):\\n                    res.append(stack.pop())\\n                res.append(cur_char)\\n                \\n                while pre < p_index:\\n                    stack.append(s[pre])\\n                    pre += 1\\n                pre = p_index+1\\n        \\n        while len(stack) != 0:\\n            res.append(stack.pop())\\n    \\n        print(res)\\n        return \"\".join(res)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n\\n        my_dict = {}\\n        for i in range(len(s)):\\n            if s[i] not in my_dict:\\n                my_dict[s[i]] = []\\n            my_dict[s[i]].append(i)\\n        \\n        res = []\\n        pre = 0\\n        stack = []\\n        for i in range(26):\\n            cur_char = chr(ord(\\'a\\') + i)\\n            if cur_char not in my_dict:\\n                continue\\n            \\n            for p_index in my_dict[cur_char]:\\n                if p_index < pre:\\n                    continue\\n                while len(stack) != 0 and ord(stack[len(stack)-1]) <= ord(cur_char):\\n                    res.append(stack.pop())\\n                res.append(cur_char)\\n                \\n                while pre < p_index:\\n                    stack.append(s[pre])\\n                    pre += 1\\n                pre = p_index+1\\n        \\n        while len(stack) != 0:\\n            res.append(stack.pop())\\n    \\n        print(res)\\n        return \"\".join(res)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031614,
                "title": "stack-no-counter-solution-python",
                "content": "**Time: O(n)\\nSpace: O(n)**\\n```\\ndef robotWithString(self, s: str) -> str:\\n    n = len(s)\\n\\n    Min = [n-1]*(n+1)\\n    for i in range(n - 1, -1, -1):\\n        Min[i] = min(i, Min[i+1], key=lambda j: (s[j], j))\\n\\n    i = 0\\n    stack = []\\n    output = \"\"\\n    while i < n:\\n        if stack and stack[-1] <= s[Min[i]]:\\n            output += stack.pop()\\n        elif Min[i] >= i:\\n            stack.append(s[i])\\n            i += 1\\n\\n    return output + \"\".join(stack[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\ndef robotWithString(self, s: str) -> str:\\n    n = len(s)\\n\\n    Min = [n-1]*(n+1)\\n    for i in range(n - 1, -1, -1):\\n        Min[i] = min(i, Min[i+1], key=lambda j: (s[j], j))\\n\\n    i = 0\\n    stack = []\\n    output = \"\"\\n    while i < n:\\n        if stack and stack[-1] <= s[Min[i]]:\\n            output += stack.pop()\\n        elif Min[i] >= i:\\n            stack.append(s[i])\\n            i += 1\\n\\n    return output + \"\".join(stack[::-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3000694,
                "title": "c-easy-fast-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char minValue(vector<int> &freq)\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            if(freq[i]!=0)\\n                return (\\'a\\'+i);\\n        }\\n        return \\'a\\';\\n    }\\n    string robotWithString(string s) {\\n        vector<int> freq(26,0);\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            freq[s[i]-\\'a\\']++;\\n        }\\n\\n        string ans=\"\";\\n        stack<char> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.push(s[i]);\\n            freq[s[i]-\\'a\\']--;\\n\\n            while(st.empty()==false and st.top()<=minValue(freq))\\n            {\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char minValue(vector<int> &freq)\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            if(freq[i]!=0)\\n                return (\\'a\\'+i);\\n        }\\n        return \\'a\\';\\n    }\\n    string robotWithString(string s) {\\n        vector<int> freq(26,0);\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            freq[s[i]-\\'a\\']++;\\n        }\\n\\n        string ans=\"\";\\n        stack<char> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.push(s[i]);\\n            freq[s[i]-\\'a\\']--;\\n\\n            while(st.empty()==false and st.top()<=minValue(freq))\\n            {\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989590,
                "title": "simple-approach-using-stack-vector-and-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nthe approach is to keep track of the smallest char which is present on the right side of the index \\n\\nwe will create a vector v to store the smallest char for the index i\\nfor example -> s=\"edabdabc\"\\nthen v=[a,a,a,a,a,b,c,|];\\n\\nwe will take the last element to be \\'|\\' as its ascii value is higher than all the all the lowercase elements\\n \\n\\nfor the robot we will create a stack st;\\n\\nnow we will one by one put each char to stack \\'st\\' and at each step check whether the topmost element is smaller than all the element after it , if it is then we will add it to the answer ;\\ni.e  condition is (st.top()<=v[i]);\\n\\ni  |     stack st     |     v[i]    |    ans     condition\\n\\n0  |     {e}          |     a       |    \"\"     not matched\\n\\n1  |     {e,d}        |     a       |    \"\"     not matched\\n\\n2  |     {e,d,a}      |     a       |    \"a\"   matched so add and pop\\n\\n3  |     {e,d,b}      |     a       |    \"a\"    not matched\\n\\n4  |     {e,d,b,d}    |     a       |    \"a\"    not matched\\n\\n5  |     {e,d,b,d,a}  |     b       |    \"aa\"  matched so add and pop\\n\\n6  |     {e,d,b,d,b}  |     c       |    \"aab\" matched so add and pop\\n\\n7  |     {e,d,b,d,c}  |     |       |    \"aabc\"\\n\\n7  |     {e,d,b,d}    |     |       |    \"aabcd\"\\n\\n7  |     {e,d,b}      |     |       |    \"aabcdb\"\\n\\n7  |     {e,d}        |     |       |    \"aabcdbd\"\\n\\n7  |     {e}          |     |       |    \"aabcdbde\"\\n\\nstack is empty and the j==s.length();\\nso the required solution is achieved; \\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<char> v(s.length(),0);\\n        char mi=\\'|\\';\\n        for(int i=s.length()-1;i>0;i--){\\n            if(s[i]-\\'a\\'<mi-\\'a\\'){\\n                mi=s[i];\\n                v[i-1]=s[i];\\n            }\\n            else{\\n                v[i-1]=v[i];\\n            }\\n        }\\n        v[s.length()-1]=\\'|\\';\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++){\\n            st.push(s[i]);\\n            while(!st.empty() && st.top()<=v[i] ){\\n                ans+=st.top();\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<char> v(s.length(),0);\\n        char mi=\\'|\\';\\n        for(int i=s.length()-1;i>0;i--){\\n            if(s[i]-\\'a\\'<mi-\\'a\\'){\\n                mi=s[i];\\n                v[i-1]=s[i];\\n            }\\n            else{\\n                v[i-1]=v[i];\\n            }\\n        }\\n        v[s.length()-1]=\\'|\\';\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++){\\n            st.push(s[i]);\\n            while(!st.empty() && st.top()<=v[i] ){\\n                ans+=st.top();\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983260,
                "title": "c",
                "content": "```\\nchar * robotWithString(char * s){\\n    int n = strlen(s);\\n    char* ans = malloc((n+1) * sizeof(char));\\n    ans[n] = \\'\\\\0\\' ;\\n    int a_idx = 0;\\n    char* t = malloc(n * sizeof(char));\\n    int t_idx = 0;\\n    char lower = \\'a\\';\\n    int min_idx = 0;\\n    int begin = 0;\\n    while(begin < n){\\n        char min = s[begin]; \\n        min_idx = begin;\\n        //find minimum c in s, save it to lower\\n        for(int i = begin ; i < n; i++){\\n            if(s[i] == lower){\\n                min_idx = i;\\n                min = lower;\\n                break;\\n            }\\n            else if(s[i] < min){\\n                min = s[i];\\n                min_idx = i;\\n            }\\n        }\\n        lower = s[min_idx];\\n        //if t stack is empty, print the lower\\n        if(t_idx == 0){\\n            ans[a_idx] = lower;\\n            a_idx++;\\n            for(int j = begin ; j < min_idx; j++){\\n                t[t_idx] = s[j];\\n                t_idx++;\\n            }\\n        }        \\n        //t is not empty\\n        //  1. check if top of t is <= lower\\n        //  2. if yes, pop t out to ans\\n        //  3. put lower to ans\\n        //  4. push begin ~ min_idx  to t\\n        else{\\n            while(t_idx >= 0){\\n                if(t_idx > 0 && t[t_idx-1] <= s[min_idx]){\\n                    ans[a_idx] = t[t_idx-1];\\n                    a_idx++;\\n                    t_idx--;\\n                }\\n                else{\\n                    ans[a_idx] = s[min_idx];\\n                    a_idx++;\\n                    for(int j = begin; j < min_idx; j++){\\n                        t[t_idx] = s[j];\\n                        t_idx++;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        begin = min_idx + 1;\\n    }\\n    //pop t to ans\\n    for(int i = t_idx-1; i >=0; i--){\\n        ans[a_idx] = t[i];\\n        a_idx++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * robotWithString(char * s){\\n    int n = strlen(s);\\n    char* ans = malloc((n+1) * sizeof(char));\\n    ans[n] = \\'\\\\0\\' ;\\n    int a_idx = 0;\\n    char* t = malloc(n * sizeof(char));\\n    int t_idx = 0;\\n    char lower = \\'a\\';\\n    int min_idx = 0;\\n    int begin = 0;\\n    while(begin < n){\\n        char min = s[begin]; \\n        min_idx = begin;\\n        //find minimum c in s, save it to lower\\n        for(int i = begin ; i < n; i++){\\n            if(s[i] == lower){\\n                min_idx = i;\\n                min = lower;\\n                break;\\n            }\\n            else if(s[i] < min){\\n                min = s[i];\\n                min_idx = i;\\n            }\\n        }\\n        lower = s[min_idx];\\n        //if t stack is empty, print the lower\\n        if(t_idx == 0){\\n            ans[a_idx] = lower;\\n            a_idx++;\\n            for(int j = begin ; j < min_idx; j++){\\n                t[t_idx] = s[j];\\n                t_idx++;\\n            }\\n        }        \\n        //t is not empty\\n        //  1. check if top of t is <= lower\\n        //  2. if yes, pop t out to ans\\n        //  3. put lower to ans\\n        //  4. push begin ~ min_idx  to t\\n        else{\\n            while(t_idx >= 0){\\n                if(t_idx > 0 && t[t_idx-1] <= s[min_idx]){\\n                    ans[a_idx] = t[t_idx-1];\\n                    a_idx++;\\n                    t_idx--;\\n                }\\n                else{\\n                    ans[a_idx] = s[min_idx];\\n                    a_idx++;\\n                    for(int j = begin; j < min_idx; j++){\\n                        t[t_idx] = s[j];\\n                        t_idx++;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        begin = min_idx + 1;\\n    }\\n    //pop t to ans\\n    for(int i = t_idx-1; i >=0; i--){\\n        ans[a_idx] = t[i];\\n        a_idx++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2896629,
                "title": "simple-approach-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<char> mn(s.length(),s.back());\\n        for(int i=s.length()-2;i>=0;i--)\\n            mn[i]=min(mn[i+1],s[i]);\\n        \\n        stack<char> t;\\n        string ans;\\n        \\n        for(int i=0;i<s.length();i++){\\n            while(t.size() and t.top()<=mn[i]){\\n                ans.push_back(t.top());\\n                t.pop();\\n            }\\n            t.push(s[i]);    \\n        }\\n        \\n        while(t.size()){\\n            ans.push_back(t.top());\\n            t.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<char> mn(s.length(),s.back());\\n        for(int i=s.length()-2;i>=0;i--)\\n            mn[i]=min(mn[i+1],s[i]);\\n        \\n        stack<char> t;\\n        string ans;\\n        \\n        for(int i=0;i<s.length();i++){\\n            while(t.size() and t.top()<=mn[i]){\\n                ans.push_back(t.top());\\n                t.pop();\\n            }\\n            t.push(s[i]);    \\n        }\\n        \\n        while(t.size()){\\n            ans.push_back(t.top());\\n            t.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815671,
                "title": "c-use-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string res;\\n        string mins = s; \\n        int n = s.size();\\n        mins[n-1] = s[n-1];\\n        for(int i=n-2; i>=0; i--)\\n            mins[i] = min(s[i], mins[i+1]);\\n        stack<char> sc;\\n        int i = 0;\\n        while(i<n)\\n        {\\n\\t\\t\\tif (i<n && (sc.size() == 0 || mins[i] < sc.top()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint tmp = mins[i];\\n\\t\\t\\t\\twhile(i<n)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsc.push(s[i]);\\n\\t\\t\\t\\t\\tif (s[i] == tmp)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tres.push_back(sc.top());\\n\\t\\t\\tsc.pop();\\n        }\\n        while(sc.size() != 0)\\n        {\\n            res.push_back(sc.top());\\n            sc.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string res;\\n        string mins = s; \\n        int n = s.size();\\n        mins[n-1] = s[n-1];\\n        for(int i=n-2; i>=0; i--)\\n            mins[i] = min(s[i], mins[i+1]);\\n        stack<char> sc;\\n        int i = 0;\\n        while(i<n)\\n        {\\n\\t\\t\\tif (i<n && (sc.size() == 0 || mins[i] < sc.top()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint tmp = mins[i];\\n\\t\\t\\t\\twhile(i<n)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsc.push(s[i]);\\n\\t\\t\\t\\t\\tif (s[i] == tmp)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tres.push_back(sc.top());\\n\\t\\t\\tsc.pop();\\n        }\\n        while(sc.size() != 0)\\n        {\\n            res.push_back(sc.top());\\n            sc.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801347,
                "title": "using-stack-keeping-track-of-smallest-character-to-right",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        vector<char> check(s.size(),\\'z\\');\\n        char stn = s[n-1];\\n        check[n-1] = stn;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            if(s[i]<stn)\\n            {\\n                check[i]= stn;\\n                stn = s[i];\\n            }\\n            else if(s[i]==stn)\\n            {\\n                check[i] = stn;\\n            }\\n        }\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i = 0; i<n; i++)\\n        {\\n            if(s[i]!=stn)\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]);\\n                stn = check[i];\\n                while(!st.empty()&&stn>=st.top())\\n                {\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        vector<char> check(s.size(),\\'z\\');\\n        char stn = s[n-1];\\n        check[n-1] = stn;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            if(s[i]<stn)\\n            {\\n                check[i]= stn;\\n                stn = s[i];\\n            }\\n            else if(s[i]==stn)\\n            {\\n                check[i] = stn;\\n            }\\n        }\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i = 0; i<n; i++)\\n        {\\n            if(s[i]!=stn)\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]);\\n                stn = check[i];\\n                while(!st.empty()&&stn>=st.top())\\n                {\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783810,
                "title": "c-easy-understanding-stack-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        //logic --> next smaller to right\\n        // s    t   first letter of s --> t  last letter of t --> ans\\n        // s=zza t=\"\"    s=za  t=z  s=zaz t=\"\"  s=az  t=z  s=azz t=\"\"\\n        stack<char>st;  //this will work as t as it keeps track of last character\\n        string ans=\"\";\\n        vector<int>freq(26,0);  // it will keep track of smaller letters on right\\n        for(int i=0;i<s.length();i++)\\n        {\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(s[i]<=st.top())\\n                {\\n                    st.push(s[i]);\\n                }\\n                else\\n                {\\n                    while(!st.empty() and st.top()<=fun(freq))\\n                    {\\n                        ans.push_back(st.top());\\n                        st.pop();\\n                    }\\n                    st.push(s[i]);\\n                }\\n            }\\n            freq[s[i]-\\'a\\']--;\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n    char fun(vector<int>&freq)\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            if(freq[i]>0)\\n            {\\n                return (i+\\'a\\');\\n            }\\n        }\\n        return \\'a\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        //logic --> next smaller to right\\n        // s    t   first letter of s --> t  last letter of t --> ans\\n        // s=zza t=\"\"    s=za  t=z  s=zaz t=\"\"  s=az  t=z  s=azz t=\"\"\\n        stack<char>st;  //this will work as t as it keeps track of last character\\n        string ans=\"\";\\n        vector<int>freq(26,0);  // it will keep track of smaller letters on right\\n        for(int i=0;i<s.length();i++)\\n        {\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(s[i]<=st.top())\\n                {\\n                    st.push(s[i]);\\n                }\\n                else\\n                {\\n                    while(!st.empty() and st.top()<=fun(freq))\\n                    {\\n                        ans.push_back(st.top());\\n                        st.pop();\\n                    }\\n                    st.push(s[i]);\\n                }\\n            }\\n            freq[s[i]-\\'a\\']--;\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n    char fun(vector<int>&freq)\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            if(freq[i]>0)\\n            {\\n                return (i+\\'a\\');\\n            }\\n        }\\n        return \\'a\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772404,
                "title": "java-easy-solution-with-stack-in-o-n",
                "content": "\\tclass Solution {\\n\\t\\tpublic String robotWithString(String s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tchar[] charArr = new char[n];\\n\\t\\t\\tStack<Integer> stck = new Stack();\\n\\t\\t\\tList<Integer>[] arr = new ArrayList[26];\\n\\t\\t\\tIntStream.range(0, 26).forEach(i-> arr[i] = new ArrayList());\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tarr[s.charAt(i) - \\'a\\'].add(i);\\n\\t\\t\\t}\\n\\t\\t\\tList<Integer> sortedList = new ArrayList();\\n\\n\\t\\t\\tfor(int i = 0; i < 26; i++)\\n\\t\\t\\t\\tsortedList.addAll(arr[i]);\\n\\n\\t\\t\\tint j = 0, k = -1; \\n\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\n\\t\\t\\t\\tif(j <= sortedList.get(i)) {\\n\\t\\t\\t\\t\\tint x = sortedList.get(i);\\n\\n\\t\\t\\t\\t\\twhile(x <= sortedList.get(i) && !stck.isEmpty() && s.charAt(stck.peek()) <= s.charAt(x)) \\n\\t\\t\\t\\t\\t\\tcharArr[++k] = s.charAt(stck.pop());   \\n\\n\\t\\t\\t\\t\\twhile(j <= sortedList.get(i)) \\n\\t\\t\\t\\t\\t\\tstck.push(j++);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(!stck.isEmpty())\\n\\t\\t\\t\\tcharArr[++k] = s.charAt(stck.pop());        \\n\\n\\t\\t\\treturn String.valueOf(charArr);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\t\\tpublic String robotWithString(String s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tchar[] charArr = new char[n];\\n\\t\\t\\tStack<Integer> stck = new Stack();\\n\\t\\t\\tList<Integer>[] arr = new ArrayList[26];\\n\\t\\t\\tIntStream.range(0, 26).forEach(i-> arr[i] = new ArrayList());\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tarr[s.charAt(i) - \\'a\\'].add(i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2769156,
                "title": "simple-two-stack-solutions-o-n-no-counter-needed",
                "content": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        ArrayDeque<Character> stack = new ArrayDeque<>();\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            if(stack.isEmpty() || arr[i]<=stack.peek()){\\n                stack.push(arr[i]);\\n            }\\n        }\\n        ArrayDeque<Character> stack1 = new ArrayDeque<>();\\n        for(int i = 0;i<n;i++)\\n        {\\n            stack1.push(arr[i]);\\n            while(!stack.isEmpty() && !stack1.isEmpty() && stack1.peek()<=stack.peek()){\\n                sb.append(stack1.pop());\\n                if(arr[i]==stack.peek()) stack.pop();\\n            }\\n        }\\n        while(!stack1.isEmpty()) sb.append(stack1.pop());\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        ArrayDeque<Character> stack = new ArrayDeque<>();\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            if(stack.isEmpty() || arr[i]<=stack.peek()){\\n                stack.push(arr[i]);\\n            }\\n        }\\n        ArrayDeque<Character> stack1 = new ArrayDeque<>();\\n        for(int i = 0;i<n;i++)\\n        {\\n            stack1.push(arr[i]);\\n            while(!stack.isEmpty() && !stack1.isEmpty() && stack1.peek()<=stack.peek()){\\n                sb.append(stack1.pop());\\n                if(arr[i]==stack.peek()) stack.pop();\\n            }\\n        }\\n        while(!stack1.isEmpty()) sb.append(stack1.pop());\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766713,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  string robotWithString(const string &s) {\\n    const int n = static_cast<int>(s.size());\\n    char min_value[n];\\n    min_value[n - 1] = s.back();\\n    for (int i = n - 2; i > -1; --i) {\\n      if (s[i] < min_value[i + 1]) {\\n        min_value[i] = s[i];\\n      } else {\\n        min_value[i] = min_value[i + 1];\\n      }\\n    }\\n    \\n    string ret;\\n    stack<char> st;\\n    for (int i = 0; i < n; ++i) {\\n      while (!st.empty() && (st.top() <= min_value[i])) {\\n        ret.push_back(st.top());\\n        st.pop();\\n      }\\n      st.emplace(s[i]);\\n    }\\n    while (!st.empty()) {\\n      ret.push_back(st.top());\\n      st.pop();\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  string robotWithString(const string &s) {\\n    const int n = static_cast<int>(s.size());\\n    char min_value[n];\\n    min_value[n - 1] = s.back();\\n    for (int i = n - 2; i > -1; --i) {\\n      if (s[i] < min_value[i + 1]) {\\n        min_value[i] = s[i];\\n      } else {\\n        min_value[i] = min_value[i + 1];\\n      }\\n    }\\n    \\n    string ret;\\n    stack<char> st;\\n    for (int i = 0; i < n; ++i) {\\n      while (!st.empty() && (st.top() <= min_value[i])) {\\n        ret.push_back(st.top());\\n        st.pop();\\n      }\\n      st.emplace(s[i]);\\n    }\\n    while (!st.empty()) {\\n      ret.push_back(st.top());\\n      st.pop();\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766560,
                "title": "c-easy-understanding-stack-solution",
                "content": "**If it helps, please UPVOTE : )**\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) \\n    {\\n        int n = s.size();\\n        vector<char> v_min(n);       //maintain a vector of minimum element from right at any index\\n        \\n        v_min[n-1] = s[n-1];\\n        for(int i=n-2; i>=0; i--)\\n            v_min[i] = min(s[i], v_min[i+1]);\\n        \\n        stack<char> st;\\n        string p = \"\";\\n        \\n        int mini = v_min[0];\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i] != mini)\\n                st.push(s[i]);\\n            else\\n            {\\n                p += s[i];\\n                i++;\\n                if(i < n)\\n                    mini = v_min[i];\\n                while(i < n and !st.empty() and st.top() <= mini)\\n                {\\n                    p += st.top();\\n                    st.pop();\\n                }\\n                i--;                    //for ka i++ badha dega fir\\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            p += st.top();\\n            st.pop();\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) \\n    {\\n        int n = s.size();\\n        vector<char> v_min(n);       //maintain a vector of minimum element from right at any index\\n        \\n        v_min[n-1] = s[n-1];\\n        for(int i=n-2; i>=0; i--)\\n            v_min[i] = min(s[i], v_min[i+1]);\\n        \\n        stack<char> st;\\n        string p = \"\";\\n        \\n        int mini = v_min[0];\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i] != mini)\\n                st.push(s[i]);\\n            else\\n            {\\n                p += s[i];\\n                i++;\\n                if(i < n)\\n                    mini = v_min[i];\\n                while(i < n and !st.empty() and st.top() <= mini)\\n                {\\n                    p += st.top();\\n                    st.pop();\\n                }\\n                i--;                    //for ka i++ badha dega fir\\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            p += st.top();\\n            st.pop();\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761654,
                "title": "dp-solution-python3",
                "content": "We use two arrays to record the smallest char in the rest of s and the smallest char in t.\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        #Focus on the last char in t.\\n        #If current char is the smallest -> current char writes on paper.\\n        \\n        post_smallest = [s[-1]]*len(s)\\n        for i in range(len(s) - 2, -1, -1):\\n            post_smallest[i] = min(post_smallest[i + 1], s[i])\\n        t = []\\n        pre_smallest = []\\n        index = 0\\n        ans = []\\n        while index < len(s):\\n            if t and t[-1] <= post_smallest[index] and ((not pre_smallest) or t[-1] <= pre_smallest[-1]):\\n                ans.append(t[-1])\\n                t.pop()\\n                pre_smallest.pop()\\n            else:\\n                if pre_smallest:\\n                    pre_smallest.append(min(s[-1], pre_smallest[-1]))\\n                else:\\n                    pre_smallest.append(s[-1])\\n                t.append(s[index])\\n                index += 1\\n        while t:\\n            ans.append(t[-1])\\n            t.pop()\\n        return \"\".join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        #Focus on the last char in t.\\n        #If current char is the smallest -> current char writes on paper.\\n        \\n        post_smallest = [s[-1]]*len(s)\\n        for i in range(len(s) - 2, -1, -1):\\n            post_smallest[i] = min(post_smallest[i + 1], s[i])\\n        t = []\\n        pre_smallest = []\\n        index = 0\\n        ans = []\\n        while index < len(s):\\n            if t and t[-1] <= post_smallest[index] and ((not pre_smallest) or t[-1] <= pre_smallest[-1]):\\n                ans.append(t[-1])\\n                t.pop()\\n                pre_smallest.pop()\\n            else:\\n                if pre_smallest:\\n                    pre_smallest.append(min(s[-1], pre_smallest[-1]))\\n                else:\\n                    pre_smallest.append(s[-1])\\n                t.append(s[index])\\n                index += 1\\n        while t:\\n            ans.append(t[-1])\\n            t.pop()\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760270,
                "title": "python3-stack-o-n-simple",
                "content": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        dct = collections.Counter(s)\\n        t = []\\n        res = []\\n        for el in s:\\n            t.append(el)\\n            dct[el] -= 1\\n            if not dct[el]: del dct[el]\\n            while dct and t and t[-1] <= min(dct):\\n                res.append(t.pop())\\n        res.extend(t[::-1])\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        dct = collections.Counter(s)\\n        t = []\\n        res = []\\n        for el in s:\\n            t.append(el)\\n            dct[el] -= 1\\n            if not dct[el]: del dct[el]\\n            while dct and t and t[-1] <= min(dct):\\n                res.append(t.pop())\\n        res.extend(t[::-1])\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757130,
                "title": "c-best-solution-with-explanation-o-n-time-beat-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor getting lexicographically lowest string, we will choose all lowest char first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- first count each character.\\n- for getting lexicographically smaller string,  start from lowest character , take all selected lower character first and meanwhile push all char in string t until we don\\'t take all selected lower character.\\n- for taking next lower char, first check in string t from back , take all char from string t from back until we don\\'t get empty string t or char present at last is greater than curr selected lower char.\\n- total diff char present are only 26, so use vector or we can use map.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - in worst case size of t will be n-1;\\n\\n# Code\\n```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<int> count(26);\\n        for(char ch : s){\\n            int i = ch - \\'a\\';\\n            count[i]++;\\n        }\\n\\n        string t;\\n        string ans;\\n\\n        int j = 0;\\n        for(int i=0;i<26;i++){\\n            char ch = \\'a\\' + i;\\n            while(t.length()>0 && t.back()<=ch){\\n                ans.push_back(t.back());\\n                t.pop_back();\\n            }\\n            while(count[i]>0){\\n                if(s[j]==ch){\\n                    count[i]--;\\n                    ans.push_back(ch);\\n                }\\n                else {\\n                    t.pb(s[j]);\\n                    count[(s[j]-\\'a\\')]--;\\n                }\\n                j++;\\n            }   \\n        }\\n\\n        reverse(t.begin(), t.end());\\n        ans += t;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        vector<int> count(26);\\n        for(char ch : s){\\n            int i = ch - \\'a\\';\\n            count[i]++;\\n        }\\n\\n        string t;\\n        string ans;\\n\\n        int j = 0;\\n        for(int i=0;i<26;i++){\\n            char ch = \\'a\\' + i;\\n            while(t.length()>0 && t.back()<=ch){\\n                ans.push_back(t.back());\\n                t.pop_back();\\n            }\\n            while(count[i]>0){\\n                if(s[j]==ch){\\n                    count[i]--;\\n                    ans.push_back(ch);\\n                }\\n                else {\\n                    t.pb(s[j]);\\n                    count[(s[j]-\\'a\\')]--;\\n                }\\n                j++;\\n            }   \\n        }\\n\\n        reverse(t.begin(), t.end());\\n        ans += t;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747524,
                "title": "javascript-stack",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar robotWithString = function (s) {\\n  const chars = new Array(26).fill(0);\\n  for (const char of s) {\\n    const idx = char.charCodeAt() - 97;\\n    chars[idx]++;\\n  }\\n  \\n  let ans = \"\";\\n  const stack = [];\\n  for (const char of s) {\\n    const idx = char.charCodeAt() - 97;\\n    chars[idx]--;\\n    stack.push(char);\\n\\n    while (stack.length > 0 && stack[stack.length - 1] <= getLowestChar(chars)) {\\n      ans += stack.pop();\\n    }\\n  }\\n  \\n  while (stack.length > 0) {\\n    ans += stack.pop();\\n  }\\n\\n  return ans;\\n};\\n\\nfunction getLowestChar(chars) {\\n  for (let i = 0; i < chars.length; i++) {\\n    if (chars[i] > 0) {\\n      return String.fromCharCode(i + 97);\\n    }\\n  }\\n  return String.fromCharCode(97);\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar robotWithString = function (s) {\\n  const chars = new Array(26).fill(0);\\n  for (const char of s) {\\n    const idx = char.charCodeAt() - 97;\\n    chars[idx]++;\\n  }\\n  \\n  let ans = \"\";\\n  const stack = [];\\n  for (const char of s) {\\n    const idx = char.charCodeAt() - 97;\\n    chars[idx]--;\\n    stack.push(char);\\n\\n    while (stack.length > 0 && stack[stack.length - 1] <= getLowestChar(chars)) {\\n      ans += stack.pop();\\n    }\\n  }\\n  \\n  while (stack.length > 0) {\\n    ans += stack.pop();\\n  }\\n\\n  return ans;\\n};\\n\\nfunction getLowestChar(chars) {\\n  for (let i = 0; i < chars.length; i++) {\\n    if (chars[i] > 0) {\\n      return String.fromCharCode(i + 97);\\n    }\\n  }\\n  return String.fromCharCode(97);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740037,
                "title": "python-solution-code-pseudo-code",
                "content": "## brief:\\n- create a list \"abc\" that each cell contain the idxes of the char in the string\\n- create the \"t\" list stack for the \"robot\"\\n- create cur_pos that holds where we are in our main string\\n- we will loop this abc list\\n\\t- first check the \"tlist\" and insert to final if the head char is equal or smaller than our current looped one\\n\\t- run through the current char matchs\\n\\t\\t- if the match idx is smaller from our cur_pos, that means it was already calculated\\n\\t\\t- if not, insert all the charaters up to the match positions\\n\\t\\t- make sure to insert the last item we added to tlist\\n- connect and return the leftover from tlist to final\\n\\n## code:\\n```python\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        final = []\\n        slist = list(s)\\n        tlist = []\\n        abc = [{} for _ in range(26)]\\n        for idx, c in enumerate(slist):\\n            abc[ord(c) - ord(\"a\")][idx] = True\\n        \\n        cur_pos = 0\\n        for idx, matches in enumerate(abc):\\n            c = chr(idx + ord(\"a\"))\\n\\n            while tlist and ord(tlist[-1]) <= ord(c):\\n                final.append(tlist.pop())\\n\\n            for match in matches:\\n                if match < cur_pos:\\n                    continue\\n                while cur_pos <= match:\\n                    tlist.append(s[cur_pos])\\n                    cur_pos += 1\\n                final.append(tlist.pop())\\n            \\n        final += tlist[::-1]\\n        return \"\".join(final)\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        final = []\\n        slist = list(s)\\n        tlist = []\\n        abc = [{} for _ in range(26)]\\n        for idx, c in enumerate(slist):\\n            abc[ord(c) - ord(\"a\")][idx] = True\\n        \\n        cur_pos = 0\\n        for idx, matches in enumerate(abc):\\n            c = chr(idx + ord(\"a\"))\\n\\n            while tlist and ord(tlist[-1]) <= ord(c):\\n                final.append(tlist.pop())\\n\\n            for match in matches:\\n                if match < cur_pos:\\n                    continue\\n                while cur_pos <= match:\\n                    tlist.append(s[cur_pos])\\n                    cur_pos += 1\\n                final.append(tlist.pop())\\n            \\n        final += tlist[::-1]\\n        return \"\".join(final)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733998,
                "title": "golang-monotonic-stack",
                "content": "#### Complexity\\nTime Complexity: O(3 * N)\\nSpace Complexity: O(3 * N)\\n\\n\\n#### Observation\\n\\n1. Character from `s` to `t` cannot go back to `s`\\n2. Smaller characters in front have smaller strings\\n\\n#### Solution\\n1. if s contains a smaller character (compare to `t[len(t)-1]`), it should append to t.\\n2. otherwise, append `t[len(t)-1]` to string `p`.\\n\\n```golang\\nfunc robotWithString(s string) string {\\n    p, t := make([]byte, 0, len(s)), make([]byte, 0, len(s))\\n    stack := make([]int, len(s)) // Monotonic stack, checking for characters smaller than the current index\\n    stack[len(stack)-1] = len(stack) - 1\\n    for i := len(s) - 2; i >= 0; i-- {\\n        stack[i] = i\\n        if s[stack[i+1]] < s[i] {\\n            stack[i] = stack[i+1]\\n        }\\n    }\\n    for idx := 0; idx < len(s); {\\n        if len(t) == 0 || s[stack[idx]] < t[len(t)-1] { // check the last character in t and smallest character in s\\n            t = append(t, s[idx])\\n            idx += 1\\n        } else {\\n            p = append(p, t[len(t)-1])\\n            t = t[:len(t)-1]\\n        }\\n    }\\n    for idx := len(t) - 1; idx >= 0; idx-- {\\n        p = append(p, t[idx])\\n    }\\n    return string(p)\\n}\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```golang\\nfunc robotWithString(s string) string {\\n    p, t := make([]byte, 0, len(s)), make([]byte, 0, len(s))\\n    stack := make([]int, len(s)) // Monotonic stack, checking for characters smaller than the current index\\n    stack[len(stack)-1] = len(stack) - 1\\n    for i := len(s) - 2; i >= 0; i-- {\\n        stack[i] = i\\n        if s[stack[i+1]] < s[i] {\\n            stack[i] = stack[i+1]\\n        }\\n    }\\n    for idx := 0; idx < len(s); {\\n        if len(t) == 0 || s[stack[idx]] < t[len(t)-1] { // check the last character in t and smallest character in s\\n            t = append(t, s[idx])\\n            idx += 1\\n        } else {\\n            p = append(p, t[len(t)-1])\\n            t = t[:len(t)-1]\\n        }\\n    }\\n    for idx := len(t) - 1; idx >= 0; idx-- {\\n        p = append(p, t[idx])\\n    }\\n    return string(p)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733211,
                "title": "python-o-n",
                "content": "```\\ndef robotWithString(self, s: str) -> str:\\n        d = dict()\\n        for i, l in enumerate(s):\\n            d[l] = i\\n        cur, res, left = 0, \"\", deque()\\n        for l in ascii_lowercase:\\n            if l in d and d[l]>=cur:\\n                while left and left[0]<=l:\\n                    res+=left.popleft()\\n                for idx in range(cur, d[l]+1):\\n                    if s[idx]==l:\\n                        res+=l\\n                    else:\\n                        left.appendleft(s[idx])\\n                cur = d[l]+1\\n        return res+\"\".join(left)",
                "solutionTags": [],
                "code": "```\\ndef robotWithString(self, s: str) -> str:\\n        d = dict()\\n        for i, l in enumerate(s):\\n            d[l] = i\\n        cur, res, left = 0, \"\", deque()\\n        for l in ascii_lowercase:\\n            if l in d and d[l]>=cur:\\n                while left and left[0]<=l:\\n                    res+=left.popleft()\\n                for idx in range(cur, d[l]+1):\\n                    if s[idx]==l:\\n                        res+=l\\n                    else:\\n                        left.appendleft(s[idx])\\n                cur = d[l]+1\\n        return res+\"\".join(left)",
                "codeTag": "Python3"
            },
            {
                "id": 2729543,
                "title": "javascript-print-if-there-is-nothing-smaller-left-in-s-string",
                "content": "```\\nvar robotWithString = function(s) {\\n    const freqs = new Array(26).fill(0)\\n    \\n    // 1. Calculate freqs of each character\\n    for(const char of s) {\\n        const ascii = char.charCodeAt()-97\\n        freqs[ascii]++\\n    }\\n    \\n    let t = []\\n    let res = []\\n    let sPointer = 0\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        const curr = s[i]\\n        const firstOfFirst = s[sPointer++]\\n        // 2. Push \\'t\\' array and subtract by 1 from freqs to keep track of what\\'s left in \\'s\\'\\n        freqs[firstOfFirst.charCodeAt()-97]--\\n        t.push(firstOfFirst)\\n        \\n        const currAscii = curr.charCodeAt()-97\\n        \\n        let isSmallerInFuture = false\\n        \\n        // 3. if we have something in \\'t\\' and there is nothing smaller left in string \\'s\\', we can print it\\n        while(t.length && !isSmallerInFuture) {\\n            const last = t.at(-1).charCodeAt()-97\\n            \\n            for(let j = 0; j < last; j++) {\\n                if(freqs[j]>0) {\\n                    isSmallerInFuture = true\\n                    break\\n                }\\n            }\\n\\n            if(!isSmallerInFuture && t.length!==0) {\\n               res.push(t.pop()) \\n            } \\n        }\\n    }\\n    \\n    return res.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar robotWithString = function(s) {\\n    const freqs = new Array(26).fill(0)\\n    \\n    // 1. Calculate freqs of each character\\n    for(const char of s) {\\n        const ascii = char.charCodeAt()-97\\n        freqs[ascii]++\\n    }\\n    \\n    let t = []\\n    let res = []\\n    let sPointer = 0\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        const curr = s[i]\\n        const firstOfFirst = s[sPointer++]\\n        // 2. Push \\'t\\' array and subtract by 1 from freqs to keep track of what\\'s left in \\'s\\'\\n        freqs[firstOfFirst.charCodeAt()-97]--\\n        t.push(firstOfFirst)\\n        \\n        const currAscii = curr.charCodeAt()-97\\n        \\n        let isSmallerInFuture = false\\n        \\n        // 3. if we have something in \\'t\\' and there is nothing smaller left in string \\'s\\', we can print it\\n        while(t.length && !isSmallerInFuture) {\\n            const last = t.at(-1).charCodeAt()-97\\n            \\n            for(let j = 0; j < last; j++) {\\n                if(freqs[j]>0) {\\n                    isSmallerInFuture = true\\n                    break\\n                }\\n            }\\n\\n            if(!isSmallerInFuture && t.length!==0) {\\n               res.push(t.pop()) \\n            } \\n        }\\n    }\\n    \\n    return res.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2725425,
                "title": "scala-recursive-pattern-matching",
                "content": "```scala\\nimport scala.collection.immutable.TreeMap\\n\\ndef robotWithString(s: String): String = {\\n  val chars = s.foldLeft(TreeMap.empty[Char, Int])((m, c) => m.updated(c, m.getOrElse(c, 0) + 1))\\n  go(chars, s.toList, List.empty, List.empty).mkString\\n}\\n\\ndef go(chars: TreeMap[Char, Int], s: List[Char], t: List[Char], acc: List[Char]): List[Char] =\\n  (s, t) match {\\n    case (Nil, Nil) => acc.reverse\\n    case (Nil, tHead :: tTail) => go(chars, s, tTail, tHead :: acc)\\n    case (sHead :: sTail, Nil) => go(decrease(chars, sHead), sTail, sHead :: t, acc)\\n    case (sHead :: sTail, tHead :: tTail) =>\\n      val isSmallerExists = chars.maxBefore(Array(sHead, tHead).min).nonEmpty\\n      if (isSmallerExists || sHead < tHead) go(decrease(chars, sHead), sTail, sHead :: t, acc)\\n      else go(chars, s, tTail, tHead :: acc)\\n  }\\n  \\ndef decrease(chars: TreeMap[Char, Int], c: Char) =\\n  if (chars(c) > 1) chars.updated(c, chars(c) - 1) else chars.removed(c)\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nimport scala.collection.immutable.TreeMap\\n\\ndef robotWithString(s: String): String = {\\n  val chars = s.foldLeft(TreeMap.empty[Char, Int])((m, c) => m.updated(c, m.getOrElse(c, 0) + 1))\\n  go(chars, s.toList, List.empty, List.empty).mkString\\n}\\n\\ndef go(chars: TreeMap[Char, Int], s: List[Char], t: List[Char], acc: List[Char]): List[Char] =\\n  (s, t) match {\\n    case (Nil, Nil) => acc.reverse\\n    case (Nil, tHead :: tTail) => go(chars, s, tTail, tHead :: acc)\\n    case (sHead :: sTail, Nil) => go(decrease(chars, sHead), sTail, sHead :: t, acc)\\n    case (sHead :: sTail, tHead :: tTail) =>\\n      val isSmallerExists = chars.maxBefore(Array(sHead, tHead).min).nonEmpty\\n      if (isSmallerExists || sHead < tHead) go(decrease(chars, sHead), sTail, sHead :: t, acc)\\n      else go(chars, s, tTail, tHead :: acc)\\n  }\\n  \\ndef decrease(chars: TreeMap[Char, Int], c: Char) =\\n  if (chars(c) > 1) chars.updated(c, chars(c) - 1) else chars.removed(c)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2722543,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string ans, t;\\n        int cnt[26] = {}, n = size(s);\\n        for (char c: s) cnt[c-\\'a\\']++;\\n        for (int i = 0, j = 0; i < n; i++) {\\n            t.push_back(s[i]), cnt[s[i]-\\'a\\']--;\\n            while (j < 26 && !cnt[j]) j++;\\n            while (!t.empty() && t.back() <= \\'a\\'+j)\\n                ans.push_back(t.back()), t.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string ans, t;\\n        int cnt[26] = {}, n = size(s);\\n        for (char c: s) cnt[c-\\'a\\']++;\\n        for (int i = 0, j = 0; i < n; i++) {\\n            t.push_back(s[i]), cnt[s[i]-\\'a\\']--;\\n            while (j < 26 && !cnt[j]) j++;\\n            while (!t.empty() && t.back() <= \\'a\\'+j)\\n                ans.push_back(t.back()), t.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712942,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    char lower(vector<int>& freq){\\n        for(int i=0;i<26;i++){\\n            if(freq[i]!=0) return \\'a\\'+i;\\n        }\\n        return \\'a\\';\\n    }\\n    string robotWithString(string s) {\\n        vector<int> freq(26,0);\\n        for(auto it:s){\\n            freq[it-\\'a\\']++;\\n        }\\n        \\n        stack<char> st;\\n        string ans=\"\";\\n        for(auto i:s){\\n            st.push(i);\\n            freq[i-\\'a\\']--;\\n            while(st.size()>0 && st.top()<=lower(freq)){\\n                char ele=st.top();\\n                \\n                ans+=ele;\\n                st.pop();\\n            }\\n            \\n        }\\n        \\n        while(st.size()>0){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char lower(vector<int>& freq){\\n        for(int i=0;i<26;i++){\\n            if(freq[i]!=0) return \\'a\\'+i;\\n        }\\n        return \\'a\\';\\n    }\\n    string robotWithString(string s) {\\n        vector<int> freq(26,0);\\n        for(auto it:s){\\n            freq[it-\\'a\\']++;\\n        }\\n        \\n        stack<char> st;\\n        string ans=\"\";\\n        for(auto i:s){\\n            st.push(i);\\n            freq[i-\\'a\\']--;\\n            while(st.size()>0 && st.top()<=lower(freq)){\\n                char ele=st.top();\\n                \\n                ans+=ele;\\n                st.pop();\\n            }\\n            \\n        }\\n        \\n        while(st.size()>0){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710119,
                "title": "python3-counter-and-stack-o-n-commented-code-easy-to-understand",
                "content": "Please Upvote if the solution is helpful to you, Thanks !! Happy Coding !!\\n\\n\\n        \\n\\tclass Solution:\\n\\t\\tdef robotWithString(self, s: str) -> str:\\n\\n\\t\\t\\t#store occurences of letters\\n\\t\\t\\tdic = [0]*26\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tdic[ord(s[i])-ord(\\'a\\')] += 1\\n\\n\\t\\t\\t#define stack, current index while loop and ans -> the final string\\n\\t\\t\\tstack = []\\n\\t\\t\\tcurr_index = 0\\n\\t\\t\\tans = \"\"\\n\\t\\t\\tn = len(s)\\n\\n\\t\\t\\t#for each of the characters traverse the string from \\'a\\' to \\'z\\'(lexicographically sorted)\\n\\t\\t\\tfor i in range(len(dic)):\\n\\n\\t\\t\\t\\t#if we have reached end of string break loop\\n\\t\\t\\t\\tif curr_index == n:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t#backtrack stack and append any character to final ans if it is less or equal current character\\n\\t\\t\\t\\twhile stack and (ord(stack[-1]) - ord(\\'a\\')) <= i:\\n\\t\\t\\t\\t\\t\\tans += stack.pop()\\n\\n\\t\\t\\t\\t#loop until our current character counter becomes zero\\n\\t\\t\\t\\twhile dic[i] > 0:\\n\\n\\t\\t\\t\\t\\t# if this our current(desired) character then append to answer\\n\\t\\t\\t\\t\\tif ord(s[curr_index]) - ord(\\'a\\') == i:\\n\\t\\t\\t\\t\\t\\tans += s[curr_index]\\n\\n\\t\\t\\t\\t\\t#else put it in stack for later(when we will do the backtrack)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tstack.append(s[curr_index])\\n\\n\\t\\t\\t\\t\\t#decrease counter for each character(each character either part of final ans or stack)\\n\\t\\t\\t\\t\\tdic[ord(s[curr_index]) - ord(\\'a\\')] -= 1\\n\\n\\t\\t\\t\\t\\t#increase index\\n\\t\\t\\t\\t\\tcurr_index += 1\\n\\n\\t\\t\\t#pop all characters from stack ans append to the answer\\n\\t\\t\\twhile len(stack) > 0:\\n\\t\\t\\t\\tans += stack.pop()\\n\\n\\t\\t\\t#return the answer\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "Please Upvote if the solution is helpful to you, Thanks !! Happy Coding !!\\n\\n\\n        \\n\\tclass Solution:\\n\\t\\tdef robotWithString(self, s: str) -> str:\\n\\n\\t\\t\\t#store occurences of letters\\n\\t\\t\\tdic = [0]*26\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tdic[ord(s[i])-ord(\\'a\\')] += 1\\n\\n\\t\\t\\t#define stack, current index while loop and ans -> the final string\\n\\t\\t\\tstack = []\\n\\t\\t\\tcurr_index = 0\\n\\t\\t\\tans = \"\"\\n\\t\\t\\tn = len(s)\\n\\n\\t\\t\\t#for each of the characters traverse the string from \\'a\\' to \\'z\\'(lexicographically sorted)\\n\\t\\t\\tfor i in range(len(dic)):\\n\\n\\t\\t\\t\\t#if we have reached end of string break loop\\n\\t\\t\\t\\tif curr_index == n:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t#backtrack stack and append any character to final ans if it is less or equal current character\\n\\t\\t\\t\\twhile stack and (ord(stack[-1]) - ord(\\'a\\')) <= i:\\n\\t\\t\\t\\t\\t\\tans += stack.pop()\\n\\n\\t\\t\\t\\t#loop until our current character counter becomes zero\\n\\t\\t\\t\\twhile dic[i] > 0:\\n\\n\\t\\t\\t\\t\\t# if this our current(desired) character then append to answer\\n\\t\\t\\t\\t\\tif ord(s[curr_index]) - ord(\\'a\\') == i:\\n\\t\\t\\t\\t\\t\\tans += s[curr_index]\\n\\n\\t\\t\\t\\t\\t#else put it in stack for later(when we will do the backtrack)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tstack.append(s[curr_index])\\n\\n\\t\\t\\t\\t\\t#decrease counter for each character(each character either part of final ans or stack)\\n\\t\\t\\t\\t\\tdic[ord(s[curr_index]) - ord(\\'a\\')] -= 1\\n\\n\\t\\t\\t\\t\\t#increase index\\n\\t\\t\\t\\t\\tcurr_index += 1\\n\\n\\t\\t\\t#pop all characters from stack ans append to the answer\\n\\t\\t\\twhile len(stack) > 0:\\n\\t\\t\\t\\tans += stack.pop()\\n\\n\\t\\t\\t#return the answer\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2707068,
                "title": "go",
                "content": "```\\nfunc robotWithString(s string) string {\\n    \\n    dict := make(map[byte]int)\\n    for i := 0; i < len(s); i++ {\\n        dict[s[i]]++\\n    }\\n    \\n    list := []byte(s)\\n    sort.Slice(list, func(i int, j int) bool {\\n        return list[i] < list[j]\\n    })\\n    \\n    var paper bytes.Buffer\\n    var t []byte\\n    i, j := 0, 0\\n    last := 0\\n    for i < len(s) {\\n        if dict[list[j]] <= 0 {\\n            j++\\n            continue\\n        }\\n        \\n        if len(t) > 0 && list[j] >= t[len(t) - 1] {\\n            paper.WriteByte(t[len(t) - 1])\\n            t = t[:len(t) - 1]\\n            continue\\n        }\\n        \\n        if s[i] == list[j] {\\n            paper.WriteByte(s[i])\\n            dict[s[i]]--\\n            for k := last; k < i; k++ {\\n                t = append(t, s[k])\\n                dict[s[k]]--\\n            }\\n            last = i + 1\\n            i++\\n            j++\\n        } else {\\n            i++\\n        }\\n    }\\n    \\n    for i := len(t) - 1; i >= 0; i-- {\\n        paper.WriteByte(t[i])\\n    }\\n    return paper.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc robotWithString(s string) string {\\n    \\n    dict := make(map[byte]int)\\n    for i := 0; i < len(s); i++ {\\n        dict[s[i]]++\\n    }\\n    \\n    list := []byte(s)\\n    sort.Slice(list, func(i int, j int) bool {\\n        return list[i] < list[j]\\n    })\\n    \\n    var paper bytes.Buffer\\n    var t []byte\\n    i, j := 0, 0\\n    last := 0\\n    for i < len(s) {\\n        if dict[list[j]] <= 0 {\\n            j++\\n            continue\\n        }\\n        \\n        if len(t) > 0 && list[j] >= t[len(t) - 1] {\\n            paper.WriteByte(t[len(t) - 1])\\n            t = t[:len(t) - 1]\\n            continue\\n        }\\n        \\n        if s[i] == list[j] {\\n            paper.WriteByte(s[i])\\n            dict[s[i]]--\\n            for k := last; k < i; k++ {\\n                t = append(t, s[k])\\n                dict[s[k]]--\\n            }\\n            last = i + 1\\n            i++\\n            j++\\n        } else {\\n            i++\\n        }\\n    }\\n    \\n    for i := len(t) - 1; i >= 0; i-- {\\n        paper.WriteByte(t[i])\\n    }\\n    return paper.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2705505,
                "title": "java-time-o-n-space-o-n-stack-prefix-sum",
                "content": "```\\n//offered examples:\\n//zza\\n//bac\\n//bdda\\n\\n//from above examples, we can figure out that, for any element at index i,\\n//if it is smaller than or equal to any elements after i, we need to print it out pronto.\\n\\n//example 1 : zza\\n//at index 0, the smallest after index 0 is a, we keep it in the stack\\n//at index 1, the smallest after index 1 is a, we keep it in the satck\\n//at index 2, the smallest after index 2 is a, which is equal to a, we print this out.\\n//print everything left in the stack results in \"azz\"\\n\\n\\n//example 2 : bac\\n//at index 0, the smallest after index 0, is a, we kee pit in the stack\\n//at index 1, the smallest after index 1, is c, which is bigger than \\'a\\', we print it out\\n//            once \\'a\\' is printed out, at the top of the stack is left with \\'b\\', and it is still smaller\\n//           than the smallest element after 1, which is \\'c\\', we need to print \\'b\\' out as well.\\n//stack is empty\\n//at index 2, the smallest after index 2, is null, so we just print it out\\n//eventually, we get \\'abc\\'\\n\\n//therefore, we want to know, what is the smallest element after index i,\\n//this can be achieved by traversing from back, kinda like prefix sum.\\n\\n//with the help of using a stack, we can get the answer we want.\\n\\n\\n\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        int[] min = new int[n+1];\\n        min[n] = 25;\\n        for(int i=n-1;i>=0;i--)\\n            min[i] = Math.min(min[i+1], s.charAt(i)-\\'a\\');\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Deque<Character> stack = new ArrayDeque<>();\\n        for(int i=0;i<n;i++){\\n            char ch = s.charAt(i);\\n            stack.push(ch);\\n            while(!stack.isEmpty() && stack.peek()-\\'a\\' <= min[i+1])\\n                sb.append(stack.pop());\\n        }\\n        \\n        while(!stack.isEmpty())\\n            sb.append(stack.pop());\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\n//offered examples:\\n//zza\\n//bac\\n//bdda\\n\\n//from above examples, we can figure out that, for any element at index i,\\n//if it is smaller than or equal to any elements after i, we need to print it out pronto.\\n\\n//example 1 : zza\\n//at index 0, the smallest after index 0 is a, we keep it in the stack\\n//at index 1, the smallest after index 1 is a, we keep it in the satck\\n//at index 2, the smallest after index 2 is a, which is equal to a, we print this out.\\n//print everything left in the stack results in \"azz\"\\n\\n\\n//example 2 : bac\\n//at index 0, the smallest after index 0, is a, we kee pit in the stack\\n//at index 1, the smallest after index 1, is c, which is bigger than \\'a\\', we print it out\\n//            once \\'a\\' is printed out, at the top of the stack is left with \\'b\\', and it is still smaller\\n//           than the smallest element after 1, which is \\'c\\', we need to print \\'b\\' out as well.\\n//stack is empty\\n//at index 2, the smallest after index 2, is null, so we just print it out\\n//eventually, we get \\'abc\\'\\n\\n//therefore, we want to know, what is the smallest element after index i,\\n//this can be achieved by traversing from back, kinda like prefix sum.\\n\\n//with the help of using a stack, we can get the answer we want.\\n\\n\\n\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        int[] min = new int[n+1];\\n        min[n] = 25;\\n        for(int i=n-1;i>=0;i--)\\n            min[i] = Math.min(min[i+1], s.charAt(i)-\\'a\\');\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Deque<Character> stack = new ArrayDeque<>();\\n        for(int i=0;i<n;i++){\\n            char ch = s.charAt(i);\\n            stack.push(ch);\\n            while(!stack.isEmpty() && stack.peek()-\\'a\\' <= min[i+1])\\n                sb.append(stack.pop());\\n        }\\n        \\n        while(!stack.isEmpty())\\n            sb.append(stack.pop());\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704288,
                "title": "golang",
                "content": "```\\nfunc robotWithString(s string) string {\\n\\tret := make([]byte, 0, len(s))\\n\\tvar count [26]int\\n\\tfor i := range s {count[s[i]-\\'a\\']++}\\n\\tlo := 0\\n\\tvar ss []byte\\n\\tfor i := range s {\\n\\t\\tb := s[i]\\n\\t\\tif int(b-\\'a\\') <= lo {\\n\\t\\t\\tret = append(ret, b)\\n\\t\\t} else {\\n\\t\\t\\tss = append(ss, b)\\n\\t\\t}\\n\\t\\tcount[b-\\'a\\']--\\n\\t\\tfor lo < 26 && count[lo] == 0 { lo++ }\\n\\t\\tfor len(ss) > 0 {\\n\\t\\t\\tif int(ss[len(ss)-1]-\\'a\\') <= lo {\\n\\t\\t\\t\\tret = append(ret, ss[len(ss)-1])\\n\\t\\t\\t\\tss = ss[:len(ss)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn string(ret)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc robotWithString(s string) string {\\n\\tret := make([]byte, 0, len(s))\\n\\tvar count [26]int\\n\\tfor i := range s {count[s[i]-\\'a\\']++}\\n\\tlo := 0\\n\\tvar ss []byte\\n\\tfor i := range s {\\n\\t\\tb := s[i]\\n\\t\\tif int(b-\\'a\\') <= lo {\\n\\t\\t\\tret = append(ret, b)\\n\\t\\t} else {\\n\\t\\t\\tss = append(ss, b)\\n\\t\\t}\\n\\t\\tcount[b-\\'a\\']--\\n\\t\\tfor lo < 26 && count[lo] == 0 { lo++ }\\n\\t\\tfor len(ss) > 0 {\\n\\t\\t\\tif int(ss[len(ss)-1]-\\'a\\') <= lo {\\n\\t\\t\\t\\tret = append(ret, ss[len(ss)-1])\\n\\t\\t\\t\\tss = ss[:len(ss)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn string(ret)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704043,
                "title": "java-detailed-code-100-time",
                "content": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        List<List<Integer>> al = new ArrayList<>();\\n        for (int i = 0; i < 26; ++i) {\\n            al.add(new ArrayList<>());\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            al.get(s.charAt(i) - \\'a\\').add(i);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        boolean visited[] = new boolean[n];\\n        int pointer = 0;\\n        \\n        for (int i = 0; i < 26; ++i) {\\n            List<Integer> indices = al.get(i);\\n            if (indices.size() == 0 || pointer > indices.get(indices.size() - 1)) continue;\\n            \\n            int nextPotentialSmallest = i;\\n            int leftAccumulator = pointer - 1;\\n            \\n            while (leftAccumulator >= 0 && ((s.charAt(leftAccumulator) - \\'a\\') <= nextPotentialSmallest)) {\\n                if (!visited[leftAccumulator]) sb.append(s.charAt(leftAccumulator));\\n                \\n                visited[leftAccumulator] = true;\\n                leftAccumulator--;\\n            }\\n             \\n            int rightAccumlator = Collections.binarySearch(indices, pointer);\\n            if (rightAccumlator < 0) rightAccumlator = (rightAccumlator + 1) * -1;\\n            \\n            for (int j = rightAccumlator; j < indices.size(); ++j) {\\n                int currentPointer = indices.get(j);\\n                \\n                visited[currentPointer] = true;\\n                sb.append(s.charAt(currentPointer));\\n                pointer = currentPointer;\\n            }\\n        }\\n        \\n        for (int i = n - 1; i >=0; --i) {\\n            if (!visited[i]) sb.append(s.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        List<List<Integer>> al = new ArrayList<>();\\n        for (int i = 0; i < 26; ++i) {\\n            al.add(new ArrayList<>());\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            al.get(s.charAt(i) - \\'a\\').add(i);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        boolean visited[] = new boolean[n];\\n        int pointer = 0;\\n        \\n        for (int i = 0; i < 26; ++i) {\\n            List<Integer> indices = al.get(i);\\n            if (indices.size() == 0 || pointer > indices.get(indices.size() - 1)) continue;\\n            \\n            int nextPotentialSmallest = i;\\n            int leftAccumulator = pointer - 1;\\n            \\n            while (leftAccumulator >= 0 && ((s.charAt(leftAccumulator) - \\'a\\') <= nextPotentialSmallest)) {\\n                if (!visited[leftAccumulator]) sb.append(s.charAt(leftAccumulator));\\n                \\n                visited[leftAccumulator] = true;\\n                leftAccumulator--;\\n            }\\n             \\n            int rightAccumlator = Collections.binarySearch(indices, pointer);\\n            if (rightAccumlator < 0) rightAccumlator = (rightAccumlator + 1) * -1;\\n            \\n            for (int j = rightAccumlator; j < indices.size(); ++j) {\\n                int currentPointer = indices.get(j);\\n                \\n                visited[currentPointer] = true;\\n                sb.append(s.charAt(currentPointer));\\n                pointer = currentPointer;\\n            }\\n        }\\n        \\n        for (int i = n - 1; i >=0; --i) {\\n            if (!visited[i]) sb.append(s.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702986,
                "title": "binary-search-c",
                "content": "# Intuition\\nThink Greedy, as we have to make string lexicographically smaller\\n\\n# Approach\\nfind all the indexes of character and start adding character as small as possible to the ans \\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string ans, temp;\\n        \\n        vector<vector<int>> v(26);\\n        for(int i=0;i<s.size();i++){\\n            v[s[i]-\\'a\\'].push_back(i);\\n        }\\n        \\n        int j = 0;\\n        for(int i=0;i<26;i++){\\n            if(v[i].empty()) continue;\\n            while(temp.size() and temp.back() <= char(i+\\'a\\')){\\n                ans += temp.back(); temp.pop_back();\\n            }\\n            while(j <= v[i].back()){\\n                auto lb = lower_bound(v[i].begin(),v[i].end(),j);\\n                if(*lb == j) ans += s[j++];\\n                else temp += s[j++];\\n            }\\n            \\n        }\\n        \\n        \\n        for(int i=temp.size()-1;i>=0;i--) ans += temp[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        string ans, temp;\\n        \\n        vector<vector<int>> v(26);\\n        for(int i=0;i<s.size();i++){\\n            v[s[i]-\\'a\\'].push_back(i);\\n        }\\n        \\n        int j = 0;\\n        for(int i=0;i<26;i++){\\n            if(v[i].empty()) continue;\\n            while(temp.size() and temp.back() <= char(i+\\'a\\')){\\n                ans += temp.back(); temp.pop_back();\\n            }\\n            while(j <= v[i].back()){\\n                auto lb = lower_bound(v[i].begin(),v[i].end(),j);\\n                if(*lb == j) ans += s[j++];\\n                else temp += s[j++];\\n            }\\n            \\n        }\\n        \\n        \\n        for(int i=temp.size()-1;i>=0;i--) ans += temp[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702854,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn robot_with_string(s: String) -> String {\\n        // collect all last positions of chars in sorted order\\n        let mut map = std::collections::BTreeMap::new();\\n        s.char_indices().for_each(|(i, c)| {\\n            map.insert(c, i as i32);\\n        });\\n\\n        let mut res = String::with_capacity(s.len());\\n        let mut t = Vec::with_capacity(s.len());\\n        let mut prev_i = -1;\\n\\n        for (c, i) in map.into_iter() {\\n            // check top of stack\\n            while let Some(&ct) = t.last() {\\n                match ct <= c {\\n                    true => res.push(t.pop().unwrap()),\\n                    false => break,\\n                }\\n            }\\n\\n            if i > prev_i {\\n                // go to last next char\\n                let start = (prev_i + 1) as usize;\\n                let n = (i - prev_i) as usize;\\n\\n                s[start..].chars().take(n).for_each(|cc| match c == cc {\\n                    true => res.push(c),\\n                    false => t.push(cc),\\n                });\\n\\n                prev_i = i;\\n            }\\n        }\\n\\n        // other symbols from stack\\n        res.extend(t.iter().cloned().rev());\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn robot_with_string(s: String) -> String {\\n        // collect all last positions of chars in sorted order\\n        let mut map = std::collections::BTreeMap::new();\\n        s.char_indices().for_each(|(i, c)| {\\n            map.insert(c, i as i32);\\n        });\\n\\n        let mut res = String::with_capacity(s.len());\\n        let mut t = Vec::with_capacity(s.len());\\n        let mut prev_i = -1;\\n\\n        for (c, i) in map.into_iter() {\\n            // check top of stack\\n            while let Some(&ct) = t.last() {\\n                match ct <= c {\\n                    true => res.push(t.pop().unwrap()),\\n                    false => break,\\n                }\\n            }\\n\\n            if i > prev_i {\\n                // go to last next char\\n                let start = (prev_i + 1) as usize;\\n                let n = (i - prev_i) as usize;\\n\\n                s[start..].chars().take(n).for_each(|cc| match c == cc {\\n                    true => res.push(c),\\n                    false => t.push(cc),\\n                });\\n\\n                prev_i = i;\\n            }\\n        }\\n\\n        // other symbols from stack\\n        res.extend(t.iter().cloned().rev());\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701889,
                "title": "java-stack-solution-with-explanation-s",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length() ;\\n        int least[] = new int[n] ;\\n        least[n-1]=(int)s.charAt(n-1) ;\\n        for(int i=n-2 ; i>=0 ; i--){\\n            int val = (int)s.charAt(i) ;\\n            if(least[i+1] < val){\\n                least[i] = least[i+1] ;\\n            }\\n            else{\\n                least[i] = val;\\n            }\\n        }\\n        \\n        Stack<Character> stack = new Stack<>() ;\\n        StringBuilder op = new StringBuilder() ;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            char ch = s.charAt(i) ;\\n            if(i==n-1 || least[i+1]<(int)ch){\\n                stack.push(ch) ;\\n            }\\n            else{\\n                stack.push(ch) ;\\n                while(!stack.isEmpty() && least[i+1]>=(int)stack.peek()) {\\n                    op.append(stack.pop()) ;\\n                }\\n            }\\n        }\\n        \\n        while(!stack.isEmpty()){\\n            op.append(stack.pop()) ;\\n        }\\n        return op.toString() ;\\n    }\\n}\\n```\\nWe preprocess the array to find out what the samllest element is upto a particular index from the right . \\nThen we traverse the string from the zero\\'th index :\\n 1) push the current element into the stack\\n\\n 2) check whether there is an element that is lexographically smaller than the current top of stack and occurs after this index .\\n\\n 3) if that is the case then do nothing (move on with the iteration),\\n\\n 4) if there is no smaller element occuring after the current index\\n then start popping elements from the stack and appending them to your answer , while the current top of the stack is lexographically smaller than the least element occuring after this index .\\n\\n5) After traversing the complete string pop the remaining elements from the stack and append them to your answer .\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length() ;\\n        int least[] = new int[n] ;\\n        least[n-1]=(int)s.charAt(n-1) ;\\n        for(int i=n-2 ; i>=0 ; i--){\\n            int val = (int)s.charAt(i) ;\\n            if(least[i+1] < val){\\n                least[i] = least[i+1] ;\\n            }\\n            else{\\n                least[i] = val;\\n            }\\n        }\\n        \\n        Stack<Character> stack = new Stack<>() ;\\n        StringBuilder op = new StringBuilder() ;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            char ch = s.charAt(i) ;\\n            if(i==n-1 || least[i+1]<(int)ch){\\n                stack.push(ch) ;\\n            }\\n            else{\\n                stack.push(ch) ;\\n                while(!stack.isEmpty() && least[i+1]>=(int)stack.peek()) {\\n                    op.append(stack.pop()) ;\\n                }\\n            }\\n        }\\n        \\n        while(!stack.isEmpty()){\\n            op.append(stack.pop()) ;\\n        }\\n        return op.toString() ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700455,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public string RobotWithString(string s) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.Length; i++) {\\n            ++counts[s[i] - \\'a\\'];\\n        }\\n        \\n        Stack<char> st = new Stack<char>();\\n        int length = s.Length;\\n        int pos = 0;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while (st.Count > 0 || pos < length) {\\n            bool moveToRobot = st.Count == 0;\\n            \\n            if (!moveToRobot) {\\n                int startPos = st.Peek() - \\'a\\' - 1;\\n                for (int i = startPos; i >=0; i--) {\\n                    if (counts[i] > 0) {\\n                        moveToRobot = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (moveToRobot) {\\n                char thisChar = s[pos++];\\n                --counts[thisChar - \\'a\\'];\\n                st.Push(thisChar);\\n            }\\n            else {\\n                sb.Append(st.Pop());\\n            }            \\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string RobotWithString(string s) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.Length; i++) {\\n            ++counts[s[i] - \\'a\\'];\\n        }\\n        \\n        Stack<char> st = new Stack<char>();\\n        int length = s.Length;\\n        int pos = 0;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while (st.Count > 0 || pos < length) {\\n            bool moveToRobot = st.Count == 0;\\n            \\n            if (!moveToRobot) {\\n                int startPos = st.Peek() - \\'a\\' - 1;\\n                for (int i = startPos; i >=0; i--) {\\n                    if (counts[i] > 0) {\\n                        moveToRobot = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (moveToRobot) {\\n                char thisChar = s[pos++];\\n                --counts[thisChar - \\'a\\'];\\n                st.Push(thisChar);\\n            }\\n            else {\\n                sb.Append(st.Pop());\\n            }            \\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699265,
                "title": "a-few-solutions",
                "content": "Let `s` be a queue, and `t` be a stack which behaves as a monotonic queue, ie. we greedily pop from `t` whenever the remaining characters `c` in `s` are all greater-than-or-equal-to the ordinal value at top of `t`.  Use a counter `m` to track the remaining characters `c` in `s` and let `best` be the lexicographical minimum.\\n\\n* Note: the ordinal values of uppercase characters `A..Z` is `65..90` which are all less-than `a..z` which is `97..122`, so `X` is just an arbitrary choice to use when the counter `m` is empty (this occurs when processing the last character of `s`)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun robotWithString(s: String): String {\\n        var (t, m, ans) = Triple(mutableListOf<Char>(), mutableMapOf<Char, Int>(), mutableListOf<Char>())\\n        var best = { m.keys.min() ?: \\'X\\' }\\n        for (c in s)\\n            m[c] = 1 + (m[c] ?: 0)\\n        for (c in s) {\\n            t.add(c); m[c] = -1 + m[c]!!\\n            if (m[c]!! == 0)\\n                m.remove(c)\\n            while (0 < t.size && t.last().toInt() <= best().toInt())\\n                ans.add(t.removeAt(t.lastIndex))\\n        }\\n        return ans.joinToString(\"\") + t.reversed().joinToString(\"\")\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet robotWithString = (s, t = [], m = new Map(), ord = c => c.charCodeAt(0), ans = []) => {\\n    let best = () => m.size ? [...m.keys()].sort((a, b) => ord(a) - ord(b))[0] : \\'X\\';\\n    for (let c of s)\\n        m.set(c, 1 + (m.get(c) || 0));\\n    for (let c of s) {\\n        t.push(c), m.set(c, -1 + m.get(c));\\n        if (!m.get(c))\\n            m.delete(c);\\n        while (t.length && ord(t[t.length - 1]) <= ord(best()))\\n            ans.push(t.pop());\\n    }\\n    return ans.join(\\'\\') + t.reverse().join(\\'\\');\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        t, m, ans = [], Counter(s), []\\n        best = lambda: min([c for c in m.keys()] or \\'X\\')\\n        for c in s:\\n            t.append(c); m[c] -= 1\\n            if not m[c]:\\n                del m[c]\\n            while len(t) and t[-1] <= best():\\n                ans.append(t.pop())\\n        return \\'\\'.join(ans) + \\'\\'.join(t[::-1])\\n```\\n\\n*Rust*\\n```\\n// TODO: implement me!\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = map<char, int>;\\n    string robotWithString(string s, string t = {}, Map m = {}, ostringstream ans = {}) {\\n        auto best = [&]() { return m.size() ? m.begin()->first : \\'X\\'; };\\n        for (auto c: s)\\n            ++m[c];\\n        for (auto c: s) {\\n            t.push_back(c);\\n            if (!--m[c])\\n                m.erase(c);\\n            while (t.size() && t.back() <= best())\\n                ans << t.back(), t.pop_back();\\n        }\\n        return string(ans.str()).append({t.rbegin(), t.rend()});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun robotWithString(s: String): String {\\n        var (t, m, ans) = Triple(mutableListOf<Char>(), mutableMapOf<Char, Int>(), mutableListOf<Char>())\\n        var best = { m.keys.min() ?: \\'X\\' }\\n        for (c in s)\\n            m[c] = 1 + (m[c] ?: 0)\\n        for (c in s) {\\n            t.add(c); m[c] = -1 + m[c]!!\\n            if (m[c]!! == 0)\\n                m.remove(c)\\n            while (0 < t.size && t.last().toInt() <= best().toInt())\\n                ans.add(t.removeAt(t.lastIndex))\\n        }\\n        return ans.joinToString(\"\") + t.reversed().joinToString(\"\")\\n    }\\n}\\n```\n```\\nlet robotWithString = (s, t = [], m = new Map(), ord = c => c.charCodeAt(0), ans = []) => {\\n    let best = () => m.size ? [...m.keys()].sort((a, b) => ord(a) - ord(b))[0] : \\'X\\';\\n    for (let c of s)\\n        m.set(c, 1 + (m.get(c) || 0));\\n    for (let c of s) {\\n        t.push(c), m.set(c, -1 + m.get(c));\\n        if (!m.get(c))\\n            m.delete(c);\\n        while (t.length && ord(t[t.length - 1]) <= ord(best()))\\n            ans.push(t.pop());\\n    }\\n    return ans.join(\\'\\') + t.reverse().join(\\'\\');\\n};\\n```\n```\\nclass Solution:\\n    def robotWithString(self, s: str) -> str:\\n        t, m, ans = [], Counter(s), []\\n        best = lambda: min([c for c in m.keys()] or \\'X\\')\\n        for c in s:\\n            t.append(c); m[c] -= 1\\n            if not m[c]:\\n                del m[c]\\n            while len(t) and t[-1] <= best():\\n                ans.append(t.pop())\\n        return \\'\\'.join(ans) + \\'\\'.join(t[::-1])\\n```\n```\\n// TODO: implement me!\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = map<char, int>;\\n    string robotWithString(string s, string t = {}, Map m = {}, ostringstream ans = {}) {\\n        auto best = [&]() { return m.size() ? m.begin()->first : \\'X\\'; };\\n        for (auto c: s)\\n            ++m[c];\\n        for (auto c: s) {\\n            t.push_back(c);\\n            if (!--m[c])\\n                m.erase(c);\\n            while (t.size() && t.back() <= best())\\n                ans << t.back(), t.pop_back();\\n        }\\n        return string(ans.str()).append({t.rbegin(), t.rend()});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698968,
                "title": "golang-solution-with-comment",
                "content": "```go\\nfunc robotWithString(s string) string {\\n\\talphaRecorder := [26]int{}\\n\\tfor _, c := range s {\\n\\t\\talphaRecorder[c-\\'a\\']++\\n\\t}\\n\\tbuffer := make([]rune, 0, len(s)/2)\\n\\tresult := make([]rune, 0, len(s))\\n\\tcurIndex := -1\\n\\tfor i, v := range alphaRecorder {\\n\\t\\tif v > 0 {\\n\\t\\t\\tcurIndex = i\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\tfor _, c := range s {\\n\\t\\tif alphaRecorder[curIndex] > 0 {\\n\\t\\t\\t// current alpha exist in remaining string, pick it\\n\\t\\t\\talphaRecorder[int(c-\\'a\\')]--\\n\\t\\t\\tif int(c-\\'a\\') != curIndex {\\n\\t\\t\\t\\t// not dest alpha, append to buffer\\n\\t\\t\\t\\tbuffer = append(buffer, c)\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\t// dest alpha, append to result\\n\\t\\t\\tresult = append(result, c)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// current alpha used up, find next\\n\\t\\tfor {\\n\\t\\t\\tcurIndex++\\n\\t\\t\\tif curIndex == 26 {\\n\\t\\t\\t\\t// not found\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tif alphaRecorder[curIndex] > 0 {\\n\\t\\t\\t\\t// next found\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif curIndex == 26 {\\n\\t\\t\\t// not found, loop over\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tfor len(buffer) > 0 && buffer[len(buffer)-1] <= rune(\\'a\\'+curIndex) {\\n\\t\\t\\tresult = append(result, buffer[len(buffer)-1])\\n\\t\\t\\tbuffer = buffer[:len(buffer)-1]\\n\\t\\t}\\n\\t\\talphaRecorder[int(c-\\'a\\')]--\\n\\t\\tif int(c-\\'a\\') != curIndex {\\n\\t\\t\\tbuffer = append(buffer, c)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tresult = append(result, c)\\n\\t}\\n\\treverse(buffer)\\n\\tresult = append(result, buffer...)\\n\\treturn string(result)\\n}\\n\\nfunc reverse(A []rune) {\\n\\tfor i := 0; i < len(A)/2; i++ {\\n\\t\\tA[i], A[len(A)-1-i] = A[len(A)-1-i], A[i]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc robotWithString(s string) string {\\n\\talphaRecorder := [26]int{}\\n\\tfor _, c := range s {\\n\\t\\talphaRecorder[c-\\'a\\']++\\n\\t}\\n\\tbuffer := make([]rune, 0, len(s)/2)\\n\\tresult := make([]rune, 0, len(s))\\n\\tcurIndex := -1\\n\\tfor i, v := range alphaRecorder {\\n\\t\\tif v > 0 {\\n\\t\\t\\tcurIndex = i\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\tfor _, c := range s {\\n\\t\\tif alphaRecorder[curIndex] > 0 {\\n\\t\\t\\t// current alpha exist in remaining string, pick it\\n\\t\\t\\talphaRecorder[int(c-\\'a\\')]--\\n\\t\\t\\tif int(c-\\'a\\') != curIndex {\\n\\t\\t\\t\\t// not dest alpha, append to buffer\\n\\t\\t\\t\\tbuffer = append(buffer, c)\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\t// dest alpha, append to result\\n\\t\\t\\tresult = append(result, c)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// current alpha used up, find next\\n\\t\\tfor {\\n\\t\\t\\tcurIndex++\\n\\t\\t\\tif curIndex == 26 {\\n\\t\\t\\t\\t// not found\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tif alphaRecorder[curIndex] > 0 {\\n\\t\\t\\t\\t// next found\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif curIndex == 26 {\\n\\t\\t\\t// not found, loop over\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tfor len(buffer) > 0 && buffer[len(buffer)-1] <= rune(\\'a\\'+curIndex) {\\n\\t\\t\\tresult = append(result, buffer[len(buffer)-1])\\n\\t\\t\\tbuffer = buffer[:len(buffer)-1]\\n\\t\\t}\\n\\t\\talphaRecorder[int(c-\\'a\\')]--\\n\\t\\tif int(c-\\'a\\') != curIndex {\\n\\t\\t\\tbuffer = append(buffer, c)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tresult = append(result, c)\\n\\t}\\n\\treverse(buffer)\\n\\tresult = append(result, buffer...)\\n\\treturn string(result)\\n}\\n\\nfunc reverse(A []rune) {\\n\\tfor i := 0; i < len(A)/2; i++ {\\n\\t\\tA[i], A[len(A)-1-i] = A[len(A)-1-i], A[i]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2698814,
                "title": "javascript-stack-hashmap",
                "content": "\\n\\n```\\nconst robotWithString = function (s) {\\n    const t = []\\n    const stack_s = []\\n    for(let i = s.length - 1; i >=0; i--) {\\n        stack_s.push(s[i])\\n    }\\n    const charsMap = Array.from({length: s.length}, ()=> \\'\\')\\n    charsMap[0] = s[s.length - 1]\\n    for(let i = 1; i < charsMap.length; i++) {\\n        charsMap[i] = charsMap[i-1] > s[s.length - i - 1] ? s[s.length - i - 1] :charsMap[i-1]\\n    }\\n    const output = []\\n    const chars = []\\n    for(let i = 122; i >= 97; i--) {\\n        chars.push(String.fromCharCode(i))\\n    }\\n    for(let i = 0; i < 26 && stack_s.length; i++) {\\n        const char = chars.pop()\\n        while (stack_s.length && charsMap[stack_s.length - 1] == char) {\\n            t.push(stack_s.pop())\\n            while(t.length && t[t.length - 1] <= charsMap[stack_s.length - 1]) {\\n                output.push(t.pop())\\n            }\\n        }\\n    }\\n    while(t.length) {\\n        output.push(t.pop())\\n    }\\n    return output.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nconst robotWithString = function (s) {\\n    const t = []\\n    const stack_s = []\\n    for(let i = s.length - 1; i >=0; i--) {\\n        stack_s.push(s[i])\\n    }\\n    const charsMap = Array.from({length: s.length}, ()=> \\'\\')\\n    charsMap[0] = s[s.length - 1]\\n    for(let i = 1; i < charsMap.length; i++) {\\n        charsMap[i] = charsMap[i-1] > s[s.length - i - 1] ? s[s.length - i - 1] :charsMap[i-1]\\n    }\\n    const output = []\\n    const chars = []\\n    for(let i = 122; i >= 97; i--) {\\n        chars.push(String.fromCharCode(i))\\n    }\\n    for(let i = 0; i < 26 && stack_s.length; i++) {\\n        const char = chars.pop()\\n        while (stack_s.length && charsMap[stack_s.length - 1] == char) {\\n            t.push(stack_s.pop())\\n            while(t.length && t[t.length - 1] <= charsMap[stack_s.length - 1]) {\\n                output.push(t.pop())\\n            }\\n        }\\n    }\\n    while(t.length) {\\n        output.push(t.pop())\\n    }\\n    return output.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2698780,
                "title": "simple-c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        string ans; \\n        vector<char>a (n+1,\\'z\\');\\n        a[n-1] = s[n-1] ;\\n        for (int i=n-2;i>=0;i--) a[i] = min(s[i], a[i+1]) ;\\n        stack<char>st; \\n        for (int i=0;i<n;i++){\\n            while (st.size() && st.top() <= a[i]){\\n                ans += st.top();\\n                st.pop();\\n            }        \\n            st.push(s[i]);\\n        }\\n        while(st.size() ) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.size();\\n        string ans; \\n        vector<char>a (n+1,\\'z\\');\\n        a[n-1] = s[n-1] ;\\n        for (int i=n-2;i>=0;i--) a[i] = min(s[i], a[i+1]) ;\\n        stack<char>st; \\n        for (int i=0;i<n;i++){\\n            while (st.size() && st.top() <= a[i]){\\n                ans += st.top();\\n                st.pop();\\n            }        \\n            st.push(s[i]);\\n        }\\n        while(st.size() ) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698230,
                "title": "simple-c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.length();\\n        stack<char>t;\\n        map<char,int>mp;\\n        set<char>st;\\n        for(char c:s){\\n            mp[c]++;\\n            st.insert(c);\\n        }\\n        int idx = 0;\\n        string ans = \"\";\\n        for(char curr:st){\\n            while(t.size() && (t.top() <= curr )){\\n                ans += t.top();\\n                t.pop();\\n            }\\n            while(idx<n && mp[curr]){\\n                mp[s[idx]]--;\\n                if(s[idx] == curr){\\n                    ans += curr;\\n                }\\n                else{\\n                    t.push(s[idx]);\\n                }\\n                idx++;\\n            }\\n        }\\n        while(t.size()){\\n            ans += t.top();\\n            t.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string robotWithString(string s) {\\n        int n = s.length();\\n        stack<char>t;\\n        map<char,int>mp;\\n        set<char>st;\\n        for(char c:s){\\n            mp[c]++;\\n            st.insert(c);\\n        }\\n        int idx = 0;\\n        string ans = \"\";\\n        for(char curr:st){\\n            while(t.size() && (t.top() <= curr )){\\n                ans += t.top();\\n                t.pop();\\n            }\\n            while(idx<n && mp[curr]){\\n                mp[s[idx]]--;\\n                if(s[idx] == curr){\\n                    ans += curr;\\n                }\\n                else{\\n                    t.push(s[idx]);\\n                }\\n                idx++;\\n            }\\n        }\\n        while(t.size()){\\n            ans += t.top();\\n            t.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697691,
                "title": "java",
                "content": "```\\npublic String robotWithString(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        int[] arr = new int[26];\\n        for(int i = 0; i < s.length(); i++) {\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        int idx = 0;\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            while(idx < 26 && arr[idx] <= 0) {\\n                idx++;\\n            }\\n            while(!st.isEmpty() && st.peek()-\\'a\\' <= idx) {\\n                ans.append(st.pop());\\n            }\\n            st.add(s.charAt(i));\\n            arr[s.charAt(i)-\\'a\\']--;\\n        }\\n        while(!st.isEmpty()) {\\n            ans.append(st.pop());\\n        }\\n        return ans.toString();\\n    }\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic String robotWithString(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        int[] arr = new int[26];\\n        for(int i = 0; i < s.length(); i++) {\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        int idx = 0;\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            while(idx < 26 && arr[idx] <= 0) {\\n                idx++;\\n            }\\n            while(!st.isEmpty() && st.peek()-\\'a\\' <= idx) {\\n                ans.append(st.pop());\\n            }\\n            st.add(s.charAt(i));\\n            arr[s.charAt(i)-\\'a\\']--;\\n        }\\n        while(!st.isEmpty()) {\\n            ans.append(st.pop());\\n        }\\n        return ans.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2697187,
                "title": "c-solution-stack-map-greedy",
                "content": "Greedily choose the letters, \\n1. if there is a better choice of letter which has not yet been encountered put current letter in the stack, if no better letter exists append the current letter to the answer.\\n2. Suppose the stack top has a letter which is the current best choice, append it to the answer.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkBetterOption(char &c, map<char,int> &m){\\n        for(auto &i:m){\\n            if(i.second>0){\\n                if(i.first<c){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    string robotWithString(string s) {\\n        stack<char> s1;\\n        string ans;\\n        map<char,int> yetToCome;\\n        for(auto &i:s){\\n            yetToCome[i]++;\\n        }\\n        \\n        for(auto i: s){\\n            while(!s1.empty() and s1.top()<=i){\\n                if(!checkBetterOption(s1.top(), yetToCome)){\\n                    ans.push_back(s1.top());\\n                    s1.pop();\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(checkBetterOption(i, yetToCome)){\\n                s1.push(i);\\n            }\\n            else{\\n                ans.push_back(i);\\n            }\\n            yetToCome[i]--;\\n        }\\n      \\n        while(!s1.empty()){\\n            ans.push_back(s1.top());\\n            s1.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkBetterOption(char &c, map<char,int> &m){\\n        for(auto &i:m){\\n            if(i.second>0){\\n                if(i.first<c){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    string robotWithString(string s) {\\n        stack<char> s1;\\n        string ans;\\n        map<char,int> yetToCome;\\n        for(auto &i:s){\\n            yetToCome[i]++;\\n        }\\n        \\n        for(auto i: s){\\n            while(!s1.empty() and s1.top()<=i){\\n                if(!checkBetterOption(s1.top(), yetToCome)){\\n                    ans.push_back(s1.top());\\n                    s1.pop();\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(checkBetterOption(i, yetToCome)){\\n                s1.push(i);\\n            }\\n            else{\\n                ans.push_back(i);\\n            }\\n            yetToCome[i]--;\\n        }\\n      \\n        while(!s1.empty()){\\n            ans.push_back(s1.top());\\n            s1.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1881096,
                "content": [
                    {
                        "username": "soliton80",
                        "content": "imho a very complicated problem statement"
                    },
                    {
                        "username": "segorucu",
                        "content": "I\\'m not really understanding this problem statement."
                    },
                    {
                        "username": "mcnguyen88",
                        "content": "1. With the two allowed operations, i.e. shift from low-end of s and then push to/pop from t, we can only get \"badd\" for case 3.\\n2. If any additional pre-processing is allowed, we may bring in a max heap to shift all elements from s to the max heap before pushing them to the stack t to get the best \"abdd\" for case 3.\\n3. Hence, the answer of \"addb\" for case 3 is either breaking constraints of the problem as in above (1.) or not the best answer as in above (2.), IMHO."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "A quick hint/clarification as to the \"smallest lexicographical string\" part. For test case three, if you\\'re wondering why the output isn\\'t \"abdd\", that is b/c of the two operations we can do. It is impossible to get \"abdd\" with only the two operations we are allowed to do. \\nThese two operations serve as limitations. Try and use these as \"guides\" when building your solution. "
                    },
                    {
                        "username": "shubs307",
                        "content": "Hints are suggesting as if Robot has knowledge of all the characters it is going to get in advance (not like a streaming as the description is suggesting). e.g. if it is getting a letter \"b\", it\\'ll use \"b\" if it knows that the smallest letter going forward is >=\"b\". Otherwise, it\\'ll decide to wait for that \"smallest\" letter (known in advance) to get the lexicographically smallest string. It suggests a conflict with the constraints or more clarity is needed in the description"
                    },
                    {
                        "username": "8972392",
                        "content": "Agreed. Honestly the entire idea about the robot could be dropped. Just say you have a queue \\'s\\' and a stack \\'t\\', move the letters from s -> t -> \\'ans\\' such that ans is as small as lexographically possible."
                    },
                    {
                        "username": "user5454M",
                        "content": "Absolute traumatic experience with this relatively simple problem."
                    },
                    {
                        "username": "f20212839",
                        "content": "Anyone else getter Memory limit exceeded"
                    },
                    {
                        "username": "adilabuwani",
                        "content": "that sounds like a compile time error. (Probably an infinite loop)"
                    }
                ]
            },
            {
                "id": 1943164,
                "content": [
                    {
                        "username": "soliton80",
                        "content": "imho a very complicated problem statement"
                    },
                    {
                        "username": "segorucu",
                        "content": "I\\'m not really understanding this problem statement."
                    },
                    {
                        "username": "mcnguyen88",
                        "content": "1. With the two allowed operations, i.e. shift from low-end of s and then push to/pop from t, we can only get \"badd\" for case 3.\\n2. If any additional pre-processing is allowed, we may bring in a max heap to shift all elements from s to the max heap before pushing them to the stack t to get the best \"abdd\" for case 3.\\n3. Hence, the answer of \"addb\" for case 3 is either breaking constraints of the problem as in above (1.) or not the best answer as in above (2.), IMHO."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "A quick hint/clarification as to the \"smallest lexicographical string\" part. For test case three, if you\\'re wondering why the output isn\\'t \"abdd\", that is b/c of the two operations we can do. It is impossible to get \"abdd\" with only the two operations we are allowed to do. \\nThese two operations serve as limitations. Try and use these as \"guides\" when building your solution. "
                    },
                    {
                        "username": "shubs307",
                        "content": "Hints are suggesting as if Robot has knowledge of all the characters it is going to get in advance (not like a streaming as the description is suggesting). e.g. if it is getting a letter \"b\", it\\'ll use \"b\" if it knows that the smallest letter going forward is >=\"b\". Otherwise, it\\'ll decide to wait for that \"smallest\" letter (known in advance) to get the lexicographically smallest string. It suggests a conflict with the constraints or more clarity is needed in the description"
                    },
                    {
                        "username": "8972392",
                        "content": "Agreed. Honestly the entire idea about the robot could be dropped. Just say you have a queue \\'s\\' and a stack \\'t\\', move the letters from s -> t -> \\'ans\\' such that ans is as small as lexographically possible."
                    },
                    {
                        "username": "user5454M",
                        "content": "Absolute traumatic experience with this relatively simple problem."
                    },
                    {
                        "username": "f20212839",
                        "content": "Anyone else getter Memory limit exceeded"
                    },
                    {
                        "username": "adilabuwani",
                        "content": "that sounds like a compile time error. (Probably an infinite loop)"
                    }
                ]
            },
            {
                "id": 1886124,
                "content": [
                    {
                        "username": "soliton80",
                        "content": "imho a very complicated problem statement"
                    },
                    {
                        "username": "segorucu",
                        "content": "I\\'m not really understanding this problem statement."
                    },
                    {
                        "username": "mcnguyen88",
                        "content": "1. With the two allowed operations, i.e. shift from low-end of s and then push to/pop from t, we can only get \"badd\" for case 3.\\n2. If any additional pre-processing is allowed, we may bring in a max heap to shift all elements from s to the max heap before pushing them to the stack t to get the best \"abdd\" for case 3.\\n3. Hence, the answer of \"addb\" for case 3 is either breaking constraints of the problem as in above (1.) or not the best answer as in above (2.), IMHO."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "A quick hint/clarification as to the \"smallest lexicographical string\" part. For test case three, if you\\'re wondering why the output isn\\'t \"abdd\", that is b/c of the two operations we can do. It is impossible to get \"abdd\" with only the two operations we are allowed to do. \\nThese two operations serve as limitations. Try and use these as \"guides\" when building your solution. "
                    },
                    {
                        "username": "shubs307",
                        "content": "Hints are suggesting as if Robot has knowledge of all the characters it is going to get in advance (not like a streaming as the description is suggesting). e.g. if it is getting a letter \"b\", it\\'ll use \"b\" if it knows that the smallest letter going forward is >=\"b\". Otherwise, it\\'ll decide to wait for that \"smallest\" letter (known in advance) to get the lexicographically smallest string. It suggests a conflict with the constraints or more clarity is needed in the description"
                    },
                    {
                        "username": "8972392",
                        "content": "Agreed. Honestly the entire idea about the robot could be dropped. Just say you have a queue \\'s\\' and a stack \\'t\\', move the letters from s -> t -> \\'ans\\' such that ans is as small as lexographically possible."
                    },
                    {
                        "username": "user5454M",
                        "content": "Absolute traumatic experience with this relatively simple problem."
                    },
                    {
                        "username": "f20212839",
                        "content": "Anyone else getter Memory limit exceeded"
                    },
                    {
                        "username": "adilabuwani",
                        "content": "that sounds like a compile time error. (Probably an infinite loop)"
                    }
                ]
            },
            {
                "id": 1812446,
                "content": [
                    {
                        "username": "soliton80",
                        "content": "imho a very complicated problem statement"
                    },
                    {
                        "username": "segorucu",
                        "content": "I\\'m not really understanding this problem statement."
                    },
                    {
                        "username": "mcnguyen88",
                        "content": "1. With the two allowed operations, i.e. shift from low-end of s and then push to/pop from t, we can only get \"badd\" for case 3.\\n2. If any additional pre-processing is allowed, we may bring in a max heap to shift all elements from s to the max heap before pushing them to the stack t to get the best \"abdd\" for case 3.\\n3. Hence, the answer of \"addb\" for case 3 is either breaking constraints of the problem as in above (1.) or not the best answer as in above (2.), IMHO."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "A quick hint/clarification as to the \"smallest lexicographical string\" part. For test case three, if you\\'re wondering why the output isn\\'t \"abdd\", that is b/c of the two operations we can do. It is impossible to get \"abdd\" with only the two operations we are allowed to do. \\nThese two operations serve as limitations. Try and use these as \"guides\" when building your solution. "
                    },
                    {
                        "username": "shubs307",
                        "content": "Hints are suggesting as if Robot has knowledge of all the characters it is going to get in advance (not like a streaming as the description is suggesting). e.g. if it is getting a letter \"b\", it\\'ll use \"b\" if it knows that the smallest letter going forward is >=\"b\". Otherwise, it\\'ll decide to wait for that \"smallest\" letter (known in advance) to get the lexicographically smallest string. It suggests a conflict with the constraints or more clarity is needed in the description"
                    },
                    {
                        "username": "8972392",
                        "content": "Agreed. Honestly the entire idea about the robot could be dropped. Just say you have a queue \\'s\\' and a stack \\'t\\', move the letters from s -> t -> \\'ans\\' such that ans is as small as lexographically possible."
                    },
                    {
                        "username": "user5454M",
                        "content": "Absolute traumatic experience with this relatively simple problem."
                    },
                    {
                        "username": "f20212839",
                        "content": "Anyone else getter Memory limit exceeded"
                    },
                    {
                        "username": "adilabuwani",
                        "content": "that sounds like a compile time error. (Probably an infinite loop)"
                    }
                ]
            },
            {
                "id": 1968016,
                "content": [
                    {
                        "username": "soliton80",
                        "content": "imho a very complicated problem statement"
                    },
                    {
                        "username": "segorucu",
                        "content": "I\\'m not really understanding this problem statement."
                    },
                    {
                        "username": "mcnguyen88",
                        "content": "1. With the two allowed operations, i.e. shift from low-end of s and then push to/pop from t, we can only get \"badd\" for case 3.\\n2. If any additional pre-processing is allowed, we may bring in a max heap to shift all elements from s to the max heap before pushing them to the stack t to get the best \"abdd\" for case 3.\\n3. Hence, the answer of \"addb\" for case 3 is either breaking constraints of the problem as in above (1.) or not the best answer as in above (2.), IMHO."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "A quick hint/clarification as to the \"smallest lexicographical string\" part. For test case three, if you\\'re wondering why the output isn\\'t \"abdd\", that is b/c of the two operations we can do. It is impossible to get \"abdd\" with only the two operations we are allowed to do. \\nThese two operations serve as limitations. Try and use these as \"guides\" when building your solution. "
                    },
                    {
                        "username": "shubs307",
                        "content": "Hints are suggesting as if Robot has knowledge of all the characters it is going to get in advance (not like a streaming as the description is suggesting). e.g. if it is getting a letter \"b\", it\\'ll use \"b\" if it knows that the smallest letter going forward is >=\"b\". Otherwise, it\\'ll decide to wait for that \"smallest\" letter (known in advance) to get the lexicographically smallest string. It suggests a conflict with the constraints or more clarity is needed in the description"
                    },
                    {
                        "username": "8972392",
                        "content": "Agreed. Honestly the entire idea about the robot could be dropped. Just say you have a queue \\'s\\' and a stack \\'t\\', move the letters from s -> t -> \\'ans\\' such that ans is as small as lexographically possible."
                    },
                    {
                        "username": "user5454M",
                        "content": "Absolute traumatic experience with this relatively simple problem."
                    },
                    {
                        "username": "f20212839",
                        "content": "Anyone else getter Memory limit exceeded"
                    },
                    {
                        "username": "adilabuwani",
                        "content": "that sounds like a compile time error. (Probably an infinite loop)"
                    }
                ]
            },
            {
                "id": 2061424,
                "content": [
                    {
                        "username": "soliton80",
                        "content": "imho a very complicated problem statement"
                    },
                    {
                        "username": "segorucu",
                        "content": "I\\'m not really understanding this problem statement."
                    },
                    {
                        "username": "mcnguyen88",
                        "content": "1. With the two allowed operations, i.e. shift from low-end of s and then push to/pop from t, we can only get \"badd\" for case 3.\\n2. If any additional pre-processing is allowed, we may bring in a max heap to shift all elements from s to the max heap before pushing them to the stack t to get the best \"abdd\" for case 3.\\n3. Hence, the answer of \"addb\" for case 3 is either breaking constraints of the problem as in above (1.) or not the best answer as in above (2.), IMHO."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "A quick hint/clarification as to the \"smallest lexicographical string\" part. For test case three, if you\\'re wondering why the output isn\\'t \"abdd\", that is b/c of the two operations we can do. It is impossible to get \"abdd\" with only the two operations we are allowed to do. \\nThese two operations serve as limitations. Try and use these as \"guides\" when building your solution. "
                    },
                    {
                        "username": "shubs307",
                        "content": "Hints are suggesting as if Robot has knowledge of all the characters it is going to get in advance (not like a streaming as the description is suggesting). e.g. if it is getting a letter \"b\", it\\'ll use \"b\" if it knows that the smallest letter going forward is >=\"b\". Otherwise, it\\'ll decide to wait for that \"smallest\" letter (known in advance) to get the lexicographically smallest string. It suggests a conflict with the constraints or more clarity is needed in the description"
                    },
                    {
                        "username": "8972392",
                        "content": "Agreed. Honestly the entire idea about the robot could be dropped. Just say you have a queue \\'s\\' and a stack \\'t\\', move the letters from s -> t -> \\'ans\\' such that ans is as small as lexographically possible."
                    },
                    {
                        "username": "user5454M",
                        "content": "Absolute traumatic experience with this relatively simple problem."
                    },
                    {
                        "username": "f20212839",
                        "content": "Anyone else getter Memory limit exceeded"
                    },
                    {
                        "username": "adilabuwani",
                        "content": "that sounds like a compile time error. (Probably an infinite loop)"
                    }
                ]
            },
            {
                "id": 1911009,
                "content": [
                    {
                        "username": "soliton80",
                        "content": "imho a very complicated problem statement"
                    },
                    {
                        "username": "segorucu",
                        "content": "I\\'m not really understanding this problem statement."
                    },
                    {
                        "username": "mcnguyen88",
                        "content": "1. With the two allowed operations, i.e. shift from low-end of s and then push to/pop from t, we can only get \"badd\" for case 3.\\n2. If any additional pre-processing is allowed, we may bring in a max heap to shift all elements from s to the max heap before pushing them to the stack t to get the best \"abdd\" for case 3.\\n3. Hence, the answer of \"addb\" for case 3 is either breaking constraints of the problem as in above (1.) or not the best answer as in above (2.), IMHO."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "A quick hint/clarification as to the \"smallest lexicographical string\" part. For test case three, if you\\'re wondering why the output isn\\'t \"abdd\", that is b/c of the two operations we can do. It is impossible to get \"abdd\" with only the two operations we are allowed to do. \\nThese two operations serve as limitations. Try and use these as \"guides\" when building your solution. "
                    },
                    {
                        "username": "shubs307",
                        "content": "Hints are suggesting as if Robot has knowledge of all the characters it is going to get in advance (not like a streaming as the description is suggesting). e.g. if it is getting a letter \"b\", it\\'ll use \"b\" if it knows that the smallest letter going forward is >=\"b\". Otherwise, it\\'ll decide to wait for that \"smallest\" letter (known in advance) to get the lexicographically smallest string. It suggests a conflict with the constraints or more clarity is needed in the description"
                    },
                    {
                        "username": "8972392",
                        "content": "Agreed. Honestly the entire idea about the robot could be dropped. Just say you have a queue \\'s\\' and a stack \\'t\\', move the letters from s -> t -> \\'ans\\' such that ans is as small as lexographically possible."
                    },
                    {
                        "username": "user5454M",
                        "content": "Absolute traumatic experience with this relatively simple problem."
                    },
                    {
                        "username": "f20212839",
                        "content": "Anyone else getter Memory limit exceeded"
                    },
                    {
                        "username": "adilabuwani",
                        "content": "that sounds like a compile time error. (Probably an infinite loop)"
                    }
                ]
            }
        ]
    }
]