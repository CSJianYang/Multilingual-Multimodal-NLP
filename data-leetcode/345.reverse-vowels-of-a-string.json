[
    {
        "title": "Jump Game II",
        "question_content": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\n\t0 <= j <= nums[i] and\n\ti + j < n\n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [2,3,0,1,4]\nOutput: 2\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t0 <= nums[i] <= 1000\n\tIt's guaranteed that you can reach nums[n - 1].",
        "solutions": [
            {
                "id": 18014,
                "title": "concise-o-n-one-loop-java-solution-based-on-greedy",
                "content": "**Explanation**\\n\\nThe main idea is based on greedy. Let's say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach.  Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following:\\n\\n    public int jump(int[] A) {\\n    \\tint jumps = 0, curEnd = 0, curFarthest = 0;\\n    \\tfor (int i = 0; i < A.length - 1; i++) {\\n    \\t\\tcurFarthest = Math.max(curFarthest, i + A[i]);\\n    \\t\\tif (i == curEnd) {\\n    \\t\\t\\tjumps++;\\n    \\t\\t\\tcurEnd = curFarthest;\\n    \\t\\t}\\n    \\t}\\n    \\treturn jumps;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe main idea is based on greedy. Let's say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach.  Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following:\\n\\n    public int jump(int[] A) {\\n    \\tint jumps = 0, curEnd = 0, curFarthest = 0;\\n    \\tfor (int i = 0; i < A.length - 1; i++) {\\n    \\t\\tcurFarthest = Math.max(curFarthest, i + A[i]);\\n    \\t\\tif (i == curEnd) {\\n    \\t\\t\\tjumps++;\\n    \\t\\t\\tcurEnd = curFarthest;\\n    \\t\\t}\\n    \\t}\\n    \\treturn jumps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1192401,
                "title": "easy-solutions-w-explanation-optimizations-from-brute-force-to-dp-to-greedy-bfs",
                "content": "\\u274C ***Solution - I (Brute Force) [Rejected]***\\n\\nWe start at index 0 and are required to reach index `n - 1` (where `n = nums.size()`). We can\\'t always do the maximum jump at each index. This can be easily verified by looking at the example test cases.\\n\\nSo, at each position, we can use a jump size of anywhere in the range *`[1, nums[pos]]`*. The final answer will be the minimum jumps required. We can recursively solve this problem as -\\n\\n* If we reach index *`n-1`* return 0, signifying that we need 0 more jumps.\\n* Else recurse for each jump size possible from the current index and return the answer in which we require the minimum number of jumps\\n\\n\\n```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 10001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**. At each index `i` we have `N-i` choices and we recursively explore each of them till end. So we require `O(N*(N-1)*(N-2)...1) = O(N!)`. \\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive Dynamic Programming - Memoization) [Accepted]***\\n\\nWe can see that for a given position, we are repeatedly calculating the same answer over and over again. The jumps required to reach for a given index on the path remains fixed and can be stored in *`dp`* array to avoid re-calculations.\\n\\nThe solution is similar as the brute force with just the change that we are storing the solutions for each *`pos`* and returning it if it is already calculated.\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 10001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 10001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Iterative Dynamic Programming - Tabulation) [Accepted]***\\n\\nWe can solve this iteratively as well. For this, we start from the last index. We need 0 jumps from `nums[n-1]` to reach the end. We store this as *`dp[n - 1] = 0`* and then iteratively solve this for each previous index till the 0th index. Here *`dp[i]`* denotes minimum jumps required from current index to reach till the end.\\n\\n1. For each index, we explore all the possible jump sizes available with us. \\n2. The minimum jumps required to reach the end from the current index would be - **`min(dp[jumpLen])`**, where *`1 <= jumpLen <= nums[currentPostion]`*\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 10001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution IV (Greedy BFS)***\\n\\nWe can iterate over all indices maintaining the furthest reachable position from current index - *`maxReachable`* and currently furthest reached position - *`lastJumpedPos`*. Everytime we will try to update *`lastJumpedPos`* to furthest possible reachable index - `maxReachable`.\\n\\nUpdating the `lastJumpedPos` separately from *`maxReachable`* allows us to maintain track of minimum *`jumps`* required. Each time `lastJumpedPos` is updated, ***`jumps`*** will also be updated and store the minimum jumps required to reach `lastJumpedPos` (On the contrary, updating `jumps` with `maxReachable` won\\'t give the optimal (minimum possible) value of jumps required). \\n\\nWe will just return it as soon as *`lastJumpedPos`* reaches(or exceeds) last index.\\n\\nWe can try to understand the steps in code below as analogous to those in BFS as -\\n\\n1. **`maxReachable = max(maxReachable, i + nums[i])`** : Updating the range of next level. Similar to  *`queue.push(node)`* step of BFS but here we are only greedily storing the max reachable index on next level.\\n\\n\\n2. **`i == lastJumpedPos`** :  When it becomes true, current level iteration has been completed.\\n3. **`lastJumpedPos = maxReachable`** : Set range till which we need to iterate the next level\\n4. **`jumps++`** : Move on to the next level.\\n\\n5. **`return jumps`** : The final answer will be number of levels in BFS traversal.\\n\\nFor eg. Take the example : `nums = [2,3,1,4,1,1,1,2]`. This approach proceeds as illustrated in image below -\\n\\n<p align=center>\\n<img src=https://assets.leetcode.com/users/images/4e5cbbb4-a6d0-4523-a945-261ee4b53f72_1620216977.5849538.png /></p>\\n\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 10001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 10001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 10001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 10001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18028,
                "title": "o-n-bfs-solution",
                "content": "I try to change this problem to a BFS problem, where nodes in level i are all the nodes that can be reached in i-1th jump. for example.   2 3 1 1 4 , is \\n                   2||\\n               3   1||\\n               1   4  || \\n\\nclearly,  the minimum jump of 4 is 2 since 4 is in level 3.  my ac code.\\n\\n\\n\\n     int jump(int A[], int n) {\\n    \\t if(n<2)return 0;\\n    \\t int level=0,currentMax=0,i=0,nextMax=0;\\n    \\n    \\t while(currentMax-i+1>0){\\t\\t//nodes count of current level>0\\n    \\t\\t level++;\\n    \\t\\t for(;i<=currentMax;i++){\\t//traverse current level , and update the max reach of next level\\n    \\t\\t\\tnextMax=max(nextMax,A[i]+i);\\n    \\t\\t\\tif(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level \\n    \\t\\t }\\n    \\t\\t currentMax=nextMax;\\n    \\t }\\n    \\t return 0;\\n     }",
                "solutionTags": [],
                "code": "I try to change this problem to a BFS problem, where nodes in level i are all the nodes that can be reached in i-1th jump. for example.   2 3 1 1 4 , is \\n                   2||\\n               3   1||\\n               1   4  || \\n\\nclearly,  the minimum jump of 4 is 2 since 4 is in level 3.  my ac code.\\n\\n\\n\\n     int jump(int A[], int n) {\\n    \\t if(n<2)return 0;\\n    \\t int level=0,currentMax=0,i=0,nextMax=0;\\n    \\n    \\t while(currentMax-i+1>0){\\t\\t//nodes count of current level>0\\n    \\t\\t level++;\\n    \\t\\t for(;i<=currentMax;i++){\\t//traverse current level , and update the max reach of next level\\n    \\t\\t\\tnextMax=max(nextMax,A[i]+i);\\n    \\t\\t\\tif(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level \\n    \\t\\t }\\n    \\t\\t currentMax=nextMax;\\n    \\t }\\n    \\t return 0;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 170518,
                "title": "8-lines-in-python-easiest-solution",
                "content": "The idea is to maintain two pointers `left` and `right`, where left initialy set to be `0` and `right` set to be `nums[0]`.\\nSo points between `0` and `nums[0]` are the ones you can reach by using just 1 jump.\\nNext, we want to find points I can reach using 2 jumps, so our new  `left` will be set equal to `right`, and our new `right` will be set equal to the farest point we can reach by `two` jumps. which is:\\n`right = max(i + nums[i] for i in range(left, right + 1)`\\n\\nCode:\\n```python\\n    def jump(self, nums):\\n        if len(nums) <= 1: return 0\\n        l, r = 0, nums[0]\\n        times = 1\\n        while r < len(nums) - 1:\\n            times += 1\\n            nxt = max(i + nums[i] for i in range(l, r + 1))\\n            l, r = r, nxt\\n        return times\\n```",
                "solutionTags": [],
                "code": "```python\\n    def jump(self, nums):\\n        if len(nums) <= 1: return 0\\n        l, r = 0, nums[0]\\n        times = 1\\n        while r < len(nums) - 1:\\n            times += 1\\n            nxt = max(i + nums[i] for i in range(l, r + 1))\\n            l, r = r, nxt\\n        return times\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18019,
                "title": "10-lines-c-16ms-python-bfs-solutions-with-explanations",
                "content": "This problem has a nice BFS structure. Let's illustrate it using the example `nums = [2, 3, 1, 1, 4]` in the problem statement. We are initially at position `0`. Then we can move at most `nums[0]` steps from it. So, after one move, we may reach `nums[1] = 3` or `nums[2] = 1`. So these nodes are reachable in `1` move. From these nodes, we can further move to `nums[3] = 1` and `nums[4] = 4`. Now you can see that the target `nums[4] = 4` is reachable in `2` moves. \\n\\nPutting these into codes, we keep two pointers `start` and `end` that record the current range of the starting nodes. Each time after we make a move, update `start` to be `end  + 1` and `end` to be the farthest index that can be reached in `1` move from the current `[start, end]`. \\n \\nTo get an accepted solution, it is important to handle all the edge cases. And the following codes handle all of them in a unified way without using the unclean `if` statements :-)\\n \\n----------\\n**C++**\\n\\n    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int n = nums.size(), step = 0, start = 0, end = 0;\\n            while (end < n - 1) {\\n                step++; \\n    \\t\\t\\tint maxend = end + 1;\\n    \\t\\t\\tfor (int i = start; i <= end; i++) {\\n                    if (i + nums[i] >= n - 1) return step;\\n    \\t\\t\\t\\tmaxend = max(maxend, i + nums[i]);\\n    \\t\\t\\t}\\n                start = end + 1;\\n                end = maxend;\\n            }\\n    \\t\\treturn step;\\n        }\\n    };\\n\\n----------\\n**Python** \\n\\n    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def jump(self, nums):\\n            n, start, end, step = len(nums), 0, 0, 0\\n            while end < n - 1:\\n                step += 1\\n                maxend = end + 1\\n                for i in range(start, end + 1):\\n                    if i + nums[i] >= n - 1:\\n                        return step\\n                    maxend = max(maxend, i + nums[i])\\n                start, end = end + 1, maxend\\n            return step",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int n = nums.size(), step = 0, start = 0, end = 0;\\n            while (end < n - 1) {\\n                step++; \\n    \\t\\t\\tint maxend = end + 1;\\n    \\t\\t\\tfor (int i = start; i <= end; i++) {\\n                    if (i + nums[i] >= n - 1) return step;\\n    \\t\\t\\t\\tmaxend = max(maxend, i + nums[i]);\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3158218,
                "title": "c-faster-than-75-straight-forward-method-clean-and-concise-code",
                "content": "\\n# Code\\n\\n# Please Do Upvote!!!!\\n##### Connect with me on Linkedin -> https://www.linkedin.com/in/md-kamran-55b98521a/\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int ind = 0;\\n      int ans = 0;\\n\\n      while(ind < nums.size() - 1)\\n      {\\n        ans++;\\n        ind = nums[ind];\\n      }\\n\\n      return ans;\\n    }\\n};\\n\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/24f080eb-397a-4a09-a9f5-6a9a315c955f_1675822350.8603303.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int ind = 0;\\n      int ans = 0;\\n\\n      while(ind < nums.size() - 1)\\n      {\\n        ans++;\\n        ind = nums[ind];\\n      }\\n\\n      return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18023,
                "title": "single-loop-simple-java-solution",
                "content": "    public int jump(int[] A) {\\n        int sc = 0;\\n        int e = 0;\\n        int max = 0;\\n        for(int i=0; i<A.length-1; i++) {\\n            max = Math.max(max, i+A[i]);\\n            if( i == e ) {\\n                sc++;\\n                e = max;\\n            } \\n        }\\n        return sc;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int jump(int[] A) {\\n        int sc = 0;\\n        int e = 0;\\n        int max = 0;\\n        for(int i=0; i<A.length-1; i++) {\\n            max = Math.max(max, i+A[i]);\\n            if( i == e ) {\\n                sc++;\\n                e = max;\\n            } \\n        }\\n        return sc;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3158169,
                "title": "clean-codes-full-explanation-implicit-bfs-c-java-python3",
                "content": "# Intuition :\\n- We have to find the minimum number of jumps required to reach the end of a given array of non-negative integers i.e the shortest number of jumps needed to reach the end of an array of numbers.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Explanation to Approach :\\n- We are using a search algorithm that works by moving forward in steps and counting each step as a jump. \\n- The algorithm keeps track of the farthest reachable position at each step and updates the number of jumps needed to reach that farthest position. \\n- The algorithm returns the minimum number of jumps needed to reach the end of the array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n\\n# Codes [C++ |Java |Python3] with Comments :\\n```C++ []\\nclass Solution {\\n public:\\n  int jump(vector<int>& nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.size() - 1; ++i) {\\n      farthest = max(farthest, i + nums[i]);\\n      if (farthest >= nums.size() - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {    // Visited all the items on the current level\\n        ++ans;           // Increment the level\\n        end = farthest;  // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int jump(int[] nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.length - 1; ++i) {\\n      farthest = Math.max(farthest, i + nums[i]);\\n      if (farthest >= nums.length - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {   // Visited all the items on the current level\\n        ++ans;          // Increment the level\\n        end = farthest; // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def jump(self, nums: List[int]) -> int:\\n    ans = 0\\n    end = 0\\n    farthest = 0\\n\\n    # Implicit BFS\\n    for i in range(len(nums) - 1):\\n      farthest = max(farthest, i + nums[i])\\n      if farthest >= len(nums) - 1:\\n        ans += 1\\n        break\\n      if i == end:      # Visited all the items on the current level\\n        ans += 1        # Increment the level\\n        end = farthest  # Make the queue size for the next level\\n\\n    return ans\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/de42de8f-f353-42b7-b09c-6408c3aa214b_1675820540.1398566.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int jump(vector<int>& nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.size() - 1; ++i) {\\n      farthest = max(farthest, i + nums[i]);\\n      if (farthest >= nums.size() - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {    // Visited all the items on the current level\\n        ++ans;           // Increment the level\\n        end = farthest;  // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int jump(int[] nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.length - 1; ++i) {\\n      farthest = Math.max(farthest, i + nums[i]);\\n      if (farthest >= nums.length - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {   // Visited all the items on the current level\\n        ++ans;          // Increment the level\\n        end = farthest; // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def jump(self, nums: List[int]) -> int:\\n    ans = 0\\n    end = 0\\n    farthest = 0\\n\\n    # Implicit BFS\\n    for i in range(len(nums) - 1):\\n      farthest = max(farthest, i + nums[i])\\n      if farthest >= len(nums) - 1:\\n        ans += 1\\n        break\\n      if i == end:      # Visited all the items on the current level\\n        ans += 1        # Increment the level\\n        end = farthest  # Make the queue size for the next level\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770191,
                "title": "cpp-recursive-memoization-o-n-three-solution-easy-to-understand",
                "content": "***Resources: https://github.com/AJAYKR00KJ/LeetCode_Solution***\\n\\n**Here is step by step three solution recursive , memoization solution and finally O(n) solution**\\n\\n**1. Recursive solution but it will give TLE:**\\n```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> nums , int curr, int dest)\\n    {       \\n            if(curr>=dest) return 0; \\n            long long int tmp=INT_MAX;\\n\\t\\t\\t\\n            //Try Every jump 1 to nums[curr] jump\\n            //and find minimum steps need to reach to end\\n\\t\\t\\t\\n            for(int i=1;i<=nums[curr];i++)\\n            {\\n                tmp=min(tmp,1+jump(nums,curr+i,dest));  \\n            } \\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) { \\n         return jump(nums,0,nums.size()-1);\\n    }\\n};\\n```\\n**Time Complexity: O(k^n)**, Where,  **k** is max element of nums and **n** is size of nums.\\n**Space Complexity: O(1).**\\nBecause every time inside the recursive function it is calling itself nums[i] times and this is happening for every element (i.e n elements).  \\n\\n\\n**2. Memoization of recursive solution but it may give TLE.**\\n\\n```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> &nums , int curr, int dest,vector<int> &dp)\\n    {       \\n            if(curr==dest) return 0;\\n            if(dp[curr]!=-1) return dp[curr];\\n            //cout<<curr<<\" \";\\n            long long int tmp=INT_MAX;\\n     \\n            for(int i=1;i<=nums[curr];i++)\\n            {   if(i+curr>dest) break;\\n                tmp=min(tmp,1+jump(nums,curr+i,dest,dp));  \\n            }\\n         dp[curr]=tmp;\\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) {\\n         vector<int> dp(nums.size(),-1);\\n         return jump(nums,0,nums.size()-1,dp);\\n    }\\n};\\n\\n```\\n**Time Complexity: O(k * n)**, Where,  **k** is max element of nums and **n** is size of nums.\\n**Space Complexity: O(n).**\\nBecause every time inside the recursive function it is calling itself nums[i] times and this is happening for every element (i.e n elements). But here we have stored previous calculated result, so there will be no repeation.  \\n\\n\\n\\n**3. O(n) Solution (accepted)**\\n\\n**We run loop from 0 to size()-1 because we have to reach at last index, think just previous stage when we take jump and reach to last index (size()-1) the we have counted our jump previously and we reach to last index hence we end our journey.**\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump, we can take jump from particular  index\\n\\t\\t//mxjump , we cango up to maximum\\n\\t\\t// jump to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(n)**, Where,  **n** is size of nums.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> nums , int curr, int dest)\\n    {       \\n            if(curr>=dest) return 0; \\n            long long int tmp=INT_MAX;\\n\\t\\t\\t\\n            //Try Every jump 1 to nums[curr] jump\\n            //and find minimum steps need to reach to end\\n\\t\\t\\t\\n            for(int i=1;i<=nums[curr];i++)\\n            {\\n                tmp=min(tmp,1+jump(nums,curr+i,dest));  \\n            } \\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) { \\n         return jump(nums,0,nums.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> &nums , int curr, int dest,vector<int> &dp)\\n    {       \\n            if(curr==dest) return 0;\\n            if(dp[curr]!=-1) return dp[curr];\\n            //cout<<curr<<\" \";\\n            long long int tmp=INT_MAX;\\n     \\n            for(int i=1;i<=nums[curr];i++)\\n            {   if(i+curr>dest) break;\\n                tmp=min(tmp,1+jump(nums,curr+i,dest,dp));  \\n            }\\n         dp[curr]=tmp;\\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) {\\n         vector<int> dp(nums.size(),-1);\\n         return jump(nums,0,nums.size()-1,dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump, we can take jump from particular  index\\n\\t\\t//mxjump , we cango up to maximum\\n\\t\\t// jump to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 485780,
                "title": "python-java-js-c-o-n-sol-based-on-greedy-of-coverage-with-explanation",
                "content": "O( n ) sol. based on greedy of coverage.\\n\\n---\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        # destination is last index\\n        destination = size - 1\\n        \\n        # record of current coverage, record of last jump index\\n        cur_coverage, last_jump_index = 0, 0\\n        \\n        # counter for jump\\n        times_of_jump = 0\\n        \\n         # Quick response if start index == destination index == 0\\n        if size == 1:\\n            return 0\\n        \\n        \\n        # Greedy strategy: extend coverage as long as possible with lazy jump\\n        for i in range( 0, size):\\n            \\n            # extend current coverage as further as possible\\n            cur_coverage = max( cur_coverage, i + nums[i] )\\n            \\n\\n            # forced to jump (by lazy jump) to extend coverage  \\n            if i == last_jump_index:\\n            \\n                # update last jump index\\n                last_jump_index = cur_coverage\\n                \\n                # update counter of jump by +1\\n                times_of_jump += 1\\n                \\n                # check if reached destination already\\n                if cur_coverage >= destination:\\n                        return times_of_jump\\n                \\n        return times_of_jump\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\nvar jump = function(nums) {\\n\\n    const size = nums.length;\\n\\n    // destination is last index\\n    let destination = size-1;\\n\\n    let curCoverage = 0, lastJumpIdx = 0;\\n\\n    // counter of jump\\n    let timesOfJump = 0;\\n\\n    // Quick response if start index == destination index == 0\\n    if( size == 1 ){\\n        return 0;\\n    }\\n\\n\\n    // Greedy stragegy: extend coverage as long as possible with lazp jump\\n    for( let i = 0 ; i < size ; i++){\\n\\n        // extend coverage\\n        curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n        // forced to jump (by lazy jump) to extend coverage\\n        if( i == lastJumpIdx ){\\n\\n            lastJumpIdx = curCoverage;\\n\\n            timesOfJump++;\\n\\n            // check if we reached destination already\\n            if( curCoverage >= destination){\\n                return timesOfJump;\\n            }\\n        }\\n    }\\n\\n    return timesOfJump;\\n    \\n\\n};\\n```\\n\\n---\\n\\n**C++**:\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        const int size = nums.size();\\n        \\n        // destination is last index\\n        int destination = size-1;\\n        \\n        int curCoverage = 0, lastJumpIdx = 0;\\n        \\n        // counter of jump\\n        int timesOfJump = 0;\\n        \\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n            \\n        \\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n            \\n            // extend coverage\\n            curCoverage = max(curCoverage, i + nums[i] );\\n            \\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n                \\n                lastJumpIdx = curCoverage;\\n                \\n                timesOfJump++;\\n                \\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n        \\n        return timesOfJump;\\n    }\\n};\\n```\\n\\n---\\n\\n**Java**:\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        final int size = nums.length;\\n\\n        // destination is last index\\n        int destination = size-1;\\n\\n        int curCoverage = 0, lastJumpIdx = 0;\\n\\n        // counter of jump\\n        int timesOfJump = 0;\\n\\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n\\n\\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n\\n            // extend coverage\\n            curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n\\n                lastJumpIdx = curCoverage;\\n\\n                timesOfJump++;\\n\\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n\\n        return timesOfJump;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        # destination is last index\\n        destination = size - 1\\n        \\n        # record of current coverage, record of last jump index\\n        cur_coverage, last_jump_index = 0, 0\\n        \\n        # counter for jump\\n        times_of_jump = 0\\n        \\n         # Quick response if start index == destination index == 0\\n        if size == 1:\\n            return 0\\n        \\n        \\n        # Greedy strategy: extend coverage as long as possible with lazy jump\\n        for i in range( 0, size):\\n            \\n            # extend current coverage as further as possible\\n            cur_coverage = max( cur_coverage, i + nums[i] )\\n            \\n\\n            # forced to jump (by lazy jump) to extend coverage  \\n            if i == last_jump_index:\\n            \\n                # update last jump index\\n                last_jump_index = cur_coverage\\n                \\n                # update counter of jump by +1\\n                times_of_jump += 1\\n                \\n                # check if reached destination already\\n                if cur_coverage >= destination:\\n                        return times_of_jump\\n                \\n        return times_of_jump\\n```\n```\\nvar jump = function(nums) {\\n\\n    const size = nums.length;\\n\\n    // destination is last index\\n    let destination = size-1;\\n\\n    let curCoverage = 0, lastJumpIdx = 0;\\n\\n    // counter of jump\\n    let timesOfJump = 0;\\n\\n    // Quick response if start index == destination index == 0\\n    if( size == 1 ){\\n        return 0;\\n    }\\n\\n\\n    // Greedy stragegy: extend coverage as long as possible with lazp jump\\n    for( let i = 0 ; i < size ; i++){\\n\\n        // extend coverage\\n        curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n        // forced to jump (by lazy jump) to extend coverage\\n        if( i == lastJumpIdx ){\\n\\n            lastJumpIdx = curCoverage;\\n\\n            timesOfJump++;\\n\\n            // check if we reached destination already\\n            if( curCoverage >= destination){\\n                return timesOfJump;\\n            }\\n        }\\n    }\\n\\n    return timesOfJump;\\n    \\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        const int size = nums.size();\\n        \\n        // destination is last index\\n        int destination = size-1;\\n        \\n        int curCoverage = 0, lastJumpIdx = 0;\\n        \\n        // counter of jump\\n        int timesOfJump = 0;\\n        \\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n            \\n        \\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n            \\n            // extend coverage\\n            curCoverage = max(curCoverage, i + nums[i] );\\n            \\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n                \\n                lastJumpIdx = curCoverage;\\n                \\n                timesOfJump++;\\n                \\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n        \\n        return timesOfJump;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        final int size = nums.length;\\n\\n        // destination is last index\\n        int destination = size-1;\\n\\n        int curCoverage = 0, lastJumpIdx = 0;\\n\\n        // counter of jump\\n        int timesOfJump = 0;\\n\\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n\\n\\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n\\n            // extend coverage\\n            curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n\\n                lastJumpIdx = curCoverage;\\n\\n                timesOfJump++;\\n\\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n\\n        return timesOfJump;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192396,
                "title": "js-python-java-c-simple-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince each element of our input array (**N**) represents the maximum jump length and not the definite jump length, that means we can visit any index between the current index (**i**) and **i + N[i]**. Stretching that to its logical conclusion, we can safely iterate through **N** while keeping track of the furthest index reachable (**next**) at any given moment (**next = max(next, i + N[i])**). We\\'ll know we\\'ve found our solution once **next** reaches or passes the last index (**next >= N.length - 1**).\\n\\nThe difficulty then lies in keeping track of how many jumps it takes to reach that point. We can\\'t simply count the number of times we update **next**, as we may see that happen more than once while still in the current jump\\'s range. In fact, we can\\'t be sure of the best next jump until we reach the end of the current jump\\'s range.\\n\\nSo in addition to **next**, we\\'ll also need to keep track of the current jump\\'s endpoint (**curr**) as well as the number of jumps taken so far (**ans**).\\n\\nSince we\\'ll want to **return ans** at the earliest possibility, we should base it on **next**, as noted earlier. With careful initial definitions for **curr** and **next**, we can start our iteration at **i = 0** and **ans = 0** without the need for edge case return expressions.\\n\\n - _**Time Complexity: O(N)** where N is the length of N_\\n - _**Space Cmplexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 37.7MB** (beats 95% / 100%).\\n```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **16ms / 14.0MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.1MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.9MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18089,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "If we cannot come up with the optimal solution at first thought, we may think about the brute force method and improve it.\\n1. Brute force O(2^n), this is the most straight forward solution, just try all the moves.\\n* java\\n```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return minSteps;\\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0; //end is reached\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1; //end can be reached by 1 jump from p\\n        int ret = n, mj; // n is larger than max jumps (n-1)\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums)) == 1) return 2; //end can be reached by 2 jumps from p\\n            ret = min(ret,mj);\\n        }\\n        return ret+1;\\n    }\\n```\\n2. Memoization O(n^2)\\n* java\\n```\\n\\tInteger[] mem;\\n    public int jump(int[] nums) {\\n        mem=new Integer[nums.length];\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(mem[p]!=null)\\n            return mem[p];\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return mem[p]=minSteps;\\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        vector<int> mem(nums.size(),-1);\\n        return jump(0,nums,mem);    \\n    }\\n    int jump(int p, vector<int>& nums, vector<int>& mem) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        if(mem[p]>=0) return mem[p];\\n        int ret = n, mj;\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums,mem)) == 1) return mem[p]=2;\\n            ret = min(ret,mj);\\n        }\\n        return mem[p] = ret+1;\\n    }\\n```\\n3. dp O(n^2)\\n* java\\n```\\n\\tpublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp=new int[n];\\n        for(int i=n-2;i>=0;i--) {\\n            dp[i]=n;\\n            for(int j=1;j<=nums[i]&&i+j<n;j++) \\n                dp[i]=Math.min(dp[i],1+dp[i+j]);\\n        }\\n        return dp[0];        \\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,n);\\n        dp[n-1]=0;\\n        for(int i=n-2;i>=0;i--) {\\n            int range = i+nums[i];\\n            if (range >= n-1) { \\n                dp[i]=1;\\n                continue;\\n            }\\n            for(int j = range; j > i; j--) {\\n                if(dp[j]==1) {\\n                    dp[i]=2;\\n                    break;\\n                }\\n                dp[i] = min(dp[i],dp[j]+1);\\n            }\\n        }\\n        return dp[0];    \\n    }\\n```\\n4. Greedy O(n). There are redundancy in the above approaches. From a position, the number of steps to jump is the one that can go furthest after the jump. Because it covers all the options of the other choices.\\n* java\\n```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(p+nums[p]>=n-1)\\n            return 1;\\n        int max=0, steps=0;\\n        for(int i=1;i<=nums[p];i++) {\\n            int jump2 = i+nums[p+i];\\n            if(jump2>max) {\\n                max = jump2;\\n                steps = i;\\n            }   \\n        }\\n        return 1+jump(p+steps, nums);\\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        int nxt, max_reach = -1, reach;\\n        for(int i=range; i>p;i--) {\\n            if((reach=i+nums[i]) >= n-1) return 2;\\n            if(reach > max_reach) {\\n                max_reach = reach;\\n                nxt = i;\\n            }\\n        }\\n        return 1+jump(nxt,nums);\\n    }\\n```\\n5. BFS O(n) Time, O(1) Space. The problem asks for shortest path and it is natrual to think of BFS. Nodes are array elements. For an element, neighbors are the elements that are within its max jump length. Given nodes in current level, we generate all nodes in the next level. Nodes are traversed level by level.\\n```\\n\\tpublic int jump(int[] nums) {\\n        int steps = 0, curLevelEnd = 0, nxtLevelEnd = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(i>curLevelEnd) {\\n                steps++;\\n                curLevelEnd = nxtLevelEnd;\\n            }    \\n            nxtLevelEnd = Math.max(nxtLevelEnd, i+nums[i]);\\n        }\\n        return steps;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return minSteps;\\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0; //end is reached\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1; //end can be reached by 1 jump from p\\n        int ret = n, mj; // n is larger than max jumps (n-1)\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums)) == 1) return 2; //end can be reached by 2 jumps from p\\n            ret = min(ret,mj);\\n        }\\n        return ret+1;\\n    }\\n```\n```\\n\\tInteger[] mem;\\n    public int jump(int[] nums) {\\n        mem=new Integer[nums.length];\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(mem[p]!=null)\\n            return mem[p];\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return mem[p]=minSteps;\\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        vector<int> mem(nums.size(),-1);\\n        return jump(0,nums,mem);    \\n    }\\n    int jump(int p, vector<int>& nums, vector<int>& mem) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        if(mem[p]>=0) return mem[p];\\n        int ret = n, mj;\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums,mem)) == 1) return mem[p]=2;\\n            ret = min(ret,mj);\\n        }\\n        return mem[p] = ret+1;\\n    }\\n```\n```\\n\\tpublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp=new int[n];\\n        for(int i=n-2;i>=0;i--) {\\n            dp[i]=n;\\n            for(int j=1;j<=nums[i]&&i+j<n;j++) \\n                dp[i]=Math.min(dp[i],1+dp[i+j]);\\n        }\\n        return dp[0];        \\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,n);\\n        dp[n-1]=0;\\n        for(int i=n-2;i>=0;i--) {\\n            int range = i+nums[i];\\n            if (range >= n-1) { \\n                dp[i]=1;\\n                continue;\\n            }\\n            for(int j = range; j > i; j--) {\\n                if(dp[j]==1) {\\n                    dp[i]=2;\\n                    break;\\n                }\\n                dp[i] = min(dp[i],dp[j]+1);\\n            }\\n        }\\n        return dp[0];    \\n    }\\n```\n```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(p+nums[p]>=n-1)\\n            return 1;\\n        int max=0, steps=0;\\n        for(int i=1;i<=nums[p];i++) {\\n            int jump2 = i+nums[p+i];\\n            if(jump2>max) {\\n                max = jump2;\\n                steps = i;\\n            }   \\n        }\\n        return 1+jump(p+steps, nums);\\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        int nxt, max_reach = -1, reach;\\n        for(int i=range; i>p;i--) {\\n            if((reach=i+nums[i]) >= n-1) return 2;\\n            if(reach > max_reach) {\\n                max_reach = reach;\\n                nxt = i;\\n            }\\n        }\\n        return 1+jump(nxt,nums);\\n    }\\n```\n```\\n\\tpublic int jump(int[] nums) {\\n        int steps = 0, curLevelEnd = 0, nxtLevelEnd = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(i>curLevelEnd) {\\n                steps++;\\n                curLevelEnd = nxtLevelEnd;\\n            }    \\n            nxtLevelEnd = Math.max(nxtLevelEnd, i+nums[i]);\\n        }\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192457,
                "title": "java-python-dp-greedy-solutions-time-o-n-space-o-1",
                "content": "**\\u2714\\uFE0F Solution 1: Top-Down DP (Some time TLE)**\\n- Let `dp(i)` denote the minimum number of steps to reach the `i`th index, starting from index `0`.\\n- Then `dp(0)` is our result.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1: return 0  # Reached to last index\\n            ans = math.inf\\n            maxJump = min(n - 1, i + nums[i])\\n            for j in range(i + 1, maxJump + 1):\\n                ans = min(ans, dp(j) + 1)\\n            return ans\\n\\n        return dp(0)\\n```\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is the length of array `nums`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Top-Down DP**\\n- Let `dp[i]` denote the minimum number of steps to reach the `i`th index, starting from index `0`.\\n- Then `dp[0]` is our result.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [math.inf] * n\\n        dp[n-1] = 0\\n        \\n        for i in range(n-2, -1, -1):\\n            maxJump = min(i+nums[i], n-1)\\n            for j in range(i+1, maxJump+1):\\n                dp[i] = min(dp[i], dp[j] + 1)\\n                \\n        return dp[0]\\n```\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is the length of array `nums`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Greedy**\\n- The main idea is based on greedy. \\n- Step 1: Let\\'s say the range of the current jump is `[left, right]`, `farthest` is the farthest position that all positions in `[left, right]` can reach.\\n- Step 2: Once we reach to `right`, we trigger another jump with `left = right + 1`, `right = farthest`, then repeat step 1 util we reach at the end.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps = 0\\n        farthest = 0\\n        left = right = 0\\n        while right < len(nums) - 1:\\n            for i in range(left, right + 1):\\n                farthest = max(farthest, i + nums[i])\\n            left = right + 1\\n            right = farthest\\n            jumps += 1\\n            \\n        return jumps\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int jumps = 0, farthest = 0;\\n        int left = 0, right = 0;\\n        while (right < nums.length - 1) {\\n            for (int i = left; i <= right; ++i)\\n                farthest = Math.max(farthest, i + nums[i]);\\n            left = right + 1;\\n            right = farthest;\\n            ++jumps;\\n        }\\n        return jumps;\\n    }\\n}\\n```\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is the length of array `nums`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1: return 0  # Reached to last index\\n            ans = math.inf\\n            maxJump = min(n - 1, i + nums[i])\\n            for j in range(i + 1, maxJump + 1):\\n                ans = min(ans, dp(j) + 1)\\n            return ans\\n\\n        return dp(0)\\n```\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [math.inf] * n\\n        dp[n-1] = 0\\n        \\n        for i in range(n-2, -1, -1):\\n            maxJump = min(i+nums[i], n-1)\\n            for j in range(i+1, maxJump+1):\\n                dp[i] = min(dp[i], dp[j] + 1)\\n                \\n        return dp[0]\\n```\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps = 0\\n        farthest = 0\\n        left = right = 0\\n        while right < len(nums) - 1:\\n            for i in range(left, right + 1):\\n                farthest = max(farthest, i + nums[i])\\n            left = right + 1\\n            right = farthest\\n            jumps += 1\\n            \\n        return jumps\\n```\n```java\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int jumps = 0, farthest = 0;\\n        int left = 0, right = 0;\\n        while (right < nums.length - 1) {\\n            for (int i = left; i <= right; ++i)\\n                farthest = Math.max(farthest, i + nums[i]);\\n            left = right + 1;\\n            right = farthest;\\n            ++jumps;\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197063,
                "title": "intuitive-explanation-w-solution-analysis-java-beginner-dp",
                "content": "This problem is one of the simplest and best problems for beginners to understand one of the most difficult yet rewarding algorithm - **Dynamic Programming**. The aim of the post is not to just throw away with a working solution, rather provide a new perspective for beginners and potential learners on how to deconstruct a problem statement to understand the crux of it and reconstruct back into a working algorithm. Let\\'s quickly get into the process of understanding the problem and coming up with some intuitions and solutions.\\n\\n**INTUITION**\\n1. **It is mentioned in the problem that we start from the initial position and we can always reach the end position. We need to reach them with minimum possible steps.**\\nThis means that from the start position, there can be one or many possible ways of jumps (traversing through multiple sets of indices) to reach the end point. Hence it will be initially necessary to have a data structure that stores the optimum number of jumps to reach any particular index. Since the constraints states that the input array length will be less than 1000 *(1 <= nums.length <= 1000)*, we create an output array of length 1000 *(ideally length of input array)* and maintain the minimum jumps required to reach each position.\\n\\n2. **All indices are unreachable initially.**\\nSince we start from the first position, it is impossible to reach all the other indices without making the first move. So all of them can be initialized with some maximum value *(1e9 or Integer.MAX_VALUE)*. However, since we are standing in the first position, it is reachable by default without making any move. Hence we initialize the value of the first index in the output array as 0.\\n\\n**CODE & EXPLANTION**\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int i,n,j;\\n        n=nums.length;\\n        int [] pre = new int[n];\\n        for(i=0;i<n;i++)\\n        {\\n            // Initialize all the index position with some max value to denote it is unreachable\\n            pre[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Make the first position value as 0 as it is the default place where we start\\n        pre[0] = 0;\\n\\t\\t// Main condition check goes here.\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=i;j<=i+nums[i] && j<n;j++)\\n            {\\n                pre[j] = Math.min(pre[j], pre[i]+1);\\n            }\\n        }\\n        return pre[n-1];\\n    }\\n}\\n```\\n\\nLet\\'s try to understand the loop where the main condition check happens. Each value in the nums array specifies the jump that is possible to take from the current position. So if the value in the ith index is nums[i], then it is understandable that from **(ith) position to (i+nums[i])th position** *(i, i+1, i+2, ...., i+nums[i])*, it can be reached in a single jump. However as already mentioned, since a particular position can be reached from various other position, we need to store the minimum possible jump value to reach the position.\\n*pre[j] = Math.min(pre[j], pre[i]+1)*.\\n\\nBy filling it this way, we can naturally fill the way the last element is reached also and return the pre[n-1] value directly.\\n\\nThere goes around a popular saying that *\\'When one learns things right, he learns them only once\\'*. There could be many people (including me :P) who would have done hundreds of problems and still finds it difficult to crack the next one because of a gap in the understanding and ability to convert that into code. Lets make use of this post to address some basic intuitions and approaches along with constructing a solution for this problem.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int i,n,j;\\n        n=nums.length;\\n        int [] pre = new int[n];\\n        for(i=0;i<n;i++)\\n        {\\n            // Initialize all the index position with some max value to denote it is unreachable\\n            pre[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Make the first position value as 0 as it is the default place where we start\\n        pre[0] = 0;\\n\\t\\t// Main condition check goes here.\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=i;j<=i+nums[i] && j<n;j++)\\n            {\\n                pre[j] = Math.min(pre[j], pre[i]+1);\\n            }\\n        }\\n        return pre[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18207,
                "title": "sharing-my-straightforward-c-solution",
                "content": "    int jump(int A[], int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        int maxReachPos = A[0];\\n        int curMaxReachPos = A[0];\\n        int curStep = 1;\\n        for(int i = 1; i <= min(n, maxReachPos); i++){\\n            curMaxReachPos = max(curMaxReachPos, i + A[i]);\\n            if(i == n - 1){\\n                return curStep;\\n            }\\n            if(i == maxReachPos){\\n                maxReachPos = curMaxReachPos;\\n                curStep++;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nThe variable maxReachPos indicates the farthest reachable position and the variable curMaxReachPos indicates the current farthest reachable position.\\n\\nAt the very beginning, both maxReachPos and curMaxReachPos are equal to A[0].\\n\\nIn the For loop, we keep updating curMaxReachPos while i <= maxReachPos. However, if( i == n - 1), we return curStep, which is the minimum step. If i reaches the maxReachPos, we update maxReachPos with curMaxReachPos and increment curStep by one. \\n\\nFinally, if we can't reach the end point, just return 0.",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "    int jump(int A[], int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        int maxReachPos = A[0];\\n        int curMaxReachPos = A[0];\\n        int curStep = 1;\\n        for(int i = 1; i <= min(n, maxReachPos); i++){\\n            curMaxReachPos = max(curMaxReachPos, i + A[i]);\\n            if(i == n - 1){\\n                return curStep;\\n            }\\n            if(i == maxReachPos){\\n                maxReachPos = curMaxReachPos;\\n                curStep++;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nThe variable maxReachPos indicates the farthest reachable position and the variable curMaxReachPos indicates the current farthest reachable position.\\n\\nAt the very beginning, both maxReachPos and curMaxReachPos are equal to A[0].\\n\\nIn the For loop, we keep updating curMaxReachPos while i <= maxReachPos. However, if( i == n - 1), we return curStep, which is the minimum step. If i reaches the maxReachPos, we update maxReachPos with curMaxReachPos and increment curStep by one. \\n\\nFinally, if we can't reach the end point, just return 0.",
                "codeTag": "Unknown"
            },
            {
                "id": 3158205,
                "title": "super-easy-solution-fully-explained-c-python-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n\\n# Intuition\\nIn this question we have to find the minimum number of jumps to reach the last index.\\nSo, we calculate the maximum index we can reach from the current index.\\nIf our pointer `i` reaches the last index that can be reached with current number of jumps then we have to make a jumps.\\nSo, we increase the `count`. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Greedy Approach\\n    Example\\n    nums = [2,3,1,1,4]\\n    Here at index `0` reach become 2 and `i` == `last`. \\n    So increase the `count`(1)\\n    At index `1` `reach` becomes `4`.\\n    So, when `i` becomes `2` it becomes equal to last.\\n    We update last with current maximum jump(`reach`) last = 4.\\n    And increase `count`.\\n    So, answer  = 2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int reach=0, count=0, last=0;  // reach: maximum reachable index from current position\\n    // count: number of jumps made so far\\n    // last: rightmost index that has been reached so far\\n        for(int i=0;i<nums.size()-1;i++){  // loop through the array excluding the last element\\n            reach = max(reach, i+nums[i]);  // update reach to the maximum between reach and i+nums[i]\\n            if(i==last){  // if i has reached the last index that can be reached with the current number of jumps\\n                last = reach;  // update last to the new maximum reachable index\\n                count++;  // increment the number of jumps made so far\\n            }\\n        }\\n        return count;  // return the minimum number of jumps required\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def jump(self, nums):\\n        # Initialize reach (maximum reachable index), count (number of jumps), and last (rightmost index reached)\\n        reach, count, last = 0, 0, 0\\n        \\n        # Loop through the array excluding the last element\\n        for i in range(len(nums)-1):    \\n            # Update reach to the maximum between reach and i + nums[i]\\n            reach = max(reach, i + nums[i])\\n        \\n            # If i has reached the last index that can be reached with the current number of jumps\\n            if i == last:\\n                # Update last to the new maximum reachable index\\n                last = reach\\n                # Increment the number of jumps made so far\\n                count += 1\\n        \\n        # Return the minimum number of jumps required\\n        return count\\n\\n```\\n\\n```\\n              Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int reach=0, count=0, last=0;  // reach: maximum reachable index from current position\\n    // count: number of jumps made so far\\n    // last: rightmost index that has been reached so far\\n        for(int i=0;i<nums.size()-1;i++){  // loop through the array excluding the last element\\n            reach = max(reach, i+nums[i]);  // update reach to the maximum between reach and i+nums[i]\\n            if(i==last){  // if i has reached the last index that can be reached with the current number of jumps\\n                last = reach;  // update last to the new maximum reachable index\\n                count++;  // increment the number of jumps made so far\\n            }\\n        }\\n        return count;  // return the minimum number of jumps required\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def jump(self, nums):\\n        # Initialize reach (maximum reachable index), count (number of jumps), and last (rightmost index reached)\\n        reach, count, last = 0, 0, 0\\n        \\n        # Loop through the array excluding the last element\\n        for i in range(len(nums)-1):    \\n            # Update reach to the maximum between reach and i + nums[i]\\n            reach = max(reach, i + nums[i])\\n        \\n            # If i has reached the last index that can be reached with the current number of jumps\\n            if i == last:\\n                # Update last to the new maximum reachable index\\n                last = reach\\n                # Increment the number of jumps made so far\\n                count += 1\\n        \\n        # Return the minimum number of jumps required\\n        return count\\n\\n```\n```\\n              Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18152,
                "title": "java-solution-with-explanation",
                "content": "    public class Solution {\\n    public int jump(int[] nums) {\\n        // If nums.length < 2, means that we do not\\n        // need to move at all.\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }\\n\\n        // First set up current region, which is\\n        // from 0 to nums[0].\\n        int l = 0;\\n        int r = nums[0];\\n        // Since the length of nums is greater than\\n        // 1, we need at least 1 step.\\n        int step = 1;\\n\\n        // We go through all elements in the region.\\n        while (l <= r) {\\n\\n            // If the right of current region is greater\\n            // than nums.length - 1, that means we are done.\\n            if (r >= nums.length - 1) {\\n                return step;\\n            }\\n\\n            // We should know how far can we reach in current\\n            // region.\\n            int max = Integer.MIN_VALUE;\\n            for (; l <= r; l++) {\\n                max = Math.max(max, l + nums[l]);\\n            }\\n\\n            // If we can reach far more in this round, we update\\n            // the boundary of current region, and also add a step.\\n            if (max > r) {\\n                l = r;\\n                r = max;\\n                step++;\\n            }\\n        }\\n\\n        // We can not finish the job.\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int jump(int[] nums) {\\n        // If nums.length < 2, means that we do not\\n        // need to move at all.\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1192398,
                "title": "jump-game-ii-js-python-java-c-simple-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince each element of our input array (**N**) represents the maximum jump length and not the definite jump length, that means we can visit any index between the current index (**i**) and **i + N[i]**. Stretching that to its logical conclusion, we can safely iterate through **N** while keeping track of the furthest index reachable (**next**) at any given moment (**next = max(next, i + N[i])**). We\\'ll know we\\'ve found our solution once **next** reaches or passes the last index (**next >= N.length - 1**).\\n\\nThe difficulty then lies in keeping track of how many jumps it takes to reach that point. We can\\'t simply count the number of times we update **next**, as we may see that happen more than once while still in the current jump\\'s range. In fact, we can\\'t be sure of the best next jump until we reach the end of the current jump\\'s range.\\n\\nSo in addition to **next**, we\\'ll also need to keep track of the current jump\\'s endpoint (**curr**) as well as the number of jumps taken so far (**ans**).\\n\\nSince we\\'ll want to **return ans** at the earliest possibility, we should base it on **next**, as noted earlier. With careful initial definitions for **curr** and **next**, we can start our iteration at **i = 0** and **ans = 0** without the need for edge case return expressions.\\n\\n - _**Time Complexity: O(N)** where N is the length of N_\\n - _**Space Cmplexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 37.7MB** (beats 95% / 100%).\\n```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **16ms / 14.0MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.1MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.9MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098179,
                "title": "fully-commented-and-explained-greedy-approach-in-6-liner-code",
                "content": "```\\nint jump(vector<int>& nums) {\\n        \\n        int numOfJumps = 0, currentIntervalEnd = 0, farthestReachFoundSoFar = 0;\\n        \\n        for(int i = 0 ; i < nums.size() - 1 ; i++) {     // Because you can stop the work once youve\\n                                                                            // reached the last index\\n            farthestReachFoundSoFar = max(farthestReachFoundSoFar, i + nums[i]);    // maximize our                                                                                                    \\n                                                                                    // reach\\n            if(i == currentIntervalEnd) {                // When we reach the end of current intervals\\n                                                         // end, we need to make our next jump and\\n                numOfJumps++;                            // and update our current interval end with       \\n                currentIntervalEnd = farthestReachFoundSoFar;   // the farthest reach found so far\\n                                                         // We made sure this was the best possible jump\\n            }                                            // because we traversed th whole interval and \\n        }                                                // maximized our reach and now we are sure\\n        return numOfJumps;                               // where our next jump will be. Greedy!\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        \\n        int numOfJumps = 0, currentIntervalEnd = 0, farthestReachFoundSoFar = 0;\\n        \\n        for(int i = 0 ; i < nums.size() - 1 ; i++) {     // Because you can stop the work once youve\\n                                                                            // reached the last index\\n            farthestReachFoundSoFar = max(farthestReachFoundSoFar, i + nums[i]);    // maximize our                                                                                                    \\n                                                                                    // reach\\n            if(i == currentIntervalEnd) {                // When we reach the end of current intervals\\n                                                         // end, we need to make our next jump and\\n                numOfJumps++;                            // and update our current interval end with       \\n                currentIntervalEnd = farthestReachFoundSoFar;   // the farthest reach found so far\\n                                                         // We made sure this was the best possible jump\\n            }                                            // because we traversed th whole interval and \\n        }                                                // maximized our reach and now we are sure\\n        return numOfJumps;                               // where our next jump will be. Greedy!\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18093,
                "title": "sharing-my-ac-java-solution",
                "content": "Hi All, below is my AC solution:\\n \\n>     public int jump(int[] A) {\\n>         int maxReach = A[0];\\n>         int edge = 0;\\n>         int minstep = 0;\\n>         \\n>         for(int i = 1; i < A.length; i++) {\\n>             if (i > edge) {\\n>                 minstep += 1;\\n>                 edge = maxReach;\\n>                 if(edge > A.length - 1)\\n>                     return minstep;\\n>             }\\n>             maxReach = Math.max(maxReach, A[i] + i);\\n>             if (maxReach == i):\\n>                 return -1;\\n>         }\\n>         \\n>         return minstep;\\n>     } \\n\\nWhen iterate the array, I set an edge for the Search phase, which means that if I exceeds the edge, the minstep must add one and the maxReach will be update. And when the last index is within the range of the edge, output the minstep.\\n\\n[2, 3, 1, 1, 4]\\n\\nFirst, the edge is 0;\\nSecond, after start iterate the array, it exceeds the edge 0 when reaching the A[0] and update the edge to 2;\\nThird, after it reach the A[2], it exceeds the edge 2 and update the new edge to the maxReach 4.\\nFinally, end of the array is inside the edge, output the minstep.",
                "solutionTags": [],
                "code": "Hi All, below is my AC solution:\\n \\n>     public int jump(int[] A) {\\n>         int maxReach = A[0];\\n>         int edge = 0;\\n>         int minstep = 0;\\n>         \\n>         for(int i = 1; i < A.length; i++) {\\n>             if (i > edge) {\\n>                 minstep += 1;\\n>                 edge = maxReach;\\n>                 if(edge > A.length - 1)\\n>                     return minstep;\\n>             }\\n>             maxReach = Math.max(maxReach, A[i] + i);\\n>             if (maxReach == i):\\n>                 return -1;\\n>         }\\n>         \\n>         return minstep;\\n>     } \\n\\nWhen iterate the array, I set an edge for the Search phase, which means that if I exceeds the edge, the minstep must add one and the maxReach will be update. And when the last index is within the range of the edge, output the minstep.\\n\\n[2, 3, 1, 1, 4]\\n\\nFirst, the edge is 0;\\nSecond, after start iterate the array, it exceeds the edge 0 when reaching the A[0] and update the edge to 2;\\nThird, after it reach the A[2], it exceeds the edge 2 and update the new edge to the maxReach 4.\\nFinally, end of the array is inside the edge, output the minstep.",
                "codeTag": "Unknown"
            },
            {
                "id": 2591598,
                "title": "recursion-memoization-tabulation-o-n-with-constant-space",
                "content": "# Recursion\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        return f(0, n, nums);\\n    }\\n\\t\\n\\tint f(int ind, int n, vector<int>& nums) {\\n        if(ind == n-1) return 0;\\n        \\n        int jump = nums[ind], mini = 1e9;\\n        for(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n            int val = 1 + f(i, n, nums);\\n            mini = min(mini, val);\\n        }\\n        return mini;\\n    }\\n\\t\\n# \\tMemoization\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, n, nums, dp);\\n    }\\n\\t\\n\\tint f(int ind, int n, vector<int>& nums, vector<int>& dp) {\\n        if(ind == n-1) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int jump = nums[ind], mini = 1e9;\\n        for(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n            int val = 1 + f(i, n, nums, dp);\\n            mini = min(mini, val);\\n        }\\n        return dp[ind] = mini;\\n    }\\n\\t\\n# \\tTabulation\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> dp(n, 0);\\n\\n\\tfor(int ind = n-2; ind >= 0; ind--) {\\n\\t\\tint jump = nums[ind], mini = 1e9;\\n\\t\\tfor(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n\\t\\t\\tint val = 1 + dp[i];\\n\\t\\t\\tmini = min(mini, val);\\n\\t\\t}\\n\\t\\tdp[ind] = mini;\\n\\t}\\n\\treturn dp[0];\\n}\\n```\\n\\n# Optimal\\n```\\nint jump(vector<int>& nums) {\\n\\tint jump_cnt = 0, curLimit = 0, limit = 0;\\n\\tfor(int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tlimit = max(limit, i + nums[i]);\\n\\t\\tif(i == curLimit){\\n\\t\\t\\tjump_cnt++;\\n\\t\\t\\tcurLimit = limit;\\n\\t\\t}\\n\\t}\\n\\treturn jump_cnt;\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> dp(n, 0);\\n\\n\\tfor(int ind = n-2; ind >= 0; ind--) {\\n\\t\\tint jump = nums[ind], mini = 1e9;\\n\\t\\tfor(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n\\t\\t\\tint val = 1 + dp[i];\\n\\t\\t\\tmini = min(mini, val);\\n\\t\\t}\\n\\t\\tdp[ind] = mini;\\n\\t}\\n\\treturn dp[0];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint jump_cnt = 0, curLimit = 0, limit = 0;\\n\\tfor(int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tlimit = max(limit, i + nums[i]);\\n\\t\\tif(i == curLimit){\\n\\t\\t\\tjump_cnt++;\\n\\t\\t\\tcurLimit = limit;\\n\\t\\t}\\n\\t}\\n\\treturn jump_cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18035,
                "title": "easy-python-greedy-solution-with-explanation",
                "content": "    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def jump(self, A):\\n        last_max_reach, current_max_reach = 0 , 0\\n        njump , i = 0 , 0\\n        while current_max_reach < len(A)-1:\\n            while i <= last_max_reach:\\n                current_max_reach = max(i+A[i],current_max_reach)\\n                i+=1\\n            if last_max_reach == current_max_reach:\\n                return -1\\n            last_max_reach = current_max_reach\\n            njump+=1\\n        return njump\\n\\n\\nThe basic thoughts underline is a greedy style. Every one more jump, you want to jump as far as possible.\\nIn Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position. but here in Jump Game II, instead you care about what would be the next furthest jump could be made when you could reach as far as ith position from last jump.  So you iterate all positions could be reached from last jump till i th position to find it out.",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def jump(self, A):\\n        last_max_reach, current_max_reach = 0 , 0\\n        njump , i = 0 , 0\\n        while current_max_reach < len(A)-1:\\n            while i <= last_max_reach:\\n                current_max_reach = max(i+A[i],current_max_reach)\\n                i+=1\\n            if last_max_reach == current_max_reach:\\n                return -1\\n            last_max_reach = current_max_reach\\n            njump+=1\\n        return njump\\n\\n\\nThe basic thoughts underline is a greedy style. Every one more jump, you want to jump as far as possible.\\nIn Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position. but here in Jump Game II, instead you care about what would be the next furthest jump could be made when you could reach as far as ith position from last jump.  So you iterate all positions could be reached from last jump till i th position to find it out.",
                "codeTag": "Java"
            },
            {
                "id": 1355952,
                "title": "swift-jump-game-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n        guard 1 <= nums.count && nums.count <= Int(10e4) else { return 0 }\\n        var step = 0, end = 0, maxPos = 0\\n        for i in 0..<nums.count - 1 {\\n            maxPos = max(maxPos, i + nums[i])\\n            if i == end { end = maxPos; step += 1 }\\n        }\\n        return step\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.jump([2,3,1,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n    func test1() {\\n        let res = s.jump([2,3,0,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n        guard 1 <= nums.count && nums.count <= Int(10e4) else { return 0 }\\n        var step = 0, end = 0, maxPos = 0\\n        for i in 0..<nums.count - 1 {\\n            maxPos = max(maxPos, i + nums[i])\\n            if i == end { end = maxPos; step += 1 }\\n        }\\n        return step\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.jump([2,3,1,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n    func test1() {\\n        let res = s.jump([2,3,0,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383112,
                "title": "to-all-my-struggling-friends-don-t-worry-its-fine",
                "content": "If you are not able to do it, its completely fine. I have also went over 10+ solutions and finally compiled below solution. \\nPut this code in the IDE and debug step by step. I bet you will understand it. \\n# ***Explanation:*** \\nSince we are already at nums[0]. The no of steps to reach on nums[0] is 0.\\nFrom n = 1 to nums.length-1, do this: \\nAt each step, calculate min steps to reach that step i.e. if you are at step 1, loop from begining and get the min jumps to reach step1. Similarly if you are at step 2, calculate min steps needed to reach step 2 by looping from begining and get min steps. \\n\\n```\\npublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE); //Initially we do not know, what is min steps, hence initialize all with Integer.MAX_Value.\\n        dp[0] = 0;\\n        for (int i = 1; i < n; i++) { //Start from 1 to n\\n            for (int j = 0; j < i; j++) { //At each index, get min steps to reach dp[i] by looping from begining (i.e. start from 0 till i)\\n                if (j + nums[j] >= i) { //if j+nums[j] >=i, then from \\'j\\' index we can have j+nums[j] jump, which can reach (or go over) nums[i]. This means we can jump from index \\'j\\'.\\n                    dp[i] = Math.min(dp[i], dp[j] + 1); //Check if the this is min.\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE); //Initially we do not know, what is min steps, hence initialize all with Integer.MAX_Value.\\n        dp[0] = 0;\\n        for (int i = 1; i < n; i++) { //Start from 1 to n\\n            for (int j = 0; j < i; j++) { //At each index, get min steps to reach dp[i] by looping from begining (i.e. start from 0 till i)\\n                if (j + nums[j] >= i) { //if j+nums[j] >=i, then from \\'j\\' index we can have j+nums[j] jump, which can reach (or go over) nums[i]. This means we can jump from index \\'j\\'.\\n                    dp[i] = Math.min(dp[i], dp[j] + 1); //Check if the this is min.\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774616,
                "title": "easy-linear-time-o-n-and-space-o-1-explanation",
                "content": "1. We start travering the array from start\\n2. While traversing, we keep a track on maximum reachable index and update it accordingly.\\n3. If we reach the previous reachable index, this implies we have reached this index with current jumps and now we can reach the next maximum possible index by  **current jumps+1** jumps and update the previous reachable index to maximum reachable index. Now, if updated previous reachable index is greater than equal to last index, just return the jump count.  \\n\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        \\n        reachableIndex = 0\\n        previousReachableIndex = 0\\n        jump = 0\\n\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n\\n            if curr == previousReachableIndex:\\n                jump += 1\\n                previousReachableIndex = reachableIndex\\n                if previousReachableIndex >= len(nums) - 1:\\n                    return jump\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        \\n        reachableIndex = 0\\n        previousReachableIndex = 0\\n        jump = 0\\n\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n\\n            if curr == previousReachableIndex:\\n                jump += 1\\n                previousReachableIndex = reachableIndex\\n                if previousReachableIndex >= len(nums) - 1:\\n                    return jump\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659010,
                "title": "easiest-step-by-step-bfs-solution-o-n",
                "content": "This problem can be changed to a tree problem, with the search tree looks like below:\\n![image](https://assets.leetcode.com/users/leih/image_1590776042.png)\\nOur goal is to find the shortest path from root to a target node, sounds like a traditional BFS question? This leads to our first solution:\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n = len(nums)\\n        visited, queue = [False for i in range(n)], deque()\\n        queue.append((0, 0))\\n        visited[0] = True\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(1, min(nums[pos] + 1, n - pos)):\\n                if not visited[pos + jump]:\\n                    queue.append((pos + jump, step + 1))\\n                    visited[pos + jump] = True\\n```\\nThis solution gets TLE with time complexity `O(n^2)`. Where is the bottleneck? We know the time complexity of the best solution could NOT be less than `O(n)` since we need to jump step by step in the case of [1, 1, 1, 1, ....., 1, 1]. For each position, do we really need to check its every possible next postion with 1 jump?  The answer is NO, because some of such positions have been visited.\\n\\nIn solution 1, we used a `visited` array to record these positions, but we actually can just ignore these positions and only consider the positions that have not been visited. Note that the visited positions are consecutive, which means if position `j + 1` has been visited, position `j` also has been visited. We can use a variable `maxVisitedPos` to keep tracking the largest position that has been visited. For the jump at a position, we just check the positions that are further than `maxVisitedPos`. As such, each position will be operated at most twice (append and popleft), which gives us `O(n)` complexity and we know there cannot be a better solution.\\n\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n, queue = len(nums), deque()\\n        queue.append((0, 0))\\n        maxVisitedPos = 0\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(maxVisitedPos - pos + 1, min(nums[pos] + 1, n - pos)):\\n                queue.append((pos + jump, step + 1))\\n                maxVisitedPos = pos + jump\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n = len(nums)\\n        visited, queue = [False for i in range(n)], deque()\\n        queue.append((0, 0))\\n        visited[0] = True\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(1, min(nums[pos] + 1, n - pos)):\\n                if not visited[pos + jump]:\\n                    queue.append((pos + jump, step + 1))\\n                    visited[pos + jump] = True\\n```\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n, queue = len(nums), deque()\\n        queue.append((0, 0))\\n        maxVisitedPos = 0\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(maxVisitedPos - pos + 1, min(nums[pos] + 1, n - pos)):\\n                queue.append((pos + jump, step + 1))\\n                maxVisitedPos = pos + jump\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158986,
                "title": "java-solution-fast-1ms-runtime",
                "content": "# JAVA Code\\n\\n99% faster code [1ms runtime]\\n\\n``` JAVA []\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/94908bb9-b442-4096-9b26-4debb918ed16_1675838156.0297992.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18177,
                "title": "concise-o-n-java-solution-with-explanation",
                "content": "For each step of jump, there is a range you can reach. \\nThen try jumping from each position in current range, you will get a new range where the next step can reach.\\nRepeat this process util the range covers the last index.\\n\\n    public class Solution {\\n        public int jump(int[] nums){\\n            int step = 0;\\n            for(int l = 0, r = 0; r < nums.length - 1; step++){\\n            \\tint rNew = 0;\\n            \\tfor(int i = l; i <= r; i++) rNew = Math.max(rNew, i + nums[i]);\\n            \\tl = r + 1;\\n            \\tr = rNew;\\n            }\\n            return step;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int jump(int[] nums){\\n            int step = 0;\\n            for(int l = 0, r = 0; r < nums.length - 1; step++){\\n            \\tint rNew = 0;\\n            \\tfor(int i = l; i <= r; i++) rNew = Math.max(rNew, i + nums[i]);\\n            \\tl = r + 1;\\n            \\tr = rNew;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3758457,
                "title": "java-0ms-100-easy-solution",
                "content": "The main idea is based on greedy. Let\\'s say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following:\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n      int jumps = 0, currEnd = 0, currFarthest = 0;\\n      for(int i = 0; i < nums.length - 1; i ++) {\\n          currFarthest = Math.max(currFarthest, i + nums[i]);\\n          if(i == currEnd) {\\n              currEnd = currFarthest;\\n              jumps ++;\\n          }\\n      }  \\n      return jumps;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n      int jumps = 0, currEnd = 0, currFarthest = 0;\\n      for(int i = 0; i < nums.length - 1; i ++) {\\n          currFarthest = Math.max(currFarthest, i + nums[i]);\\n          if(i == currEnd) {\\n              currEnd = currFarthest;\\n              jumps ++;\\n          }\\n      }  \\n      return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204682,
                "title": "easy-c-greedy-faster-than-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int jumps = 0;\\n        int maxReach = 0;\\n        int currReach = 0;\\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            maxReach = max(maxReach, i+nums[i]);\\n            \\n            if(i==currReach)\\n            {\\n                jumps++;\\n                currReach = maxReach;\\n            }\\n            \\n        }\\n        \\n        return jumps;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int jumps = 0;\\n        int maxReach = 0;\\n        int currReach = 0;\\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            maxReach = max(maxReach, i+nums[i]);\\n            \\n            if(i==currReach)\\n            {\\n                jumps++;\\n                currReach = maxReach;\\n            }\\n            \\n        }\\n        \\n        return jumps;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192404,
                "title": "jump-game-ii-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-greedy-bfs",
                "content": "\\u274C ***Solution - I (Brute Force) [Rejected]***\\n\\nWe start at index 0 and are required to reach index `n - 1` (where `n = nums.size()`). We can\\'t always do the maximum jump at each index. This can be easily verified by looking at the example test cases.\\n\\nSo, at each position, we can use a jump size of anywhere in the range *`[1, nums[pos]]`*. The final answer will be the minimum jumps required. We can recursively solve this problem as -\\n\\n* If we reach index *`n-1`* return 0, signifying that we need 0 more jumps.\\n* Else recurse for each jump size possible from the current index and return the answer in which we require the minimum number of jumps\\n\\n\\n```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 1001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**. At each index `i` we have `N-i` choices and we recursively explore each of them till end. So we require `O(N*(N-1)*(N-2)...1) = O(N!)`. \\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive Dynamic Programming - Memoization) [Accepted]***\\n\\nWe can see that for a given position, we are repeatedly calculating the same answer over and over again. The jumps required to reach for a given index on the path remains fixed and can be stored in *`dp`* array to avoid re-calculations.\\n\\nThe solution is similar as the brute force with just the change that we are storing the solutions for each *`pos`* and returning it if it is already calculated.\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 1001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 1001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Iterative Dynamic Programming - Tabulation) [Accepted]***\\n\\nWe can solve this iteratively as well. For this, we start from the last index. We need 0 jumps from `nums[n-1]` to reach the end. We store this as *`dp[n - 1] = 0`* and then iteratively solve this for each previous index till the 0th index. Here *`dp[i]`* denotes minimum jumps required from current index to reach till the end.\\n\\n1. For each index, we explore all the possible jump sizes available with us. \\n2. The minimum jumps required to reach the end from the current index would be - **`min(dp[jumpLen])`**, where *`1 <= jumpLen <= nums[currentPostion]`*\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 1001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution IV (BFS)***\\n\\nWe can iterate over all indices maintaining the furthest reachable position from current index - *`maxReachable`* and currently furthest reached position - *`lastJumpedPos`*. Everytime we will try to update *`lastJumpedPos`* to furthest possible reachable index - `maxReachable`.\\n\\nUpdating the `lastJumpedPos` separately from *`maxReachable`* allows us to maintain track of minimum *`jumps`* required. Each time `lastJumpedPos` is updated, ***`jumps`*** will also be updated and store the minimum jumps required to reach `lastJumpedPos` (On the contrary, updating `jumps` with `maxReachable` won\\'t give the optimal (minimum possible) value of jumps required). \\n\\nWe will just return it as soon as *`lastJumpedPos`* reaches(or exceeds) last index.\\n\\nWe can try to understand the steps in code below as analogous to those in BFS as -\\n\\n1. **`maxReachable = max(maxReachable, i + nums[i])`** : Updating the range of next level. Similar to  *`queue.push(node)`* step of BFS but here we are only greedily storing the max reachable index on next level.\\n\\n\\n2. **`i == lastJumpedPos`** :  When it becomes true, current level iteration has been completed.\\n3. **`lastJumpedPos = maxReachable`** : Set range till which we need to iterate the next level\\n4. **`jumps++`** : Move on to the next level.\\n\\n5. **`return jumps`** : The final answer will be number of levels in BFS traversal.\\n\\nFor eg. Take the example : `nums = [2,3,1,4,1,1,1,2]`. This approach proceeds as illustrated in image below -\\n\\n<p align=center>\\n<img src=https://assets.leetcode.com/users/images/4e5cbbb4-a6d0-4523-a945-261ee4b53f72_1620216977.5849538.png /></p>\\n\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 1001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 1001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 1001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 1001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192521,
                "title": "python-greedy-o-n-solution-epxlained",
                "content": "There are two algorithms: one is dp with complexity `O(n^2)`, where `dp(i)` is the minimum number of steps to reach position `i` and on each step we need to check potentially `O(n)` jumps. \\n\\nHowever there is a solution with better complexity, using `greedy` idea: we need to look at `i + nums[i]` values and look at running maximum of these values. Then all we need to do is to start from the zero index and do `ind = t[ind]` until we reach the ending point or bigger. \\n\\nWe can look at our process like this: what is the biggest index we can reach after say `i` jumps. Then if we have new index to traverse we update our range. For example for `nums = [2, 3, 0, 1, 4]` we have `t = [2, 4, 4, 4, 8]` and after `1` jump we can reach index `2` and after each new index processed we expand our window if we have bigger value than the end of window and increase total number of steps or we do not do anything.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space is `O(n)` as well, it can be made `O(1)`, if we calculate cumulative maximum on the fly.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def jump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        ind, q = 0, 0\\n        while ind < len(nums) - 1:\\n            ind = t[ind]\\n            q += 1\\n        return q\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def jump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        ind, q = 0, 0\\n        while ind < len(nums) - 1:\\n            ind = t[ind]\\n            q += 1\\n        return q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443098,
                "title": "javascript-solution-w-explanation",
                "content": "### The idea\\n1. We know that every point is reachable, so we are only looking for the relationship between the maximum reach of each index and the number of jumps\\n2. `oldMax` is the previous jump\\'s maximum reach, if we are at the old max, that means no matter how we move, the next move will cost an extra jump, thus we increment  jump, at the same time, we update the `oldMax` to the current global max. This max, indicates the maximum reach we will have by having an extra jump.\\n``` javascript\\nvar jump = function(nums) {\\n    let newMax = 0;\\n    let jump = 0;\\n    let oldMax = 0;\\n    for (let i=0;i<nums.length-1;i++) {\\n        newMax = Math.max(newMax, i+nums[i]);\\n        if (i == oldMax) {\\n            jump++;\\n            oldMax = newMax;\\n        }\\n    }\\n    return jump;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar jump = function(nums) {\\n    let newMax = 0;\\n    let jump = 0;\\n    let oldMax = 0;\\n    for (let i=0;i<nums.length-1;i++) {\\n        newMax = Math.max(newMax, i+nums[i]);\\n        if (i == oldMax) {\\n            jump++;\\n            oldMax = newMax;\\n        }\\n    }\\n    return jump;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18144,
                "title": "demonstrate-the-detailed-flow-process-of-my-thinking",
                "content": "    one example:\\n    index      0  1  2  3  4  5  6  7  8  9  10  11\\n    value      5  9  3  2  1  0  2  3  3  1  0   0\\n    farthest   5  10 10 10 10 10 10 10 11 11 11  11\\n        \\n        my thought -- scan from right to left.\\n        \\n            -- to reach index 11, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, no\\n                -- index 2, 2+3=5, no\\n                -- index 3, 3+2=5, no\\n                -- index 4, 4+1=5, no\\n                -- index 5, 5+0=5, no\\n                -- index 6, 6+2=8, no\\n                -- index 7, 7+3=10, no\\n                -- index 8, 8+3=11, yes!\\n                thus we have to first reach index 8.\\n            -- to reach index 8, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, yes\\n                thus we have to first reach index 1.\\n            -- to reach index 1, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, yes\\n                thus we have to first reach index 0.\\n            \\n            therefore, 3 steps in total.\\n            \\n        one issue i thought about.\\n            -- when scanning from left to right to search for the \"viable\" index, we take the first \"viable\" index.\\n               what if this first \"viable\" index is not reachable?\\n               \\n               for example:\\n               index  0  1  2  3  4  5  6  7  8  9  10  11\\n               value  1  6  5  4  3  2  1  3  3  1  1   0\\n               \\n               scanned from left to right, the first \"viable\" index is 8, the second \"viable\" index is 10.\\n               what if we cannot reach index 8 but we can reach index 10?\\n                    -- silly question, lol\\n               will it take more steps to choose index 8 than 10?\\n                    -- 8-->11 and 10-->11 both take 1 step\\n                    -- will it take more steps to reach index 8 than 10?\\n                        -- the answer is **NO**.\\n                           if reaching index 10 takes **n** steps, we can definitely reach index 8 in **<=n** steps.\\n               \\n               therefore we have no problem to choose the first \"viable\" index.\\n               such is the correctness of the algorithm.",
                "solutionTags": [],
                "code": "    one example:\\n    index      0  1  2  3  4  5  6  7  8  9  10  11\\n    value      5  9  3  2  1  0  2  3  3  1  0   0\\n    farthest   5  10 10 10 10 10 10 10 11 11 11  11\\n        \\n        my thought -- scan from right to left.\\n        \\n            -- to reach index 11, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, no\\n                -- index 2, 2+3=5, no\\n                -- index 3, 3+2=5, no\\n                -- index 4, 4+1=5, no\\n                -- index 5, 5+0=5, no\\n                -- index 6, 6+2=8, no\\n                -- index 7, 7+3=10, no\\n                -- index 8, 8+3=11, yes!\\n                thus we have to first reach index 8.\\n            -- to reach index 8, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, yes\\n                thus we have to first reach index 1.\\n            -- to reach index 1, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, yes\\n                thus we have to first reach index 0.\\n            \\n            therefore, 3 steps in total.\\n            \\n        one issue i thought about.\\n            -- when scanning from left to right to search for the \"viable\" index, we take the first \"viable\" index.\\n               what if this first \"viable\" index is not reachable?\\n               \\n               for example:\\n               index  0  1  2  3  4  5  6  7  8  9  10  11\\n               value  1  6  5  4  3  2  1  3  3  1  1   0\\n               \\n               scanned from left to right, the first \"viable\" index is 8, the second \"viable\" index is 10.\\n               what if we cannot reach index 8 but we can reach index 10?\\n                    -- silly question, lol\\n               will it take more steps to choose index 8 than 10?\\n                    -- 8-->11 and 10-->11 both take 1 step\\n                    -- will it take more steps to reach index 8 than 10?\\n                        -- the answer is **NO**.\\n                           if reaching index 10 takes **n** steps, we can definitely reach index 8 in **<=n** steps.\\n               \\n               therefore we have no problem to choose the first \"viable\" index.\\n               such is the correctness of the algorithm.",
                "codeTag": "Unknown"
            },
            {
                "id": 3158214,
                "title": "putta-easy-solution-c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minjump(int i,vector<int>& nums,vector<int>& dp){\\n        if(i >= nums.size()-1){\\n            return 0;\\n        }\\n        if (dp[i] != -1 ) return dp[i];\\n        int mini= 1e9;\\n        for(int k=i+1;k<=i+nums[i];k++){\\n            mini = min(mini,1+minjump(k,nums,dp));\\n        }\\n        return dp[i]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return minjump(0,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minjump(int i,vector<int>& nums,vector<int>& dp){\\n        if(i >= nums.size()-1){\\n            return 0;\\n        }\\n        if (dp[i] != -1 ) return dp[i];\\n        int mini= 1e9;\\n        for(int k=i+1;k<=i+nums[i];k++){\\n            mini = min(mini,1+minjump(k,nums,dp));\\n        }\\n        return dp[i]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return minjump(0,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208416,
                "title": "python-intuitive-bfs-solution-with-a-deque-explained",
                "content": "What is minimum number of jump in other words? Shortest path! What is shortest path? It is BFS!\\n```\\ndef jump(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\t\\t\\n\\t\\t# queue stores index and number jump to reach it\\n        q = deque([(0,0)])\\n\\t\\t\\n\\t\\t# created visited set to stored visited indices\\n\\t\\t# this set is needed to avoid duplicate work and to protect you from TLE :-)\\n\\t\\t# we initialize it with the first index because it will be inevitably visited.\\n        visited = set([0])\\n        \\n        while q:\\n            \\n\\t\\t\\t# don\\'t forget to use popleft instead of pop to get desired first in first out behavior\\n            cur, jumps = q.popleft()\\n            \\n\\t\\t\\t# if we\\'ve reached the last index we are done\\n\\t\\t\\t# And because BFS is shortest path we just return corresponding number of jumps\\n            if cur == n - 1:\\n                return jumps\\n            \\n\\t\\t\\t# jump for each possible index from current position according to available number of jumps\\n\\t\\t\\t# min(cur+nums[cur]+1,n) just cuts jumps which are out of bound of our array\\n            for i in range(cur + 1, min(cur+nums[cur]+1,n)):\\n\\t\\t\\t\\n\\t\\t\\t\\t# jump only if we haven\\'t visited this index already\\n                if i not in visited:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if jump mark index as visited\\n                    visited.add(i)\\n                    q.append((i,jumps+1))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\ndef jump(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\t\\t\\n\\t\\t# queue stores index and number jump to reach it\\n        q = deque([(0,0)])\\n\\t\\t\\n\\t\\t# created visited set to stored visited indices\\n\\t\\t# this set is needed to avoid duplicate work and to protect you from TLE :-)\\n\\t\\t# we initialize it with the first index because it will be inevitably visited.\\n        visited = set([0])\\n        \\n        while q:\\n            \\n\\t\\t\\t# don\\'t forget to use popleft instead of pop to get desired first in first out behavior\\n            cur, jumps = q.popleft()\\n            \\n\\t\\t\\t# if we\\'ve reached the last index we are done\\n\\t\\t\\t# And because BFS is shortest path we just return corresponding number of jumps\\n            if cur == n - 1:\\n                return jumps\\n            \\n\\t\\t\\t# jump for each possible index from current position according to available number of jumps\\n\\t\\t\\t# min(cur+nums[cur]+1,n) just cuts jumps which are out of bound of our array\\n            for i in range(cur + 1, min(cur+nums[cur]+1,n)):\\n\\t\\t\\t\\n\\t\\t\\t\\t# jump only if we haven\\'t visited this index already\\n                if i not in visited:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if jump mark index as visited\\n                    visited.add(i)\\n                    q.append((i,jumps+1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1701773,
                "title": "c-solution-using-dp-skipping-wrong-answer",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursive Dynamic Programming - Memoization.***\\n- **Remember while initializing the array with 10001, if we do 1001 then it will give the wrong answer for large values.**\\n- We take a dp array to store recursive solutions.\\n- Help array for the recursion, base case when start index is greater than size of the array.\\n- From 1 to the num position we\\u2019ll calculate the minimum value & update the dp array.\\n- Finally return the value dp[start].\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(size(nums), 10001);\\n        return help(nums, dp, 0);\\n    }\\n    int help(vector<int>& nums,  vector<int>& dp, int start){\\n        if(start >= size(nums)-1) return 0;\\n        if(dp[start] != 10001) return dp[start];\\n        \\n        for(int i=1; i<=nums[start]; i++){\\n            dp[start] = min(dp[start], 1+help(nums, dp, start+i));\\n        }\\n        return dp[start];\\n    } \\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(size(nums), 10001);\\n        return help(nums, dp, 0);\\n    }\\n    int help(vector<int>& nums,  vector<int>& dp, int start){\\n        if(start >= size(nums)-1) return 0;\\n        if(dp[start] != 10001) return dp[start];\\n        \\n        for(int i=1; i<=nums[start]; i++){\\n            dp[start] = min(dp[start], 1+help(nums, dp, start+i));\\n        }\\n        return dp[start];\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469752,
                "title": "python-3-recursion-memoization-self-understandable-easy-understading",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        memo={}\\n        def min_jumps(index):\\n            if index>=len(nums)-1:\\n                return 0\\n            if index in memo:\\n                return memo[index]\\n            ans=float(\\'inf\\')\\n            for i in range(index,index+nums[index]):\\n                ans=min(ans,1+min_jumps(i+1))\\n            memo[index]=ans\\n            return ans\\n        return min_jumps(0)\\n                \\n                    \\n```\\n\\n***Do Upvote if you found my solution helpful :)***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        memo={}\\n        def min_jumps(index):\\n            if index>=len(nums)-1:\\n                return 0\\n            if index in memo:\\n                return memo[index]\\n            ans=float(\\'inf\\')\\n            for i in range(index,index+nums[index]):\\n                ans=min(ans,1+min_jumps(i+1))\\n            memo[index]=ans\\n            return ans\\n        return min_jumps(0)\\n                \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192566,
                "title": "c-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10001];\\n    int solve(vector<int>& nums, int curridx, int lidx)\\n    {\\n        if(curridx == lidx) return 0;\\n        if(curridx > lidx || nums[curridx] == 0) return 1e6;\\n        \\n        if(dp[curridx] < 1e6) return dp[curridx];\\n        \\n        for(int i=1;i<=nums[curridx];++i)\\n        {\\n            dp[curridx] = min(dp[curridx], solve(nums,curridx+i,lidx));\\n        }\\n        \\n        dp[curridx]+=1;\\n        return dp[curridx];\\n    }\\n    \\n    int jump(vector<int>& nums) {\\n        memset(dp,1e6,sizeof(dp));\\n        int ans = solve(nums,0,nums.size()-1);\\n        if(ans == 1e6) return 0;\\n        else return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10001];\\n    int solve(vector<int>& nums, int curridx, int lidx)\\n    {\\n        if(curridx == lidx) return 0;\\n        if(curridx > lidx || nums[curridx] == 0) return 1e6;\\n        \\n        if(dp[curridx] < 1e6) return dp[curridx];\\n        \\n        for(int i=1;i<=nums[curridx];++i)\\n        {\\n            dp[curridx] = min(dp[curridx], solve(nums,curridx+i,lidx));\\n        }\\n        \\n        dp[curridx]+=1;\\n        return dp[curridx];\\n    }\\n    \\n    int jump(vector<int>& nums) {\\n        memset(dp,1e6,sizeof(dp));\\n        int ans = solve(nums,0,nums.size()-1);\\n        if(ans == 1e6) return 0;\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017980,
                "title": "c-dp-based-solution-100-time-100-space",
                "content": "I thought everybody would solve this problem with a sheer DP approach, but it looks like I was wrong and greedy was the most popular one.\\n\\nWell, good for me: I got to practice a pattern and will learn even more reading other people\\'s approaches :)\\n\\nOur core idea here is to create an array of the same size as `nums` and progress so that each slot of it will represent the minimum amount of steps to reach that position.\\n\\nTo do so, we will create just 2 variables:\\n* `len` will store the length of our input;\\n* `steps` is the array we mentioned above.\\n\\nWe will initialised all cells of `steps` to `INT_MAX`, but the first one, set to `0` (since we start there and it takes no movement to reach it).\\n\\nThen we go for the main loop, going with `i` from `0` up to the last element of our input and we will:\\n* loop with `j` from the minimum value between `len - 1` (last element of the array) and `i + nums[i])` (last element you can reach with the current jump) up to `i` (excluded);\\n* check if the current value of `step[j]` is greater than what we can achieve jumping from the currently considered cell (`step[i] + 1`) and in case update `step[j]` to a smaller, more convenient value;\\n* otherwise, since we know that we cannot offer anything better to both `step[j]` and all the cells left on the left of `j`, we break out of the inner loop and move on with another value of `i`.\\n\\nOnce we are done, we can just return the last value of `steps` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), steps[len];\\n        // presetting steps\\n        for (int i = 1; i < len; i++) {\\n            steps[i] = INT_MAX;\\n        }\\n        steps[0] = 0;\\n        // populating steps with the lowest possible values\\n        for (int i = 0; i < len; i++) {\\n            for (int lmt = i, j = min(len - 1, i + nums[i]); j > lmt; j--) {\\n                if (steps[j] > steps[i] + 1) steps[j] = steps[i] + 1;\\n                else break;\\n            }\\n        }\\n        return steps[len - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), steps[len];\\n        // presetting steps\\n        for (int i = 1; i < len; i++) {\\n            steps[i] = INT_MAX;\\n        }\\n        steps[0] = 0;\\n        // populating steps with the lowest possible values\\n        for (int i = 0; i < len; i++) {\\n            for (int lmt = i, j = min(len - 1, i + nums[i]); j > lmt; j--) {\\n                if (steps[j] > steps[i] + 1) steps[j] = steps[i] + 1;\\n                else break;\\n            }\\n        }\\n        return steps[len - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18024,
                "title": "my-c-bfs-solution-o-n-time-o-1-space",
                "content": "This minimum path problem is a typical BFS problem. Each step, expand all the nodes at the same level (i.e. i in (curEnd, newEnd])\\n\\n\\n    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps =1, i, curEnd = 0, newEnd=0, len = nums.size();\\n            if(len<=1) return 0;\\n            for(i=0; i<=curEnd; ++i)\\n            {\\n                newEnd = max(newEnd, i+nums[i]);\\n                if(newEnd>=(len-1)) return steps;\\n                if(i==curEnd)  // end of the current level, move to the next level\\n                {\\n                    curEnd = newEnd;\\n                    ++steps;\\n                }\\n            }\\n            return INT_MAX; // curEnd = newEnd, can not reach the end\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps =1, i, curEnd = 0, newEnd=0, len = nums.size();\\n            if(len<=1) return 0;\\n            for(i=0; i<=curEnd; ++i)\\n            {\\n                newEnd = max(newEnd, i+nums[i]);\\n                if(newEnd>=(len-1)) return steps;\\n                if(i==curEnd)  // end of the current level, move to the next level\\n                {\\n                    curEnd = newEnd;\\n                    ++steps;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2027340,
                "title": "python-dynamic-programming-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return 0\\n        \\n        # dp[i] means the minimum number of jumps to reach index i\\n        # for each dp[i]\\uFF0Cwe need to find the earliest j that can reach i from j\\n        # dp[i] = dp[j] + 1\\n        \\n        dp = [0] * n\\n        j = 0\\n        for i in range(1, n):\\n            while j + nums[j] < i:\\n                j += 1\\n            dp[i] = dp[j] + 1\\n        \\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return 0\\n        \\n        # dp[i] means the minimum number of jumps to reach index i\\n        # for each dp[i]\\uFF0Cwe need to find the earliest j that can reach i from j\\n        # dp[i] = dp[j] + 1\\n        \\n        dp = [0] * n\\n        j = 0\\n        for i in range(1, n):\\n            while j + nums[j] < i:\\n                j += 1\\n            dp[i] = dp[j] + 1\\n        \\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 1621483,
                "title": "c-greedy-approach-o-n-w-explanation",
                "content": "**APPROACH :**\\nAt any index i in ```nums```, we can jump a maximum of ```nums[i]``` steps and we need to reach the last index in the minimum number of jumps. \\nThis approach can be solved using DP but that requires O(N^2) time and O(N) space. \\nSo, we\\'ll solve it using Greedy approach. \\n\\nLet\\'s consider the array :\\n```nums = [1, 3, 5, 8, 6, 2, 6, 7, 6, 8, 9]```\\n(The minumum number of jumps to reach the end of the array is 3 ```(0--->1--->4--->10)``` )\\n\\n* We maintain 3 variables ```max_reach```, ```curr_reach```, ```jumps```. \\n* The idea is to jump the maximum no. of steps we can from an index, and update the ```max_reach``` and ```curr_reach``` to the index we jump to, increment ```jumps``` each time we jump (ie. each time we reach the max. index that could be reached from the starting index.)\\n* For the intermediate indices, we check if we can go farther than that from the index we started with and if yes, we update ```max_reach``` (Greedy Approach).\\n* When we reach the end of a segment (segment is the range of indices we can jump to from a given index), we see if ```max_reach``` is greater than the ```curr_reach``` and update ```curr_reach``` and increment ```jumps```, because we\\'ve reached the end of a segment and will the take the next jump.\\n* We continue this until the last but one index and then return ```jumps``` as the minimum value.\\n ![image](https://assets.leetcode.com/users/images/e4c49f12-2a3e-4af6-aa0f-76a916875c52_1639141695.0349996.jpeg)\\n In the above example, the segments are : index - 1, index - 2 to 4, index - 4 to 10.\\n\\n**Time Complexity :** O(N)\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int max_reach=0, curr_reach=0, jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            max_reach = max(max_reach, nums[i]+i);\\n            if(i==curr_reach) curr_reach = max_reach, jumps++;   \\n        }\\n        return jumps;\\n    }\\n};\\n```\\n\\nPlease upvote if you like it!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```nums```\n```nums[i]```\n```nums = [1, 3, 5, 8, 6, 2, 6, 7, 6, 8, 9]```\n```(0--->1--->4--->10)```\n```max_reach```\n```curr_reach```\n```jumps```\n```max_reach```\n```curr_reach```\n```jumps```\n```max_reach```\n```max_reach```\n```curr_reach```\n```curr_reach```\n```jumps```\n```jumps```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int max_reach=0, curr_reach=0, jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            max_reach = max(max_reach, nums[i]+i);\\n            if(i==curr_reach) curr_reach = max_reach, jumps++;   \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158343,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=O46mFXtuGJY&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=8) if you are interested.\\n\\n<iframe src=\"https://leetcode.com/playground/QhdE2L8F/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=O46mFXtuGJY&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=8) if you are interested.\\n\\n<iframe src=\"https://leetcode.com/playground/QhdE2L8F/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1193170,
                "title": "c-0ms-dp-approach-explained-logic",
                "content": "Initialize dp vector with max value (10000, from constraints). This vector will keep track of minimum jumps needed to reach to that position.\\nTo reach to first index, needed jumps =0\\nGet the value at nums[i]\\nFor the next nums[i] index, the needed jumps would be minimum of jumps at ith index+1, or jumps stored at dp[i]\\n\\n```\\nint jump(vector<int>& nums) {\\n        int i, j, index;\\n        vector<int> dp(nums.size(), 10000);\\n        dp[0]=0;            // to reach 1st index, jumps needed=0\\n        for(i=0; i<nums.size(); i++)\\n        {\\n            index=i+1;          // if nums[i]=2 and i=5, index will start from 6 and go till 8th position\\n            while(index<i+nums[i]+1)\\n            {\\n                if(index >= nums.size())        \\n                    break;\\n                dp[index] = min(dp[index], dp[i]+1);\\n                index++;\\n            }\\n        }\\n        return dp[nums.size()-1];\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        int i, j, index;\\n        vector<int> dp(nums.size(), 10000);\\n        dp[0]=0;            // to reach 1st index, jumps needed=0\\n        for(i=0; i<nums.size(); i++)\\n        {\\n            index=i+1;          // if nums[i]=2 and i=5, index will start from 6 and go till 8th position\\n            while(index<i+nums[i]+1)\\n            {\\n                if(index >= nums.size())        \\n                    break;\\n                dp[index] = min(dp[index], dp[i]+1);\\n                index++;\\n            }\\n        }\\n        return dp[nums.size()-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3159250,
                "title": "c-greedy-bfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all don\\'t worry about greedy it is not compulsory that it should come to our mind at first .. So initially we can think of brute force i.e recursive + backtracking then we can optimize using dp. So this is normally how to aproach the problem . There is no need to worry about greedy ..\\n-  Now after doing dp if we want like how the greedy will work for this we can give it some time and try to take it as a shortest path problem like we do in graph by bfs. In the similar way we can check at some level what can be the maximum jump we can take and we also check in between the maximum jump so far till curr_max (if there is some more we can get) . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Greedy:** So In greedy we can take two pointers  [max_so_far , curr_maxi]\\n- Then we check one by one upto our curr maximum what can be maximum jump i.e max_so_far and after checking upto our curr_maxi we will upafte our curr_maxi with max_so_far and also we will incraese counter by 1 becuse 1 jump is taken .\\n- This will run upto our max_so_far become >=n-1 i.e end point so after that we will return the answer (no. of jumps till now).\\n- There are two  ways of doing greedy like shown below : First one seems like more bfs type but both are actually implicit bfs ,idea is same incremnet the level and check in curr level the  max jump we can take  and when max > n-1 we will return the no .of levels  till now.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Dynamic Programming O(n^2)**\\n```\\nint solve(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind>=arr.size()-1)return 0;\\n        if(dp[ind]!=10001)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){\\n            dp[ind]=min(dp[ind],1+solve(arr,i+ind,dp));\\n        }\\n        return dp[ind];\\n    }\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n+1,10001);\\n        return solve(arr,0,dp);\\n    }\\n```\\n**Greedy I**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)return 0;\\n        int max_so_far=0,ans=0,maxi=0;\\n        int i=0;\\n        while(maxi-i+1>0){\\n           ans++;\\n            for(i;i<=maxi;i++){\\n                max_so_far=max(max_so_far,i+arr[i]);\\n                if(max_so_far>=n-1)return ans;\\n            }\\n            maxi=max_so_far;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Greedy II**\\n```\\nint jump(vector<int>& arr) {\\n        int n=arr.size(),sum=0,c=0;\\n        if(n==1)return 0;\\n        int currFar=0,currEnd=0;\\n        for(int i=0;i<n-1;i++){\\n            currFar=max(currFar,arr[i]+i);\\n            if(i==currEnd){\\n                c++;\\n                currEnd=currFar;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nint solve(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind>=arr.size()-1)return 0;\\n        if(dp[ind]!=10001)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){\\n            dp[ind]=min(dp[ind],1+solve(arr,i+ind,dp));\\n        }\\n        return dp[ind];\\n    }\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n+1,10001);\\n        return solve(arr,0,dp);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)return 0;\\n        int max_so_far=0,ans=0,maxi=0;\\n        int i=0;\\n        while(maxi-i+1>0){\\n           ans++;\\n            for(i;i<=maxi;i++){\\n                max_so_far=max(max_so_far,i+arr[i]);\\n                if(max_so_far>=n-1)return ans;\\n            }\\n            maxi=max_so_far;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nint jump(vector<int>& arr) {\\n        int n=arr.size(),sum=0,c=0;\\n        if(n==1)return 0;\\n        int currFar=0,currEnd=0;\\n        for(int i=0;i<n-1;i++){\\n            currFar=max(currFar,arr[i]+i);\\n            if(i==currEnd){\\n                c++;\\n                currEnd=currFar;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697195,
                "title": "c-easy-fast-short-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int step = nums[i];\\n            for(int j=1;j<=step and i+j<n;j++)\\n            {\\n                dp[i+j]=min(dp[i+j], dp[i]+1);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int step = nums[i];\\n            for(int j=1;j<=step and i+j<n;j++)\\n            {\\n                dp[i+j]=min(dp[i+j], dp[i]+1);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909415,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n\\t\\tguard nums.count > 1 else { return 0 }\\n\\t\\tvar maxIndex: [Int] = [1]\\n\\n\\t\\tfor i in 0..<nums.count {\\n\\t\\t\\tvar max = 0\\n\\n\\t\\t\\tfor j in 0..<maxIndex[i] {\\n\\t\\t\\t\\tif (j >= nums.count) { break }\\n\\t\\t\\t\\tlet index = j + nums[j] + 1\\n\\n\\t\\t\\t\\tmax = max > index ? max : index\\n\\t\\t\\t\\tif max >= nums.count { return i + 1 }\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaxIndex.append(max)\\n\\t\\t}\\n        return 0\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n\\t\\tguard nums.count > 1 else { return 0 }\\n\\t\\tvar maxIndex: [Int] = [1]\\n\\n\\t\\tfor i in 0..<nums.count {\\n\\t\\t\\tvar max = 0\\n\\n\\t\\t\\tfor j in 0..<maxIndex[i] {\\n\\t\\t\\t\\tif (j >= nums.count) { break }\\n\\t\\t\\t\\tlet index = j + nums[j] + 1\\n\\n\\t\\t\\t\\tmax = max > index ? max : index\\n\\t\\t\\t\\tif max >= nums.count { return i + 1 }\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaxIndex.append(max)\\n\\t\\t}\\n        return 0\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160405,
                "title": "easy-java-solution-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using a greedy approach. We can keep track of the maximum reachable index in each iteration and jump to that index in the next iteration. The minimum number of jumps can be calculated by counting the number of iterations needed to reach the end of the array.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int n = nums.length; // length of the nums array\\n        int jumps = 0; // number of jumps needed to reach the end\\n        int curEnd = 0; // farthest index that can be reached with the current number of jumps\\n        int curFarthest = 0; // farthest index that can be reached from the current index\\n        \\n        // iterate over the nums array from 0 to n - 1\\n        for (int i = 0; i < n - 1; i++) {\\n            curFarthest = Math.max(curFarthest, i + nums[i]); // update curFarthest with the maximum distance that can be reached from this index\\n            \\n            // if i is equal to curEnd, we have reached the farthest possible index with the current number of jumps\\n            if (i == curEnd) {\\n                jumps++; // increment jumps by 1\\n                curEnd = curFarthest; // update curEnd with the new farthest index\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int n = nums.length; // length of the nums array\\n        int jumps = 0; // number of jumps needed to reach the end\\n        int curEnd = 0; // farthest index that can be reached with the current number of jumps\\n        int curFarthest = 0; // farthest index that can be reached from the current index\\n        \\n        // iterate over the nums array from 0 to n - 1\\n        for (int i = 0; i < n - 1; i++) {\\n            curFarthest = Math.max(curFarthest, i + nums[i]); // update curFarthest with the maximum distance that can be reached from this index\\n            \\n            // if i is equal to curEnd, we have reached the farthest possible index with the current number of jumps\\n            if (i == curEnd) {\\n                jumps++; // increment jumps by 1\\n                curEnd = curFarthest; // update curEnd with the new farthest index\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159282,
                "title": "4-best-approaches-recursion-memorization-tabulation-most-optimized-approach",
                "content": "# **Please Upvote if you like these approaches**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(K^n)\\nWhere K = maxElementOf(nums)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n)\\nO(n) for recursive call stack space\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        return recJump(nums, 0);\\n    }\\n\\n     public int recJump(int [] nums, int idx){\\n         if(idx == nums.length - 1)\\n             return 0;\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, recJump(nums, i)+1);\\n         }\\n         return min;\\n     }\\n\\n\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMemorization\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMemorization Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(K*n)\\nWhere K = maxElementOf(nums)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n)\\n```\\n\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n\\n     public int memoJump(int [] nums, int idx, int [] dp){\\n         if(idx == nums.length - 1)\\n             return dp[idx] = 0;\\n        \\n         if(dp[idx] != -1)\\n             return dp[idx];\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, memoJump(nums, i, dp)+1);\\n         }\\n         return dp[idx] = min;\\n     }\\n}\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTabulation\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTabulation Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(K*n)\\nWhere K = maxElementOf(nums)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n)\\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n    public int tabJump(int [] nums, int idx, int [] dp){\\n        for(idx = nums.length - 1; idx>=0; idx--){\\n            if(idx == nums.length-1){\\n                dp[idx] = 0;\\n                continue;\\n            }\\n\\n            int min = 99999;\\n            for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n                min = Math.min(min, dp[i]+1);\\n            }\\n\\n            dp[idx] = min;\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo Pointers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Pointers Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(n)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(1)\\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums){\\n        int end = 0, farthest = 0;\\n        int jump = 0;\\n\\n        for(int i = 0; i < nums.length-1; i++){\\n            farthest = Math.max(farthest, i + nums[i]);\\n            if(i == end){\\n                jump++;\\n                end = farthest;\\n            }\\n        }\\n        return jump;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        return recJump(nums, 0);\\n    }\\n\\n     public int recJump(int [] nums, int idx){\\n         if(idx == nums.length - 1)\\n             return 0;\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, recJump(nums, i)+1);\\n         }\\n         return min;\\n     }\\n\\n\\n```\n```\\n\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n\\n     public int memoJump(int [] nums, int idx, int [] dp){\\n         if(idx == nums.length - 1)\\n             return dp[idx] = 0;\\n        \\n         if(dp[idx] != -1)\\n             return dp[idx];\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, memoJump(nums, i, dp)+1);\\n         }\\n         return dp[idx] = min;\\n     }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n    public int tabJump(int [] nums, int idx, int [] dp){\\n        for(idx = nums.length - 1; idx>=0; idx--){\\n            if(idx == nums.length-1){\\n                dp[idx] = 0;\\n                continue;\\n            }\\n\\n            int min = 99999;\\n            for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n                min = Math.min(min, dp[i]+1);\\n            }\\n\\n            dp[idx] = min;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158322,
                "title": "easy-memoised-solution-c",
                "content": "\\n# Code Approach 1\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &nums,int idx,int n,vector<int> &dp){\\n        //base case\\n        if(idx >= n-1) return 0;\\n        \\n        if(dp[idx] != 10001) return dp[idx];\\n        \\n        int jumps=10001;\\n        for(int i=1; i <= nums[idx]; i++){\\n            jumps = min(jumps,1 + f(nums,idx + i,n,dp));\\n        }\\n        \\n        return dp[idx] = jumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<int> dp(n,10001);\\n        return f(nums,0,n,dp);\\n    }\\n};\\n```\\n# Code Approach 2 [greedy]\\n```\\nclass Solution {\\npublic:\\n//app 2: greedy\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,maxReachable=0,curLevelReach=0;\\n        int jumps=0;\\n\\n        while(i<n-1){\\n            maxReachable = max(maxReachable,i+nums[i]);\\n\\n            if(i == curLevelReach){\\n                curLevelReach = maxReachable;\\n                jumps++;\\n            }\\n            i++;\\n        }\\n\\n        return jumps;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int> &nums,int idx,int n,vector<int> &dp){\\n        //base case\\n        if(idx >= n-1) return 0;\\n        \\n        if(dp[idx] != 10001) return dp[idx];\\n        \\n        int jumps=10001;\\n        for(int i=1; i <= nums[idx]; i++){\\n            jumps = min(jumps,1 + f(nums,idx + i,n,dp));\\n        }\\n        \\n        return dp[idx] = jumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<int> dp(n,10001);\\n        return f(nums,0,n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//app 2: greedy\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,maxReachable=0,curLevelReach=0;\\n        int jumps=0;\\n\\n        while(i<n-1){\\n            maxReachable = max(maxReachable,i+nums[i]);\\n\\n            if(i == curLevelReach){\\n                curLevelReach = maxReachable;\\n                jumps++;\\n            }\\n            i++;\\n        }\\n\\n        return jumps;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306691,
                "title": "all-methods-recursive-dp-memoization-dp-tabulation-greedy-dfs-c",
                "content": "**Recursive Method**\\nTime Complexity: O(2^n)\\nSpace Complexity: O(1)\\nAuxilary Space Complexity for Recursive Stack Space: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums){\\n        if(i>=nums.size()-1) return 0;\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums));\\n        }\\n        return minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        return getMinJump(0, nums);\\n    }\\n};\\n```\\n**DP- Memoization**\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums, vector<int> &dp){\\n        if(i>=nums.size()-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums, dp));\\n        }\\n        return dp[i]=minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return getMinJump(0, nums, dp);\\n    }\\n};\\n```\\n**DP- Tabulation**\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n, n);\\n        dp[0]=0;\\n        for(int i{}; i<n-1; i++){\\n            for(int j=i+1; j<=i+nums[i]&&j<n; j++){\\n                dp[j]=min(dp[j], 1+dp[i]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**Greedy Method**\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int farthest=0, jumps=0, current=0;\\n        for(int i=0; i<n; ++i){\\n            if(i>current){\\n                current=farthest;\\n                jumps++;\\n            }\\n            farthest=max(farthest, i+nums[i]);\\n        }\\n        return jumps;\\n    }\\n};\\n```\\n\\n***If you like this post, Please Upvote this post***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums){\\n        if(i>=nums.size()-1) return 0;\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums));\\n        }\\n        return minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        return getMinJump(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums, vector<int> &dp){\\n        if(i>=nums.size()-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums, dp));\\n        }\\n        return dp[i]=minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return getMinJump(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n, n);\\n        dp[0]=0;\\n        for(int i{}; i<n-1; i++){\\n            for(int j=i+1; j<=i+nums[i]&&j<n; j++){\\n                dp[j]=min(dp[j], 1+dp[i]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int farthest=0, jumps=0, current=0;\\n        for(int i=0; i<n; ++i){\\n            if(i>current){\\n                current=farthest;\\n                jumps++;\\n            }\\n            farthest=max(farthest, i+nums[i]);\\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677863,
                "title": "java-solution-4-approaches-from-recursive-to-top-down-to-botton-up-and-finally-greedy",
                "content": "In question it is mentioned that answer will always exists. \\nlast element of array does not matter also as even if its value is 0 we don\\'t need to hop further.\\n**Brute Force-**\\nstart from i=0 to n-2 and foreach element i check at how many position we can go and for each valid posiiton again check how many locations we can go. keep on returning min for each path. once we reach last index we have the desired answer.\\n\\n```\\npublic int bruteForce(int[] nums) {\\n\\t\\treturn bruteForceRec(nums, 0);\\n\\t}\\n\\n\\tprivate int bruteForceRec(int[] nums, int start) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint min = 10001;//max value can be 1000\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + bruteForceRec(nums, i));\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n```\\n\\n**Top Down -**\\nIn above approach we are visiting every branch and at most of the times same branch is re-calucated. to save that take output array and before calling method check if for that index output array already has some data. if yes return directly else call method.\\n\\n```\\n\\tpublic int topDownDp(int[] nums) {\\n\\t\\treturn topDownRec(nums, 0, new int[nums.length]);\\n\\t}\\n\\n\\tprivate int topDownRec(int[] nums, int start, int[] output) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (output[start] != 0) {\\n\\t\\t\\treturn output[start];\\n\\t\\t}\\n\\t\\tint min = 10001; // max possible jump is 10^4\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + topDownRec(nums, i, output));\\n\\t\\t}\\n\\t\\toutput[start] = min;\\n\\t\\treturn min;\\n\\t}\\n\\n```\\n\\n**Bottom Up->**\\nwe can just reverse the outer loop and can make recursive solution to iterative.\\n```\\n\\tpublic int bottomUpDp(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] output = new int[n];\\n\\t\\tfor (int start = n - 2; start >= 0; start--) {\\n\\t\\t\\tint min = 10001;\\n\\t\\t\\tfor (int i = start + 1; i <= start + nums[start]; i++) {\\n\\t\\t\\t\\tmin = Math.min(min, 1 + (i>=n ? 0 : output[i]));\\n\\t\\t\\t}\\n\\t\\t\\toutput[start] = min;\\n\\t\\t}\\n\\t\\treturn output[0];\\n\\t}\\n```\\n\\n**Greedy Approach ->**\\nwe can make use of greedy idea + sliding window concept also and can reduce the complexity from o(n^2) to o(n)\\nfor that keep maintaing left and right pointers to hold the window size on which we can go from each step.\\njump will store total jump needed to reach from first window till last window.\\ninitially set l=r=jump=0\\nnow loop till right< n-1\\ncheck for item starting from left till right what is max value i.e.\\nmax=Math.max(max,i+nums[i]);\\nonce inner loop finsihes we have max hops that we can go. now, increment jump, and left and right boundary also.\\nonce outer loop finishes jump has the desired answer.\\n```\\npublic int greedy(int[] nums) {\\n\\t\\tint jump = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = 0;\\n\\t\\t//till we reach end of the array\\n\\t\\twhile (right < nums.length - 1) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\t//find max reach (in range of indexes left and right)\\n\\t\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\t\\tmax = Math.max(nums[i] + i, max);\\n\\t\\t\\t}\\n\\t\\t\\t//update new boundaries\\n\\t\\t\\tleft = right + 1;\\n\\t\\t\\tright = max;\\n\\t\\t\\tjump++;\\n\\t\\t}\\n\\t\\treturn jump;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\npublic int bruteForce(int[] nums) {\\n\\t\\treturn bruteForceRec(nums, 0);\\n\\t}\\n\\n\\tprivate int bruteForceRec(int[] nums, int start) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint min = 10001;//max value can be 1000\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + bruteForceRec(nums, i));\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n```\n```\\n\\tpublic int topDownDp(int[] nums) {\\n\\t\\treturn topDownRec(nums, 0, new int[nums.length]);\\n\\t}\\n\\n\\tprivate int topDownRec(int[] nums, int start, int[] output) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (output[start] != 0) {\\n\\t\\t\\treturn output[start];\\n\\t\\t}\\n\\t\\tint min = 10001; // max possible jump is 10^4\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + topDownRec(nums, i, output));\\n\\t\\t}\\n\\t\\toutput[start] = min;\\n\\t\\treturn min;\\n\\t}\\n\\n```\n```\\n\\tpublic int bottomUpDp(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] output = new int[n];\\n\\t\\tfor (int start = n - 2; start >= 0; start--) {\\n\\t\\t\\tint min = 10001;\\n\\t\\t\\tfor (int i = start + 1; i <= start + nums[start]; i++) {\\n\\t\\t\\t\\tmin = Math.min(min, 1 + (i>=n ? 0 : output[i]));\\n\\t\\t\\t}\\n\\t\\t\\toutput[start] = min;\\n\\t\\t}\\n\\t\\treturn output[0];\\n\\t}\\n```\n```\\npublic int greedy(int[] nums) {\\n\\t\\tint jump = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = 0;\\n\\t\\t//till we reach end of the array\\n\\t\\twhile (right < nums.length - 1) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\t//find max reach (in range of indexes left and right)\\n\\t\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\t\\tmax = Math.max(nums[i] + i, max);\\n\\t\\t\\t}\\n\\t\\t\\t//update new boundaries\\n\\t\\t\\tleft = right + 1;\\n\\t\\t\\tright = max;\\n\\t\\t\\tjump++;\\n\\t\\t}\\n\\t\\treturn jump;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640734,
                "title": "0ms-o-n-solution-faster-than-100-users-less-memory-than-97-java-users-explained",
                "content": "\\n\\n```\\nclass Solution {\\n\\n    public int jump(int[] a) {\\n        int n = a.length;\\n\\n        // Check Base Conditions\\n        if (n == 0 || n == 1) {\\n            return 0;\\n        } else if (a[0] >= n - 1) {\\n            return 1;\\n        }\\n\\n        // Keeps count of number of jumps\\n        int count = 1;\\n\\n        // 2 pointers to loop through the array\\n        int current_pos = 0; // stores the current position\\n        int parsed_pos = -1; // stores the last index of the position that have been parsed\\n\\n        //stores the position of the max value one can jump to between the parsed position and the current position\\n        int jumpTo = current_pos + a[current_pos];\\n\\n        // while not reached destination/end\\n        while (jumpTo < n - 1) {\\n            int arr[] = nextJump(a, current_pos, parsed_pos);\\n            current_pos = arr[0];\\n            parsed_pos = arr[1];\\n            jumpTo = arr[2];\\n            count += 1;\\n        }\\n\\n        return count;\\n    }\\n\\n    //finds the best index to jump from, between parsed_pos and max index reachable from current_pos\\n    static int[] nextJump(int[] a, int current_pos, int parsed_pos) {\\n        // stores the best position to jump from, between parsed_pos and max index reachable from current_pos \\n        int new_pos = current_pos;\\n\\n        // iterate parsed_pos and max index reachable from current_pos and find the index that can jump the farthest and set that as new_pos\\n        for (int i = parsed_pos + 1; i <= current_pos + a[current_pos]; i++) {\\n            if (i + a[i] >= new_pos + a[new_pos]) {\\n                new_pos = i;\\n            }\\n        }\\n\\n        //contains the new position to jump to, last index parsed in this iteration(new parsed_pos), maximum index reachable from the new position \\n        int arr[] = { new_pos, current_pos + a[current_pos], new_pos + a[new_pos] };\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int jump(int[] a) {\\n        int n = a.length;\\n\\n        // Check Base Conditions\\n        if (n == 0 || n == 1) {\\n            return 0;\\n        } else if (a[0] >= n - 1) {\\n            return 1;\\n        }\\n\\n        // Keeps count of number of jumps\\n        int count = 1;\\n\\n        // 2 pointers to loop through the array\\n        int current_pos = 0; // stores the current position\\n        int parsed_pos = -1; // stores the last index of the position that have been parsed\\n\\n        //stores the position of the max value one can jump to between the parsed position and the current position\\n        int jumpTo = current_pos + a[current_pos];\\n\\n        // while not reached destination/end\\n        while (jumpTo < n - 1) {\\n            int arr[] = nextJump(a, current_pos, parsed_pos);\\n            current_pos = arr[0];\\n            parsed_pos = arr[1];\\n            jumpTo = arr[2];\\n            count += 1;\\n        }\\n\\n        return count;\\n    }\\n\\n    //finds the best index to jump from, between parsed_pos and max index reachable from current_pos\\n    static int[] nextJump(int[] a, int current_pos, int parsed_pos) {\\n        // stores the best position to jump from, between parsed_pos and max index reachable from current_pos \\n        int new_pos = current_pos;\\n\\n        // iterate parsed_pos and max index reachable from current_pos and find the index that can jump the farthest and set that as new_pos\\n        for (int i = parsed_pos + 1; i <= current_pos + a[current_pos]; i++) {\\n            if (i + a[i] >= new_pos + a[new_pos]) {\\n                new_pos = i;\\n            }\\n        }\\n\\n        //contains the new position to jump to, last index parsed in this iteration(new parsed_pos), maximum index reachable from the new position \\n        int arr[] = { new_pos, current_pos + a[current_pos], new_pos + a[new_pos] };\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193341,
                "title": "o-n-golang-solution-beats-100",
                "content": "```\\nfunc jump(nums []int) int {\\n\\tcurJump, farthestJump, jumps := 0, 0, 0\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t    // push index of furthest jump during current iteration\\n\\t\\tif i+nums[i] > farthestJump {\\n\\t\\t\\tfarthestJump = i + nums[i]\\n\\t\\t}\\n\\n\\t\\t// if current iteration is ended - setup the next one\\n\\t\\tif i == curJump {\\n\\t\\t\\tjumps, curJump = jumps+1, farthestJump\\n\\n\\t\\t\\tif curJump >= len(nums)-1 {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// it\\'s guaranteed to never hit it\\n\\treturn 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc jump(nums []int) int {\\n\\tcurJump, farthestJump, jumps := 0, 0, 0\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t    // push index of furthest jump during current iteration\\n\\t\\tif i+nums[i] > farthestJump {\\n\\t\\t\\tfarthestJump = i + nums[i]\\n\\t\\t}\\n\\n\\t\\t// if current iteration is ended - setup the next one\\n\\t\\tif i == curJump {\\n\\t\\t\\tjumps, curJump = jumps+1, farthestJump\\n\\n\\t\\t\\tif curJump >= len(nums)-1 {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// it\\'s guaranteed to never hit it\\n\\treturn 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18149,
                "title": "my-python-solution",
                "content": "    class Solution(object):\\n    def jump(self, nums):\\n        res = 0\\n        edge = 0\\n        maxEdge = 0\\n        for i in range(len(nums)):\\n            if i > edge:\\n                edge = maxEdge\\n                res += 1\\n            maxEdge = max(maxEdge,i+nums[i])\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def jump(self, nums):\\n        res = 0\\n        edge = 0\\n        maxEdge = 0\\n        for i in range(len(nums)):\\n            if i > edge:\\n                edge = maxEdge\\n                res += 1\\n            maxEdge = max(maxEdge,i+nums[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 18201,
                "title": "17ms-ac-c-code-very-easy-to-understand",
                "content": "    int jump(int A[], int n) {\\n    \\t\\tint i = 0, j = 1, cnt = 0, mx;\\n    \\n    \\t\\tif (n == 1) return 0;\\n    \\n    \\t\\twhile (i < n - 1 && i + A[i] < n - 1) {\\n    \\t\\t\\tfor (mx = j; j <= i + A[i]; j++) { mx = (mx + A[mx] <= j + A[j]) ? j : mx; }\\n    \\t\\t\\ti = mx; cnt++;\\n    \\t\\t}\\n    \\t\\treturn ++cnt; /* One more step to last index. */\\n    \\t}\\n\\nAll we have to do is to iterate though all positions we can jump from where we standing, find the largest i + A[i] (greedy) and jump to that index. O(n) in time and constant space.",
                "solutionTags": [],
                "code": "    int jump(int A[], int n) {\\n    \\t\\tint i = 0, j = 1, cnt = 0, mx;\\n    \\n    \\t\\tif (n == 1) return 0;\\n    \\n    \\t\\twhile (i < n - 1 && i + A[i] < n - 1) {\\n    \\t\\t\\tfor (mx = j; j <= i + A[i]; j++) { mx = (mx + A[mx] <= j + A[j]) ? j : mx; }\\n    \\t\\t\\ti = mx; cnt++;\\n    \\t\\t}\\n    \\t\\treturn ++cnt; /* One more step to last index. */\\n    \\t}\\n\\nAll we have to do is to iterate though all positions we can jump from where we standing, find the largest i + A[i] (greedy) and jump to that index. O(n) in time and constant space.",
                "codeTag": "Unknown"
            },
            {
                "id": 1668826,
                "title": "dp-greedy-c-soln",
                "content": "**Greedy**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n    int res = 0 , currmax = 0 , reach = 0;\\n        \\n        for(int index = 0 ; index < nums.size() - 1 ; index++)\\n        {\\n            if(index + nums[index] > currmax)\\n                currmax = index + nums[index];\\n            \\n            if(index == reach)\\n            {\\n                res++;\\n                reach = currmax;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n***DP***\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, INT_MAX-1);\\n        dp[n - 1] = 0;  \\n        for(int i = n - 2; i >= 0; i--) \\n            for(int j = 1; j <= nums[i]; j++) \\n                dp[i] = min(dp[i], 1 + dp[min(n - 1, i + j)]);  \\n        return dp[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n    int res = 0 , currmax = 0 , reach = 0;\\n        \\n        for(int index = 0 ; index < nums.size() - 1 ; index++)\\n        {\\n            if(index + nums[index] > currmax)\\n                currmax = index + nums[index];\\n            \\n            if(index == reach)\\n            {\\n                res++;\\n                reach = currmax;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, INT_MAX-1);\\n        dp[n - 1] = 0;  \\n        for(int i = n - 2; i >= 0; i--) \\n            for(int j = 1; j <= nums[i]; j++) \\n                dp[i] = min(dp[i], 1 + dp[min(n - 1, i + j)]);  \\n        return dp[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439932,
                "title": "simple-python-o-n-greedy-solution",
                "content": "The idea is that we only jump when we absolutely have to, this way the total number of jumps will be minimized.\\n**next_jump_max**: the furtherest we can jump next time\\n**cur_jump_max**: the furtherest we reach from previous jump\\n```Python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        cur_jump_max = next_jump_max = ret = 0\\n        for i in range(len(nums)-1):\\n            next_jump_max = max(next_jump_max, i+nums[i])\\n            if i == cur_jump_max:\\n                ret += 1\\n                cur_jump_max = next_jump_max\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```Python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        cur_jump_max = next_jump_max = ret = 0\\n        for i in range(len(nums)-1):\\n            next_jump_max = max(next_jump_max, i+nums[i])\\n            if i == cur_jump_max:\\n                ret += 1\\n                cur_jump_max = next_jump_max\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915437,
                "title": "hurray",
                "content": "**Approach**: I solved the problem with greedy approach. For the last couple of days i was practicing and studying greedy aprroach heavily. This topic always bothered me. But after with enough study and practicing common greedy problems now i can detect which problems to tackle with greedy approach and device a way how to solve.\\n\\nMy approach for this particular problem is to get the indices from nums which **minimises the distance from the end.**\\n```\\n\\t\\t\\tint a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n```\\nThis block of code achives this.\\n\\nOverall Code:\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if (nums.length <= 1) return 0;\\n        int max = nums[0];\\n        int i = 0;\\n        int count = 1;\\n        while (i <= nums.length) {\\n            if (i + max >= nums.length - 1) return count;\\n            int[] res = helper(nums, i + 1, i + max);\\n            max = res[0];\\n            i = res[1];\\n            count++;\\n        }\\n        return 0;\\n    }\\n    \\n     private int[] helper(int[] nums, int start, int end) {\\n        int min = Integer.MAX_VALUE;\\n        int aMin = Integer.MAX_VALUE;\\n        int pos = -1;\\n        for (int i = end; i >=start ; i--) {\\n            int a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n\\n        }\\n        return new int[]{min, pos};\\n    }\\n}\\n```\\n\\nTime taken is 2ms. I think the TC is **O(N)**. Cause in the worst case this program can process an elment max two times. I cant find a worse case that in an elemnt will be processed multiple times. Can anyone help me here if am right or wrong here?\\n\\nNevertheless thanks everyone to the discuss channel contributers which helps me a lot to progress. <3",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\t\\t\\tint a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n```\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if (nums.length <= 1) return 0;\\n        int max = nums[0];\\n        int i = 0;\\n        int count = 1;\\n        while (i <= nums.length) {\\n            if (i + max >= nums.length - 1) return count;\\n            int[] res = helper(nums, i + 1, i + max);\\n            max = res[0];\\n            i = res[1];\\n            count++;\\n        }\\n        return 0;\\n    }\\n    \\n     private int[] helper(int[] nums, int start, int end) {\\n        int min = Integer.MAX_VALUE;\\n        int aMin = Integer.MAX_VALUE;\\n        int pos = -1;\\n        for (int i = end; i >=start ; i--) {\\n            int a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n\\n        }\\n        return new int[]{min, pos};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158252,
                "title": "c-java-simple-solution-easy-to-understand-code-with-comments",
                "content": "# Intuition\\nAdvice: Frist ,You need to analyse the question to which data structure to apply for this solution,It will come automatically,when you solve more problems.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMy first Approach was Dynammic programming,but solution beats 50%.\\nI moved to greedy method and Beats 95%.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Greedy Approach\\npublic class Solution {\\n    public int Jump(int[] nums) {\\n        int length=nums.Length;\\n\\n        int highJump=0;\\n        int jump=0;\\n        int currPos=0;\\n        // corner case :only one positio don\\'t need jump\\n        if(length==1){\\n            return 0;\\n        }\\n        // base case : If start position given range,you won\\'t jump more So,return -1;\\n        if(nums[0]==0){\\n            return -1;\\n        }\\n        //Loop through steps \\n        for(int i=0;i<length;i++){\\n            highJump=Math.Max(highJump, i+nums[i]);\\n            // When the jump reaches the end return the total jumps\\n            if(highJump>=length-1){\\n                return jump+1;\\n            }\\n            if(i==currPos){\\n                currPos=highJump;\\n                jump++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```UPVOTE THE POST (Upvote karo masth.. Karo bhaiye..)\\n    //Dynammic Programming\\n    int length=nums.Length;\\n    //It\\'s the way to assign value to all indexes\\n    int[] dp = Enumerable.Repeat(Int32.MaxValue,length).ToArray();\\n    dp[0] = 0;\\n    for(int i = 0; i <length; i++) {\\n        for(int j = 0; j <= nums[i] && i + j < length; j++) {\\n            dp[i+j] = Math.Min(dp[i+j], dp[i] + 1);                \\n        }\\n    }\\n    return dp[length - 1];\\n",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\n//Greedy Approach\\npublic class Solution {\\n    public int Jump(int[] nums) {\\n        int length=nums.Length;\\n\\n        int highJump=0;\\n        int jump=0;\\n        int currPos=0;\\n        // corner case :only one positio don\\'t need jump\\n        if(length==1){\\n            return 0;\\n        }\\n        // base case : If start position given range,you won\\'t jump more So,return -1;\\n        if(nums[0]==0){\\n            return -1;\\n        }\\n        //Loop through steps \\n        for(int i=0;i<length;i++){\\n            highJump=Math.Max(highJump, i+nums[i]);\\n            // When the jump reaches the end return the total jumps\\n            if(highJump>=length-1){\\n                return jump+1;\\n            }\\n            if(i==currPos){\\n                currPos=highJump;\\n                jump++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327160,
                "title": "very-easy-100-fully-explained-c-java-javascript-c",
                "content": "# **C++ Solution:**\\n```\\n**// Using Optimal Greedy Approach...**\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        //Initialize left and right pointers to point to the start and end of a segment...\\n        //segment refers to the steps a particular index can move...\\n        //Initialize jumps variable to store the number of jumps made so far which will be the minimum...\\n        int left = 0, right = 0, jump = 0;\\n        // While right pointer is not at the end of the list...\\n        while(right < nums.size() - 1){\\n            int maxi = 0;\\n            //Loop through the segment and maximize the reach...\\n            for(int i = left; i < right + 1; i++)\\n                maxi = max(maxi, nums[i] + i);\\n            // Update the pointers...\\n            // left pointer to be at right + 1...\\n            left = right + 1;\\n            // right pointer to be at the maximum reach...\\n            right = maxi;\\n            jump += 1;\\n        }\\n        return jump;\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\n**// Using Dynamic Programming Approach...**\\nclass Solution {\\n    public int jump(int[] nums) {\\n        //Create an auxiliary array to store minimum jumps needed to reach nums[i] from nums[0].\\n        int[] jump = new int[nums.length];\\n        jump[0] = 0;\\n        //Implement a nested loop to traverse the whole list.\\n        for (int i = 1; i < nums.length; i++) {\\n            jump[i] = Integer.MAX_VALUE;\\n            //traverse the segments and stores the minimum jumps to an index in the auxiliary array.\\n            for(int j = 0; j < i; j++){\\n                // Find the minimum number of jumps to reach nums[i] from the start\\n                // And add this value to the auxiliary array.\\n                if(i <= nums[j] + j && jump[j] != Integer.MAX_VALUE) {\\n                    jump[i] = Math.min(jump[i], jump[j] + 1);\\n                }\\n            }\\n        }\\n        return jump[nums.length - 1];   //Return the minimum number of jumps.\\n    }\\n}\\n```\\n\\n# **JavaScript Solution:**\\n```\\n**//Time Complexity : O(n),   Space Complexity: O(1)**\\nvar jump = function(nums) {\\n    var jump = 0;\\n    var prev = 0;\\n    var max = 0;\\n    for (var i = 0; i < nums.length - 1; i++) {\\n        // Keep track of the maximum jump\\n        max = Math.max(max, i + nums[i]);\\n        // When we get to the index where we had our previous maximum jump, we increase our jump...\\n        if (i === prev) {\\n            jump++;\\n            prev = max;\\n        }\\n    }\\n    return jump;\\n};\\n```\\n\\n# **C Language:**\\n```\\n// Another approach is here...\\nint jump(int* nums, int numsSize){\\n    int pos = 0;\\n    int n = 0;\\n    while(pos < numsSize-1) {\\n        int next_pos=-1;\\n        if(pos+nums[pos]<numsSize-1) {\\n            for(int i=1; i<=nums[pos]; i++) {\\n                if(next_pos == -1 || (pos+i<numsSize && nums[next_pos]+(next_pos-pos) <= nums[pos+i]+i))\\n                    next_pos = pos+i;\\n            }\\n        }else\\n            next_pos = pos+nums[pos];\\n            pos = next_pos;\\n            n++;\\n    }\\n    return n;\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n**// Using Optimal Greedy Approach...**\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        //Initialize left and right pointers to point to the start and end of a segment...\\n        //segment refers to the steps a particular index can move...\\n        //Initialize jumps variable to store the number of jumps made so far which will be the minimum...\\n        int left = 0, right = 0, jump = 0;\\n        // While right pointer is not at the end of the list...\\n        while(right < nums.size() - 1){\\n            int maxi = 0;\\n            //Loop through the segment and maximize the reach...\\n            for(int i = left; i < right + 1; i++)\\n                maxi = max(maxi, nums[i] + i);\\n            // Update the pointers...\\n            // left pointer to be at right + 1...\\n            left = right + 1;\\n            // right pointer to be at the maximum reach...\\n            right = maxi;\\n            jump += 1;\\n        }\\n        return jump;\\n    }\\n};\\n```\n```\\n**// Using Dynamic Programming Approach...**\\nclass Solution {\\n    public int jump(int[] nums) {\\n        //Create an auxiliary array to store minimum jumps needed to reach nums[i] from nums[0].\\n        int[] jump = new int[nums.length];\\n        jump[0] = 0;\\n        //Implement a nested loop to traverse the whole list.\\n        for (int i = 1; i < nums.length; i++) {\\n            jump[i] = Integer.MAX_VALUE;\\n            //traverse the segments and stores the minimum jumps to an index in the auxiliary array.\\n            for(int j = 0; j < i; j++){\\n                // Find the minimum number of jumps to reach nums[i] from the start\\n                // And add this value to the auxiliary array.\\n                if(i <= nums[j] + j && jump[j] != Integer.MAX_VALUE) {\\n                    jump[i] = Math.min(jump[i], jump[j] + 1);\\n                }\\n            }\\n        }\\n        return jump[nums.length - 1];   //Return the minimum number of jumps.\\n    }\\n}\\n```\n```\\n**//Time Complexity : O(n),   Space Complexity: O(1)**\\nvar jump = function(nums) {\\n    var jump = 0;\\n    var prev = 0;\\n    var max = 0;\\n    for (var i = 0; i < nums.length - 1; i++) {\\n        // Keep track of the maximum jump\\n        max = Math.max(max, i + nums[i]);\\n        // When we get to the index where we had our previous maximum jump, we increase our jump...\\n        if (i === prev) {\\n            jump++;\\n            prev = max;\\n        }\\n    }\\n    return jump;\\n};\\n```\n```\\n// Another approach is here...\\nint jump(int* nums, int numsSize){\\n    int pos = 0;\\n    int n = 0;\\n    while(pos < numsSize-1) {\\n        int next_pos=-1;\\n        if(pos+nums[pos]<numsSize-1) {\\n            for(int i=1; i<=nums[pos]; i++) {\\n                if(next_pos == -1 || (pos+i<numsSize && nums[next_pos]+(next_pos-pos) <= nums[pos+i]+i))\\n                    next_pos = pos+i;\\n            }\\n        }else\\n            next_pos = pos+nums[pos];\\n            pos = next_pos;\\n            n++;\\n    }\\n    return n;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732493,
                "title": "linear-and-easy-bfs-solution-in-c",
                "content": "```\\nint jump(vector<int>& nums) {\\n        \\n        int current=0,farthest=0,jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++) {\\n            \\n            farthest=max(farthest, nums[i]+i);\\n            if(i==current) {\\n                current=farthest; jumps++;\\n            }\\n        }\\n        return jumps;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        \\n        int current=0,farthest=0,jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++) {\\n            \\n            farthest=max(farthest, nums[i]+i);\\n            if(i==current) {\\n                current=farthest; jumps++;\\n            }\\n        }\\n        return jumps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 527262,
                "title": "python-dp-ezpz-10-line-solution-91-20",
                "content": "```\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return 0\\n        dp = [0]*len(nums)\\n        frontier = 0\\n        for i, n in enumerate(nums):\\n            if i + n > frontier:\\n                dp[frontier + 1:i + n + 1] = [dp[i] + 1] * (i + n - frontier)\\n                frontier = i + n\\n                if i + n >= len(nums) - 1: break\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return 0\\n        dp = [0]*len(nums)\\n        frontier = 0\\n        for i, n in enumerate(nums):\\n            if i + n > frontier:\\n                dp[frontier + 1:i + n + 1] = [dp[i] + 1] * (i + n - frontier)\\n                frontier = i + n\\n                if i + n >= len(nums) - 1: break\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18082,
                "title": "5-lines-o-n-python-with-explanation",
                "content": "Check comments in the code. \\n\\n    def jump2(self, A):\\n        \"\"\"\\n        Basically it's a shortest-path problem. \\n        As an unweighted graph, BFS should be able to solve it in O(|E|).\\n        But as it's an array with non-negative numbers, we can't jump backward. \\n        So we can do better here.\\n        Suppose we devided the arrays into segments depending on the elment \\n        in the array. So for each segment, we find the farthest index we can \\n        jump. For example, the first segment is always A[0]. The second will be\\n        from A[1] to A[A[0]]. The third will be from A[A[0]] to the farthest \\n        index we can find in the second segment. We start looking between \\n        the end of the last segment and the begin of the next segment.\\n        \"\"\"\\n        ans = lastIdx = nextIdx = 0\\n        while nextIdx < len(A) - 1:\\n            ans += 1\\n            lastIdx, nextIdx = nextIdx, max(i + A[i] for i in xrange(lastIdx, nextIdx + 1))\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "Check comments in the code. \\n\\n    def jump2(self, A):\\n        \"\"\"\\n        Basically it's a shortest-path problem. \\n        As an unweighted graph, BFS should be able to solve it in O(|E|).\\n        But as it's an array with non-negative numbers, we can't jump backward. \\n        So we can do better here.\\n        Suppose we devided the arrays into segments depending on the elment \\n        in the array. So for each segment, we find the farthest index we can \\n        jump. For example, the first segment is always A[0]. The second will be\\n        from A[1] to A[A[0]]. The third will be from A[A[0]] to the farthest \\n        index we can find in the second segment. We start looking between \\n        the end of the last segment and the begin of the next segment.\\n        \"\"\"\\n        ans = lastIdx = nextIdx = 0\\n        while nextIdx < len(A) - 1:\\n            ans += 1\\n            lastIdx, nextIdx = nextIdx, max(i + A[i] for i in xrange(lastIdx, nextIdx + 1))\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 3158368,
                "title": "beginner-friendly-solution-easy-greedy-approach",
                "content": "# Intuition\\nGreddy Approach\\n\\n# Approach\\n- take three integer values jumps,curr_end and curr_Farthest  \\n- iterate through  loop to update curr_farthest and curr_end\\n- update curr_Farthest with max between curr_Farthest and i+nums[i]\\n- update curr_end when i is equal to curr_End and increase jumps\\n- return jumps\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code in C++\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n\\tint jumps = 0, curr_End = 0, curr_Farthest = 0;\\n\\tfor (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tcurr_Farthest = max(curr_Farthest, i + nums[i]);\\n\\t\\tif (i == curr_End) {\\n\\t\\t\\tjumps++;\\n\\t\\t\\tcurr_End = curr_Farthest;\\n\\t\\t}\\n\\t}\\n\\treturn jumps;\\n\\n    }\\n};\\n```\\n# Code in Python\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps=0\\n        curr_end=0\\n        curr_farthest=0\\n        n=len(nums)\\n        for i in range(n-1):\\n            curr_farthest=max(curr_farthest,i+nums[i])\\n            if(i==curr_end):\\n                jumps+=1\\n                curr_end=curr_farthest\\n        return jumps\\n```\\n\\n# DON\\'T FORGET TO UPVOTE !",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n\\tint jumps = 0, curr_End = 0, curr_Farthest = 0;\\n\\tfor (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tcurr_Farthest = max(curr_Farthest, i + nums[i]);\\n\\t\\tif (i == curr_End) {\\n\\t\\t\\tjumps++;\\n\\t\\t\\tcurr_End = curr_Farthest;\\n\\t\\t}\\n\\t}\\n\\treturn jumps;\\n\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps=0\\n        curr_end=0\\n        curr_farthest=0\\n        n=len(nums)\\n        for i in range(n-1):\\n            curr_farthest=max(curr_farthest,i+nums[i])\\n            if(i==curr_end):\\n                jumps+=1\\n                curr_end=curr_farthest\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522839,
                "title": "o-n-single-pass-well-explained-ladder-steps-technique",
                "content": "Ladder Analogy\\n-\\n___\\nTake an iterator ``itr`` pointing to first element. We\\'ll move this over the array.\\n\\nFrom an element at position ``itr``, we can jump steps less than equal to ``nums[itr]``.\\nSo, we can move from ``itr`` to ``itr + nums[itr]`` (and stop anywhere in between)\\n\\nConsider this as a ladder connecting`` itr`` to ``itr + nums[itr]``, where we can stop at any step of this ladder.\\n\\nAlso, for every ``itr``, we have a seperate ladder going till ``itr + nums[itr]``.\\nFollowing figure shows all ladders connecting the elements in ``[3, 2, 2, 1, 4, 5]``\\n\\n![image](https://assets.leetcode.com/users/images/5b8ca20f-4d49-4eb4-bfcb-61de1a02345c_1634322078.0108702.png)\\n\\nSo, as ``itr`` moves from start to end, we can say that we are moving along a ladder or jumping from one ladder to another and moving along it.\\n\\nEach ladder change is analogous to a jump, so we need to reach the end with minimum ladder changes.\\nFollowing figure shows a path (in green) with minimum ladder changes.\\n\\n![image](https://assets.leetcode.com/users/images/28840ca0-3d48-4837-b7aa-72b11cf01020_1634322104.7879624.png)\\n\\nApproach\\n-\\n___\\n\\nMove along a ladder till we reach its end.\\n\\nWhile moving ahead find the ladder that has the farthest end and save it.\\n\\nWhen the current ladder ends, jump to the ladder that takes you the farthest.\\n\\nRepeat the same till we reach the end of ``nums``.\\n\\nCode\\n-\\n___\\n\\n``steps``: Number of steps in current ladder\\n\\n``ladder``:  Ending index of the ladder that takes us to the farthest point\\n\\n``jumps``: Number of ladder switches done till now\\n\\n``itr``: Iterator that moves across the array\\n\\n```\\ndef jump(self, nums: List[int]) -> int:\\n\\n\\t# Boundary case\\n\\tn = len(nums)\\n\\tif n == 1:\\n\\t\\treturn 0\\n\\n\\t# Initialize variables\\n\\tjumps = 1\\n\\tladder = nums[0]\\n\\tsteps = ladder\\n\\titr = 0\\n\\n\\t# Move over the current ladder\\n\\twhile steps >= 0:\\n\\n\\t\\t# Terminal condition - reached end of nums\\n\\t\\tif itr == n - 1:\\n\\t\\t\\treturn jumps\\n\\n\\t\\t# Update ladder endpoint if a longer one is found\\n\\t\\tladder = max( itr + nums[itr], ladder )\\n\\n\\t\\t# Current ladder has ended\\n\\t\\tif steps == 0:\\n\\t\\t\\tsteps = ladder - itr     # move to new ladder\\n\\t\\t\\tjumps += 1               # and update jumps\\n\\t\\t\\n\\t\\t# Continue moving ahead\\n\\t\\telse:\\n\\t\\t\\tsteps -= 1\\n\\t\\t\\titr += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef jump(self, nums: List[int]) -> int:\\n\\n\\t# Boundary case\\n\\tn = len(nums)\\n\\tif n == 1:\\n\\t\\treturn 0\\n\\n\\t# Initialize variables\\n\\tjumps = 1\\n\\tladder = nums[0]\\n\\tsteps = ladder\\n\\titr = 0\\n\\n\\t# Move over the current ladder\\n\\twhile steps >= 0:\\n\\n\\t\\t# Terminal condition - reached end of nums\\n\\t\\tif itr == n - 1:\\n\\t\\t\\treturn jumps\\n\\n\\t\\t# Update ladder endpoint if a longer one is found\\n\\t\\tladder = max( itr + nums[itr], ladder )\\n\\n\\t\\t# Current ladder has ended\\n\\t\\tif steps == 0:\\n\\t\\t\\tsteps = ladder - itr     # move to new ladder\\n\\t\\t\\tjumps += 1               # and update jumps\\n\\t\\t\\n\\t\\t# Continue moving ahead\\n\\t\\telse:\\n\\t\\t\\tsteps -= 1\\n\\t\\t\\titr += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 672805,
                "title": "easy-to-understand-faster-simple-python-solution",
                "content": "```\\n    def jump(self, nums: List[int]) -> int:\\n        dp = []\\n        curr = 0\\n        prev = -1\\n        while curr < len(nums) - 1:\\n            max_reach = self.get_max_reach(nums[prev+1:curr+1])\\n            dp.append(max_reach)\\n            prev = curr\\n            curr += dp[-1]\\n            if curr == prev: return 0\\n        return len(dp)\\n    \\n    def get_max_reach(self, arr):\\n        out = 0\\n        for i,v in enumerate(arr):\\n            out = max(out, (i+1+v) - len(arr))\\n        return out\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n    def jump(self, nums: List[int]) -> int:\\n        dp = []\\n        curr = 0\\n        prev = -1\\n        while curr < len(nums) - 1:\\n            max_reach = self.get_max_reach(nums[prev+1:curr+1])\\n            dp.append(max_reach)\\n            prev = curr\\n            curr += dp[-1]\\n            if curr == prev: return 0\\n        return len(dp)\\n    \\n    def get_max_reach(self, arr):\\n        out = 0\\n        for i,v in enumerate(arr):\\n            out = max(out, (i+1+v) - len(arr))\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 459329,
                "title": "c-concise-solution-beats-97",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint jump(vector<int>& nums) {\\n\\t\\t\\tint far=0;\\n\\t\\t\\tint res=0;\\n\\t\\t\\tint MAX=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++){\\n\\t\\t\\t\\tMAX=max(MAX,i+nums[i]);\\n\\t\\t\\t\\tif(far<=i){\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\tfar=MAX;\\n\\t\\t\\t\\t\\tMAX=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint jump(vector<int>& nums) {\\n\\t\\t\\tint far=0;\\n\\t\\t\\tint res=0;\\n\\t\\t\\tint MAX=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++){\\n\\t\\t\\t\\tMAX=max(MAX,i+nums[i]);\\n\\t\\t\\t\\tif(far<=i){\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\tfar=MAX;\\n\\t\\t\\t\\t\\tMAX=0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 18107,
                "title": "the-most-intuitive-solution-yet-still-accepted-as-best-in-c-well-explained",
                "content": "Using greedy method is quite strai\\nght-forward here, we need to finish this jumping as soon as possible but the question is what should be the factor for us to be greedy for:  <font color=\"#ff0000\">**the farthest jump**</font> \\n\\nOnce we are in a position **i** the farthest position we can reach is **i+nums[i]** and within this range we should find the most potential index **j** which will give us the biggest **j+nums[j]** and then we move to the most potential position **j** and then on and on till we move to the last or over it.\\n\\n    int next = 0, maxDes = 0;\\n    for(int j = i+1; j <= i+nums[i]; ++j)\\n    {\\n        if(nums[j]+j > maxDes) \\n        next = j, maxDes = nums[j]+j;   \\n    }\\n\\nQuite direct and simple though some details should be cared about. \\n\\n\\n----------\\n\\n\\n    class Solution {\\n    public:\\n        //AC - 16ms - greedy method selecting the proper factor to be greedy for;\\n        int jump(vector<int>& nums) \\n        {\\n            int i = 0, jumps = 0, size = nums.size();\\n            if(size == 1) return 0;\\n            while(i < size)\\n            {\\n                if(i+nums[i] > size-2) return ++jumps; //the last jump to or over the last;\\n                int next = 0, maxDes = 0;\\n                for(int j = i+1; j <= i+nums[i]; ++j) //searching for the most potential position;\\n                {\\n                    if(nums[j]+j > maxDes) \\n                        next = j, maxDes = nums[j]+j;\\n                }\\n                i = next; //jump to the most potential position;\\n                jumps++; //count the jump;\\n            }\\n            return 0; //for compilation matter, actually this statement will never be invoked;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        //AC - 16ms - greedy method selecting the proper factor to be greedy for;\\n        int jump(vector<int>& nums) \\n        {\\n            int i = 0, jumps = 0, size = nums.size();\\n            if(size == 1) return 0;\\n            while(i < size)\\n            {\\n                if(i+nums[i] > size-2) return ++jumps; //the last jump to or over the last;\\n                int next = 0, maxDes = 0;\\n                for(int j = i+1; j <= i+nums[i]; ++j) //searching for the most potential position;\\n                {\\n                    if(nums[j]+j > maxDes) \\n                        next = j, maxDes = nums[j]+j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 18131,
                "title": "easy-understand-o-n-time-o-1-space-code",
                "content": "The main idea is using 2 integer to record the longest distance of current jump can arrive.\\nIf n jump cannot arrive at index i, it must jump one more time. Which means, the least jump time to get index i is (n+1).    \\n\\n\\n     int jump(vector<int>& nums) {\\n        if (n <= 1)\\n            return 0;\\n        int i, n = nums.size(), lc, ln, step = 1;\\n        // lc means the longest distance can achieve by current jump\\n        // ln means the longest distance can achieve by next jump\\n\\n        lc = nums[0], ln = nums[0]; //Initialize to index 0, the start point.\\n        for (i = 1; i < n; ++i)\\n        {\\n            if (i > lc) //current jump cannot get index i -->>> must jump one more time.\\n            {\\n                lc = ln;\\n                step++;\\n            }\\n            if (i + nums[i] > ln) //maintain the furthest distance of next jump can get\\n                ln = i + nums[i];\\n            if (lc >= n - 1) //current jump can achieve the last index\\n                return step;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The main idea is using 2 integer to record the longest distance of current jump can arrive.\\nIf n jump cannot arrive at index i, it must jump one more time. Which means, the least jump time to get index i is (n+1).    \\n\\n\\n     int jump(vector<int>& nums) {\\n        if (n <= 1)\\n            return 0;\\n        int i, n = nums.size(), lc, ln, step = 1;\\n        // lc means the longest distance can achieve by current jump\\n        // ln means the longest distance can achieve by next jump\\n\\n        lc = nums[0], ln = nums[0]; //Initialize to index 0, the start point.\\n        for (i = 1; i < n; ++i)\\n        {\\n            if (i > lc) //current jump cannot get index i -->>> must jump one more time.\\n            {\\n                lc = ln;\\n                step++;\\n            }\\n            if (i + nums[i] > ln) //maintain the furthest distance of next jump can get\\n                ln = i + nums[i];\\n            if (lc >= n - 1) //current jump can achieve the last index\\n                return step;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18156,
                "title": "python-o-n-solution",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def jump(self, nums):\\n            n, cur_max, next_max, steps = len(nums), 0, 0, 0\\n            for i in xrange(n):\\n                if i > cur_max:\\n                    steps += 1\\n                    cur_max = next_max\\n                    if cur_max >= n: break\\n                next_max = max(next_max, nums[i] + i)\\n            return steps",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3314558,
                "title": "start-and-end-approach-simple-to-understand",
                "content": "\\n\\n# 1.Start and End Approach\\n```\\nclass Solution:\\n    def jump(self,nums:List[int])->int:\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                count+=1\\n        return count\\n    #please upvote me it would encourage me alot\\n       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self,nums:List[int])->int:\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                count+=1\\n        return count\\n    #please upvote me it would encourage me alot\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158892,
                "title": "day-39-c-greedy-easiest-beginner-friendly-sol-o-n-time-and-o-1-space",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create two variables, jumps and maxReach, to keep track of the minimum number of jumps and the maximum reach from the current position.\\n2. Loop through the array.\\n3. For each index i, update maxReach to be the maximum between maxReach and i + nums[i].\\n4. If the current position i is equal to the current reach curReach, increment the number of jumps and update curReach to be the value of maxReach.\\n5. If curReach is greater than or equal to the last index of the array, return jumps.\\n6. If i is greater than or equal to maxReach, return 0 as it means it cannot reach the end.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int jumps = 0;\\n        int maxReach = 0; \\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                //I added below two statements to cover if it will not reach to end of the array then return 0...but Actualy this case is out of scope but it is helpful for followups problem. If you want you can remove for this this problem\\n                // ex - [1,2,1,0,0]\\n                if (i >= maxReach) \\n                    return 0; // Cannot reach the end\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\npublic \\n    int jump(int[] nums) {\\n        int n = nums.length;\\n        int jumps = 0;\\n        int maxReach = 0;\\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                if (i >= maxReach)\\n                    return 0;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        jumps = 0\\n        maxReach = 0\\n        curReach = 0\\n        for i in range(n - 1):\\n            maxReach = max(maxReach, i + nums[i])\\n            if i == curReach:\\n                jumps += 1\\n                curReach = maxReach\\n            if curReach >= n - 1:\\n                return jumps\\n            if i >= maxReach:\\n                return 0\\n        return jumps\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int jumps = 0;\\n        int maxReach = 0; \\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                //I added below two statements to cover if it will not reach to end of the array then return 0...but Actualy this case is out of scope but it is helpful for followups problem. If you want you can remove for this this problem\\n                // ex - [1,2,1,0,0]\\n                if (i >= maxReach) \\n                    return 0; // Cannot reach the end\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\npublic \\n    int jump(int[] nums) {\\n        int n = nums.length;\\n        int jumps = 0;\\n        int maxReach = 0;\\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                if (i >= maxReach)\\n                    return 0;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        jumps = 0\\n        maxReach = 0\\n        curReach = 0\\n        for i in range(n - 1):\\n            maxReach = max(maxReach, i + nums[i])\\n            if i == curReach:\\n                jumps += 1\\n                curReach = maxReach\\n            if curReach >= n - 1:\\n                return jumps\\n            if i >= maxReach:\\n                return 0\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115905,
                "title": "how-to-build-up-to-the-optimal-solution-backtracking-dp-greedy-detailed-explanation",
                "content": "# Approach\\nGenerally, for problems consisting of subproblems, we can use the following approach find the optimal algorithm:\\n1. Write the most intuitive recursive backtracking algorithm\\n2. Memoize repeated work using top-down dynamic programming\\n3. Eliminate recursion by using bottom-up dynamic programming\\n4. Apply final tricks\\n\\nIn the end, this problem can be solved with a simple but hard-to-find greedy algorithm.\\n\\nLet\\'s walk through each step.\\n\\n\\n# Recursive Backtracking\\nAlright, so how to approach this problem? The most intuitive way is to, at each index, check every index you can go to. Then, consider every index you can go to from there. At the end, the candidate with the least indices is our answer. We can make an optimization by discarding any candidates of length greater than what we\\'ve already found to be the best, but this algorithm is still exponential.\\n```\\n# Backtracking\\n# O(2^n) - Times out\\ndef jump0(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    def backtrack(candidate, end):\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\\n\\n# Top-Down Dynamic Programming\\nClearly there is a lot of repeated work in the above algorithm. It calculates `backtrack(candidate + i, i)` for identical values of `candidate` and `i` repeatedly. By memoizing every result, we can bring the time complexity down to polynomial time, as the maximum number of iterations will be `candidate` (<=n) times `i` (=n).\\n```\\n# Memoized backtracking (Top-down DP)\\n# O(n^2) - Times out\\ndef jump00(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    memo = {}\\n    def backtrack(candidate, end):\\n        if (candidate, end) in memo:\\n            return memo[candidate, end]\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n        memo[(candidate, end)] = self.best\\n        return memo[(candidate, end)]\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\\nNow we get to around test case 100 before timing out. Progress, but still not good enough.\\n\\n# Bottom-Up DP\\nThe input arrays are extremely large. If we want to pass, we need to eliminate recursion.\\n\\nLet\\'s make an observation about the top-down DP: we are memoizing values that do not need to be memoized. The key intuition here is that if we have a score for index_start and index_end, we need not recompute values in the middle. Why? Well, if we can get to a certain ending index, then we can necessarily get to every index before that too.\\n\\n```\\n# Bottom-Up DP\\n# O(nm) - Passes\\n#   * n = len(nums) = max # of jumps\\n#   * m = max(jumps) = max jump length\\n# At each jump, jump to the index that gives us the farthest possible next jump\\n# This works because even if the optimal next jump isn\\'t the farthest, it will be contained in range(farthest)\\n# Optimal jump will always be at an index less than or equal to the farthest possible jump\\n# dp[i+1] = max_i(nums[j]+j for j in range(dp[i]+1))\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    dp = [0]\\n    for i in range(len(nums)):\\n        dp.append(max((nums[j]+j for j in range(dp[i]+1))))\\n        if dp[i+1] >= len(nums)-1:\\n            break\\n\\n    return len(dp) - 1\\n```\\n\\n\\nOur algorithm finally passes! Why is it so much faster than the one above? After converting to bottom-up, we see that this approach is actually greedy! \\n\\nLet\\'s do even better.\\n\\n# Final Greedy Solution\\nFinally, we can get rid of trivial repeated work in order to optimize to linear time and constant space.\\n\\nWhy loop from 0 each time? Just loop from the last farthest index, which is the end of the last jump. And why store all values of dp? We only need two at a time.\\n```\\n# Now the algorithm is O(n) time and O(1) space\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    last = next = 0\\n    count = 1\\n    for i in range(len(nums)):\\n        temp = next\\n        next = max((nums[j]+j for j in range(last, next+1)))\\n        if next >= len(nums)-1:\\n            break\\n        count += 1\\n        last = temp\\n\\n    return count\\n```\\n\\n# Complexity\\n- Time complexity: O(n). We effectively loop over the list twice. Once with the outer loop, and only once with the inner loop because it considers each value in nums only once due to it moving.\\n\\n- Space complexity: O(1). We only keep track of 4 integers.\\n# Performance\\n![x](https://assets.leetcode.com/users/images/8a2c6528-eb64-42e8-af3d-22c166ede68b_1675047170.0640862.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n# Backtracking\\n# O(2^n) - Times out\\ndef jump0(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    def backtrack(candidate, end):\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\n```\\n# Memoized backtracking (Top-down DP)\\n# O(n^2) - Times out\\ndef jump00(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    memo = {}\\n    def backtrack(candidate, end):\\n        if (candidate, end) in memo:\\n            return memo[candidate, end]\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n        memo[(candidate, end)] = self.best\\n        return memo[(candidate, end)]\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\n```\\n# Bottom-Up DP\\n# O(nm) - Passes\\n#   * n = len(nums) = max # of jumps\\n#   * m = max(jumps) = max jump length\\n# At each jump, jump to the index that gives us the farthest possible next jump\\n# This works because even if the optimal next jump isn\\'t the farthest, it will be contained in range(farthest)\\n# Optimal jump will always be at an index less than or equal to the farthest possible jump\\n# dp[i+1] = max_i(nums[j]+j for j in range(dp[i]+1))\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    dp = [0]\\n    for i in range(len(nums)):\\n        dp.append(max((nums[j]+j for j in range(dp[i]+1))))\\n        if dp[i+1] >= len(nums)-1:\\n            break\\n\\n    return len(dp) - 1\\n```\n```\\n# Now the algorithm is O(n) time and O(1) space\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    last = next = 0\\n    count = 1\\n    for i in range(len(nums)):\\n        temp = next\\n        next = max((nums[j]+j for j in range(last, next+1)))\\n        if next >= len(nums)-1:\\n            break\\n        count += 1\\n        last = temp\\n\\n    return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2671506,
                "title": "6-liner-c-very-easy-o-n-faster-than-93-solutions",
                "content": "```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<2) return 0;\\n        int jump=1, maxi=nums[0], curr=nums[0];\\n        for(int i=0;i<n-1;i++)\\n        {\\n            maxi=max(maxi, nums[i]+i);\\n            if(curr==i)\\n            {\\n                jump++;\\n                curr=maxi;\\n            }\\n        }\\n        return jump;\\n    }\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKE IT!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<2) return 0;\\n        int jump=1, maxi=nums[0], curr=nums[0];\\n        for(int i=0;i<n-1;i++)\\n        {\\n            maxi=max(maxi, nums[i]+i);\\n            if(curr==i)\\n            {\\n                jump++;\\n                curr=maxi;\\n            }\\n        }\\n        return jump;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2600578,
                "title": "java-easiest-code-time-complexity-o-n",
                "content": "Hi Coders,\\n\\nPlease have a look into the code with Proper comment, it will helps you to understand the code\\n\\n```\\n\\t\\tpublic int jump(int[] nums) {\\n       \\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        \\n        // max steps that we can make in one window\\n        int max_steps = 0;\\n        int cur = 0;\\n        \\n        // jumps that we need to calculate\\n        int jumps = 0;\\n        \\n        // till n-1 because we have to reach at the end point which is n-1\\n        \\n        \\n        for (int i=0;i<n-1;i++){\\n            // calculating the max at every point\\n            max_steps = Math.max(max_steps,i + nums[i]);\\n            // whenever you reached the point where you dont have steps\\n            // you need to update the step with the max_steps till this index\\n            if (cur == i){\\n                cur = max_steps;\\n                jumps++;\\n            }\\n            \\n            // if you already reached to end then no need to iterate further\\n            if (cur>n-1) return jumps;\\n            \\n        }\\n        return jumps;\\n        \\n        \\n    }\\n```\\n\\nPlease Please Please Upvote the code if you liked\\nThanks!!!\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\t\\tpublic int jump(int[] nums) {\\n       \\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        \\n        // max steps that we can make in one window\\n        int max_steps = 0;\\n        int cur = 0;\\n        \\n        // jumps that we need to calculate\\n        int jumps = 0;\\n        \\n        // till n-1 because we have to reach at the end point which is n-1\\n        \\n        \\n        for (int i=0;i<n-1;i++){\\n            // calculating the max at every point\\n            max_steps = Math.max(max_steps,i + nums[i]);\\n            // whenever you reached the point where you dont have steps\\n            // you need to update the step with the max_steps till this index\\n            if (cur == i){\\n                cur = max_steps;\\n                jumps++;\\n            }\\n            \\n            // if you already reached to end then no need to iterate further\\n            if (cur>n-1) return jumps;\\n            \\n        }\\n        return jumps;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045834,
                "title": "5-simple-c-solutions-brute-force-recursion-memoization-dp-bfs-greedy",
                "content": "### Approach 1 : Recursion (Brute Force)\\n```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums));\\n        }\\n        return minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\\n\\nTime Complexity - O(k^n) Where k is the max value in nums\\nSpace Complexity - O(n) Recursive Stack Space\\n\\n### Approach 2 - Recursion + Memoization\\n```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums, dp));\\n        }\\n        \\n        return dp[inx] = minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\\n\\nTime Complexity - O(k*n) Where k is the max value in nums\\nSpace Complexity - O(n + n) Recursive Stack Space + memoization table\\n\\n### Approach 3 - Tabulation\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            int minJumps = 10e5;\\n            for(int i=1; i<=nums[inx]; i++){\\n                if(i + inx < nums.size()) minJumps = min(minJumps, 1 + dp[i + inx]);\\n            }\\n            dp[inx] = minJumps;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n\\nTime Complexity - O(k*n) Where k is the max value in nums\\nSpace Complexity - O(n) Dp table\\n\\n### Approach 4 - BFS\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        queue<int> q;\\n        q.push(0);\\n        unordered_set<int> vis = {0};\\n        int minMoves = 0;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                int inx = q.front(); q.pop();\\n                if(inx >= nums.size()-1) return minMoves;\\n                for(int i=1; i<=nums[inx]; i++){\\n                    int newInx = i + inx;\\n                    if(vis.count(newInx)) continue;\\n                    vis.insert(newInx);\\n                    q.push(newInx);\\n                }\\n            }\\n            minMoves++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\nTime Complexity - O(k*n) Where k is the max value in nums\\nSpace Complexity - O(k) BFS queue\\n\\n###  Approach 5 - Greedy\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        pair<int,int> jumpRange = {0,0};\\n        int ans = 0;\\n        while(jumpRange.second < nums.size()-1){\\n            int maxJump = 0;\\n            for(int i=jumpRange.first; i<=jumpRange.second; i++){\\n                maxJump = max(maxJump, i + nums[i]);\\n            }\\n            jumpRange = {jumpRange.second+1, maxJump};\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity - O(n)\\nSpace Complexity - O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums));\\n        }\\n        return minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums, dp));\\n        }\\n        \\n        return dp[inx] = minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            int minJumps = 10e5;\\n            for(int i=1; i<=nums[inx]; i++){\\n                if(i + inx < nums.size()) minJumps = min(minJumps, 1 + dp[i + inx]);\\n            }\\n            dp[inx] = minJumps;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        queue<int> q;\\n        q.push(0);\\n        unordered_set<int> vis = {0};\\n        int minMoves = 0;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                int inx = q.front(); q.pop();\\n                if(inx >= nums.size()-1) return minMoves;\\n                for(int i=1; i<=nums[inx]; i++){\\n                    int newInx = i + inx;\\n                    if(vis.count(newInx)) continue;\\n                    vis.insert(newInx);\\n                    q.push(newInx);\\n                }\\n            }\\n            minMoves++;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        pair<int,int> jumpRange = {0,0};\\n        int ans = 0;\\n        while(jumpRange.second < nums.size()-1){\\n            int maxJump = 0;\\n            for(int i=jumpRange.first; i<=jumpRange.second; i++){\\n                maxJump = max(maxJump, i + nums[i]);\\n            }\\n            jumpRange = {jumpRange.second+1, maxJump};\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806520,
                "title": "java-with-comments-100-faster-o-n-time",
                "content": "* O(n) time\\n* O(1) space\\n* easy explanation\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        \\n        //start from 0\\n        //maximum jump we can do is nums[0] or in other words i+nums[i] (i==0)\\n        //steps taken is 1\\n        //don\\'t worry for length 1 (we are at the end so no need to jump, steps 0)\\n        int n=nums.length, max_long_jump=nums[0], longest_jump=nums[0], steps=1;\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            //maximum longest jump we can make is this (same as case i==0)\\n            max_long_jump=Math.max(max_long_jump,i+nums[i]);\\n            \\n            //if our longest jump is done\\n            if(i==longest_jump){\\n                \\n                //means we need to make one more jump\\n                steps++;\\n                //now our longest jump is \"maximum longest jump\" (which we are updating everytime)\\n                longest_jump=max_long_jump;\\n            \\n            }\\n            \\n            // (in addition : if you understood so far, i assume you already get this - if longest_jump == the last element i.e. n-1, so we are done and break also)\\n        \\n        }\\n        \\n        return n==1?0:steps;\\n    }\\n}\\n```\\n**Don\\'t forgot to upvote, it will help others**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        \\n        //start from 0\\n        //maximum jump we can do is nums[0] or in other words i+nums[i] (i==0)\\n        //steps taken is 1\\n        //don\\'t worry for length 1 (we are at the end so no need to jump, steps 0)\\n        int n=nums.length, max_long_jump=nums[0], longest_jump=nums[0], steps=1;\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            //maximum longest jump we can make is this (same as case i==0)\\n            max_long_jump=Math.max(max_long_jump,i+nums[i]);\\n            \\n            //if our longest jump is done\\n            if(i==longest_jump){\\n                \\n                //means we need to make one more jump\\n                steps++;\\n                //now our longest jump is \"maximum longest jump\" (which we are updating everytime)\\n                longest_jump=max_long_jump;\\n            \\n            }\\n            \\n            // (in addition : if you understood so far, i assume you already get this - if longest_jump == the last element i.e. n-1, so we are done and break also)\\n        \\n        }\\n        \\n        return n==1?0:steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642940,
                "title": "o-n-d-p-solution-c",
                "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }      \\n        }\\n        return jumps;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1121800,
                "title": "faster-than-any-submitted-python-code-beats-100-time-and-space-complexity",
                "content": "O(N^2) time and O(N) Space DP Solution\\n```\\nclass Solution:\\n    def jump(self, array: List[int]) -> int:\\n        minJumps = [float(\"inf\") for _ in array]\\n        minJumps[0] = 0\\n        for index in range(1, len(array)):\\n            for idx in range(index):\\n                if array[idx] >= index - idx:\\n                    minJumps[index] = min(minJumps[index], minJumps[idx] +1)\\n        return minJumps[-1]\\n\\t\\t\\n```\\nEdit: Above Method Leads To TLE Now. Used Below Optimised Method.\\n\\nO(N) Time and O(1) space solution\\n```\\nclass Solution:\\n    def jump(self, array):\\n        if len(array) == 1:\\n            return 0\\n        jumps, maxReach, steps = 0, array[0], array[0]\\n        for idx in range(1, len(array)-1):\\n            maxReach = max(maxReach, idx+array[idx])\\n            steps -= 1\\n            if steps == 0:\\n                jumps += 1\\n                steps = maxReach-idx\\n        return jumps+1\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, array: List[int]) -> int:\\n        minJumps = [float(\"inf\") for _ in array]\\n        minJumps[0] = 0\\n        for index in range(1, len(array)):\\n            for idx in range(index):\\n                if array[idx] >= index - idx:\\n                    minJumps[index] = min(minJumps[index], minJumps[idx] +1)\\n        return minJumps[-1]\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def jump(self, array):\\n        if len(array) == 1:\\n            return 0\\n        jumps, maxReach, steps = 0, array[0], array[0]\\n        for idx in range(1, len(array)-1):\\n            maxReach = max(maxReach, idx+array[idx])\\n            steps -= 1\\n            if steps == 0:\\n                jumps += 1\\n                steps = maxReach-idx\\n        return jumps+1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 949270,
                "title": "python3-o-n-solution-with-detailed-explanations",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        if len(nums) < 2: return 0                      # corner case\\n        \\n        jump = 1                                        # if not corner case, at least 1 jump is needed\\n        curr_max = max_reach = nums[0]                  # max_reach to record the max index can be reached with current # of jump\\n                                                        # curr_max to record the max index can be reached from the current index\\n        \\n        \\n        for i in range(1, len(nums)):                   # we start from index 1 if not corner case, but including 0 still works\\n            if max_reach >= len(nums) - 1:              # termination check\\n                return jump\\n            if i < max_reach:                           # if i is within the reach of current jump\\n                if i + nums[i] > curr_max:              # we update the current max reach if a larger one exists\\n                    curr_max = i + nums[i]              \\n                    if curr_max >= len(nums) - 1:       # early terminatin check, but solution still works even without this\\n                        return jump + 1                 # remember to add 1 to current jump if you use early termination\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    # here we dont jump yet until we figure out the max range we can reach \\n                                                        # if we jump one more time\\n                        \\n            else:                                       # when we enter this else statement, it means max_reach is not the end of list\\n                                                        # thus we have to jump now\\n                max_reach = max(curr_max, i + nums[i])  # we update our max_reach using the curr_max recorded so far or i + nums[i]\\n                jump += 1                               # and we add 1 to jump to add this jump\\n        \\n        return jump\\n    \\n    # TC: O(n)\\n    # n is the len(nums), as we only scan the list once\\n    \\n    # SC: O(1)\\n    # we only init 3 variables, thus space is constant\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        if len(nums) < 2: return 0                      # corner case\\n        \\n        jump = 1                                        # if not corner case, at least 1 jump is needed\\n        curr_max = max_reach = nums[0]                  # max_reach to record the max index can be reached with current # of jump\\n                                                        # curr_max to record the max index can be reached from the current index\\n        \\n        \\n        for i in range(1, len(nums)):                   # we start from index 1 if not corner case, but including 0 still works\\n            if max_reach >= len(nums) - 1:              # termination check\\n                return jump\\n            if i < max_reach:                           # if i is within the reach of current jump\\n                if i + nums[i] > curr_max:              # we update the current max reach if a larger one exists\\n                    curr_max = i + nums[i]              \\n                    if curr_max >= len(nums) - 1:       # early terminatin check, but solution still works even without this\\n                        return jump + 1                 # remember to add 1 to current jump if you use early termination\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    # here we dont jump yet until we figure out the max range we can reach \\n                                                        # if we jump one more time\\n                        \\n            else:                                       # when we enter this else statement, it means max_reach is not the end of list\\n                                                        # thus we have to jump now\\n                max_reach = max(curr_max, i + nums[i])  # we update our max_reach using the curr_max recorded so far or i + nums[i]\\n                jump += 1                               # and we add 1 to jump to add this jump\\n        \\n        return jump\\n    \\n    # TC: O(n)\\n    # n is the len(nums), as we only scan the list once\\n    \\n    # SC: O(1)\\n    # we only init 3 variables, thus space is constant\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645404,
                "title": "all-approach-from-brute-force-memoization-bottom-up-and-finally-greedy",
                "content": "***Brute Force***\\n```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps));\\n        maxSteps--;\\n    }\\n    \\n    return answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        return (int)decideJump(nums,n,0);   \\n    }\\n};\\n```\\n***Memorization***\\n```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos,vector<int>& dp){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    if(dp[currPos] != -1){\\n        return dp[currPos];\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps,dp));\\n        maxSteps--;\\n    }\\n    \\n    return dp[currPos] = answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+10,-1);\\n        return (int)decideJump(nums,n,0,dp);   \\n    }\\n};\\n```\\n***Bottom-Up***\\n```\\n//bottom up approach to this problem\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> dp(n,INT_MAX);\\n        \\n        dp[n-1] = 0;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=1;j<=nums[i];j++){\\n                if(i+j < n){\\n                    dp[i] = min(dp[i],1+dp[i+j]);\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[0];\\n    }\\n};\\n```\\n***Greedy***\\n```\\n//now our only hope left is greedy solution that will run in O(n) time complexity and\\n//O(1) space complexity\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n == 0){\\n            return 1;\\n        }\\n        \\n        int maxReach = nums[0];\\n        int jump = 1;\\n        int step = nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(i == n-1){\\n                return jump;\\n            }\\n            step--;\\n            maxReach = max(maxReach,i+nums[i]);\\n            \\n            if(step == 0){\\n                if(i >= maxReach){\\n                    return -1;\\n                }\\n                jump++;\\n                step = maxReach - i;\\n            }\\n            \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Memoization"
                ],
                "code": "```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps));\\n        maxSteps--;\\n    }\\n    \\n    return answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        return (int)decideJump(nums,n,0);   \\n    }\\n};\\n```\n```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos,vector<int>& dp){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    if(dp[currPos] != -1){\\n        return dp[currPos];\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps,dp));\\n        maxSteps--;\\n    }\\n    \\n    return dp[currPos] = answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+10,-1);\\n        return (int)decideJump(nums,n,0,dp);   \\n    }\\n};\\n```\n```\\n//bottom up approach to this problem\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> dp(n,INT_MAX);\\n        \\n        dp[n-1] = 0;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=1;j<=nums[i];j++){\\n                if(i+j < n){\\n                    dp[i] = min(dp[i],1+dp[i+j]);\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[0];\\n    }\\n};\\n```\n```\\n//now our only hope left is greedy solution that will run in O(n) time complexity and\\n//O(1) space complexity\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n == 0){\\n            return 1;\\n        }\\n        \\n        int maxReach = nums[0];\\n        int jump = 1;\\n        int step = nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(i == n-1){\\n                return jump;\\n            }\\n            step--;\\n            maxReach = max(maxReach,i+nums[i]);\\n            \\n            if(step == 0){\\n                if(i >= maxReach){\\n                    return -1;\\n                }\\n                jump++;\\n                step = maxReach - i;\\n            }\\n            \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502009,
                "title": "javascript-o-n-time-and-o-1-space-extended-notes",
                "content": "To tackle this we...\\n\\n* Set the number of steps we are allowed to take from the first value in the array\\n* Iterate through the array once\\n* At each index we set a maxReach variable ( the further place in the array we can reach)\\n* At the same time, for each index we reduce the number of steps by one\\n* If we run out of steps it means we must have taken a jump to get to our current location\\n* So... we need to update the number of steps... to do this we look at how far we are from our maxReach and subtract our current index\\n* When we reach the final index we return the number of jumps it\\'s taken us to arrive there PLUS ONE . This is because we have not consumed all our final steps. \\n\\nThe iteration pattern plays out like this...\\n\\n**INITIAL SETUP**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//   ^ \\n//   |  \\n// \\n// Max Reach: 3\\n//     Steps: 3\\n//     Jumps: 0\\n```\\n\\n**1ST ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//      ^ \\n//      |  \\n// \\n// Max Reach: 5\\n//     Steps: 2\\n//     Jumps: 0\\n```\\n\\n**2ND ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//         ^ \\n//         |  \\n// \\n// Max Reach: 5\\n//     Steps: 1\\n//     Jumps: 0\\n```\\n\\n**3RD ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//            ^ \\n//            |  \\n// \\n// Max Reach: 5\\n//     Steps: 0 --> Resets to 2 (maxReach of 5 minus current index of 3)\\n//     Jumps: 1\\n```\\n\\n**4TH ITERATION**\\n```\\n//               ^ \\n//               |  \\n// \\n// Max Reach: 6\\n//     Steps: 1\\n//     Jumps: 1\\n```\\n\\n**5TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                  ^ \\n//                  |  \\n// \\n// Max Reach: 8\\n//     Steps: 0 --> Resets to 3 (maxReach of 8 minus current index of 5)\\n//     Jumps: 2\\n```\\n\\n**6TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                     ^ \\n//                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 2\\n```\\n\\n**7TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                        ^ \\n//                        |  \\n// \\n// Max Reach: 13\\n//     Steps: 1\\n//     Jumps: 2\\n```\\n\\n**8TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                           ^ \\n//                           |  \\n// \\n// Max Reach: 13\\n//     Steps: 0 --> Resets to 5 (maxReach 13 minus current index of 8)\\n//     Jumps: 3\\n```\\n\\n**9THITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                              ^ \\n//                              |  \\n// \\n// Max Reach: 13\\n//     Steps: 4 \\n//     Jumps: 3\\n```\\n\\n**10TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                 ^ \\n//                                 |  \\n// \\n// Max Reach: 13\\n//     Steps: 3 \\n//     Jumps: 3\\n```\\n\\n**POST ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                     ^ \\n//                                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 3\\n// At this point we have unconsumed steps meaning we need to add ONE to our jump total to represent the consumption of the remaining steps (imagine jumping from value 7 to the end)\\n```\\n\\n\\n\\n\\n**SOLUTION**\\n```\\nvar jump = function(nums) {\\n\\tif(nums.length === 1) return 0;\\n\\tlet jumps = 0;\\n\\tlet maxReach = nums[0];\\n\\tlet steps = nums[0];\\n\\tfor(let i = 1; i < nums.length - 1; i++){\\n\\t\\tmaxReach = Math.max(maxReach, i + nums[i])\\n\\t\\tsteps--;\\n\\t\\tif(steps === 0){\\n\\t\\t\\tjumps++;\\n\\t\\t\\tsteps = maxReach - i;\\n\\t\\t}\\n\\t}\\n\\treturn jumps + 1;  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//   ^ \\n//   |  \\n// \\n// Max Reach: 3\\n//     Steps: 3\\n//     Jumps: 0\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//      ^ \\n//      |  \\n// \\n// Max Reach: 5\\n//     Steps: 2\\n//     Jumps: 0\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//         ^ \\n//         |  \\n// \\n// Max Reach: 5\\n//     Steps: 1\\n//     Jumps: 0\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//            ^ \\n//            |  \\n// \\n// Max Reach: 5\\n//     Steps: 0 --> Resets to 2 (maxReach of 5 minus current index of 3)\\n//     Jumps: 1\\n```\n```\\n//               ^ \\n//               |  \\n// \\n// Max Reach: 6\\n//     Steps: 1\\n//     Jumps: 1\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                  ^ \\n//                  |  \\n// \\n// Max Reach: 8\\n//     Steps: 0 --> Resets to 3 (maxReach of 8 minus current index of 5)\\n//     Jumps: 2\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                     ^ \\n//                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 2\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                        ^ \\n//                        |  \\n// \\n// Max Reach: 13\\n//     Steps: 1\\n//     Jumps: 2\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                           ^ \\n//                           |  \\n// \\n// Max Reach: 13\\n//     Steps: 0 --> Resets to 5 (maxReach 13 minus current index of 8)\\n//     Jumps: 3\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                              ^ \\n//                              |  \\n// \\n// Max Reach: 13\\n//     Steps: 4 \\n//     Jumps: 3\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                 ^ \\n//                                 |  \\n// \\n// Max Reach: 13\\n//     Steps: 3 \\n//     Jumps: 3\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                     ^ \\n//                                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 3\\n// At this point we have unconsumed steps meaning we need to add ONE to our jump total to represent the consumption of the remaining steps (imagine jumping from value 7 to the end)\\n```\n```\\nvar jump = function(nums) {\\n\\tif(nums.length === 1) return 0;\\n\\tlet jumps = 0;\\n\\tlet maxReach = nums[0];\\n\\tlet steps = nums[0];\\n\\tfor(let i = 1; i < nums.length - 1; i++){\\n\\t\\tmaxReach = Math.max(maxReach, i + nums[i])\\n\\t\\tsteps--;\\n\\t\\tif(steps === 0){\\n\\t\\t\\tjumps++;\\n\\t\\t\\tsteps = maxReach - i;\\n\\t\\t}\\n\\t}\\n\\treturn jumps + 1;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 380429,
                "title": "java-dynamic-programming-bottom-up-solution",
                "content": "cache[i] represents the minimum number of steps taken to reach the ith index\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int[] cache = new int[nums.length];\\n        \\n        cache[0] = 0;\\n        \\n        for (int i = 1; i < cache.length; i++) {\\n            cache[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 1; j <= nums[i]; j++) {\\n                int next = Math.min(i+j, nums.length-1);\\n        \\n                cache[next] = Math.min(cache[next], 1 + cache[i]);\\n            }\\n        }\\n        \\n        return cache[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int[] cache = new int[nums.length];\\n        \\n        cache[0] = 0;\\n        \\n        for (int i = 1; i < cache.length; i++) {\\n            cache[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 1; j <= nums[i]; j++) {\\n                int next = Math.min(i+j, nums.length-1);\\n        \\n                cache[next] = Math.min(cache[next], 1 + cache[i]);\\n            }\\n        }\\n        \\n        return cache[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340334,
                "title": "simple-dp-very-simple-pruning-and-it-works-12ms",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, n+1);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i] < nums[i-1])\\n                continue;\\n            for (int j = 1; j <= nums[i] && (i+j) < n; j++)\\n                dp[i+j] = min(dp[i+j], dp[i]+1);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, n+1);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i] < nums[i-1])\\n                continue;\\n            for (int j = 1; j <= nums[i] && (i+j) < n; j++)\\n                dp[i+j] = min(dp[i+j], dp[i]+1);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304289,
                "title": "c-greedy-boy-solution-use-magic-lasers-and-pew-pew-kitty-cats",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int aJumps = 0;\\n        int aEnd = 0;\\n        int aFarthest = 0;\\n        \\n        for (int i=0;i<(nums.size()-1);i++) {\\n            aFarthest = max(aFarthest, i + nums[i]);\\n            if (i == aEnd) {\\n                aJumps++;\\n                aEnd = aFarthest;\\n            }   \\n        }\\n        return aJumps;\\n        \\n    }\\n};\\n```\\n\\nO(N)\\n\\nWhy it works? Magic!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int aJumps = 0;\\n        int aEnd = 0;\\n        int aFarthest = 0;\\n        \\n        for (int i=0;i<(nums.size()-1);i++) {\\n            aFarthest = max(aFarthest, i + nums[i]);\\n            if (i == aEnd) {\\n                aJumps++;\\n                aEnd = aFarthest;\\n            }   \\n        }\\n        return aJumps;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18205,
                "title": "is-there-better-solution-for-jump-game-ii",
                "content": "my solution exceeds time limit.\\nI use an array to track the min step at i . It seems my solution is not efficient enough. You guys have better solution?\\n\\n    class Solution {\\n    public:\\n        int jump(int A[], int n) {\\n            vector<int> track(n, 0);\\n            \\n            for(int i=1; i<n; i++){\\n                int min = INT_MAX;\\n                for(int j=0; j<i; j++){\\n                    if(track[j] < min && A[j]+j >= i)\\n                        min = track[j];\\n                }\\n                track[i] = min+1;\\n            }\\n            return track[n-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int jump(int A[], int n) {\\n            vector<int> track(n, 0);\\n            \\n            for(int i=1; i<n; i++){\\n                int min = INT_MAX;\\n                for(int j=0; j<i; j++){\\n                    if(track[j] < min && A[j]+j >= i)\\n                        min = track[j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3372877,
                "title": "easy-clear-solution-python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[-1 for _ in range(n-1)]\\n        dp+=[0]\\n        for i in range(n-2,-1,-1):\\n            for j in range(i+1,min(n,i+nums[i]+1)):\\n                if dp[j]!=-1:\\n                    if dp[i]==-1:\\n                        dp[i]=dp[j]+1\\n                    else:\\n                        dp[i]=min(dp[i],dp[j]+1)\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[-1 for _ in range(n-1)]\\n        dp+=[0]\\n        for i in range(n-2,-1,-1):\\n            for j in range(i+1,min(n,i+nums[i]+1)):\\n                if dp[j]!=-1:\\n                    if dp[i]==-1:\\n                        dp[i]=dp[j]+1\\n                    else:\\n                        dp[i]=min(dp[i],dp[j]+1)\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159174,
                "title": "sundar-susheel-ubla-hua-ekdum-simple-sada-garam-garam-code",
                "content": "# Intuition\\nThe problem is similar to jump game with atmost k jumps. Here instead of knowing the k before hand , we will get the k dynamically by nums[ind]\\n\\n# Approach\\nFirst we will write the recursive logic and later memoise it.\\nFrom the 0th index we need to reach n-1 index in minimal possible steps.\\n- The base condition is that if we reach the end then return 0\\n- We will take a variable mini which will store the minimal jumps required to reach a particular index. We will initialise it with a large value.\\n- nums[ind] will define us how many steps atmost we can jump forward.\\nSo we will have a loop from ind till ind+ k , (k=nums[ind]) and we will jump till there and update the mini.\\n(We need to take care that we do not jump out of the nums vector. ind+i <=n)\\n```\\n//Attaching recursive code\\nint dfs(int ind,int n,vector<int>&nums)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return mini;\\n    }\\n\\n``` \\nWe will memoise it for optimisation.\\n**In main function we will pass dfs(0,n-1,nums)**\\n0 is the start index \\nn-1 is the the last index of the nums (Mentioned in ques we need to jump till n-1th index)\\n\\n# Complexity\\n- **Time complexity**:\\nTC would be O(n*k) where n is size of vector and k is the number of jumps we can take at each index.\\n\\n- **Space complexity**:\\nWe are doing recursion , so SC O(n) for recursion stack and a dp vector of O(n) space. Overall SC O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind,int n,vector<int>&nums,vector<int>&dp)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums,dp);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return dp[ind]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return dfs(0,n-1,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//Attaching recursive code\\nint dfs(int ind,int n,vector<int>&nums)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return mini;\\n    }\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind,int n,vector<int>&nums,vector<int>&dp)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums,dp);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return dp[ind]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return dfs(0,n-1,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158649,
                "title": "c-greedy-approach-constant-space-comments-added-easy",
                "content": "# Complexity\\n- Time complexity:\\n**O(N)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        int jump=0;\\n        \\n        int maximum_reach=0;\\n        int max_pos=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==n-1) return jump;\\n            maximum_reach = max(maximum_reach,i+nums[i]);      // for each particular idx storing the max jump\\n\\n            // If i has reached to it\\'s max position then we need to jump to go on next\\n            if(i==max_pos)\\n            {\\n                jump++;                          // increase jump\\n                max_pos = maximum_reach;         // assign max_reach as a max_pos for this jump\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        int jump=0;\\n        \\n        int maximum_reach=0;\\n        int max_pos=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==n-1) return jump;\\n            maximum_reach = max(maximum_reach,i+nums[i]);      // for each particular idx storing the max jump\\n\\n            // If i has reached to it\\'s max position then we need to jump to go on next\\n            if(i==max_pos)\\n            {\\n                jump++;                          // increase jump\\n                max_pos = maximum_reach;         // assign max_reach as a max_pos for this jump\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874337,
                "title": "easy-java-solution-using-sliding-window-beats-99-89",
                "content": "The solution illustrates **BFS** using **sliding window**.\\n\\n![3549-pepepopcorn.png](https://assets.leetcode.com/users/images/96d98a88-b29c-4c80-b21f-860c9f50897d_1675846588.2118175.png)\\n\\nSubmission Link: https://leetcode.com/submissions/detail/854067528/\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res = 0;\\n        int l, r, farthest;\\n        l = r = farthest = 0;\\n        while(r < nums.length - 1){\\n            farthest = 0;\\n\\t\\t\\t// r+1 because we also need to include position r\\n            for(int i=l; i<r+1; i++){\\n                farthest = Math.max(farthest, i + nums[i]);\\n            }\\n            l = r+1;\\n            r = farthest;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c3a43b2e-2e21-4ddd-bb40-4e52fb2a0e1c_1670099721.8790011.png)\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/6e4aad28-ca17-420f-a665-eface165310a_1675846567.4085553.png)\\n",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res = 0;\\n        int l, r, farthest;\\n        l = r = farthest = 0;\\n        while(r < nums.length - 1){\\n            farthest = 0;\\n\\t\\t\\t// r+1 because we also need to include position r\\n            for(int i=l; i<r+1; i++){\\n                farthest = Math.max(farthest, i + nums[i]);\\n            }\\n            l = r+1;\\n            r = farthest;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356813,
                "title": "c-beats-99-cpp-solutions-easy-understanding-ladder-approach-linear-0-n-no-space",
                "content": "The approach which we are going to use is that we will try to move along a ladder and check that what maximum distance we can travel using ladder and while travelling the current ladder what is the maximum value ladder we get\\n\\nSteps-\\n1. steps = 0, ladder = 0\\n2. iterate the loop\\n\\t1. if ladder < i, it means ladder can not reach position i so we return -1(unreachable)\\n\\t2. if ladder >= n-1, ladder has reached the end of the array so we return steps\\n\\t3. we will iterate through i to ladder and update the ladder length and while updating we will keep track that whether we update the ladder length while traversing the ladder \\n\\t4. if yes(we are increasing the length of ladder, it means we are making a step), so we increase the step count\\n\\t\\n  3.return steps\\n\\n```\\nint jump(vector<int> &arr){\\n        int n = arr.size();\\n        int ladder = 0;\\n        int steps = 0;\\n        for(int i = 0 ; i < n ; ){\\n            if(ladder >= n-1){\\n                return steps;\\n            }\\n            if(ladder < i){\\n                return -1;\\n            }\\n           \\n            bool increaseSteps = false;\\n            int k = ladder;\\n            for( ; i <= k && i < n ; i++){\\n                if(i + arr[i] > ladder && ladder < n-1){\\n                    ladder = i + arr[i];\\n                    increaseSteps = true;\\n                }   \\n            }\\n            if(increaseSteps == true){\\n                steps += 1;\\n            }\\n            \\n        }\\n        return steps;\\n    }\\n```\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nint jump(vector<int> &arr){\\n        int n = arr.size();\\n        int ladder = 0;\\n        int steps = 0;\\n        for(int i = 0 ; i < n ; ){\\n            if(ladder >= n-1){\\n                return steps;\\n            }\\n            if(ladder < i){\\n                return -1;\\n            }\\n           \\n            bool increaseSteps = false;\\n            int k = ladder;\\n            for( ; i <= k && i < n ; i++){\\n                if(i + arr[i] > ladder && ladder < n-1){\\n                    ladder = i + arr[i];\\n                    increaseSteps = true;\\n                }   \\n            }\\n            if(increaseSteps == true){\\n                steps += 1;\\n            }\\n            \\n        }\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2257911,
                "title": "dekho-bhai-ye-koi-medium-problem-nhi-hain-ye-tum-nirbhar-karta-hain-ki-kaise-sochte-ho",
                "content": "**Dekho bhai, es problem me humlog dp bhie laga sakte hain or greedy bhie, greedy ka approach bhie dekh lo ek baar in O(N) time complexity & O(1) space complexity\\nAgar phir bhi koi probelm hain to humlog Dp bhie use kar skate hain yaha par**\\nInput ke anusar humlog guess kar skate hain Achhe se.....\\nYe arha greedy ka code\\n\\n```\\n class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0; // Reach at that position after jumping from previous index\\n        int max_jump=0;  // It is in form of index only to jump at max num[max_jump]\\n        int mini_step=0;  // To count the number of step to reach at end of the index\\n        \\n            \\n            // Corner case\\n        if(n==1)\\n            return 0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            max_jump=max(max_jump,i+nums[i]);\\n            \\n            if(reach==i){ \\n                mini_step++;\\n                reach=max_jump;\\n            } \\n         }\\n         return mini_step;\\n    }\\n};\\n```\\n**Sikhte raho bhailog hamesa\\nor agar aapko ye appraoch achha laga hoga to like jaroor kare dhaynewaad bhailog!!**",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0; // Reach at that position after jumping from previous index\\n        int max_jump=0;  // It is in form of index only to jump at max num[max_jump]\\n        int mini_step=0;  // To count the number of step to reach at end of the index\\n        \\n            \\n            // Corner case\\n        if(n==1)\\n            return 0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            max_jump=max(max_jump,i+nums[i]);\\n            \\n            if(reach==i){ \\n                mini_step++;\\n                reach=max_jump;\\n            } \\n         }\\n         return mini_step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189064,
                "title": "java-greedy-in-depth-explanation",
                "content": "If you haven\\'t completed **LC.55 Jump Game**, I\\'d recommend you to do Jump Game first. You can find [my solution](https://leetcode.com/problems/jump-game/discuss/2188884/Java-or-In-depth-Explanation-or-O(n)-time-and-O(1)-space) to Jump Game here.\\n  \\n  We also use Greedy algorithm in the solution. We need three variales `max_reach` the farthest index we can reach, `jumps` the min number of jumps to last index, `currentJumpEnd` the end index that we can jump to from the previous jump. \\n  \\n  The key point is we need to update both `jumps` and `currentJumpEnd` when `i == currentJumpEnd`. Why? We need to do so because we already reach the farthest index from previous jump. Hence, we need to jump again!\\n  \\n  ```\\n  class Solution\\n{\\n    // return the min required jumps to last index\\n    public int jump(int[] nums) \\n    {\\n        // Greedy Algorithm\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        int jumps = 0;\\n        int currentJumpEnd = 0;\\n        \\n        for(int i = 0; i < nums.length-1; i++)\\n        {\\n            max_reach = Math.max(max_reach, i + nums[i]);\\n            \\n            if(i == currentJumpEnd)\\n            {\\n                jumps += 1;\\n                currentJumpEnd = max_reach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n  class Solution\\n{\\n    // return the min required jumps to last index\\n    public int jump(int[] nums) \\n    {\\n        // Greedy Algorithm\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        int jumps = 0;\\n        int currentJumpEnd = 0;\\n        \\n        for(int i = 0; i < nums.length-1; i++)\\n        {\\n            max_reach = Math.max(max_reach, i + nums[i]);\\n            \\n            if(i == currentJumpEnd)\\n            {\\n                jumps += 1;\\n                currentJumpEnd = max_reach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102498,
                "title": "java-o-n-linear-solution-greedy",
                "content": "https://leetcode.com/problems/jump-game/\\n**55. Jump Game: `TC: / SC: O(n) / O(1)`**\\n```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-ii/\\n\\u2705**45. Jump Game II: `TC: / SC: O(n) / O(1)`**\\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iii/\\n**1306. Jump Game III: `TC: / SC: O(n) / O(n)`**\\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iv/\\n**1345. Jump Game IV: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vi/submissions/\\n**1696. Jump Game VI: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vii/submissions/\\n**1871. Jump Game VII: `TC: / SC: O(n) / O(n)`**\\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1752007,
                "title": "simple-intuitive-short-solution-o-n-c",
                "content": "```\\n    public int Jump(int[] nums) {\\n        int count = 0;        \\n        int max = 0;\\n        int cur = 0;\\n        for (int i=0; i<nums.Length-1; i++)\\n        {\\n            max = Math.Max(max, i+nums[i]);\\n            if (i == cur)\\n            {\\n                count++;\\n                cur = max;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int Jump(int[] nums) {\\n        int count = 0;        \\n        int max = 0;\\n        int cur = 0;\\n        for (int i=0; i<nums.Length-1; i++)\\n        {\\n            max = Math.Max(max, i+nums[i]);\\n            if (i == cur)\\n            {\\n                count++;\\n                cur = max;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517689,
                "title": "concise-o-n-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n       if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump =>we can take jump from particular  index\\n\\t\\t//mxjump => we cango up to maximum\\n\\t\\t// jump => to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        if(currjmp<n-1)return -1; //we are not able to reach at the end of array because there may be some zeroes are present in given array so that we cannot move further\\n        return jump;\\n    }\\n    };\\n\\t\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n       if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump =>we can take jump from particular  index\\n\\t\\t//mxjump => we cango up to maximum\\n\\t\\t// jump => to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        if(currjmp<n-1)return -1; //we are not able to reach at the end of array because there may be some zeroes are present in given array so that we cannot move further\\n        return jump;\\n    }\\n    };\\n\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1352149,
                "title": "greedy-dp-solutions-c-explanation",
                "content": "### DP Solution : TC = O(N^2) SC = O(N)\\n```\\nclass Solution {\\npublic:\\n    \\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(j+nums[j] >= i){\\n                    dp[i] = min(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        // for(auto it: dp){\\n        //     cout<<it<<\" \";\\n        // }\\n        return dp[n-1];\\n    }\\n};\\n```\\n\\n### Greedy Solution : TC = O(N)   SC = O(1)\\ncurFarthest stores the farthest value till whch the jump can be made. curEnd stores the last value of upto which last jump was made.\\n``` \\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int curFarthest = 0;\\n        int curEnd = 0;\\n        for(int i=0; i<n-1; i++){\\n            curFarthest = max(i+nums[i],curFarthest);\\n            if(i==curEnd){\\n                count++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(j+nums[j] >= i){\\n                    dp[i] = min(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        // for(auto it: dp){\\n        //     cout<<it<<\" \";\\n        // }\\n        return dp[n-1];\\n    }\\n};\\n```\n``` \\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int curFarthest = 0;\\n        int curEnd = 0;\\n        for(int i=0; i<n-1; i++){\\n            curFarthest = max(i+nums[i],curFarthest);\\n            if(i==curEnd){\\n                count++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1200738,
                "title": "3-approaches-explained-greedy-bfs-dp-o-n-solution",
                "content": "```\\n\\n/*\\n\\nHarshit Gupta | 11th May, 2021\\n---------------------------------\\n\\nC++ program for\\n\\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.\\nEach element in the array represents your maximum jump length at that position.\\nYour goal is to reach the last index in the minimum number of jumps.\\n\\nYou can assume that you can always reach the last index.\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. \\n\\tJump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nhttps://leetcode.com/problems/jump-game-ii/\\n\\nSimilar Questions:\\n    1. https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/\\n    2. https://leetcode.com/problems/video-stitching/\\n\\n------\\n\\nSolution: This can be solved by BFS or DP\\n\\n    1. Greedy: Imagine that you are at index i in the array, the element in your current position \\n        defines the maximum distance that you can jump. Therefore, your next step will fall somewhere \\n        in the range [start, end], where start is the place right next to you and end is i + nums[i]. \\n        Then the question is, where to jump?\\n        Our next move will fall somewhere between [start : end] and to find the minimum number of jumps \\n        to reach the end of the array, we must determine which place will take us the farthest in the next jump.\\n        - We use a variable currEnd which tells us about the end of the current Jump\\n        - We use a variable currFarthest which tells us about the farthest jump I can make till now.\\n        - Iterate over the array & keep keep calculating the farthest jump you can make\\n            - Once you reach the currEnd, it means that this was all you can travel without any jumps\\n                but you know that you can take a jump and reach till the currFarthest point.\\n            - So if you reach the currEnd, you take that jump (so jump++) and now your currEnd will\\n                become your currentFarthest since you can travel till that point without any jumps\\n            - You keep calculating the new currentFarthest now and once reach the currEnd again\\n                you take another jump till the new currentFarthest and this goes on till you reach the end\\n        - We see that we take a greedy approach to always delay the jump and know the max we can reach without\\n            any jumps by using currentFarthest\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(1)  \\n\\n\\t2. BFS: Since we want to get to the last index in MINIMUM number fo steps, BFS comes to mind.\\n\\t\\t- Save the index and value in a queue and keep on inserting the pair<i, arr[i]> which are reachable.\\n\\t\\t- Check if it is the last index then return num of moves\\n\\t\\t- Have a visited[] array so that you do not traverse a node more than once.\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(n)\\n\\n\\t3. DP: Create a DP array and fill it with a large number (n+1 if n is the last index, we will save indexes so n+1 is a safe large index!)\\n\\t\\t- dp[i] will store the minimum number of steps to reach dp[i]\\n\\t\\t- dp[0] = 0 since you are already standing at 0 index.\\n\\t\\t- [GIVEN] For each index the arr[i] will tell you the maximum num of steps you can take\\n\\t\\t- Loop for \\'i\\' from 0 till n\\n\\t\\t\\t- Loop \\'j\\' from start = i till end = i+arr[i] (These are all jumpable from index i)\\n\\t\\t\\t- dp[j] = minimum of \\n\\t\\t\\t\\thowever you can reach j till now (dp[j]),\\n\\t\\t\\t\\thowever you can reach \\'start\\' + 1 step (dp[start] + 1)\\n\\n    Time Complexity: O(n2)\\n    Space Complexity: O(n)\\n---\\n  NOTE: \\n*/\\n\\n// ------------------\\n// Approach 1: Greedy\\n// ------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(), currEnd=0, currFarthest=0, jumps=0;\\n        for(int i=0; i<n-1;i++) {\\n            currFarthest = max(currFarthest, i+nums[i]);\\n            if (i == currEnd){\\n                jumps++;\\n                currEnd = currFarthest;\\n                if(currEnd >= n-1)\\n                    break;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n\\n// ------------------------\\n// Approach 2: BFS SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n        \\n        queue<pair<int,int>> q;\\n        vector<int>visited(n, 0);\\n        q.push(make_pair(0,nums[0]));\\n        visited[0] =1;\\n\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                pair<int, int> f = q.front();\\n                q.pop();\\n                for(int i=f.first+1;i<=f.first+f.second; i++){\\n                    if(i==n-1)\\n                        return jump+1;\\n                    if (visited[i] == 0){\\n                        q.push(make_pair(i, nums[i]));\\n                        visited[i] = 1;\\n                    }\\n                }\\n            }\\n            jump++;\\n        }\\n        return jump;\\n    }\\n};\\n\\n\\n\\n\\n// ------------------------\\n// Approach 3: DP SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n\\n        int len = nums.size();\\n        int dp[len];\\n        dp[0] = 0;\\n\\n        // Initialize it to len+1\\n        for (int i = 1; i < len; i++) {\\n            dp[i] =len+1;\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int start = i;\\n            int end = min(i + nums[i], len - 1);\\n            \\n            for (int j = start; j <= end; j++) {\\n                dp[j] = min(dp[j], dp[start] + 1);\\n            }\\n        }\\n\\n        return dp[len - 1] == len + 1 ? -1 : dp[len - 1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\n/*\\n\\nHarshit Gupta | 11th May, 2021\\n---------------------------------\\n\\nC++ program for\\n\\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.\\nEach element in the array represents your maximum jump length at that position.\\nYour goal is to reach the last index in the minimum number of jumps.\\n\\nYou can assume that you can always reach the last index.\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. \\n\\tJump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nhttps://leetcode.com/problems/jump-game-ii/\\n\\nSimilar Questions:\\n    1. https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/\\n    2. https://leetcode.com/problems/video-stitching/\\n\\n------\\n\\nSolution: This can be solved by BFS or DP\\n\\n    1. Greedy: Imagine that you are at index i in the array, the element in your current position \\n        defines the maximum distance that you can jump. Therefore, your next step will fall somewhere \\n        in the range [start, end], where start is the place right next to you and end is i + nums[i]. \\n        Then the question is, where to jump?\\n        Our next move will fall somewhere between [start : end] and to find the minimum number of jumps \\n        to reach the end of the array, we must determine which place will take us the farthest in the next jump.\\n        - We use a variable currEnd which tells us about the end of the current Jump\\n        - We use a variable currFarthest which tells us about the farthest jump I can make till now.\\n        - Iterate over the array & keep keep calculating the farthest jump you can make\\n            - Once you reach the currEnd, it means that this was all you can travel without any jumps\\n                but you know that you can take a jump and reach till the currFarthest point.\\n            - So if you reach the currEnd, you take that jump (so jump++) and now your currEnd will\\n                become your currentFarthest since you can travel till that point without any jumps\\n            - You keep calculating the new currentFarthest now and once reach the currEnd again\\n                you take another jump till the new currentFarthest and this goes on till you reach the end\\n        - We see that we take a greedy approach to always delay the jump and know the max we can reach without\\n            any jumps by using currentFarthest\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(1)  \\n\\n\\t2. BFS: Since we want to get to the last index in MINIMUM number fo steps, BFS comes to mind.\\n\\t\\t- Save the index and value in a queue and keep on inserting the pair<i, arr[i]> which are reachable.\\n\\t\\t- Check if it is the last index then return num of moves\\n\\t\\t- Have a visited[] array so that you do not traverse a node more than once.\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(n)\\n\\n\\t3. DP: Create a DP array and fill it with a large number (n+1 if n is the last index, we will save indexes so n+1 is a safe large index!)\\n\\t\\t- dp[i] will store the minimum number of steps to reach dp[i]\\n\\t\\t- dp[0] = 0 since you are already standing at 0 index.\\n\\t\\t- [GIVEN] For each index the arr[i] will tell you the maximum num of steps you can take\\n\\t\\t- Loop for \\'i\\' from 0 till n\\n\\t\\t\\t- Loop \\'j\\' from start = i till end = i+arr[i] (These are all jumpable from index i)\\n\\t\\t\\t- dp[j] = minimum of \\n\\t\\t\\t\\thowever you can reach j till now (dp[j]),\\n\\t\\t\\t\\thowever you can reach \\'start\\' + 1 step (dp[start] + 1)\\n\\n    Time Complexity: O(n2)\\n    Space Complexity: O(n)\\n---\\n  NOTE: \\n*/\\n\\n// ------------------\\n// Approach 1: Greedy\\n// ------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(), currEnd=0, currFarthest=0, jumps=0;\\n        for(int i=0; i<n-1;i++) {\\n            currFarthest = max(currFarthest, i+nums[i]);\\n            if (i == currEnd){\\n                jumps++;\\n                currEnd = currFarthest;\\n                if(currEnd >= n-1)\\n                    break;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n\\n// ------------------------\\n// Approach 2: BFS SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n        \\n        queue<pair<int,int>> q;\\n        vector<int>visited(n, 0);\\n        q.push(make_pair(0,nums[0]));\\n        visited[0] =1;\\n\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                pair<int, int> f = q.front();\\n                q.pop();\\n                for(int i=f.first+1;i<=f.first+f.second; i++){\\n                    if(i==n-1)\\n                        return jump+1;\\n                    if (visited[i] == 0){\\n                        q.push(make_pair(i, nums[i]));\\n                        visited[i] = 1;\\n                    }\\n                }\\n            }\\n            jump++;\\n        }\\n        return jump;\\n    }\\n};\\n\\n\\n\\n\\n// ------------------------\\n// Approach 3: DP SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n\\n        int len = nums.size();\\n        int dp[len];\\n        dp[0] = 0;\\n\\n        // Initialize it to len+1\\n        for (int i = 1; i < len; i++) {\\n            dp[i] =len+1;\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int start = i;\\n            int end = min(i + nums[i], len - 1);\\n            \\n            for (int j = start; j <= end; j++) {\\n                dp[j] = min(dp[j], dp[start] + 1);\\n            }\\n        }\\n\\n        return dp[len - 1] == len + 1 ? -1 : dp[len - 1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193120,
                "title": "python3-solution-24-ms-faster-than-97",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        curr_pos=0\\n        distance=0\\n        jumps=0\\n        for i in range(len(nums)-1):\\n            distance=max(distance,i+nums[i])\\n            if curr_pos==i:\\n                jumps+=1\\n                curr_pos=distance\\n        return(jumps)        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        curr_pos=0\\n        distance=0\\n        jumps=0\\n        for i in range(len(nums)-1):\\n            distance=max(distance,i+nums[i])\\n            if curr_pos==i:\\n                jumps+=1\\n                curr_pos=distance\\n        return(jumps)        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192505,
                "title": "java-easiest-clear-7-lines-solution-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int count = 0, end = 0, maxFar = nums[0];\\n        for ( int index = 0; index + 1 < nums.length; ++index ) {\\n            maxFar = Math.max(index + nums[index], maxFar);\\n            if ( index == end ) {\\n                ++count;\\n                end = maxFar;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int jump(int[] nums) {\\n        int count = 0, end = 0, maxFar = nums[0];\\n        for ( int index = 0; index + 1 < nums.length; ++index ) {\\n            maxFar = Math.max(index + nums[index], maxFar);\\n            if ( index == end ) {\\n                ++count;\\n                end = maxFar;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 996519,
                "title": "c-dp-with-full-explanation-and-comments-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      \\n        int largestLadderLen = nums[0]; // signifies where max u can reach using this ladder ...\\n        int stepsLeftOnLadder = nums[0]; // main thing ... explained more below\\n        \\n        int jumps = 1; // already jumped on first ladder\\n\\t\\t// why ? coz - if there are more than 1 element in array u will atleast make 1 jump ....\\n\\t\\t// handle one element case separately below\\n        \\n        if(nums.size()==1)\\n            return 0;\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(i==nums.size()-1)\\n                return jumps;\\n            \\n            stepsLeftOnLadder--; // took a step to reach here ...\\n            \\n            int newLadder = i+nums[i];\\n            \\n            if(newLadder > largestLadderLen)\\n                largestLadderLen = newLadder;\\n\\n\\t\\t\\t\\t//once u find a bigger ladder u just store it n dont start using it rightaway .. \\n\\t\\t\\t\\t//use it only when u find prev ladder is exhausted .. \\n\\t\\t\\t\\t//now because u had found a \"biggr\" ladder that means that bigger ladder would\\n\\t\\t\\t\\t//give u atleast one step extra ...use the bigger ladder to move fwd ... \\n            \\n            if(stepsLeftOnLadder==0){\\n\\t\\t\\t   //prev ladder is exhausted\\n                jumps++; // jump on to a new ladder\\n\\t\\t\\t\\t\\n                 // steps left on new ladder\\n\\t\\t\\t\\t \\n                stepsLeftOnLadder =  largestLadderLen-i; \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// u might have already used some steps on last ladder\\n\\t\\t\\t\\t// now bigger ladder wont be used from start from where it ws originated ..\\n\\t\\t\\t\\t//it would be used from where current is exhauseted .. or in other words .. \\n\\t\\t\\t\\t//on what step u are  .. use from that step ...\\n                \\n            }\\n           \\n                    \\n        }\\n        \\n        return jumps;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      \\n        int largestLadderLen = nums[0]; // signifies where max u can reach using this ladder ...\\n        int stepsLeftOnLadder = nums[0]; // main thing ... explained more below\\n        \\n        int jumps = 1; // already jumped on first ladder\\n\\t\\t// why ? coz - if there are more than 1 element in array u will atleast make 1 jump ....\\n\\t\\t// handle one element case separately below\\n        \\n        if(nums.size()==1)\\n            return 0;\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(i==nums.size()-1)\\n                return jumps;\\n            \\n            stepsLeftOnLadder--; // took a step to reach here ...\\n            \\n            int newLadder = i+nums[i];\\n            \\n            if(newLadder > largestLadderLen)\\n                largestLadderLen = newLadder;\\n\\n\\t\\t\\t\\t//once u find a bigger ladder u just store it n dont start using it rightaway .. \\n\\t\\t\\t\\t//use it only when u find prev ladder is exhausted .. \\n\\t\\t\\t\\t//now because u had found a \"biggr\" ladder that means that bigger ladder would\\n\\t\\t\\t\\t//give u atleast one step extra ...use the bigger ladder to move fwd ... \\n            \\n            if(stepsLeftOnLadder==0){\\n\\t\\t\\t   //prev ladder is exhausted\\n                jumps++; // jump on to a new ladder\\n\\t\\t\\t\\t\\n                 // steps left on new ladder\\n\\t\\t\\t\\t \\n                stepsLeftOnLadder =  largestLadderLen-i; \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// u might have already used some steps on last ladder\\n\\t\\t\\t\\t// now bigger ladder wont be used from start from where it ws originated ..\\n\\t\\t\\t\\t//it would be used from where current is exhauseted .. or in other words .. \\n\\t\\t\\t\\t//on what step u are  .. use from that step ...\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 541548,
                "title": "dp-and-greedy",
                "content": "Derived from [https://leetcode.com/problems/jump-game/discuss/541554/DP-and-Greedy](https://leetcode.com/problems/jump-game/discuss/541554/DP-and-Greedy).\\n### DP\\nDefine **state(i)** as the minimum jumps to reach i\\n**state(i) = min(1 + state(j))** for each j that can jump to i.\\nThe goal state is **state(nums.length - 1)**.\\n```\\n    public int jump(int[] nums) {\\n        int[] state = new int[nums.length];\\n        Arrays.fill(state, Integer.MAX_VALUE);\\n        state[0] = 0;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] + j >= i) { // j can jump to i\\n                    state[i] = Math.min(state[i], state[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        return state[nums.length - 1];\\n    }\\n```\\n### Greedy\\nJump when we have to jump, and jump to the furthest position.\\n```\\n    public int jump(int[] nums) {\\n        if (nums.length < 2) {\\n            return 0;\\n        }\\n        int toJump = 0, numJumps = 0;\\n        \\n        // Build maxReach array\\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            // Assuming we can jump to nums[i], we can reach up to maxReach[i]\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n        }\\n        \\n        // Jump when we have to and count the jumps\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == toJump) {\\n                numJumps++;\\n                if (maxReach[i] >= nums.length - 1) {\\n                    break;\\n                }\\n                toJump = maxReach[i]; // Greedy\\n            }\\n        }\\n        \\n        return numJumps;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int jump(int[] nums) {\\n        int[] state = new int[nums.length];\\n        Arrays.fill(state, Integer.MAX_VALUE);\\n        state[0] = 0;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] + j >= i) { // j can jump to i\\n                    state[i] = Math.min(state[i], state[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        return state[nums.length - 1];\\n    }\\n```\n```\\n    public int jump(int[] nums) {\\n        if (nums.length < 2) {\\n            return 0;\\n        }\\n        int toJump = 0, numJumps = 0;\\n        \\n        // Build maxReach array\\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            // Assuming we can jump to nums[i], we can reach up to maxReach[i]\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n        }\\n        \\n        // Jump when we have to and count the jumps\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == toJump) {\\n                numJumps++;\\n                if (maxReach[i] >= nums.length - 1) {\\n                    break;\\n                }\\n                toJump = maxReach[i]; // Greedy\\n            }\\n        }\\n        \\n        return numJumps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515463,
                "title": "java-100-time",
                "content": "```\\npublic int jump(int[] nums) {\\n        int res = 0, prev = 0, cur = 0;\\n        for (int i=0; i<nums.length-1;++i) {\\n            cur = Math.max(i+nums[i], cur);\\n            if (i==prev) {\\n                ++res;\\n                prev = cur;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int jump(int[] nums) {\\n        int res = 0, prev = 0, cur = 0;\\n        for (int i=0; i<nums.length-1;++i) {\\n            cur = Math.max(i+nums[i], cur);\\n            if (i==prev) {\\n                ++res;\\n                prev = cur;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18055,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Jump Game II** https://leetcode.com/problems/jump-game-ii/\\n\\n**Dynamic Programming With Memoization**\\n* Sketch the recursion tree and implement the simple solution\\n* Base case: i == N-1, return 0. i > N-1, return float('inf')\\n* Recurse through all possible jumps from index i and find the minimum\\n* Use a cache to memoize\\n* This solution gives you a run time error: maximum recursion depth exceeded while calling a Py object!\\n* Time Complexity: O(N^2). Also Space complexity: O(N).\\n\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def helper(self, i, nums, cache):\\n        if i == len(nums)-1:\\n            return 0\\n        elif i > len(nums)-1:\\n            return float('inf')\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = float('inf')\\n            for j in range(1, nums[i]+1):\\n                cache[i] = min(cache[i], self.helper(i+j, nums, cache)+1)\\n            return cache[i]\\n    \\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = defaultdict(int)\\n        return self.helper(0, nums, cache)\\n```\\n\\n**Dynamic Programming With Cache**\\n* What is minimum cost to reach index i? Minimum cost to reach index 0 is 0. \\n* For indexi, lets find all indices j less than i. Now we can take a jump from index j if and only if (i-j)<=nums[j].\\n* Time Complexity: O(N^2). Also Space complexity: O(N).\\n* This solution gives a TLE\\n\\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = [float('inf')]*len(nums)\\n        cache[0] = 0\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if i - j <= nums[j]: # Can I take a jump from position j and reach i?\\n                    cache[i] = min(cache[i], cache[j] + 1)\\n        return cache[-1]\\n```\\n\\n**BFS Solution to Find the Minimum Jump**\\n* Model it like graph search problem and apply BFS to solve it\\n* Even this method gives TLE since it is N^2 solution.\\n\\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        q, levels = [0], -1\\n        while len(q):\\n            levels, new_level= levels + 1, []\\n            for x in q:\\n                for j in range(1, nums[x]+1):\\n                    if x + j == len(nums)-1:\\n                        return levels + 1\\n                    elif x + j < len(nums)-1:\\n                        new_level.append(x+j)\\n                    else:\\n                        break\\n            q = new_level\\n        return levels\\n```\\n\\n\\n**Greedy Approach which uses \"Ladder Idea from Ideserve\"**\\n* https://www.youtube.com/playlist?list=PLamzFoFxwoNgG0Q5rqfTY6ovWSTAC9mbz\\n* The invariant is that at a start index, we already know the maximum jump index that can be reached.\\n* We therefore move from index start to current_max_index and test whether we can reach further than current_max_index. Infact, we try to be greedy - we want to pick the next start point which would make us reach the farthest from current_max_index.\\n* Once we update the next start point, we recognize that we took a single jump.\\n* Take special note of initial conditions: current_max_index, start, jumps = 0, 0, 0. This initialization helps us to tackle cases likes nums =[1]. Other when length of nums is more than 1, the first jump takes us to start index 0 and sets current_max_index to nums[0].\\n\\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        current_max_index, start, jumps = 0, 0, 0\\n        while start < len(nums):\\n            if current_max_index >= len(nums)-1:\\n                return jumps            \\n            for i in range(start, current_max_index+1):\\n                if nums[i] + i > current_max_index:\\n                    start, current_max_index = i, nums[i]+i\\n            jumps += 1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def helper(self, i, nums, cache):\\n        if i == len(nums)-1:\\n            return 0\\n        elif i > len(nums)-1:\\n            return float('inf')\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = float('inf')\\n            for j in range(1, nums[i]+1):\\n                cache[i] = min(cache[i], self.helper(i+j, nums, cache)+1)\\n            return cache[i]\\n    \\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = defaultdict(int)\\n        return self.helper(0, nums, cache)\\n```\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = [float('inf')]*len(nums)\\n        cache[0] = 0\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if i - j <= nums[j]: # Can I take a jump from position j and reach i?\\n                    cache[i] = min(cache[i], cache[j] + 1)\\n        return cache[-1]\\n```\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        q, levels = [0], -1\\n        while len(q):\\n            levels, new_level= levels + 1, []\\n            for x in q:\\n                for j in range(1, nums[x]+1):\\n                    if x + j == len(nums)-1:\\n                        return levels + 1\\n                    elif x + j < len(nums)-1:\\n                        new_level.append(x+j)\\n                    else:\\n                        break\\n            q = new_level\\n        return levels\\n```\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        current_max_index, start, jumps = 0, 0, 0\\n        while start < len(nums):\\n            if current_max_index >= len(nums)-1:\\n                return jumps            \\n            for i in range(start, current_max_index+1):\\n                if nums[i] + i > current_max_index:\\n                    start, current_max_index = i, nums[i]+i\\n            jumps += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18060,
                "title": "share-my-greedy-solution-and-proof-for-greedy-choice-property",
                "content": "I first come up with a dp solution but after some analysis, I figured out it can be reduced to a greedy problem. My idea is borrowed from one of the great top solutions (https://discuss.leetcode.com/topic/28470/concise-o-n-one-loop-java-solution-based-on-greedy) \\n\\nHowever, it seems no one gave a formal proof that it can be solved by greedy strategy. Here is my proof:\\n\\n**Greedy choice property**\\nFor position ```t```, there exists an optimal solution in which the minimum steps is obtained by jumping from position ```i```, where ```i + nums[i] == t```.\\n\\nProof by contradiction:\\n```1)```Suppose there exist a position ```j```, ```i < j```, and ```j + nums[j] >= t```, such that the minimum steps of jumping from ```j``` to ```t``` will lower than that of jumping from ```i``` to ```t```.\\n```2)``` Let ```minSteps(k)``` denotes minimum steps at position ```k```;\\n```3)``` Such that we have ``` i < j < t``` and ``` minSteps(i) > minSteps(j)``` obtained from step ```1)```\\n```4)``` Because ``` t - i > t - j ```, it implies that ```nums[i] > nums[j]```. Therefore, ```minSteps(i) <= minSteps(j)```, which contradicts the supposition that ``` minSteps(i) > minSteps(j)```\\n\\n\\n\\n```\\npublic class Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length <= 1) return 0;\\n        int minSteps = 0;\\n        int upperBound = 0;\\n        int reachable = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            reachable = Math.max(i + nums[i], reachable);\\n            if(i > upperBound){\\n                minSteps++;\\n                upperBound = reachable;\\n                if(upperBound >= nums.length - 1)\\n                    return minSteps;\\n            }\\n        }\\n        return minSteps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```t```\n```i```\n```i + nums[i] == t```\n```1)```\n```j```\n```i < j```\n```j + nums[j] >= t```\n```j```\n```t```\n```i```\n```t```\n```2)```\n```minSteps(k)```\n```k```\n```3)```\n``` i < j < t```\n``` minSteps(i) > minSteps(j)```\n```1)```\n```4)```\n``` t - i > t - j ```\n```nums[i] > nums[j]```\n```minSteps(i) <= minSteps(j)```\n``` minSteps(i) > minSteps(j)```\n```\\npublic class Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length <= 1) return 0;\\n        int minSteps = 0;\\n        int upperBound = 0;\\n        int reachable = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            reachable = Math.max(i + nums[i], reachable);\\n            if(i > upperBound){\\n                minSteps++;\\n                upperBound = reachable;\\n                if(upperBound >= nums.length - 1)\\n                    return minSteps;\\n            }\\n        }\\n        return minSteps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18109,
                "title": "my-very-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps = 0, s1 = 0, s2 = 0;// take steps can reach s1, take steps+1 can reach s2\\n            for (int i = 0; i < nums.size(); ++i) {\\n                if (s1 >= nums.size()-1) return steps;\\n                s2 = max(nums[i]+i,s2);\\n                if (i >= s1) {//steps is not enough, update s1 to s2 and increase steps\\n                    s1 = s2;\\n                    steps++;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps = 0, s1 = 0, s2 = 0;// take steps can reach s1, take steps+1 can reach s2\\n            for (int i = 0; i < nums.size(); ++i) {\\n                if (s1 >= nums.size()-1) return steps;\\n                s2 = max(nums[i]+i,s2);\\n                if (i >= s1) {//steps is not enough, update s1 to s2 and increase steps\\n                    s1 = s2;\\n                    steps++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 18160,
                "title": "concise-c-solution-bfs-16ms-20-lines",
                "content": "    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int level = 0;\\n            int cur_begin = 0;\\n            int cur_end = 0;\\n            int next_end = 0;\\n            while (cur_end < nums.size() - 1) {\\n                // search [cur_begin, cur_end]\\n                for (int index = cur_begin; index <= cur_end; ++index) {\\n                    next_end = max(next_end, index + nums[index]);\\n                }\\n                // move to next level.\\n                ++level;\\n                cur_begin = cur_end + 1;\\n                cur_end = next_end;\\n            }\\n            return level;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int level = 0;\\n            int cur_begin = 0;\\n            int cur_end = 0;\\n            int next_end = 0;\\n            while (cur_end < nums.size() - 1) {\\n                // search [cur_begin, cur_end]\\n                for (int index = cur_begin; index <= cur_end; ++index) {\\n                    next_end = max(next_end, index + nums[index]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3834147,
                "title": "python-beats-99-99-easy-solution",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n\\n        x = [nums[i]+i for i in range(len(nums))]  \\n        # each element in this represent max index that can be reached from the current index \\n\\n        l,r,jumps = 0,0,0\\n\\n        while r < len(nums)-1 :\\n            jumps += 1\\n            l,r = r+1,max(x[l:r+1]) \\n\\n        return jumps\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n\\n        x = [nums[i]+i for i in range(len(nums))]  \\n        # each element in this represent max index that can be reached from the current index \\n\\n        l,r,jumps = 0,0,0\\n\\n        while r < len(nums)-1 :\\n            jumps += 1\\n            l,r = r+1,max(x[l:r+1]) \\n\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653821,
                "title": "python-dp-memo-solution",
                "content": "# Approach\\nCreate an array containing minimum steps you need to take to get to the i-th position.\\nWe can simply go through all elements of the array and then iterate over all possible jump lengths updating information in our array.\\nWe can either jump from our current position, or some other position that we considered earlier. Take the minimum of these two and you will get an answer.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$, where k is a sum of all jumps (sum of nums array)\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[float(\\'inf\\') for _ in range(n)]\\n        dp[0]=0\\n        for i in range(n):\\n            for j in range(1,nums[i]+1):\\n                if i+j<n:\\n                    dp[i+j]=min(dp[i+j],dp[i]+1)\\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[float(\\'inf\\') for _ in range(n)]\\n        dp[0]=0\\n        for i in range(n):\\n            for j in range(1,nums[i]+1):\\n                if i+j<n:\\n                    dp[i+j]=min(dp[i+j],dp[i]+1)\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166620,
                "title": "python-3-7-lines-greedy-w-example-t-m-91-90",
                "content": "Here\\'s the plan: \\n- We iterate through`nums`(with the exception of`nums[-1]` because at that point we have reached the target)\\n- We use`mx`to determine the most efficient jump on each iteration.\\n- We increment`ans`for each iteration\\n- We return`ans` once done with this iteration. \\n\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n                                            #          0 1 2 3 4\\n        ans, mx, end = 0, 0, 0              #  nums = [2,3,0,1,4]  \\n        \\n        for i, num in enumerate(nums[:-1]): #  i    num   mx    end   ans\\n                                            # \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\n            mx = max(mx, i + num)           #  0     2     2     2     1\\n                                            #  1     3     4     2     1\\n            if i == end:                    #  2     0     4     4     2     \\n                ans += 1                    #  3     1     4     4     2                \\n                end = mx \\n\\n        return ans \\n```\\n[](http://)\\n\\nPython 3   ||   7 lines, greedy,  w/ example   ||   T/M: 91% / 90%\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n                                            #          0 1 2 3 4\\n        ans, mx, end = 0, 0, 0              #  nums = [2,3,0,1,4]  \\n        \\n        for i, num in enumerate(nums[:-1]): #  i    num   mx    end   ans\\n                                            # \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\n            mx = max(mx, i + num)           #  0     2     2     2     1\\n                                            #  1     3     4     2     1\\n            if i == end:                    #  2     0     4     4     2     \\n                ans += 1                    #  3     1     4     4     2                \\n                end = mx \\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161559,
                "title": "greedy-approach-0-n-time-and-0-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreddy Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int currreach =0;\\n        int jumps = 0;\\n        int maxreach = 0;\\n        int max = 0;\\n        for(int i = 0; i < nums.length - 1; i++)\\n        {\\n            if(i + nums[i] > maxreach)\\n                maxreach = i + nums[i];\\n            if(i == currreach)\\n            {\\n                jumps++;\\n                currreach = maxreach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int currreach =0;\\n        int jumps = 0;\\n        int maxreach = 0;\\n        int max = 0;\\n        for(int i = 0; i < nums.length - 1; i++)\\n        {\\n            if(i + nums[i] > maxreach)\\n                maxreach = i + nums[i];\\n            if(i == currreach)\\n            {\\n                jumps++;\\n                currreach = maxreach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158465,
                "title": "c-easy-greedy-approach-5-liner-code-faster-than-85-of-solution",
                "content": "# Code\\n# **PLEASE DO UPVOTE !**\\n**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(),i=0,ans=0;\\n        for(int i=1;i<n;i++)nums[i]=max(nums[i]+i,nums[i-1]);\\n        while(i<n-1){\\n            ans++;\\n            i=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(),i=0,ans=0;\\n        for(int i=1;i<n;i++)nums[i]=max(nums[i]+i,nums[i-1]);\\n        while(i<n-1){\\n            ans++;\\n            i=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158364,
                "title": "c-solution-faster-than-96-45",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBASIC APPROACH & EASY TO UNDERSTAND\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count=0;\\n        if(nums.size()==1 &&nums[0]==1)\\n        return 0;\\n\\n        \\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i-1],nums[i] + i);\\n      }\\n\\n      \\n      for(int j=0;j<nums.size()-1;j=nums[j])\\n      {\\n          count++;\\n      }\\n\\n      return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count=0;\\n        if(nums.size()==1 &&nums[0]==1)\\n        return 0;\\n\\n        \\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i-1],nums[i] + i);\\n      }\\n\\n      \\n      for(int j=0;j<nums.size()-1;j=nums[j])\\n      {\\n          count++;\\n      }\\n\\n      return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158003,
                "title": "daily-leetcoding-challenge-february-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3095921,
                "title": "99-45-javascript-fast-very-very-easy-to-understand-with-video-explanation-en-kr",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nEnglish video!\\n\\nhttps://youtu.be/wmjGaq7baTM\\n\\nKorean video!\\n\\nhttps://youtu.be/6LdZUdBZGv4\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    let left = 0;\\n    let right = 0;\\n    let res = 0;\\n\\n    while(right<nums.length-1){\\n        let max = 0;\\n\\n        for(let i = left; i<=right;i++){\\n            max = Math.max(nums[i]+i,max)\\n        }\\n        left = right+1;\\n        right = max;\\n\\n        res++\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    let left = 0;\\n    let right = 0;\\n    let res = 0;\\n\\n    while(right<nums.length-1){\\n        let max = 0;\\n\\n        for(let i = left; i<=right;i++){\\n            max = Math.max(nums[i]+i,max)\\n        }\\n        left = right+1;\\n        right = max;\\n\\n        res++\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2637851,
                "title": "java-complete-solution",
                "content": "Pre-requisite : https://leetcode.com/problems/jump-game/\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length == 1){\\n            return 0;\\n        }\\n        int max = 0;\\n        int curr = 0;\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length - 1 ; i++){\\n            max = Math.max(max , i + nums[i]);\\n            \\n            if(curr == i){\\n                curr = max;\\n                count++;\\n            }\\n            if(curr>nums.length-1){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length == 1){\\n            return 0;\\n        }\\n        int max = 0;\\n        int curr = 0;\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length - 1 ; i++){\\n            max = Math.max(max , i + nums[i]);\\n            \\n            if(curr == i){\\n                curr = max;\\n                count++;\\n            }\\n            if(curr>nums.length-1){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580276,
                "title": "c-3-solutions-recursive-memoised-tabulation-code",
                "content": "**If it helps, please UPVOTE : )**\\n\\n**RECURSIVE code:**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums)\\n    {\\n        if(i == n-1)  //if reached last index then no need to move further so no steps required\\n            return 0;\\n       \\n        int mini = INT_MAX-1;                       //-1 bc in loop 1 + solve(), if solve() returns INT_MAX, 1+INT_MAX will result stack overflow\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++) //possible steps we can take from i\\n        {\\n            int temp = 1 + solve(i+j, nums); //at i take 1 step of length j, so we reach i+j\\n            mini = min(mini, temp);          //we take minimum of all steps from i to reach n-1\\n        }\\n        \\n        return mini;  //if not reached n-1, then it will not go in loop and return mini = INT_MAX-1 at some step where further going forward is not possible, back trackingto previous call temp = 1 + INT_MAX-1, mini = min(mini, INT_MAX), so we see for current j it will get INT_MAX as temp ans, while taking minimum it won\\'t affect the answer\\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\\n\\n**MEMOISED code:**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums, vector<int> &dp)\\n    {\\n        if(i == n-1)\\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int mini = INT_MAX-1;\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n        {\\n            int temp = 1 + solve(i+j, nums, dp);\\n            mini = min(mini, temp);\\n        }\\n        \\n        return dp[i] = mini;  //agar n-1 tk nhi bhi pahucha, then it will not go in loop and return mini = INT_MAX \\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        vector<int> dp(n-1, -1);\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\\n\\n**TABULATION BOTTOM-UP code:**\\n```\\nclass Solution {\\npublic:\\n\\tint jump(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        //base case for i=n-1 is 0\\n        \\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int mini = INT_MAX-1;\\n            for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n            {\\n                int temp = 1 + dp[i+j];\\n                mini = min(mini, temp);\\n            }\\n\\n            dp[i] = mini;  //agar n-1 tk nhi pahucha, it will return INT_MAX as min steps\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums)\\n    {\\n        if(i == n-1)  //if reached last index then no need to move further so no steps required\\n            return 0;\\n       \\n        int mini = INT_MAX-1;                       //-1 bc in loop 1 + solve(), if solve() returns INT_MAX, 1+INT_MAX will result stack overflow\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++) //possible steps we can take from i\\n        {\\n            int temp = 1 + solve(i+j, nums); //at i take 1 step of length j, so we reach i+j\\n            mini = min(mini, temp);          //we take minimum of all steps from i to reach n-1\\n        }\\n        \\n        return mini;  //if not reached n-1, then it will not go in loop and return mini = INT_MAX-1 at some step where further going forward is not possible, back trackingto previous call temp = 1 + INT_MAX-1, mini = min(mini, INT_MAX), so we see for current j it will get INT_MAX as temp ans, while taking minimum it won\\'t affect the answer\\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums, vector<int> &dp)\\n    {\\n        if(i == n-1)\\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int mini = INT_MAX-1;\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n        {\\n            int temp = 1 + solve(i+j, nums, dp);\\n            mini = min(mini, temp);\\n        }\\n        \\n        return dp[i] = mini;  //agar n-1 tk nhi bhi pahucha, then it will not go in loop and return mini = INT_MAX \\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        vector<int> dp(n-1, -1);\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint jump(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        //base case for i=n-1 is 0\\n        \\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int mini = INT_MAX-1;\\n            for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n            {\\n                int temp = 1 + dp[i+j];\\n                mini = min(mini, temp);\\n            }\\n\\n            dp[i] = mini;  //agar n-1 tk nhi pahucha, it will return INT_MAX as min steps\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471981,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int pos=0;\\n        int des=0;\\n        int jmp=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            des=max(des,i+nums[i]);\\n            \\n            if(pos==i){\\n                pos=des;\\n                jmp++;\\n            }\\n        }\\n        return jmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int pos=0;\\n        int des=0;\\n        int jmp=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            des=max(des,i+nums[i]);\\n            \\n            if(pos==i){\\n                pos=des;\\n                jmp++;\\n            }\\n        }\\n        return jmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378987,
                "title": "c-two-approaches-dp-greedy-must-see-explained",
                "content": "**This problem can be solve using both dp and greedy techniques.\\nSo, just trying to explain you both the techniques**\\n\\n\\u2714\\u2714  **DYNAMIC PROGRAMMING**\\n\\nclass Solution {\\npublic:\\n \\n\\t int solve(int index,vector<int>& nums,vector<int>&dp)\\n\\t\\t{\\n       \\n\\t   if(index>=nums.size()-1) //base condition if we reached at last index or beyond it \\n        {\\n            return 0;\\n        }\\n        if(nums[index]==0) // if index element is zero then it is not possible to move further  return ing  large value \\n        {\\n            return 1e5;\\n        }\\n        if(dp[index]!=-1)\\n        {\\n            return dp[index];\\n        }\\n        int ans=1e5;\\n        for(int i=1;i<=nums[index];++i)// trying all possible ways \\n        {\\n            ans=min(ans,1+solve(index+i,nums,dp)); //taking min ans\\n        }\\n        return dp[index]=ans;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1); //dp array\\n        return solve(0,nums,dp);\\n    }\\n};\\n**Time complexity=0(N^2)\\nSpace complexity=O(N)**\\n\\n\\n \\uD83D\\uDD25\\uD83D\\uDD25 **Greedy SOlution**\\n  \\n     class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n\\t\\n     //simple just having maxsofar and currso far at each currso far we will update our jump\\n        int n=nums.size();\\n        int mxfar=nums[0];\\n        int currfar=nums[0];\\n        int jump=1;\\n        if(nums[0]==0 ||n==1)\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<n;++i)\\n        {\\n            \\n            mxfar=max(mxfar,nums[i]+i); // each time take max possible\\n\\t\\t\\t\\n            if(mxfar<=i) //check if we can reach the end though not necessary for this problem\\n            {\\n                return -1;\\n            }\\n            if(currfar==n-1) // if we can reach at last we curr max\\n            {\\n                return jump;\\n            }\\n            if(currfar==i) //if currfar limit reached then again need to take a jump\\n            {\\n                currfar=mxfar;\\n                jump++;\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n**Time complexity=0(N)\\nSpace complexity=O(1)**\\n**DO Upvote if it helped**\\uD83D\\uDE03\\uD83D\\uDE03",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n \\n\\t int solve(int index,vector<int>& nums,vector<int>&dp)\\n\\t\\t{\\n       \\n\\t   if(index>=nums.size()-1) //base condition if we reached at last index or beyond it \\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2260220,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int maxReach=0;\\n        int current=0;\\n        int jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            maxReach=max(maxReach,i+nums[i]);\\n            if(current==i)\\n            {\\n                jumps++;\\n                current=maxReach;\\n            }            \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int maxReach=0;\\n        int current=0;\\n        int jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            maxReach=max(maxReach,i+nums[i]);\\n            if(current==i)\\n            {\\n                jumps++;\\n                current=maxReach;\\n            }            \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866723,
                "title": "golang-simple-solution",
                "content": "```\\nfunc jump(nums []int) int {\\n    if len(nums) == 0 {\\n        return 0\\n    }\\n    \\n    if len(nums) == 1 {\\n        return 0\\n    }\\n    \\n    record := make(map[int]int)\\n    // key: index of num\\n    // value: min amount of steps to reach the end\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = 1\\n        } else {\\n            for key, value := range record {\\n                if nums[i] >= key - i {\\n                    if _, exist := record[i]; exist {\\n                        record[i] = min(value + 1, record[i])\\n                    } else {\\n                        record[i] = value + 1\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc jump(nums []int) int {\\n    if len(nums) == 0 {\\n        return 0\\n    }\\n    \\n    if len(nums) == 1 {\\n        return 0\\n    }\\n    \\n    record := make(map[int]int)\\n    // key: index of num\\n    // value: min amount of steps to reach the end\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = 1\\n        } else {\\n            for key, value := range record {\\n                if nums[i] >= key - i {\\n                    if _, exist := record[i]; exist {\\n                        record[i] = min(value + 1, record[i])\\n                    } else {\\n                        record[i] = value + 1\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814490,
                "title": "easy-to-understand-java-1ms",
                "content": "Given \\n**You can assume that you can always reach the last index.** \\nwe defintely reach end and we need to find min jumps\\n\\n**Example**\\n\\t\\t\\t\\tnums\\t=[2, 3, 1, 1, 4]\\nmaxreachablepos = [2, 4, 3, 4, 8]\\n\\t\\t\\t\\t\\tindex = [0, 1, 2, 3, 4]\\n\\t\\t\\t\\t\\t\\nintially at **index0**, we can reach upto **index2(1)**, store in max reachable pos, **increment ans**\\nat **index1**, we can can reach upto **index4**, store in cur_max\\nat **index2** we can reach upto index max reachable pos is **3** current index is **2** but we already know if we choose **index1** then we can reach **index4** which is stored in cur_max, so store that cur_max in max_reachable pos.. **increment ans**.    4 means we reaches **end** \\n\\nso we need **2** jumps to reach end\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int maxReachablePos=0, cur_max=0, ans=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            cur_max = Math.max(cur_max, i+nums[i]);\\n            if(i==maxReachablePos){\\n                ans++;\\n                maxReachablePos=cur_max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Dont Forget to **upvote**\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int maxReachablePos=0, cur_max=0, ans=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            cur_max = Math.max(cur_max, i+nums[i]);\\n            if(i==maxReachablePos){\\n                ans++;\\n                maxReachablePos=cur_max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804268,
                "title": "o-n2-easy-dynamic-programming-javascript-solution-with-o-n-extra-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    //jump[i] is the jumps required to reach from first element of aray to i\\'th position\\n    const jump = new Array(nums.length).fill(Infinity);\\n    jump[0] = 0; //Since we are already at index 0 initially\\n\\n    //Outer loop to calculate & store minimum jumps to  reach position i\\n    for( let i = 1; i < nums.length; i++) {\\n        /** Inner loop will run from 0\\'th index to i-1 index, We need to figure out\\n        * if we can jump directly from j\\'th position to i\\'th position, \\n        * if we can, then minimum jump to reach index i will be minimum of jump[i], jump[j]+1\\n        * Here \"+1\" in \"jump[j] + 1\" is for one more jump from j\\'th index\\n        **/\\n        for (let j = 0; j < i; j++) {\\n            if(nums[j] >= i-j) {\\n               jump[i] = Math.min(jump[i], jump[j]+1);\\n               }\\n        }\\n    }\\n    return jump[nums.length-1];\\n}\\n\\n```\\nFor suport, Hit Upvote :)\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    //jump[i] is the jumps required to reach from first element of aray to i\\'th position\\n    const jump = new Array(nums.length).fill(Infinity);\\n    jump[0] = 0; //Since we are already at index 0 initially\\n\\n    //Outer loop to calculate & store minimum jumps to  reach position i\\n    for( let i = 1; i < nums.length; i++) {\\n        /** Inner loop will run from 0\\'th index to i-1 index, We need to figure out\\n        * if we can jump directly from j\\'th position to i\\'th position, \\n        * if we can, then minimum jump to reach index i will be minimum of jump[i], jump[j]+1\\n        * Here \"+1\" in \"jump[j] + 1\" is for one more jump from j\\'th index\\n        **/\\n        for (let j = 0; j < i; j++) {\\n            if(nums[j] >= i-j) {\\n               jump[i] = Math.min(jump[i], jump[j]+1);\\n               }\\n        }\\n    }\\n    return jump[nums.length-1];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745102,
                "title": "easy-recursice-memoization-top-down-tabulation-solution-bottom-up",
                "content": "**Recursive Approach: Try to make recursive tree for each step**\\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n, nums));\\n        }\\n        return paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solve(0,n-1, nums);\\n    }\\n};\\n```\\n**Memoization: Recusion has overlapping subproblem, so we will memoize it**\\n**TC: O(n), Solving every state only once**\\n**SC: O(n) + O(n), Stack space + dp**\\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n,vector<int> &dp, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        if(dp[ind] != -1) return dp[ind];\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n,dp, nums));\\n        }\\n        return dp[ind] = paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        vector<int> dp(n, -1);\\n        return solve(0,n-1, dp,nums);\\n    }\\n};\\n```\\n**Tabulation: we know about the base case. ie. If we are at the last step...there is no path to go**\\n**TC: O(n), Solving every state only once**\\n**SC: O(n) , dp**\\n```\\nclass Solution {\\nprivate:    \\n    int solveTab(int n, vector<int> &nums){\\n        vector<int> dp(n);\\n        dp[n-1] = 0;\\n        for(int i=n-2; i>=0; i--){\\n            int step = 1e9;\\n            for(int j = 1; j<= nums[i]; j++){\\n                if(i+j < n){\\n                    step = min(step, 1+dp[i+j]);\\n                }\\n            }\\n            dp[i] = step;\\n        }\\n        return dp[0];\\n    }\\n    \\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solveTab(n, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n, nums));\\n        }\\n        return paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solve(0,n-1, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n,vector<int> &dp, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        if(dp[ind] != -1) return dp[ind];\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n,dp, nums));\\n        }\\n        return dp[ind] = paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        vector<int> dp(n, -1);\\n        return solve(0,n-1, dp,nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:    \\n    int solveTab(int n, vector<int> &nums){\\n        vector<int> dp(n);\\n        dp[n-1] = 0;\\n        for(int i=n-2; i>=0; i--){\\n            int step = 1e9;\\n            for(int j = 1; j<= nums[i]; j++){\\n                if(i+j < n){\\n                    step = min(step, 1+dp[i+j]);\\n                }\\n            }\\n            dp[i] = step;\\n        }\\n        return dp[0];\\n    }\\n    \\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solveTab(n, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583901,
                "title": "c-faster-than-99-o-n-timecomplexity-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }      \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }      \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505576,
                "title": "short-clean-java",
                "content": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int count = 0;\\n        int current_jump = 0;\\n        int last_jump = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            current_jump = Math.max(current_jump , i+nums[i]);\\n            if(i == last_jump){\\n                count++;\\n                last_jump = current_jump;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int count = 0;\\n        int current_jump = 0;\\n        int last_jump = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            current_jump = Math.max(current_jump , i+nums[i]);\\n            if(i == last_jump){\\n                count++;\\n                last_jump = current_jump;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192374,
                "title": "c-simple-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size() == 1 || nums[0] == 0) return 0;\\n        \\n        int jumps = 0, curr = 1, reach = 0, n = nums.size(), i;\\n        \\n        while (reach < n-1 && reach + nums[reach] < n - 1) {\\n            for (i = curr; curr <= reach + nums[reach]; curr++) {\\n                if (curr + nums[curr] >= i + nums[i])\\n                    i = curr;\\n            }\\n            jumps++;\\n            reach = i;\\n        }\\n        return ++jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size() == 1 || nums[0] == 0) return 0;\\n        \\n        int jumps = 0, curr = 1, reach = 0, n = nums.size(), i;\\n        \\n        while (reach < n-1 && reach + nums[reach] < n - 1) {\\n            for (i = curr; curr <= reach + nums[reach]; curr++) {\\n                if (curr + nums[curr] >= i + nums[i])\\n                    i = curr;\\n            }\\n            jumps++;\\n            reach = i;\\n        }\\n        return ++jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170736,
                "title": "java-greedy-beats-100-in-both-memory-and-time-0ms-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(nums.length) O(1)\\n\\tpublic int jump(int[] nums) {\\n\\n\\t\\tif (nums.length == 1)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint len = nums.length, curr_reach = 0, max_reach = 0, jumps = 0;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (i + nums[i] >= len - 1)\\n\\t\\t\\t\\treturn jumps + 1;\\n\\n\\t\\t\\tif (i + nums[i] > max_reach)\\n\\t\\t\\t\\tmax_reach = i + nums[i];\\n\\n\\t\\t\\tif (i == curr_reach) {\\n\\t\\t\\t\\tjumps++;\\n\\t\\t\\t\\tcurr_reach = max_reach;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(1)\\n\\tpublic int jump(int[] nums) {\\n\\n\\t\\tif (nums.length == 1)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint len = nums.length, curr_reach = 0, max_reach = 0, jumps = 0;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (i + nums[i] >= len - 1)\\n\\t\\t\\t\\treturn jumps + 1;\\n\\n\\t\\t\\tif (i + nums[i] > max_reach)\\n\\t\\t\\t\\tmax_reach = i + nums[i];\\n\\n\\t\\t\\tif (i == curr_reach) {\\n\\t\\t\\t\\tjumps++;\\n\\t\\t\\t\\tcurr_reach = max_reach;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1048278,
                "title": "c-dp-time-and-space-o-n",
                "content": "```public class Solution {\\n    public int Jump(int[] nums) {\\n        if(nums.Length < 2) {\\n            return 0;\\n        }\\n        \\n        int[] dp = new int[nums.Length];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++) {\\n\\t\\t   //Figure out the max jump at index i\\n            dp[i] = Math.Max(dp[i-1]-1, nums[i]);\\n        }\\n        \\n        int index = 0;\\n        int count = 0;\\n\\t\\t//using max jump, figure out how many jumps to hit last index\\n        while(index < nums.Length-1) {\\n            index += dp[index];\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int Jump(int[] nums) {\\n        if(nums.Length < 2) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 714429,
                "title": "c-and-go-o-n-easiest-solution-10-lines",
                "content": "C++ \\nclass Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n    \\n        int ans=0,cend=0,cmax=arr[0], n = arr.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(cend<i){\\n                ans++;\\n                cend = cmax;\\n            } \\n              cmax = max(cmax,i+arr[i]);\\n        } \\n        return ans;\\n    }\\n};\\n\\nGO Solution for the same logic.\\nfunc max(a int,b int) int {\\n    \\n    if(a > b){\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc jump(nums []int) int {\\n    \\n    n := len(nums)\\n    if (n==1) {\\n        return 0;\\n    }\\n    var ewall, cwall, jump int\\n    for i:=0; i<n; i++ {\\n        cwall = max(cwall,i+nums[i])\\n        if i == ewall {\\n            ewall = cwall\\n            jump++\\n        \\n            if ewall >= n-1 {\\n                break; \\n            }\\n        }\\n    }  \\n    return jump\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n    \\n        int ans=0,cend=0,cmax=arr[0], n = arr.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(cend<i){\\n                ans++;\\n                cend = cmax;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 559701,
                "title": "java-simple-clean-code-100-12lines-python-10line",
                "content": "Java\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res=0,next=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            max=Math.max(max,i+nums[i]);\\n            if(i==next){\\n                next=max;res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\npython\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        arr=[0,0,0]\\n        for i in range(len(nums)-1):\\n            arr[2]=max(arr[2],nums[i]+i)\\n            if i==arr[1]:\\n                arr[1]=arr[2]\\n                arr[0]+=1\\n        return arr[0]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res=0,next=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            max=Math.max(max,i+nums[i]);\\n            if(i==next){\\n                next=max;res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        arr=[0,0,0]\\n        for i in range(len(nums)-1):\\n            arr[2]=max(arr[2],nums[i]+i)\\n            if i==arr[1]:\\n                arr[1]=arr[2]\\n                arr[0]+=1\\n        return arr[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 507246,
                "title": "java-2-methods-dp-bfs-both-with-time-o-n-space-o-1",
                "content": "DP:\\n```Java\\n\\t\\t/**\\n         * maxStep means the farthest position you can get to\\n         * lastMax means the farthest position you can get to with the min step now\\n         * minVal means the minimum steps it would take right now\\n         */\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = nums[0], lastMax = nums[0], minVal = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            maxStep = Math.max(maxStep, nums[i] + i);\\n            if (i == lastMax && i != nums.length - 1) {\\n                lastMax = maxStep;\\n                minVal += 1;\\n            }\\n        }\\n        return minVal;\\n```\\n\\nBFS:\\n```Java\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = 0, lastMax = 0, minVal = 0, i = 0;\\n        while (lastMax - i + 1 > 0) {\\n            minVal++;\\n            for(; i <= lastMax; i++) {\\n                maxStep = Math.max(maxStep, nums[i] + i);\\n                if (maxStep >= nums.length - 1) return minVal;\\n            }\\n            lastMax = maxStep;\\n        }\\n        return 0;\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```Java\\n\\t\\t/**\\n         * maxStep means the farthest position you can get to\\n         * lastMax means the farthest position you can get to with the min step now\\n         * minVal means the minimum steps it would take right now\\n         */\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = nums[0], lastMax = nums[0], minVal = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            maxStep = Math.max(maxStep, nums[i] + i);\\n            if (i == lastMax && i != nums.length - 1) {\\n                lastMax = maxStep;\\n                minVal += 1;\\n            }\\n        }\\n        return minVal;\\n```\n```Java\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = 0, lastMax = 0, minVal = 0, i = 0;\\n        while (lastMax - i + 1 > 0) {\\n            minVal++;\\n            for(; i <= lastMax; i++) {\\n                maxStep = Math.max(maxStep, nums[i] + i);\\n                if (maxStep >= nums.length - 1) return minVal;\\n            }\\n            lastMax = maxStep;\\n        }\\n        return 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383980,
                "title": "easy-peasy-python-o-n-one-pass-o-1-memory-solution",
                "content": "\\t# I will start from a position and look at the position I can go from here\\n\\t# now, I know that from current position to the position where I can go I just need to make one jump for each point between these two positions\\n\\t# now I will look at the point from where I can make the max jump between these two points(including the end)\\n\\t# and I will keep on carrying this.\\n\\t# Basically I will look between the current position and the max position and find the next jump that I can make.\\n\\t# So basically adding 1 jump at a time.\\n\\t\\n\\tdef jump(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln <= 1:\\n            return 0\\n        \\n        cnt = till = 0\\n        maxIdx = 0 \\n        for i in range(ln):\\n            maxIdx = max(maxIdx, i + nums[i])\\n            if i == till:\\n                cnt += 1\\n                till = maxIdx \\n            \\n            if till >= ln-1:\\n                return cnt",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "\\t# I will start from a position and look at the position I can go from here\\n\\t# now, I know that from current position to the position where I can go I just need to make one jump for each point between these two positions\\n\\t# now I will look at the point from where I can make the max jump between these two points(including the end)\\n\\t# and I will keep on carrying this.\\n\\t# Basically I will look between the current position and the max position and find the next jump that I can make.\\n\\t# So basically adding 1 jump at a time.\\n\\t\\n\\tdef jump(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln <= 1:\\n            return 0\\n        \\n        cnt = till = 0\\n        maxIdx = 0 \\n        for i in range(ln):\\n            maxIdx = max(maxIdx, i + nums[i])\\n            if i == till:\\n                cnt += 1\\n                till = maxIdx \\n            \\n            if till >= ln-1:\\n                return cnt",
                "codeTag": "Python3"
            },
            {
                "id": 324594,
                "title": "java-o-n-100-time-o-1-100-space-loop-solution",
                "content": "The first idea is that we are not interested in the path, but only the number of jumps. The greedy approach fails if we jumps over an index with a huge jump capacity.\\n\\nThe first loop transforms the problem to one where the greedy approach does succeed. It does this by realizing that if `nums[i] < nums[i-1] - 1`, then jumping to index i  is never optimal (unless it is the last index), because jumping to index i-1 will allow a farther jump. So setting `nums[i] = nums[i-1]-1` does not change the minimal number of jumps required. However, doing this for every index solves the issue of jumping over interesting indices and thus a greedy algorithm can be applied.\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int N = nums.length;\\n        for(int i = 1; i < N; ++i) {\\n            nums[i] = Math.max(nums[i], nums[i-1] - 1);\\n        }\\n        \\n        int jumps = 0;\\n        int index = 0;\\n        while(index < N - 1) {\\n            ++jumps;\\n            index+=nums[index];\\n        }\\n        \\n        return jumps;\\n    }\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int N = nums.length;\\n        for(int i = 1; i < N; ++i) {\\n            nums[i] = Math.max(nums[i], nums[i-1] - 1);\\n        }\\n        \\n        int jumps = 0;\\n        int index = 0;\\n        while(index < N - 1) {\\n            ++jumps;\\n            index+=nums[index];\\n        }\\n        \\n        return jumps;\\n    }\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 271097,
                "title": "java-1ms-greedy-solution-which-beats-100",
                "content": "We use three varaibles:\\n* ```furthest``` to record the furthest place previous step can reach\\n* ```max``` to record the furthest place current step can reach.\\n* ``` result``` to record the minimum step we need to reach the last place.\\nTraverse the array to update ```max```. Update ```furthest```  with ```max``` and ```result``` with ```result + 1```  each time current place reach the ```furthest```. Keep traversing until we reach the last place.\\n```\\npublic int jump(int[] nums) {\\n\\tint furthest = 0, result = 0, i = 0;\\n\\twhile( i < nums.length && furthest < nums.length - 1 ) {\\n\\t\\tint max = 0;\\n\\t\\twhile( i <= furthest ) {\\n\\t\\t\\tmax = Math.max(max, nums[i] + i);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tfurthest = max;\\n\\t\\tresult++;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```furthest```\n```max```\n``` result```\n```max```\n```furthest```\n```max```\n```result```\n```result + 1```\n```furthest```\n```\\npublic int jump(int[] nums) {\\n\\tint furthest = 0, result = 0, i = 0;\\n\\twhile( i < nums.length && furthest < nums.length - 1 ) {\\n\\t\\tint max = 0;\\n\\t\\twhile( i <= furthest ) {\\n\\t\\t\\tmax = Math.max(max, nums[i] + i);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tfurthest = max;\\n\\t\\tresult++;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 242676,
                "title": "python-o-n",
                "content": "```\\n\\ndef minJumps(arr):\\n    if len(arr) < 2:\\n            return 0\\n    jump = 1\\n    step = arr[0]\\n    reach = arr[0]\\n    for i in range(1,len(arr)):\\n        if i > step:\\n            jump += 1\\n            step = reach\\n        reach = max(reach, i+arr[i])\\n\\n    return jump\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\ndef minJumps(arr):\\n    if len(arr) < 2:\\n            return 0\\n    jump = 1\\n    step = arr[0]\\n    reach = arr[0]\\n    for i in range(1,len(arr)):\\n        if i > step:\\n            jump += 1\\n            step = reach\\n        reach = max(reach, i+arr[i])\\n\\n    return jump\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18017,
                "title": "possibly-the-simplest-o-n-solution-with-explanation-9-lines-in-c",
                "content": "My solution is based on the observation that if you can reach index `i`, then you are always able to reach index `i - 1` too (**proof:** think of the last jump taken to reach index `i`. If it was of length `1`, then you were already at index `i - 1`. If it was of length ` >= 2`, then you could have taken a 1-unit smaller jump to land on `i -1` instead of `i`). Furthermore, following the same reasoning, if you can reach index `i` in `w` jumps, you can also reach index `i-1` using no more than `w` jumps (but perhaps even less).\\n\\nLet `reach[i]` be the farthest you can reach in the next jump assuming you are able to reach index `i`. (Remember, if you can reach in `i` in `w` jumps, then you can also reach any smaller index in no more than `w` jumps).  Therefore, `reach[i]` is simply `max(k + nums[k])` for all `k` with `0 <= k <= i`). \\n\\nYou can precompute `reach[i]` in O(n) for all `i`'s. (Note that in my code I reuse `nums` to precompute it and avoid defining a new array to save some memory.)\\n\\nAfter that you just simulate the jumps, always reaching as far as you can until you reach the end.\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      int n = nums.size();\\n      for (int i = 1; i < n; ++i) {\\n        nums[i] = max(nums[i - 1], i + nums[i]);\\n      }\\n      int jumps = 0;\\n      for (int at = 0; at < n - 1; at = nums[at]) {\\n        jumps++;\\n      }\\n      return jumps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      int n = nums.size();\\n      for (int i = 1; i < n; ++i) {\\n        nums[i] = max(nums[i - 1], i + nums[i]);\\n      }\\n      int jumps = 0;\\n      for (int at = 0; at < n - 1; at = nums[at]) {\\n        jumps++;\\n      }\\n      return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18213,
                "title": "o-n-runtime-o-1-space-java-solution",
                "content": "Use two pointer to keep track of lower bound and upper bound each time I move forward.\\n\\n    public int jump(int[] A) {\\n            int step = 0;\\n            int low = 0;\\n            int high = 0;\\n            while(high < A.length-1){\\n                int preLow = low;\\n                int preHigh = high;\\n                for(int t = preLow;t <= preHigh;t++)\\n                    high = Math.max(t+A[t], high);\\n                low = preHigh+1;\\n                step++;\\n            }\\n            return step;\\n        }",
                "solutionTags": [],
                "code": "Use two pointer to keep track of lower bound and upper bound each time I move forward.\\n\\n    public int jump(int[] A) {\\n            int step = 0;\\n            int low = 0;\\n            int high = 0;\\n            while(high < A.length-1){\\n                int preLow = low;\\n                int preHigh = high;\\n                for(int t = preLow;t <= preHigh;t++)\\n                    high = Math.max(t+A[t], high);\\n                low = preHigh+1;\\n                step++;\\n            }\\n            return step;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 18099,
                "title": "sharing-my-accepted-python-code",
                "content": "I think the runtime should be O(N) and space complexity is O(1).\\n\\n    def jump(self, A):\\n        if len(A) <= 1:\\n            return 0\\n        end = 0 + A[0]\\n        start = 0\\n        step = 1\\n        maxDis = 0 + A[0]\\n        while end < len(A)-1:\\n            for i in range(start+1, end+1):\\n                maxDis = max(maxDis, A[i]+i)\\n            start = end\\n            end = maxDis\\n            step += 1\\n            \\n        return step",
                "solutionTags": [],
                "code": "I think the runtime should be O(N) and space complexity is O(1).\\n\\n    def jump(self, A):\\n        if len(A) <= 1:\\n            return 0\\n        end = 0 + A[0]\\n        start = 0\\n        step = 1\\n        maxDis = 0 + A[0]\\n        while end < len(A)-1:\\n            for i in range(start+1, end+1):\\n                maxDis = max(maxDis, A[i]+i)\\n            start = end\\n            end = maxDis\\n            step += 1\\n            \\n        return step",
                "codeTag": "Python3"
            },
            {
                "id": 3791862,
                "title": "c-easy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGo on every step and check for maximum reach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf there is only one step then return 1 or if you can not take any step return -1. Initially we will start from index 1, and traverse the array and keep updating the maximum reach and decrease steps.\\n 1. Suppose you are on index 1 (i.e. nums[1] is equal to 3) so you can take 1/2/3 steps and for every step you take max of reach.\\n 2. When step==0 i.e. you can not take any more step, so you will increment the jump by 1.\\n 3. And update step by step=max_reach-1. (simple maths)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1;\\n        int step = nums[0];\\n        if(n<=1) return 0; \\n        if(step==0) return -1; \\n        int max_reach=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(i==n-1) return ans;\\n            max_reach=max(max_reach,i+nums[i]);\\n            step--;\\n            if(step==0){\\n                ans++;\\n                if(i>= max_reach) return -1;\\n                step=max_reach-i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1;\\n        int step = nums[0];\\n        if(n<=1) return 0; \\n        if(step==0) return -1; \\n        int max_reach=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(i==n-1) return ans;\\n            max_reach=max(max_reach,i+nums[i]);\\n            step--;\\n            if(step==0){\\n                ans++;\\n                if(i>= max_reach) return -1;\\n                step=max_reach-i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782140,
                "title": "c-recursive-memoized-and-tabulated-detailed-solution-with-example",
                "content": "# Intuition\\nWe have to start with index `0`, and we can jump upto `0+nums[0]`, and the process goes on. Thus we have to explore all the possible ways to reach the end index in order to get minimum jumps. We will use recursion to explore all the possibilities, and then go on to the memoization and tabulation approaches.\\n\\n# Recursive Approach\\nWe will start with index 0, and will try every possible jump i.e. till nums[i] for index `i`, and count the ways (if possible) to reach end index. Here it may be possible that we land at an index greater than `n-1`, thus the base case will be `if(j>=nums.size()-1) return 0;`. \\nThe approach is simple, the possible steps from current index are `j=i+nums[i]`, we initialise `mini` to `1e7` a big number (not to INT_MAX to avoid overflow) and we explore all jumps possible from `i+1` to `j`, compare the jumps/steps achieved for each jump to mini, and store it if we get comparatively less jumps. In the end we return **res+1**, consider this example: `nums:[1,4]` this will return 0, but we know we need atleat 1 jump to reach destination, so we return **result+1**.\\n\\n```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        return f(0,nums,dp)+1;\\n}\\n\\nint f(int i, vector<int>& nums){\\n    int j=i+nums[i];\\n    if(j>=nums.size()-1) return 0;\\n    \\n    int mini=1e7;\\n    for(int k=i+1;k<=j;k++){\\n        int steps=1+f(k,nums);\\n        mini=min(mini, steps);\\n    }\\n\\n    return mini;\\n}\\n```\\n\\n---\\n\\n\\n# Memoization\\nIn memoization we avoid repeating recursive calls, thus we declare a vector `dp` of size `n`. And as here we are taking the array to be of size n, there will be slight modification in the base case: `dp[n-1]=1`. Before computing just check if it is precomputed or not and before returning store the data in the data structure.\\n```\\nint jump(vector<int>& nums) {\\n    if(n==1) return 0;\\n    vector<int> dp(n, -1);\\n    return f(0,nums,dp)+1;\\n}\\n\\nint solve(int ind,vector<int>&nums,int minJump,vector<int>&dp){\\n    int f(int i, vector<int>& nums, vector<int> &dp){\\n        int j=i+nums[i];\\n        if(j>=nums.size()-1) return 0;\\n\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+f(k,nums,dp);\\n            mini=min(mini, steps);\\n        }\\n\\n        return dp[i]=mini;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n# Tabulation\\nThere are 3 rules for tabulation: \\n1. Write the base cases.\\n2. Reverse the looping of the changing params.\\n3. Copy the recurrence relation.\\n\\nBase case will be `dp[n-1]=0`, and the *i* loop will run from `n-2` to `0` and we copy the recurrence relation.\\n\\n## Example\\nConsider nums to be [2, 3, 1, 1, 4]\\n- Start from the second-to-last position(n-2), \\n- At i=3, j=i+nums[i] = 3+1 = 4. We can jump to position 4. Now, we need to find the minimum jumps from positions 4.\\n- At i=2, j = i+nums[i] = 2+1 = 3. We can jump to position 3 or 4.\\n- The minimum jumps needed from position 3 is dp[3] = 0 (already known). The minimum jumps needed from position 4 is dp[4] = 0 (last index, no jumps needed). Since there\\'s only one jump needed from position 3 to position 4, the minimum jumps needed from position 2 is Update dp[2] = 1.\\n- At i=1, j = i+nums[i] = 1+3 = 4. We can jump to position 4.The minimum jumps needed from position 4 is dp[4]=0 (last index, no jumps needed).Since there\\'s only one jump needed from position 1 to position 4, the minimum jumps needed from position 1 is 1+1 = 2 Update dp[1]=2.\\n- At i=0, j = i+nums[i] = 0+2 = 2. We can jump to position 2. The minimum jumps needed from position 2 is dp[2]=1. Since there\\'s only one jump needed from position 0 to position 2, the minimum jumps needed from position 0 is 1+2=3. Update dp[0]=3. \\n- The dp array is now [3, 2, 1, 1, 0]. \\n- The minimum jumps needed to reach the last index (starting from position 0) is dp[0] = 3.\\n\\n**In the iterative version, the dp array correctly represents the minimum number of jumps needed to reach the last index from each position. There\\'s no need to add +1 again at the end because the dp array already contains the correct count of jumps.**\\n\\n\\n```\\nint jump(vector<int>& nums) {\\n    //O(n)\\n    //O(n)\\n    int n=nums.size();\\n    if(n==1) return 0;\\n    vector<int> dp(n, 0);\\n    dp[n-1]=0;\\n\\n    for(int i=n-2;i>=0;i--){\\n        int j=min(n-1,i+nums[i]);\\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+dp[k];\\n            mini=min(mini, steps);\\n        }\\n\\n        dp[i] = mini;\\n    }\\n\\n    return dp[0]+1;\\n}\\n```\\n\\nUpvote if u liked :)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        return f(0,nums,dp)+1;\\n}\\n\\nint f(int i, vector<int>& nums){\\n    int j=i+nums[i];\\n    if(j>=nums.size()-1) return 0;\\n    \\n    int mini=1e7;\\n    for(int k=i+1;k<=j;k++){\\n        int steps=1+f(k,nums);\\n        mini=min(mini, steps);\\n    }\\n\\n    return mini;\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n    if(n==1) return 0;\\n    vector<int> dp(n, -1);\\n    return f(0,nums,dp)+1;\\n}\\n\\nint solve(int ind,vector<int>&nums,int minJump,vector<int>&dp){\\n    int f(int i, vector<int>& nums, vector<int> &dp){\\n        int j=i+nums[i];\\n        if(j>=nums.size()-1) return 0;\\n\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+f(k,nums,dp);\\n            mini=min(mini, steps);\\n        }\\n\\n        return dp[i]=mini;\\n    }\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n    //O(n)\\n    //O(n)\\n    int n=nums.size();\\n    if(n==1) return 0;\\n    vector<int> dp(n, 0);\\n    dp[n-1]=0;\\n\\n    for(int i=n-2;i>=0;i--){\\n        int j=min(n-1,i+nums[i]);\\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+dp[k];\\n            mini=min(mini, steps);\\n        }\\n\\n        dp[i] = mini;\\n    }\\n\\n    return dp[0]+1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781653,
                "title": "super-simple-solution",
                "content": "# Intuition:\\nThe approach to solving this problem involves utilizing the Greedy algorithm technique. The main idea is to keep track of the farthest reachable index at each step and update it accordingly. We also maintain a variable current, which represents the current boundary of the next jump. Whenever we reach this boundary (i.e., when i equals current), we update current to the farthest reachable index found so far and increment the jump count.\\n\\n# Algorithm:\\n\\nInitialize three variables: farthest, current, and jump to 0. farthest keeps track of the farthest reachable index, current represents the current boundary of the next jump, and jump is used to count the number of jumps taken.\\nIterate through the nums array from index 0 to n-2 (since we don\\'t need to jump from the last index).\\na. Update farthest as the maximum of the current farthest value and the sum of the current element nums[i] and the current index i. This is because we can reach nums[i] + i from index i.\\nb. Check if we have reached the current boundary current, which means we need to make the next jump. If i equals current, update current to the current value of farthest (as it represents the farthest index reachable from the previous jump), and increment the jump count.\\nAfter processing all elements, return the final value of jump, which represents the minimum number of jumps to reach the last index.\\nComplexity Analysis:\\n\\n# Time Complexity:\\n The algorithm iterates through the nums array once, performing constant time operations at each step. Therefore, the time complexity is O(n), where n is the length of the input array nums.\\n# Space Complexity:\\n The algorithm uses only a constant amount of extra space to store the variables farthest, current, and jump, so the space complexity is O(1).\\nOverall, the algorithm has a linear time complexity of O(n) and a constant space complexity of O(1). It efficiently finds the minimum number of jumps required to reach the last index from the first index.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int farthest=0,current=0,jump=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==current){\\n                current=farthest;\\n                jump++;\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int farthest=0,current=0,jump=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==current){\\n                current=farthest;\\n                jump++;\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687480,
                "title": "beats-100-explained-greedy-approach-c",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe initial intuition for this approach is to use the greedy strategy to find the minimum number of jumps required to reach the last index of the input vector `nums`. The idea is to iteratively update the current farthest index that can be reached from each index, while keeping track of the current end index. Whenever the current index reaches the current end index, it means we have reached the maximum position we can jump from the previous indices. In that case, we increment the jump count and update the current end index to the current farthest index. By doing this, we move forward in the vector and continue the process until we reach the last index.\\n\\nThe intuition behind this approach is that by greedily selecting the farthest index we can reach at each step, we can optimize the number of jumps needed to reach the end. This is based on the observation that if we can reach a certain index, we can also reach all the indices before it. Therefore, we can keep track of the current farthest index and update it whenever we find a farther index to jump to.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Easily Understandable Code\\n```\\n-int jump(vector<int> &nums)\\n-{\\n-    int n = nums.size();\\n-    if (n == 1)\\n-        return 0;\\n-    int left = 0, right = 0;\\n-    int jump = 0;\\n-    while (right < n - 1)\\n-    {\\n-        int farthest = 0;\\n-        for (int i = left; i < right + 1; ++i)\\n-            farthest = max(farthest, i + nums[i]);\\n-        left = right + 1;\\n-        right = farthest;\\n-        ++jump;\\n-    }\\n-    return jump;\\n-}\\n```\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n// This function calculates the minimum number of jumps required to reach the last index \\n// of the input vector.\\n\\nint jump(vector<int>& nums) {\\n    \\n    // Store the size of the input vector.\\n    int n = nums.size();\\n    \\n    // Declare and initialize variables for jumps, current end index, and current farthest index.\\n    int jumps = 0, currEnd = 0, currFarthest = 0;\\n    \\n    // Loop through the vector until the second to last element.\\n    for(int i = 0; i < n - 1; i++) {\\n        \\n        // Calculate the farthest index we can reach from the current index.\\n        currFarthest = max(currFarthest, i + nums[i]);\\n        \\n        // If we reach the current end index, we need to jump to the next furthest index.\\n        if(i == currEnd) {\\n            jumps++;\\n            currEnd = currFarthest;\\n        }\\n    } \\n    \\n    // Return the number of jumps required to reach the last index.\\n    return jumps;\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n-int jump(vector<int> &nums)\\n-{\\n-    int n = nums.size();\\n-    if (n == 1)\\n-        return 0;\\n-    int left = 0, right = 0;\\n-    int jump = 0;\\n-    while (right < n - 1)\\n-    {\\n-        int farthest = 0;\\n-        for (int i = left; i < right + 1; ++i)\\n-            farthest = max(farthest, i + nums[i]);\\n-        left = right + 1;\\n-        right = farthest;\\n-        ++jump;\\n-    }\\n-    return jump;\\n-}\\n```\n```\\nclass Solution\\n{\\npublic:\\n// This function calculates the minimum number of jumps required to reach the last index \\n// of the input vector.\\n\\nint jump(vector<int>& nums) {\\n    \\n    // Store the size of the input vector.\\n    int n = nums.size();\\n    \\n    // Declare and initialize variables for jumps, current end index, and current farthest index.\\n    int jumps = 0, currEnd = 0, currFarthest = 0;\\n    \\n    // Loop through the vector until the second to last element.\\n    for(int i = 0; i < n - 1; i++) {\\n        \\n        // Calculate the farthest index we can reach from the current index.\\n        currFarthest = max(currFarthest, i + nums[i]);\\n        \\n        // If we reach the current end index, we need to jump to the next furthest index.\\n        if(i == currEnd) {\\n            jumps++;\\n            currEnd = currFarthest;\\n        }\\n    } \\n    \\n    // Return the number of jumps required to reach the last index.\\n    return jumps;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580174,
                "title": "simple-o-n-time-o-1-space-solution",
                "content": "# Intuition\\nLooks like a greedy problem. Select the maximum index you can reach for each jump.\\nFor this, we will require to keep track of the current maximum index we can reach with given number of jumps and the farthest index we can reach if we consider to take another jump. \\n\\n# Approach\\n1. Initialize currmax = 0, farthest = 0 and the number of jumps as 0.\\n\\n2. Interate over nums, for each index i, the farthest index we can reach from i is i + nums[i]. We update farthest = max(farthest, i + nums[i]).\\n\\n3. If i = currmax, it means we have finished the current jump, and should move on to the next jump. Increment jumps, and set currentmax = farthest as we can reach till farthest with the another jump. Repeat from step 2.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int jumps=0,currmax=0,farthest=0;\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==currmax){\\n                currmax=farthest;\\n                jumps++;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int jumps=0,currmax=0,farthest=0;\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==currmax){\\n                currmax=farthest;\\n                jumps++;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161869,
                "title": "c-4-approaches-explained-recursive-dp-straight-forward",
                "content": "# Intuition\\nHere, future decisions depend upon past decisions. Also bigger problems can be broken and thus solved in smaller parts hence, we can use DP here.\\n\\n# Approach 1 - Recursive (TLE)\\n\\n## Complexity\\n- Time complexity: $$O(k*n)$$ \\nwhere k = largest element\\n- Space complexity: $$O(1)$$\\n\\n## Code\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        return func(0, nums);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums));\\n\\n        return steps;\\n    }\\n};\\n```\\n\\n# Approach 2 - Top Down DP\\n\\n## Complexity\\n- Time complexity: $$O(k*n)$$ \\nwhere k = largest element\\n- Space complexity: $$O(n)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector <int> dp(nums.size(), -1);\\n        return func(0, nums, dp);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums, vector<int> &dp){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        if(dp[ind] != -1)   return dp[ind];\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums, dp));\\n\\n        return dp[ind]=steps;\\n    }\\n};\\n```\\n\\n# Approach 3 - Bottom Up DP\\n\\n## Complexity\\n- Time complexity: $$O(n*n)$$ \\nwhere k = largest element\\n- Space complexity: $$O(n)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> dp(n, INT_MAX);\\n        dp[n-1]=0;\\n\\n        for(int i=n-2; i>=0; i--)\\n            for(int j=1; j<=nums[i]; j++) \\n                dp[i]=min(dp[i], 1+dp[min(n-1, i+j)]);\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\n# Approach 4 - Straight forward logic\\n\\n## Complexity\\n- Time complexity: $$O(n)$$ \\n- Space complexity: $$O(1)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      for(int i=1; i<nums.size(); i++)\\n        nums[i]=max(nums[i]+i, nums[i-1]);\\n\\n      int ind=0, ans=0;\\n\\n      while(ind<nums.size()-1){\\n        ind = nums[ind];\\n        ans++;\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        return func(0, nums);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums));\\n\\n        return steps;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector <int> dp(nums.size(), -1);\\n        return func(0, nums, dp);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums, vector<int> &dp){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        if(dp[ind] != -1)   return dp[ind];\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums, dp));\\n\\n        return dp[ind]=steps;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> dp(n, INT_MAX);\\n        dp[n-1]=0;\\n\\n        for(int i=n-2; i>=0; i--)\\n            for(int j=1; j<=nums[i]; j++) \\n                dp[i]=min(dp[i], 1+dp[min(n-1, i+j)]);\\n\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      for(int i=1; i<nums.size(); i++)\\n        nums[i]=max(nums[i]+i, nums[i-1]);\\n\\n      int ind=0, ans=0;\\n\\n      while(ind<nums.size()-1){\\n        ind = nums[ind];\\n        ans++;\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160826,
                "title": "c-greedy-solution-with-approach",
                "content": "# Approach\\n1. We can use a greedy approach to solve this problem. We can keep track of the current farthest index we can reach and the current end of the current jump.\\n2. We can keep track of the current farthest index we can reach by taking the maximum of the current farthest index and the current index + the value at the current index.\\n3. If the current index is equal to the current end of the current jump, we can increment the number of jumps and set the current end of the current jump to the current farthest index.\\n4. We can return the number of jumps.\\n\\n# Complexity\\n![image.png](https://assets.leetcode.com/users/images/bb65f298-e499-471b-a3f9-f2391d44c899_1675870238.6241379.png)\\n\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int Jump(int[] nums)\\n    {\\n        int jumps = 0, curEnd = 0, curFarthest = 0;\\n        for (int i = 0; i < nums.Length - 1; i++)\\n        {\\n            curFarthest = Math.Max(curFarthest, i + nums[i]);\\n            if (i == curEnd)\\n            {\\n                jumps++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int Jump(int[] nums)\\n    {\\n        int jumps = 0, curEnd = 0, curFarthest = 0;\\n        for (int i = 0; i < nums.Length - 1; i++)\\n        {\\n            curFarthest = Math.Max(curFarthest, i + nums[i]);\\n            if (i == curEnd)\\n            {\\n                jumps++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159922,
                "title": "clean-code-jump-game-ii",
                "content": "# Intuition\\nMINIMIZATION PROBLEM WHERE WE HAVE TO MINIMIZE NO OF JUMPS TO REACH \\nTHE END OF ARRAY.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n\\n    int util(vector<int>& nums, int idx){\\n        if(idx>=nums.size()-1){\\n            return 0;\\n\\n        }\\n        if(dp[idx]!=-1)return dp[idx];\\n\\n        if(nums[idx]==0)return (int)1e5+5;\\n\\n        int ans= 1e5+5;\\n        for(int i= nums[idx]; i>=1; i--){\\n            ans= min(ans, util(nums, idx+i)+1);\\n        }\\n        return dp[idx]= ans;\\n    }\\n    int jump(vector<int>& nums) {\\n        dp.resize(nums.size()+1, -1);\\n\\n        return util(nums, 0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n\\n    int util(vector<int>& nums, int idx){\\n        if(idx>=nums.size()-1){\\n            return 0;\\n\\n        }\\n        if(dp[idx]!=-1)return dp[idx];\\n\\n        if(nums[idx]==0)return (int)1e5+5;\\n\\n        int ans= 1e5+5;\\n        for(int i= nums[idx]; i>=1; i--){\\n            ans= min(ans, util(nums, idx+i)+1);\\n        }\\n        return dp[idx]= ans;\\n    }\\n    int jump(vector<int>& nums) {\\n        dp.resize(nums.size()+1, -1);\\n\\n        return util(nums, 0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158946,
                "title": "python3-o-n-easiest-solution-beats-97-runtime-89-memory",
                "content": "# Approach\\n1. The aim is to get to the second last index, so a variable `n` with value of one less than length of `nums` list is inialized.\\n2. Three more variables are initialized with their value as zero : \\n    - `max_jump_index` : it will help in getting the maximum index to which jumping is possible.\\n    - `jumps` : count of jumps\\n    - `finish` : the end index from a particular jump\\n3. Iterate through the range `0` to `n` while calculating : \\n    - `max_jump_index` as maximum of itself or sum of current index and index till jumping is possible.\\n    - if the index is equal to the finish then `jumps` is incremented.\\n    - the new `finish` is the `max_jump_index`\\n4. After all the iterations `jumps` is returned.\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n= len(nums)- 1\\n\\n        max_jump_index, jumps, finish= 0, 0, 0\\n\\n        for i in range(n):\\n            max_jump_index= max(max_jump_index, i+ nums[i])\\n\\n            if i== finish:\\n                jumps+= 1\\n                finish= max_jump_index\\n\\n        return jumps\\n```\\n---\\n\\n### Happy Coding \\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\n\\n---\\n\\n### If this solution helped you then do consider Upvoting \\u2B06.\\n#### You can connect with me on LinkedIn : [Om Anand](https://www.linkedin.com/in/om-anand-38341a1ba/)",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n= len(nums)- 1\\n\\n        max_jump_index, jumps, finish= 0, 0, 0\\n\\n        for i in range(n):\\n            max_jump_index= max(max_jump_index, i+ nums[i])\\n\\n            if i== finish:\\n                jumps+= 1\\n                finish= max_jump_index\\n\\n        return jumps\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1711786,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1566472,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569596,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1570678,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568248,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568727,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569674,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1575543,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1573427,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568870,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1711786,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1566472,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569596,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1570678,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568248,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568727,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569674,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1575543,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1573427,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568870,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1815653,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1754394,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1576567,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1724178,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1978121,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1967279,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1872396,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1793015,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1792990,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1760231,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1715945,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1576140,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1572683,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1572500,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1572142,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1571110,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1571111,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1571112,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1576598,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 2041431,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 2038617,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2031441,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2027619,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2023096,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2010645,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2003821,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1971719,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1968525,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1967322,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1967271,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1960871,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1958603,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1918874,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1868324,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1854696,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1838890,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1838856,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1806089,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793545,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793533,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793502,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793436,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793414,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793393,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793386,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793343,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793336,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793322,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793272,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793246,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793151,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1793060,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1793028,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792979,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792967,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792924,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792910,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792845,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792789,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792787,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792785,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792765,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792722,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792708,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792668,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792594,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1760266,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1752623,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1728462,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1725093,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Postorder Traversal",
        "question_content": "<p>Given the <code>root</code> of a&nbsp;binary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg\" style=\"width: 127px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [3,2,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?",
        "solutions": [
            {
                "id": 45551,
                "title": "preorder-inorder-and-postorder-iteratively-summarization",
                "content": "Here I summarize the iterative implementation for preorder, inorder, and postorder traverse.\\n\\n<hr>\\n<h3>Pre Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                result.add(p.val);  // Add before going to children\\n                p = p.left;\\n            } else {\\n                TreeNode node = stack.pop();\\n                p = node.right;   \\n            }\\n        }\\n        return result;\\n    }\\n\\n<hr>\\n<h3>In Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                TreeNode node = stack.pop();\\n                result.add(node.val);  // Add after all left children\\n                p = node.right;   \\n            }\\n        }\\n        return result;\\n    }\\n\\n<hr>\\n<h3>Post Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                result.add(p.val);  // Add before going to children\\n                stack.push(p);\\n                p = p.right;\\n            } else {\\n                p = stack.pop();\\n                p = p.left;\\n            }\\n        }\\n        Collections.reverse(result);\\n        return result;\\n    }\\n\\n<hr>\\n<h3>Appendix: Post Order Traverse V2</h3>\\n<hr>\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> result = new LinkedList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while(!stack.isEmpty() || p != null) {\\n            if(p != null) {\\n                stack.push(p);\\n                result.addFirst(p.val);  // Reverse the process of preorder\\n                p = p.right;             // Reverse the process of preorder\\n            } else {\\n                TreeNode node = stack.pop();\\n                p = node.left;           // Reverse the process of preorder\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Here I summarize the iterative implementation for preorder, inorder, and postorder traverse.\\n\\n<hr>\\n<h3>Pre Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                result.add(p.val);  // Add before going to children\\n                p = p.left;\\n            } else {\\n                TreeNode node = stack.pop();\\n                p = node.right;   \\n            }\\n        }\\n        return result;\\n    }\\n\\n<hr>\\n<h3>In Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                TreeNode node = stack.pop();\\n                result.add(node.val);  // Add after all left children\\n                p = node.right;   \\n            }\\n        }\\n        return result;\\n    }\\n\\n<hr>\\n<h3>Post Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                result.add(p.val);  // Add before going to children\\n                stack.push(p);\\n                p = p.right;\\n            } else {\\n                p = stack.pop();\\n                p = p.left;\\n            }\\n        }\\n        Collections.reverse(result);\\n        return result;\\n    }\\n\\n<hr>\\n<h3>Appendix: Post Order Traverse V2</h3>\\n<hr>\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> result = new LinkedList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while(!stack.isEmpty() || p != null) {\\n            if(p != null) {\\n                stack.push(p);\\n                result.addFirst(p.val);  // Reverse the process of preorder\\n                p = p.right;             // Reverse the process of preorder\\n            } else {\\n                TreeNode node = stack.pop();\\n                p = node.left;           // Reverse the process of preorder\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45556,
                "title": "java-simple-and-clean",
                "content": "    public List<Integer> postorderTraversal(TreeNode root) {\\n    \\tLinkedList<Integer> ans = new LinkedList<>();\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tif (root == null) return ans;\\n    \\t\\n    \\tstack.push(root);\\n    \\twhile (!stack.isEmpty()) {\\n    \\t\\tTreeNode cur = stack.pop();\\n    \\t\\tans.addFirst(cur.val);\\n    \\t\\tif (cur.left != null) {\\n    \\t\\t\\tstack.push(cur.left);\\n    \\t\\t}\\n    \\t\\tif (cur.right != null) {\\n    \\t\\t\\tstack.push(cur.right);\\n    \\t\\t} \\n    \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> postorderTraversal(TreeNode root) {\\n    \\tLinkedList<Integer> ans = new LinkedList<>();\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tif (root == null) return ans;\\n    \\t\\n    \\tstack.push(root);\\n    \\twhile (!stack.isEmpty()) {\\n    \\t\\tTreeNode cur = stack.pop();\\n    \\t\\tans.addFirst(cur.val);\\n    \\t\\tif (cur.left != null) {\\n    \\t\\t\\tstack.push(cur.left);\\n    \\t\\t}\\n    \\t\\tif (cur.right != null) {\\n    \\t\\t\\tstack.push(cur.right);\\n    \\t\\t} \\n    \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45785,
                "title": "share-my-two-python-iterative-solutions-post-order-and-modified-preorder-then-reverse",
                "content": "The first is by postorder using a flag to indicate whether the node has been visited or not.\\n\\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer[]}\\n        def postorderTraversal(self, root):\\n            traversal, stack = [], [(root, False)]\\n            while stack:\\n                node, visited = stack.pop()\\n                if node:\\n                    if visited:\\n                        # add to result if visited\\n                        traversal.append(node.val)\\n                    else:\\n                        # post-order\\n                        stack.append((node, True))\\n                        stack.append((node.right, False))\\n                        stack.append((node.left, False))\\n    \\n            return traversal\\n\\nThe 2nd uses modified preorder (right subtree first). Then reverse the result.\\n\\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer[]}\\n        def postorderTraversal(self, root):\\n            traversal, stack = [], [root]\\n            while stack:\\n                node = stack.pop()\\n                if node:\\n                    # pre-order, right first\\n                    traversal.append(node.val)\\n                    stack.append(node.left)\\n                    stack.append(node.right)\\n    \\n            # reverse result\\n            return traversal[::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 45550,
                "title": "c-iterative-recursive-and-morris-traversal",
                "content": "There are three solutions to this problem.\\n\\n 1. Iterative solution using stack --- `O(n)` time and `O(n)` space;\\n 2. Recursive solution --- `O(n)` time and `O(n)` space (function call stack);\\n 3. Morris traversal --- `O(n)` time and `O(1)` space.\\n\\n**Iterative solution using stack**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        TreeNode* last = NULL;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            } else {\\n                TreeNode* node = todo.top();\\n                if (node -> right && last != node -> right) {\\n                    root = node -> right;\\n                } else {\\n                    nodes.push_back(node -> val);\\n                    last = node;\\n                    todo.pop();\\n                }\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\\n\\n**Recursive solution**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        postorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        postorder(root -> left, nodes);\\n        postorder(root -> right, nodes);\\n        nodes.push_back(root -> val);\\n    }\\n};\\n```\\n\\n**Morris traversal**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        TreeNode* dummy = new TreeNode(0);\\n        dummy -> left = root;\\n        TreeNode* cur = dummy;\\n        while (cur) {\\n            if (cur -> left) {\\n                TreeNode* pre = cur -> left;\\n                while (pre -> right && (pre -> right != cur)) {\\n                    pre = pre -> right;\\n                }\\n                if (!(pre -> right)) {\\n                    pre -> right = cur;\\n                    cur = cur -> left;\\n                } else {\\n                    reverseAddNodes(cur -> left, pre, nodes);\\n                    pre -> right = NULL;\\n                    cur = cur -> right;\\n                }\\n            } else {\\n                cur = cur -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\nprivate:\\n    void reverseNodes(TreeNode* start, TreeNode* end) {\\n        if (start == end) {\\n            return;\\n        }\\n        TreeNode* x = start;\\n        TreeNode* y = start -> right;\\n        TreeNode* z;\\n        while (x != end) {\\n            z = y -> right;\\n            y -> right = x;\\n            x = y;\\n            y = z;\\n        }\\n    }\\n    void reverseAddNodes(TreeNode* start, TreeNode* end, vector<int>& nodes) {\\n        reverseNodes(start, end);\\n        TreeNode* node = end;\\n        while (true) {\\n            nodes.push_back(node -> val);\\n            if (node == start) {\\n                break;\\n            }\\n            node = node -> right;\\n        }\\n        reverseNodes(end, start);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        TreeNode* last = NULL;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            } else {\\n                TreeNode* node = todo.top();\\n                if (node -> right && last != node -> right) {\\n                    root = node -> right;\\n                } else {\\n                    nodes.push_back(node -> val);\\n                    last = node;\\n                    todo.pop();\\n                }\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        postorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        postorder(root -> left, nodes);\\n        postorder(root -> right, nodes);\\n        nodes.push_back(root -> val);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        TreeNode* dummy = new TreeNode(0);\\n        dummy -> left = root;\\n        TreeNode* cur = dummy;\\n        while (cur) {\\n            if (cur -> left) {\\n                TreeNode* pre = cur -> left;\\n                while (pre -> right && (pre -> right != cur)) {\\n                    pre = pre -> right;\\n                }\\n                if (!(pre -> right)) {\\n                    pre -> right = cur;\\n                    cur = cur -> left;\\n                } else {\\n                    reverseAddNodes(cur -> left, pre, nodes);\\n                    pre -> right = NULL;\\n                    cur = cur -> right;\\n                }\\n            } else {\\n                cur = cur -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\nprivate:\\n    void reverseNodes(TreeNode* start, TreeNode* end) {\\n        if (start == end) {\\n            return;\\n        }\\n        TreeNode* x = start;\\n        TreeNode* y = start -> right;\\n        TreeNode* z;\\n        while (x != end) {\\n            z = y -> right;\\n            y -> right = x;\\n            x = y;\\n            y = z;\\n        }\\n    }\\n    void reverseAddNodes(TreeNode* start, TreeNode* end, vector<int>& nodes) {\\n        reverseNodes(start, end);\\n        TreeNode* node = end;\\n        while (true) {\\n            nodes.push_back(node -> val);\\n            if (node == start) {\\n                break;\\n            }\\n            node = node -> right;\\n        }\\n        reverseNodes(end, start);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45559,
                "title": "my-accepted-code-with-explaination-does-anyone-have-a-better-idea",
                "content": "pre-order traversal is **root-left-right**, and post order is **left-right-root**. modify the code for pre-order to make it root-right-left, and then  **reverse** the output so that we can get left-right-root .\\n\\n\\n 1. Create an empty stack, Push root node to the stack.\\n 2. Do following while stack is not empty.\\n\\n 2.1. pop an item from the stack and print it.\\n \\n 2.2. push the left child of popped item to stack.\\n\\n 2.3. push the right child of popped item to stack.\\n\\n 3. reverse the ouput.\\n\\n        class Solution {\\n        public:\\n            vector<int> postorderTraversal(TreeNode *root) {\\n                stack<TreeNode*> nodeStack;\\n                vector<int> result;\\n                //base case\\n                if(root==NULL)\\n                return result;\\n                nodeStack.push(root);\\n            while(!nodeStack.empty())\\n            {\\n                TreeNode* node= nodeStack.top();  \\n                result.push_back(node->val);\\n                nodeStack.pop();\\n                if(node->left)\\n                nodeStack.push(node->left);\\n                if(node->right)\\n                nodeStack.push(node->right);\\n            }\\n             reverse(result.begin(),result.end());\\n             return result;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector<int> postorderTraversal(TreeNode *root) {\\n                stack<TreeNode*> nodeStack;\\n                vector<int> result;\\n                //base case\\n                if(root==NULL)\\n                return result;\\n                nodeStack.push(root);\\n            while(!nodeStack.empty())\\n            {\\n                TreeNode* node= nodeStack.top();  \\n                result.push_back(node->val);\\n                nodeStack.pop();\\n                if(node->left)\\n                nodeStack.push(node->left);\\n                if(node->right)\\n                nodeStack.push(node->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 45628,
                "title": "morris-traversal-time-o-n-space-o-1-inorder-preorder-postorder",
                "content": "Morris Traversal is a way of traversing BST with O(1) space and O(n) time. It's a little hard to understand but the basic idea is to link predecessor back to current node so that we can trace back to top of BST. It's also a little tricky to see how it is O(n) since finding predecessor is often O(logn). The answer is , we don't have to find predecessor for every node, only the nodes with valid left child. It will be obvious if you draw a tree to see that every edge is only visited constant time.\\n\\nInorder\\n\\n```\\n    def inorderTraversal(self, root):\\n        result=[]\\n        node=root\\n        while node!=None:\\n            if node.left==None:\\n                result.append(node.val)\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=None and pre.right!=node:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre.right=None\\n                    result.append(node.val)\\n                    node=node.right\\n        return result\\n```\\n\\nPreorder, basically the same, just one line of change\\n```\\n    def preorderTraversal(self, root):\\n        result=[]\\n        node=root\\n        while node!=None:\\n            #print(node.val)\\n            if node.left==None:\\n                result.append(node.val)\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=node and pre.right!=None:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    result.append(node.val)\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre.right=None\\n                    node=node.right\\n        return result\\n```\\n\\nPostorder, this is a little tricky, you have to output path along predecessor in reverse order. \\n```\\n    def postorderTraversal(self, root):\\n        result=[]\\n        def reverseOrder(left,right):\\n            while left<right:\\n                result[left],result[right]=result[right],result[left]\\n                left+=1\\n                right-=1\\n        dummynode= TreeNode(None) #dummy node\\n        node=dummynode\\n        node.left=root\\n        while node!=None:\\n            print(node.val)\\n            if node.left==None:\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=None and pre.right!=node:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre=node.left\\n                    count=1\\n                    while pre.right!=None and pre.right!=node:\\n                        result.append(pre.val)\\n                        pre=pre.right\\n                        count+=1\\n                    result.append(pre.val)\\n                    pre.right=None\\n                    reverseOrder(len(result)-count,len(result)-1)\\n                    node=node.right\\n                    \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n    def inorderTraversal(self, root):\\n        result=[]\\n        node=root\\n        while node!=None:\\n            if node.left==None:\\n                result.append(node.val)\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=None and pre.right!=node:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre.right=None\\n                    result.append(node.val)\\n                    node=node.right\\n        return result\\n```\n```\\n    def preorderTraversal(self, root):\\n        result=[]\\n        node=root\\n        while node!=None:\\n            #print(node.val)\\n            if node.left==None:\\n                result.append(node.val)\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=node and pre.right!=None:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    result.append(node.val)\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre.right=None\\n                    node=node.right\\n        return result\\n```\n```\\n    def postorderTraversal(self, root):\\n        result=[]\\n        def reverseOrder(left,right):\\n            while left<right:\\n                result[left],result[right]=result[right],result[left]\\n                left+=1\\n                right-=1\\n        dummynode= TreeNode(None) #dummy node\\n        node=dummynode\\n        node.left=root\\n        while node!=None:\\n            print(node.val)\\n            if node.left==None:\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=None and pre.right!=node:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre=node.left\\n                    count=1\\n                    while pre.right!=None and pre.right!=node:\\n                        result.append(pre.val)\\n                        pre=pre.right\\n                        count+=1\\n                    result.append(pre.val)\\n                    pre.right=None\\n                    reverseOrder(len(result)-count,len(result)-1)\\n                    node=node.right\\n                    \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 45582,
                "title": "a-real-postorder-traversal-without-reverse-or-insert-4ms",
                "content": "    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode *root) {\\n            vector<int> ret;\\n            if(!root) return ret;\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            st.push(root);\\n            TreeNode *cur;\\n            while(!st.empty()){\\n                cur = st.top();\\n                st.pop();\\n                if(!st.empty()&&st.top() == cur){\\n                    if(cur->right) {\\n                        st.push(cur->right);\\n                        st.push(cur->right);\\n                    }\\n                    if(cur->left){\\n                        st.push(cur->left);\\n                        st.push(cur->left);\\n                    }\\n                }\\n                else\\n                    ret.push_back(cur->val);\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode *root) {\\n            vector<int> ret;\\n            if(!root) return ret;\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            st.push(root);\\n            TreeNode *cur;\\n            while(!st.empty()){\\n                cur = st.top();\\n                st.pop();\\n                if(!st.empty()&&st.top() == cur){\\n                    if(cur->right) {\\n                        st.push(cur->right);\\n                        st.push(cur->right);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 45648,
                "title": "3-ways-of-iterative-postorder-traversing-morris-traversal",
                "content": "Three types of Iterative Postorder Traversals. \\n\\n1) **Using 1 Stack.** O(n) Time & O(n) Space\\nThis is similar to [Inorder using 1 Stack](https://discuss.leetcode.com/topic/64682/three-ways-of-iterative-inorder-traversing-easy-explanation). The difference is we keep track of the previously printed node in `pre`. And we only print a node if its right child is `null` or equal to `pre`.\\n\\t* Push all `left` nodes into the `stack` till it hits `NULL`.\\n\\t* `root` = `s.peek()`\\n\\t* if `root.right` = `null` or `pre`  (Means we have traversed the right subtree already)\\n\\t\\t* We print `root` and  pop it from `s`.\\n\\t\\t* Make `pre` = `root`\\n\\t\\t* `root` = `null` (So we dont go down to left child again)\\n\\t* else\\n\\t\\t* `root` = `root.right` (Traverse the right subtree before printing `root`)\\n\\t* Keep iterating till `both` the below conditions are met -\\n\\t\\t* Stack is empty `and`\\n        * Root is NULL.\\n\\t\\n```\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tTreeNode pre=null;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.peek();\\n\\t\\t\\t\\tif(root.right==null || root.right==pre){\\n\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t    s.pop();\\n\\t\\t\\t\\t    pre=root;\\n\\t\\t\\t\\t    root = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t    root = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\\n\\n2) **Using 2 Stacks.** O(n) Time & O(n) Space\\nWe use two stacks. Stack `s` is used to find and traverse the child nodes, and `path` stack keeps track of the path from the `root` to the current node. (This is usefull in certain problems like [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [Path Sum](https://leetcode.com/problems/path-sum/) ). \\n    * Initially we push the `root` into `s`.\\n\\t* Keep iterating with below logic till `s` is `empty`.\\n\\t\\t* `root` = `s.peek()`\\n\\t\\t* If the top elements of both the stacks are not the same :\\t\\t\\n\\t\\t\\t* Print `root` and push it into `path`.\\n\\t\\t\\t* Push `root`\\'s children into `s` in reverse order. (Remember it\\'s a stack!)\\n\\t\\t* When top elements of both stacks are equal. (Which means we hit a deadend, and need to turn back)\\n\\t\\t\\t* `Pop` from `both` stacks.\\n\\t\\t\\n```\\n\\n\\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t    List<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.peek();\\n            if(!path.empty() && path.peek()==root){\\n                out.add(root.val);\\n\\t\\t    s.pop();\\n                path.pop();\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\\n\\n\\n3) **Using No Stacks (Morris Traversal).** O(n) Time & O(1) Space\\nInstead of using stacks to remember our way back up the tree, we are going to modify the tree to create upwards links. The idea is based on [Threaded Binary Tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). \\nSimilar to [Inorder Morris Traversal](https://discuss.leetcode.com/topic/64682/three-ways-of-iterative-inorder-traversing-easy-explanation).\\n![0_1477341646335_postorder.jpg](/uploads/files/1477341648349-postorder.jpg) \\nWe reverse each diagonal shown in the picture (d1-d4), print it and re-reverse it.\\n\\n\\t* Create a `dummy` node and make `dummy.left` = `root`.\\n\\t* `root` = `dummy`\\n\\t* Iterate till `root` is null.\\n\\t\\t* If `root` has a left child.\\n\\t\\t\\t* Find the `inorder predecessor` => `pre`. (Inorder predecessor of root is the right most child of its left child)\\n\\t\\t\\t\\t* `pre.right` = `root` (Make it point to root).\\n\\t\\t\\t\\t* `root` = `root.left`.\\n\\t\\t\\t* If its already pointing to root (which means we have traversed it already and are on our way up.)\\n\\t\\t\\t\\t* Reverse from `root.left` to `pre`.\\n\\t\\t\\t\\t* Traverse from `pre` to `root.left` and print the nodes.\\n\\t\\t\\t\\t* Re-reverse it back to normal.\\n\\t\\t\\t\\t* `pre.right` = `null`.\\n\\t\\t\\t\\t* `root` = `root.right`.\\n\\t\\t* If left child is `null`\\n\\t\\t\\t* `root` = `root.right`. (We are climbing up our link.)\\n\\t\\t\\t\\n```\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n\\tList<Integer> out = new ArrayList<Integer>();\\n\\tif(root == null)\\n\\t\\treturn out;\\n\\tTreeNode dummy = new TreeNode(-1), pre = null;\\n\\tdummy.left = root; root = dummy;\\n\\twhile(root != null){\\n\\t\\tif(root.left != null){\\n\\t\\t\\tpre = root.left;\\n\\t\\t\\twhile(pre.right != null && pre.right != root)\\n\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\tif(pre.right == null){\\n\\t\\t\\t\\tpre.right = root;\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tTreeNode node = pre;\\n\\t\\t\\t\\treverse(root.left,pre);\\n\\t\\t\\t\\twhile(node != root.left){\\n\\t\\t\\t\\t\\tout.add(node.val);\\n\\t\\t\\t\\t\\tnode = node.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tout.add(node.val);          // Print again since we are stopping at node=root.left\\n\\t\\t\\t\\treverse(pre,root.left);\\n\\t\\t\\t\\tpre.right = null;\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\troot = root.right;\\n\\t\\t}\\n\\t}\\n\\treturn out;\\n}\\n\\n```\\n    \\n    public void reverse(TreeNode from, TreeNode to){\\n        if(from == to)\\n            return;\\n        TreeNode prev = from, node = from.right;\\n        while(prev != to){\\n            TreeNode next = node.right;\\n            node.right = prev;\\n            prev = node;\\n            node = next;\\n        }\\n    }\\n\\n\\nAlso checkout [Inorder](https://discuss.leetcode.com/topic/64682/three-ways-of-iterative-inorder-traversing-easy-explanation)  & [PreOrder](https://discuss.leetcode.com/topic/64675/three-ways-of-iterative-preorder-traversing-easy-explanation)  :))",
                "solutionTags": [],
                "code": "```\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tTreeNode pre=null;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.peek();\\n\\t\\t\\t\\tif(root.right==null || root.right==pre){\\n\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t    s.pop();\\n\\t\\t\\t\\t    pre=root;\\n\\t\\t\\t\\t    root = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t    root = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\n```\\n\\n\\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t    List<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.peek();\\n            if(!path.empty() && path.peek()==root){\\n                out.add(root.val);\\n\\t\\t    s.pop();\\n                path.pop();\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\n```\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n\\tList<Integer> out = new ArrayList<Integer>();\\n\\tif(root == null)\\n\\t\\treturn out;\\n\\tTreeNode dummy = new TreeNode(-1), pre = null;\\n\\tdummy.left = root; root = dummy;\\n\\twhile(root != null){\\n\\t\\tif(root.left != null){\\n\\t\\t\\tpre = root.left;\\n\\t\\t\\twhile(pre.right != null && pre.right != root)\\n\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\tif(pre.right == null){\\n\\t\\t\\t\\tpre.right = root;\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tTreeNode node = pre;\\n\\t\\t\\t\\treverse(root.left,pre);\\n\\t\\t\\t\\twhile(node != root.left){\\n\\t\\t\\t\\t\\tout.add(node.val);\\n\\t\\t\\t\\t\\tnode = node.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tout.add(node.val);          // Print again since we are stopping at node=root.left\\n\\t\\t\\t\\treverse(pre,root.left);\\n\\t\\t\\t\\tpre.right = null;\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\troot = root.right;\\n\\t\\t}\\n\\t}\\n\\treturn out;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45621,
                "title": "preorder-inorder-and-postorder-traversal-iterative-java-solution",
                "content": "Postorder traversal : [Binary Tree Postorder Traversal][1]\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.empty()){\\n            root = stack.pop();\\n            list.add(0, root.val);\\n            if(root.left != null) stack.push(root.left);\\n            if(root.right != null) stack.push(root.right);\\n        }\\n        return list;\\n    }\\n\\n\\nPreorder traversal : [Binary Tree Preorder Traversal][2]\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.empty()){\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.right != null) stack.push(root.right);\\n            if(root.left != null) stack.push(root.left);\\n        }\\n        return list;\\n    }\\n\\n\\nInorder traversal : [Binary Tree Inorder Traversal][3]\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n        }\\n        return list;\\n    }\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n  [2]: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n  [3]: https://leetcode.com/problems/binary-tree-inorder-traversal/",
                "solutionTags": [
                    "Java"
                ],
                "code": "Postorder traversal : [Binary Tree Postorder Traversal][1]\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.empty()){\\n            root = stack.pop();\\n            list.add(0, root.val);\\n            if(root.left != null) stack.push(root.left);\\n            if(root.right != null) stack.push(root.right);\\n        }\\n        return list;\\n    }\\n\\n\\nPreorder traversal : [Binary Tree Preorder Traversal][2]\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.empty()){\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.right != null) stack.push(root.right);\\n            if(root.left != null) stack.push(root.left);\\n        }\\n        return list;\\n    }\\n\\n\\nInorder traversal : [Binary Tree Inorder Traversal][3]\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n        }\\n        return list;\\n    }\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n  [2]: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n  [3]: https://leetcode.com/problems/binary-tree-inorder-traversal/",
                "codeTag": "Unknown"
            },
            {
                "id": 45558,
                "title": "a-very-concise-solution",
                "content": "i have saw lots of post in this discussion, but most of them are not concise, just share mine for your  reference, writing a concise code is very important\\n  \\n    vector<int> postorderTraversal(TreeNode *root) {\\n        vector<int> v;\\n        if (!root) return v;\\n        \\n        stack<TreeNode *> s;\\n        s.push(root);\\n        \\n        TreeNode *p = NULL;\\n        while(!s.empty()) {\\n            p = s.top();\\n            s.pop();\\n            v.insert(v.begin(), p->val);\\n            if (p->left) s.push(p->left);\\n            if (p->right) s.push(p->right);\\n        }\\n        \\n        return v;\\n    }",
                "solutionTags": [],
                "code": "i have saw lots of post in this discussion, but most of them are not concise, just share mine for your  reference, writing a concise code is very important\\n  \\n    vector<int> postorderTraversal(TreeNode *root) {\\n        vector<int> v;\\n        if (!root) return v;\\n        \\n        stack<TreeNode *> s;\\n        s.push(root);\\n        \\n        TreeNode *p = NULL;\\n        while(!s.empty()) {\\n            p = s.top();\\n            s.pop();\\n            v.insert(v.begin(), p->val);\\n            if (p->left) s.push(p->left);\\n            if (p->right) s.push(p->right);\\n        }\\n        \\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45740,
                "title": "summary-of-preorder-inorder-postorder-four-traversal-ways-for-each",
                "content": "There are four traversal ways for each included recursive, iterative and morris traversal.\\n\\n**Recursive Way**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            return ([root.val] + sum(map(self.preorderTraversal, (root.left, root.right)), [])) if root else []\\n    \\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            if not root:\\n                return []\\n            \\n            left, right = map(self.inorderTraversal, (root.left, root.right))\\n            return left + [root.val] + right\\n    \\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            return (sum(map(self.postorderTraversal, (root.left, root.right)), []) + [root.val]) if root else []\\n\\n**Iterative Way With Stack + Visited State**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r = [[root, 0]], []\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n    \\n                    if top[0].left:\\n                        stack.append([top[0].left, 0])\\n            return r\\n \\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r, poped = [[root, 0]], [], False\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    poped = True\\n    \\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n                        poped = False\\n    \\n                elif top[0].left and not poped:\\n                    stack.append([top[0].left, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n            return r\\n    \\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r = [[root, 0]], []\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    if top[0].left:\\n                        stack.append([top[0].left, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n    \\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n    \\n            return r[::-1]\\n\\n**Iterative Way With Stack**\\n\\nThis way was inspired by [Preorder, Inorder, and Postorder Iteratively Summarization][1]\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    stack.append(root)\\n                    r.append(root.val)\\n                    root = root.left\\n                else:\\n                    root = stack.pop().right\\n            return r\\n\\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    stack.append(root)\\n                    root = root.left\\n                else:\\n                    root = stack.pop()\\n                    r.append(root.val)\\n                    root = root.right\\n            return r\\n\\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    r.append(root.val)\\n                    stack.append(root)\\n                    root = root.right\\n                else:\\n                    root = stack.pop().left\\n    \\n            return r[::-1]\\n\\n**Morris Traversal Way**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.left:\\n                    r.append(root.val)\\n                    root = root.right\\n                else:\\n                    pre = root.left\\n                    while pre.right and pre.right != root:\\n                        pre = pre.right\\n    \\n                    if not pre.right:\\n                        r.append(root.val)\\n                        pre.right = root\\n                        root = root.left\\n                    else:\\n                        root = root.right\\n            return r\\n\\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.left:\\n                    r.append(root.val)\\n                    root = root.right\\n                else:\\n                    pre = root.left\\n                    while pre.right and pre.right != root:\\n                        pre = pre.right\\n    \\n                    if not pre.right:\\n                        pre.right = root\\n                        root = root.left\\n                    else:\\n                        r.append(root.val)\\n                        root = root.right\\n            return r\\n\\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.right:\\n                    r.append(root.val)\\n                    root = root.left\\n                else:\\n                    next = root.right\\n                    while next.left and next.left != root:\\n                        next = next.left\\n    \\n                    if not next.left:\\n                        r.append(root.val)\\n                        next.left = root\\n                        root = root.right\\n                    else:\\n                        root = root.left\\n            return r[::-1]\\n\\n  [1]: https://leetcode.com/discuss/71943/preorder-inorder-and-postorder-iteratively-summarization",
                "solutionTags": [
                    "Python"
                ],
                "code": "There are four traversal ways for each included recursive, iterative and morris traversal.\\n\\n**Recursive Way**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            return ([root.val] + sum(map(self.preorderTraversal, (root.left, root.right)), [])) if root else []\\n    \\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            if not root:\\n                return []\\n            \\n            left, right = map(self.inorderTraversal, (root.left, root.right))\\n            return left + [root.val] + right\\n    \\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            return (sum(map(self.postorderTraversal, (root.left, root.right)), []) + [root.val]) if root else []\\n\\n**Iterative Way With Stack + Visited State**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r = [[root, 0]], []\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n    \\n                    if top[0].left:\\n                        stack.append([top[0].left, 0])\\n            return r\\n \\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r, poped = [[root, 0]], [], False\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    poped = True\\n    \\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n                        poped = False\\n    \\n                elif top[0].left and not poped:\\n                    stack.append([top[0].left, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n            return r\\n    \\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r = [[root, 0]], []\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    if top[0].left:\\n                        stack.append([top[0].left, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n    \\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n    \\n            return r[::-1]\\n\\n**Iterative Way With Stack**\\n\\nThis way was inspired by [Preorder, Inorder, and Postorder Iteratively Summarization][1]\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    stack.append(root)\\n                    r.append(root.val)\\n                    root = root.left\\n                else:\\n                    root = stack.pop().right\\n            return r\\n\\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    stack.append(root)\\n                    root = root.left\\n                else:\\n                    root = stack.pop()\\n                    r.append(root.val)\\n                    root = root.right\\n            return r\\n\\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    r.append(root.val)\\n                    stack.append(root)\\n                    root = root.right\\n                else:\\n                    root = stack.pop().left\\n    \\n            return r[::-1]\\n\\n**Morris Traversal Way**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.left:\\n                    r.append(root.val)\\n                    root = root.right\\n                else:\\n                    pre = root.left\\n                    while pre.right and pre.right != root:\\n                        pre = pre.right\\n    \\n                    if not pre.right:\\n                        r.append(root.val)\\n                        pre.right = root\\n                        root = root.left\\n                    else:\\n                        root = root.right\\n            return r\\n\\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.left:\\n                    r.append(root.val)\\n                    root = root.right\\n                else:\\n                    pre = root.left\\n                    while pre.right and pre.right != root:\\n                        pre = pre.right\\n    \\n                    if not pre.right:\\n                        pre.right = root\\n                        root = root.left\\n                    else:\\n                        r.append(root.val)\\n                        root = root.right\\n            return r\\n\\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.right:\\n                    r.append(root.val)\\n                    root = root.left\\n                else:\\n                    next = root.right\\n                    while next.left and next.left != root:\\n                        next = next.left\\n    \\n                    if not next.left:\\n                        r.append(root.val)\\n                        next.left = root\\n                        root = root.right\\n                    else:\\n                        root = root.left\\n            return r[::-1]\\n\\n  [1]: https://leetcode.com/discuss/71943/preorder-inorder-and-postorder-iteratively-summarization",
                "codeTag": "Java"
            },
            {
                "id": 45786,
                "title": "python-recursive-and-iterative-solutions",
                "content": "        \\n    # recursively \\n    def postorderTraversal1(self, root):\\n        res = []\\n        self.dfs(root, res)\\n        return res\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            self.dfs(root.left, res)\\n            self.dfs(root.right, res)\\n            res.append(root.val)\\n    \\n    # iteratively        \\n    def postorderTraversal(self, root):\\n        res, stack = [], [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.left)\\n                stack.append(node.right)\\n        return res[::-1]",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    # recursively \\n    def postorderTraversal1(self, root):\\n        res = []\\n        self.dfs(root, res)\\n        return res\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            self.dfs(root.left, res)\\n            self.dfs(root.right, res)\\n            res.append(root.val)\\n    \\n    # iteratively        \\n    def postorderTraversal(self, root):\\n        res, stack = [], [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.left)\\n                stack.append(node.right)\\n        return res[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 45803,
                "title": "java-solution-using-two-stacks",
                "content": "    public List<Integer> postorderTraversal(TreeNode root) {\\n      List<Integer> res = new ArrayList<Integer>();\\n      \\n      if (root == null)\\n        return res;\\n          \\n      Stack<TreeNode> s1 = new Stack<TreeNode>();\\n      Stack<TreeNode> s2 = new Stack<TreeNode>();\\n      \\n      s1.push(root);\\n      \\n      while (!s1.isEmpty()) {\\n        TreeNode node = s1.pop();\\n        s2.push(node);\\n        \\n        if (node.left != null)\\n          s1.push(node.left);\\n        \\n        if (node.right != null)\\n          s1.push(node.right);\\n      }\\n      \\n      while (!s2.isEmpty())\\n        res.add(s2.pop().val);\\n      \\n      return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> postorderTraversal(TreeNode root) {\\n      List<Integer> res = new ArrayList<Integer>();\\n      \\n      if (root == null)\\n        return res;\\n          \\n      Stack<TreeNode> s1 = new Stack<TreeNode>();\\n      Stack<TreeNode> s2 = new Stack<TreeNode>();\\n      \\n      s1.push(root);\\n      \\n      while (!s1.isEmpty()) {\\n        TreeNode node = s1.pop();\\n        s2.push(node);\\n        \\n        if (node.left != null)\\n          s1.push(node.left);\\n        \\n        if (node.right != null)\\n          s1.push(node.right);\\n      }\\n      \\n      while (!s2.isEmpty())\\n        res.add(s2.pop().val);\\n      \\n      return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45539,
                "title": "iterative-method-to-do-three-kinds-of-traversal-just-like-recursive-method-only-changing-one-line-code",
                "content": "For three different kinds of traversal, we only need to change the order of tuples in one line as we've done this in the recursive solution which is very decent and classical. Just put `(0, p[1])` in different position!\\n\\nFor post-order traversal:\\n\\n    def postorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(0, p[1]), (1, p[1].right), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val)\\n        return res\\n\\nFor in-order traversal:\\n\\n    def inorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(1, p[1].right), (0, p[1]), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val)\\n        return res\\n\\n\\nFor pre-order traversal:\\n\\n    def preorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(1, p[1].right), (1, p[1].left), (0, p[1])]) if p[0] != 0 else res.append(p[1].val)\\n        return res",
                "solutionTags": [],
                "code": "For three different kinds of traversal, we only need to change the order of tuples in one line as we've done this in the recursive solution which is very decent and classical. Just put `(0, p[1])` in different position!\\n\\nFor post-order traversal:\\n\\n    def postorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(0, p[1]), (1, p[1].right), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val)\\n        return res\\n\\nFor in-order traversal:\\n\\n    def inorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(1, p[1].right), (0, p[1]), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val)\\n        return res\\n\\n\\nFor pre-order traversal:\\n\\n    def preorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(1, p[1].right), (1, p[1].left), (0, p[1])]) if p[0] != 0 else res.append(p[1].val)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 45640,
                "title": "an-extremly-straightforward-way-to-write-iterative-code-from-recursions-for-dummies",
                "content": "Here I provide a very straightforward and general way to transform recursion into iterative code. This works especially well for dummies like me.\\n\\nAs we know, the recursion code is very easy to write\\n```\\n    void recursion(TreeNode * cur, vector<int> & result) {\\n        if (cur->left) recursion(cur->left);        // line 0\\n        if (cur->right) recursion(cur->right);      // line 1\\n        result.push_back(cur->val);                 // line 2\\n        return;                                     // line 3\\n    }\\n```\\n\\nThe difficulty is to write the iterative version of such code. I fully mimic the function call stacks. I maintain two stacks: variable stack and pc stack (pc stands for programming counter). Here the variable stack maintains the value of each variable of each function call in the recursion. The pc stack stores the **line of code that is to be executed in each corresponding function**\\n\\nThe entry point in the recursion code is to call recursion(root) function. Hence, in the iterative version of the code, we push root to the variable stack, and 0 to the pc stack. This means that the first line (line 0) of recursion(root) function is to be executed.\\n\\nThen I execute the following loop until the stack is empty.\\n1. Inspect the top of the pc stack. Then increment the top of pc stack, which means that the current line of code has been executed.\\n2. If pc == 0, push the left child of the top of the variable stack to the stack if such child exists. Also push 0 to the pc stack.\\n3. If pc == 1, push the right child of the top of the variable stack to the stack if such child exists. Also push 0 to the pc stack.\\n4. if pc == 2, append the value of the top of the variable stack to the result.\\n5. If pc == 3, pop both variable and pc stack.\\n\\nYou can find pc here fully corresponds to the line number in the previous recursion code! \\n\\nThe complete code is following.\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode *> varStack;\\n        stack<int> PCStack;\\n        vector<int> result;\\n        if (!root) return result;\\n        varStack.push(root);\\n        PCStack.push(0);\\n        while (!varStack.empty()) {\\n            TreeNode * cur = varStack.top();\\n            int pc = PCStack.top();\\n            PCStack.top()++;\\n            if (pc == 0) {\\n                // line 0: if (cur->left) recursion(cur->left); \\n                if (cur->left) {\\n                    varStack.push(cur->left);\\n                    PCStack.push(0);\\n                }\\n            }\\n            else if (pc == 1) {\\n                // line 1: if (cur->right) recursion(cur->right); \\n                if (cur->right) {\\n                    varStack.push(cur->right);\\n                    PCStack.push(0);\\n                }\\n            }\\n            else if (pc == 2) {\\n                // line 2: result.push_back(cur->val);\\n                result.push_back(cur->val);\\n            }\\n            else if (pc == 3) {\\n                // line 3: return\\n                varStack.pop();\\n                PCStack.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nYes it is LONG. But it is extremely easy to write, since you are simply simulating how the computer does for recursion.\\n\\nThe most **amazing** part of such method is that, it works for all recursions!!! I think that it also shows your understanding of call stacks if you analyze recursion in such a straightforward way.",
                "solutionTags": [],
                "code": "```\\n    void recursion(TreeNode * cur, vector<int> & result) {\\n        if (cur->left) recursion(cur->left);        // line 0\\n        if (cur->right) recursion(cur->right);      // line 1\\n        result.push_back(cur->val);                 // line 2\\n        return;                                     // line 3\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode *> varStack;\\n        stack<int> PCStack;\\n        vector<int> result;\\n        if (!root) return result;\\n        varStack.push(root);\\n        PCStack.push(0);\\n        while (!varStack.empty()) {\\n            TreeNode * cur = varStack.top();\\n            int pc = PCStack.top();\\n            PCStack.top()++;\\n            if (pc == 0) {\\n                // line 0: if (cur->left) recursion(cur->left); \\n                if (cur->left) {\\n                    varStack.push(cur->left);\\n                    PCStack.push(0);\\n                }\\n            }\\n            else if (pc == 1) {\\n                // line 1: if (cur->right) recursion(cur->right); \\n                if (cur->right) {\\n                    varStack.push(cur->right);\\n                    PCStack.push(0);\\n                }\\n            }\\n            else if (pc == 2) {\\n                // line 2: result.push_back(cur->val);\\n                result.push_back(cur->val);\\n            }\\n            else if (pc == 3) {\\n                // line 3: return\\n                varStack.pop();\\n                PCStack.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443702,
                "title": "easy-recursive-iterative-100-explained-java-c-python-python3",
                "content": "# **Java Solution (Iterative Approach Using Stack):**\\nRuntime: 1 ms, faster than 89.81% of Java online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 42 MB, less than 74.94% of Java online submissions for Binary Tree Postorder Traversal.\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        // Create an array list to store the solution result...\\n        List<Integer> sol = new ArrayList<Integer>();\\n        // Return the solution answer if the tree is empty...\\n        if(root==null) return sol;\\n        // Create an empty stack and push the root node...\\n        Stack<TreeNode> bag = new Stack<TreeNode>();\\n        bag.push(root);\\n        // Loop till stack is empty...\\n        while(!bag.isEmpty()) {\\n            // set peek a node from the stack...\\n            TreeNode node = bag.peek();\\n            // If the subtrees of that node are null, then pop & store the pop value into solution result...\\n            if(node.left==null && node.right==null) {\\n                TreeNode pop = bag.pop();\\n                sol.add(pop.val);\\n            }\\n            else {\\n                // Push the right child of the popped node into the stack...\\n                if(node.right!=null) {\\n                    bag.push(node.right);\\n                    node.right = null;\\n                }\\n                // Push the left child of the popped node into the stack...\\n                if(node.left!=null) {\\n                    bag.push(node.left);\\n                    node.left = null;\\n                }\\n            }\\n        }\\n        return sol;     // Return the solution list...\\n    }\\n}\\n```\\n\\n# **C++ Solution: (Recursive Approach)**\\nRuntime: 1 ms, faster than 93.22% of C++ online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 8.3 MB, less than 96.14% of C++ online submissions for Binary Tree Postorder Traversal.\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> sol;\\n        postorder(root, sol);\\n        return sol;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector<int>& sol) {\\n        if (!root)\\n            return;\\n        postorder(root->left, sol);\\n        postorder(root->right, sol);\\n        sol.push_back(root->val);\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution (Iterative Approach Using Stack):**\\n```\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        # Base case...\\n        if not root: return []\\n        # Create an array list to store the solution result...\\n        sol = []\\n        # Create an empty stack and push the root node...\\n        bag = [root]\\n        # Loop till stack is empty...\\n        while bag:\\n            # Pop a node from the stack...\\n            node = bag.pop()\\n            sol.append(node.val)\\n            # Push the left child of the popped node into the stack...\\n            if node.left:\\n                bag.append(node.left)\\n            # Append the right child of the popped node into the stack...\\n            if node.right:\\n                bag.append(node.right)\\n        return sol[::-1]       # Return the solution list...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        // Create an array list to store the solution result...\\n        List<Integer> sol = new ArrayList<Integer>();\\n        // Return the solution answer if the tree is empty...\\n        if(root==null) return sol;\\n        // Create an empty stack and push the root node...\\n        Stack<TreeNode> bag = new Stack<TreeNode>();\\n        bag.push(root);\\n        // Loop till stack is empty...\\n        while(!bag.isEmpty()) {\\n            // set peek a node from the stack...\\n            TreeNode node = bag.peek();\\n            // If the subtrees of that node are null, then pop & store the pop value into solution result...\\n            if(node.left==null && node.right==null) {\\n                TreeNode pop = bag.pop();\\n                sol.add(pop.val);\\n            }\\n            else {\\n                // Push the right child of the popped node into the stack...\\n                if(node.right!=null) {\\n                    bag.push(node.right);\\n                    node.right = null;\\n                }\\n                // Push the left child of the popped node into the stack...\\n                if(node.left!=null) {\\n                    bag.push(node.left);\\n                    node.left = null;\\n                }\\n            }\\n        }\\n        return sol;     // Return the solution list...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> sol;\\n        postorder(root, sol);\\n        return sol;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector<int>& sol) {\\n        if (!root)\\n            return;\\n        postorder(root->left, sol);\\n        postorder(root->right, sol);\\n        sol.push_back(root->val);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        # Base case...\\n        if not root: return []\\n        # Create an array list to store the solution result...\\n        sol = []\\n        # Create an empty stack and push the root node...\\n        bag = [root]\\n        # Loop till stack is empty...\\n        while bag:\\n            # Pop a node from the stack...\\n            node = bag.pop()\\n            sol.append(node.val)\\n            # Push the left child of the popped node into the stack...\\n            if node.left:\\n                bag.append(node.left)\\n            # Append the right child of the popped node into the stack...\\n            if node.right:\\n                bag.append(node.right)\\n        return sol[::-1]       # Return the solution list...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354194,
                "title": "python-iterative-method-for-post-in-preorder-traversal",
                "content": "I add ```isinstance``` method to judge what type the value popup from stack. By adding the judge, we can easily simulate system stack and get right order. Hope it is helpful\\n```\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root]\\n        res = []\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                if isinstance(temp, TreeNode):\\n                    stack.append(temp.right)\\n                    stack.append(temp.val)\\n                    stack.append(temp.left)\\n                else:\\n                    res.append(temp)\\n        return res\\n```\\n\\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root]\\n        res = []\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                if isinstance(temp, TreeNode):\\n                    stack.append(temp.val)\\n                    stack.append(temp.right)\\n                    stack.append(temp.left)\\n                else:\\n                    res.append(temp)\\n        return res\\n```\\n\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root]\\n        res = []\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                if isinstance(temp, TreeNode):\\n                    stack.append(temp.right)\\n                    stack.append(temp.left)\\n                    stack.append(temp.val)\\n                else:\\n                    res.append(temp)\\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```isinstance```\n```\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root]\\n        res = []\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                if isinstance(temp, TreeNode):\\n                    stack.append(temp.right)\\n                    stack.append(temp.val)\\n                    stack.append(temp.left)\\n                else:\\n                    res.append(temp)\\n        return res\\n```\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root]\\n        res = []\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                if isinstance(temp, TreeNode):\\n                    stack.append(temp.val)\\n                    stack.append(temp.right)\\n                    stack.append(temp.left)\\n                else:\\n                    res.append(temp)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1026669,
                "title": "simple-java-iterative-postorder-traversal-using-one-stack",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        \\n        if(root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        // We will have a pointer to the recently popped node\\n        TreeNode curr = root, prev = null;\\n        \\n        while(curr != null || !stack.isEmpty()) {\\n            // Keep on iterating towards the leftmost node\\n            while(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // If there is no right child\\n            // or right child is the one that we recently visited\\n            // it means we have traversed all the nodes of stack.peek()\\n            \\n            if(stack.peek().right == null || stack.peek().right == prev) {\\n                // we will update the prev node\\n                prev = stack.pop();\\n                ans.add(prev.val);\\n            } else {\\n                // Otherwise we will visit the right child.\\n                curr = stack.peek().right;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        \\n        if(root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        // We will have a pointer to the recently popped node\\n        TreeNode curr = root, prev = null;\\n        \\n        while(curr != null || !stack.isEmpty()) {\\n            // Keep on iterating towards the leftmost node\\n            while(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // If there is no right child\\n            // or right child is the one that we recently visited\\n            // it means we have traversed all the nodes of stack.peek()\\n            \\n            if(stack.peek().right == null || stack.peek().right == prev) {\\n                // we will update the prev node\\n                prev = stack.pop();\\n                ans.add(prev.val);\\n            } else {\\n                // Otherwise we will visit the right child.\\n                curr = stack.peek().right;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869679,
                "title": "c-iterative-solution-with-1-stack",
                "content": "A solution I found on Chinese site. \\nIt is really amazing so I want to share it. \\nIt uses only 1 stack and does not need extra space like queue or auxiliary stack.\\nThe trick is to use a `nullptr`(or anything markable) to mark a parent node. When we find a `nullptr` on the top of the stack, it means that all children nodes of a node (which is under the current `nullptr`) has been visited. So we can pop it (and of course, the mark `nullptr`).\\n\\n### Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        if(root)stk.push(root);\\n        vector<int> ans;\\n        while(stk.size())\\n        {\\n            auto p = stk.top();\\n            //All children nodes are visited\\n            if(p == nullptr)\\n            {\\n                stk.pop();\\n                ans.push_back(stk.top()->val);\\n                stk.pop();\\n                continue;\\n            }\\n            //Use nullptr to mark parent node\\n            stk.push(nullptr);\\n            //last in first out\\n            if(p->right)stk.push(p->right);\\n            if(p->left)stk.push(p->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        if(root)stk.push(root);\\n        vector<int> ans;\\n        while(stk.size())\\n        {\\n            auto p = stk.top();\\n            //All children nodes are visited\\n            if(p == nullptr)\\n            {\\n                stk.pop();\\n                ans.push_back(stk.top()->val);\\n                stk.pop();\\n                continue;\\n            }\\n            //Use nullptr to mark parent node\\n            stk.push(nullptr);\\n            //last in first out\\n            if(p->right)stk.push(p->right);\\n            if(p->left)stk.push(p->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527604,
                "title": "python3-pre-in-post-iteratively-summarization",
                "content": "### [Python3] Pre, In, Post Iteratively Summarization\\n\\nIn preorder, the order should be\\n\\n**root -> left -> right**\\n\\nBut when we use stack, the order should be reversed:\\n\\n**right -> left -> root**\\n\\n**Pre**\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n\\t\\t\\n```\\n<br>\\n<br>  \\nIn inorder, the order should be\\n\\n**left -> root -> right**\\n\\nBut when we use stack, the order should be reversed:\\n\\n**right -> root -> left**\\n\\n**In**\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n\\t\\t\\n```\\n<br>\\n<br>\\nIn postorder, the order should be\\n\\n**left -> right -> root**\\n\\nBut when we use stack, the order should be reversed:\\n\\n**root -> right -> left**\\n\\n**Post**\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n\\t\\t\\n```\\nIf you like this solution, please click \"Star\" on Github:\\nhttps://github.com/ceezyyy/LeetCode-daily/blob/master/Python3/145.Binary%20Tree%20Postorder%20Traversal.py\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912651,
                "title": "python-easy-to-remember-different-order-traversal-by-one-template",
                "content": "It depends on `res.append(node.val)` location \\n\\n**Template**\\n```\\nclass Solution:\\n    def Traversal(self, root: Optional[TreeNode]):\\n\\t\\tstack = []\\n\\t\\tnode = root \\n\\t\\twhile node or stack:\\n\\t\\t\\twhile node:\\n\\t\\t\\t\\tstack.append(node)\\n\\t\\t\\t\\tnode = node.left\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tnode = node.right\\n\\n```\\n\\n**Preorder**\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root \\n        while node or stack:\\n            while node:\\n                res.append(node.val) ###\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            node = node.right\\n        \\n        return res\\n\\n```\\n\\n**Inorder**\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val) ###\\n            node = node.right\\n        \\n        return res\\n```\\n**Postorder**\\n![image](https://assets.leetcode.com/users/images/c07b2fc1-16b8-45df-b0d6-3202b399d318_1649147321.7663379.png)\\n\\nPostorder traversal gets value when we back from right node so we use \"pushing twice strategy\"\\nFirst \"H\" node pop from stack when we back from left node\\nSecond \"H\" node pop from stack when we back from right node\\nver1\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append((node, 2)) \\n                stack.append((node, 1))\\n                node = node.left\\n                \\n            node, seen = stack.pop()\\n            if seen == 2:\\n                res.append(node.val) ###\\n                node = None\\n            else:\\n                node = node.right\\n        \\n        return res\\n```\\nver2\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append([node, 1])\\n                node = node.left                \\n            node, seen = stack[-1]\\n            if seen == 2:\\n                node, seen = stack.pop()\\n                res.append(node.val)\\n                node = None\\n            else:\\n                stack[-1][1] = 2\\n                node = node.right\\n        \\n        return res\\n```\\n\\n**worst  case O(N^2) recursive**\\nbecause list + list  is a N operation\\n\\n**Preorder recursive**\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            [root.val] +\\n            self.preorderTraversal(root.left) +\\n            self.preorderTraversal(root.right)\\n        )\\n```\\n**Inorder recursive**\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            self.inorderTraversal(root.left) +\\n            [root.val] +\\n            self.inorderTraversal(root.right)\\n        )\\n```\\n**Postorder recursive**\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            self.postorderTraversal(root.left) +\\n            self.postorderTraversal(root.right) +\\n            [root.val] \\n        )\\n```\\n\\n**O(N)**\\n\\n**Preorder recursive**\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t\\t\\tarr.append(node.val)\\n\\t    \\tdfs(node.left)\\n\\t    \\tdfs(node.right)\\n\\t    dfs(root)\\n\\t    return arr\\n```\\n**Inorder recursive**\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t    \\tdfs(node.left)\\n\\t\\t\\tarr.append(node.val)\\n\\t    \\tdfs(node.right)\\n\\t    dfs(root)\\n\\t    return arr\\n```\\n**Postorder recursive**\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t    \\tdfs(node.left)\\n\\t    \\tdfs(node.right)\\n\\t    \\tarr.append(node.val)\\n\\t    dfs(root)\\n\\t    return arr\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def Traversal(self, root: Optional[TreeNode]):\\n\\t\\tstack = []\\n\\t\\tnode = root \\n\\t\\twhile node or stack:\\n\\t\\t\\twhile node:\\n\\t\\t\\t\\tstack.append(node)\\n\\t\\t\\t\\tnode = node.left\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tnode = node.right\\n\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root \\n        while node or stack:\\n            while node:\\n                res.append(node.val) ###\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            node = node.right\\n        \\n        return res\\n\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val) ###\\n            node = node.right\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append((node, 2)) \\n                stack.append((node, 1))\\n                node = node.left\\n                \\n            node, seen = stack.pop()\\n            if seen == 2:\\n                res.append(node.val) ###\\n                node = None\\n            else:\\n                node = node.right\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append([node, 1])\\n                node = node.left                \\n            node, seen = stack[-1]\\n            if seen == 2:\\n                node, seen = stack.pop()\\n                res.append(node.val)\\n                node = None\\n            else:\\n                stack[-1][1] = 2\\n                node = node.right\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            [root.val] +\\n            self.preorderTraversal(root.left) +\\n            self.preorderTraversal(root.right)\\n        )\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            self.inorderTraversal(root.left) +\\n            [root.val] +\\n            self.inorderTraversal(root.right)\\n        )\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            self.postorderTraversal(root.left) +\\n            self.postorderTraversal(root.right) +\\n            [root.val] \\n        )\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t\\t\\tarr.append(node.val)\\n\\t    \\tdfs(node.left)\\n\\t    \\tdfs(node.right)\\n\\t    dfs(root)\\n\\t    return arr\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t    \\tdfs(node.left)\\n\\t\\t\\tarr.append(node.val)\\n\\t    \\tdfs(node.right)\\n\\t    dfs(root)\\n\\t    return arr\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t    \\tdfs(node.left)\\n\\t    \\tdfs(node.right)\\n\\t    \\tarr.append(node.val)\\n\\t    dfs(root)\\n\\t    return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498697,
                "title": "c-using-1-stack-iterative-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return {};\\n        }\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while(!s.empty()){\\n            TreeNode* curr = s.top();\\n            if(curr->left){\\n                s.push(curr->left);\\n                curr->left = NULL;\\n            }\\n            else{\\n                if(curr->right){\\n                    s.push(curr->right);\\n                    curr->right = NULL;\\n                }\\n                else{\\n                    ans.push_back(curr->val);\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you like this solution then please upvote this solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return {};\\n        }\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while(!s.empty()){\\n            TreeNode* curr = s.top();\\n            if(curr->left){\\n                s.push(curr->left);\\n                curr->left = NULL;\\n            }\\n            else{\\n                if(curr->right){\\n                    s.push(curr->right);\\n                    curr->right = NULL;\\n                }\\n                else{\\n                    ans.push_back(curr->val);\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45674,
                "title": "accepted-tiny-java-solution-only-left-hand-children-in-stack",
                "content": "Share my solution using stack and LinkedList.\\n\\nNotes:\\n\\n 1. In this code I push only left-hand children in to the stack.\\n 2. To store result I use LinkedList and addFirst() method of it.\\n     With such approuch we can save on reverce the result.\\n\\n----------\\n\\n    public List<Integer> postorderTraversal(TreeNode node) {\\n\\t\\tLinkedList<Integer> result = new LinkedList<Integer>();\\n\\t\\tStack<TreeNode> leftChildren = new Stack<TreeNode>();\\n\\t\\twhile(node != null) {\\n\\t\\t\\tresult.addFirst(node.val);\\n\\t\\t\\tif (node.left != null) {\\n\\t\\t\\t\\tleftChildren.push(node.left);\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.right;\\n\\t\\t\\tif (node == null && !leftChildren.isEmpty()) {\\n\\t\\t\\t\\tnode = leftChildren.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Share my solution using stack and LinkedList.\\n\\nNotes:\\n\\n 1. In this code I push only left-hand children in to the stack.\\n 2. To store result I use LinkedList and addFirst() method of it.\\n     With such approuch we can save on reverce the result.\\n\\n----------\\n\\n    public List<Integer> postorderTraversal(TreeNode node) {\\n\\t\\tLinkedList<Integer> result = new LinkedList<Integer>();\\n\\t\\tStack<TreeNode> leftChildren = new Stack<TreeNode>();\\n\\t\\twhile(node != null) {\\n\\t\\t\\tresult.addFirst(node.val);\\n\\t\\t\\tif (node.left != null) {\\n\\t\\t\\t\\tleftChildren.push(node.left);\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.right;\\n\\t\\t\\tif (node == null && !leftChildren.isEmpty()) {\\n\\t\\t\\t\\tnode = leftChildren.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1104634,
                "title": "java-iterative-with-one-stack-and-no-hack-wiki",
                "content": "See more in https://en.wikipedia.org/wiki/Tree_traversal#Post-order\\n1. Just like with in-order traversal we go to the left subtree as long as we can. At the same time we keep adding the nodes to the stack.\\n2. If we can\\'t (left = null) - we try to go to the right subtree. In order to do that we check the last one we added to the stack.\\n3. If it has a right subtree and we haven\\'t visited it yet then we go there and repeat steps 1 and 2.\\n4. Else we visit the node (also pop out of the stack) \\'cause by that time we visited left and right subtrees snd it\\'s time to visit their parent. After that we continue the outer loop, peek another node from the stack and repeat 2, 3.\\n\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode cur = root, lastVisited = null;\\n        \\n        while (!stack.isEmpty() || cur != null) {\\n            if (cur != null) {\\n                stack.addLast(cur);\\n                cur = cur.left;\\n            } else {\\n                TreeNode peek = stack.peekLast();\\n                if (peek.right != null && peek.right != lastVisited) {\\n                    cur = peek.right;\\n                } else {\\n                    res.add(peek.val);\\n                    lastVisited = stack.removeLast();\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode cur = root, lastVisited = null;\\n        \\n        while (!stack.isEmpty() || cur != null) {\\n            if (cur != null) {\\n                stack.addLast(cur);\\n                cur = cur.left;\\n            } else {\\n                TreeNode peek = stack.peekLast();\\n                if (peek.right != null && peek.right != lastVisited) {\\n                    cur = peek.right;\\n                } else {\\n                    res.add(peek.val);\\n                    lastVisited = stack.removeLast();\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774726,
                "title": "c-iterative-stack-based",
                "content": "\\n\\n      class Solution {\\n      public:\\n          vector<int> postorderTraversal(TreeNode* root) {\\n              if(root==NULL)\\n                  return {};\\n              stack<TreeNode*> s1;\\n              stack<TreeNode*> s2;\\n              vector<int> vec;\\n              s1.push(root);\\n              while(!s1.empty()){\\n                  root=s1.top();\\n                  s1.pop();\\n                  if(root->left!=NULL){\\n                      s1.push(root->left);\\n                  }\\n                  if(root->right!=NULL){\\n                      s1.push(root->right);\\n                  }\\n                  s2.push(root);\\n              }\\n              while(!s2.empty()){\\n                  vec.push_back(s2.top()->val);\\n                  s2.pop();\\n              }\\n              return vec;\\n          }\\n      };\\n\\t  \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n      public:\\n          vector<int> postorderTraversal(TreeNode* root) {\\n              if(root==NULL)\\n                  return {}",
                "codeTag": "Java"
            },
            {
                "id": 158289,
                "title": "python-dfs-stack",
                "content": "### 145. Binary Tree Postorder Traversal\\n```\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS Recursive\\n```python\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n    \\n    def dfs(self, root):\\n        if not root:\\n            return \\n        self.dfs(root.left)\\n        self.dfs(root.right) \\n        self.res.append(root.val)\\n```\\n<br>\\n\\n#### Stack (Reverse Preorder)\\n\\n\\u5229\\u7528Postorder\\u548CPreorder\\u7684\\u5173\\u7CFB\\uFF0C\\u53D6\\u5DE7\\u7684\\u5148\\u8FED\\u4EE3\\u53F3\\u8FB9\\u5B50\\u5B59\\uFF0C\\u6700\\u540E\\u8FD4\\u56DEreversed\\u7684List\\u5373\\u53EF\\uFF0C\\u8111\\u5B50\\u6655\\u7684\\u5C0F\\u4F19\\u4F34\\u53BB\\u753B\\u5F20\\u56FE\\u5373\\u53EF\\u3002\\n\\n```python\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        stack, res = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                res.append(root.val)    \\n                root = root.right     #\\u5148\\u52A0\\u53F3\\u8FB9\\uFF0C\\u5728\\u5DE6\\u8FB9\\u3002\\n            else:\\n                node = stack.pop()\\n                root = node.left\\n        return res[::-1]     #\\u8FD4\\u56DEReversed\\u7684list\\n```\\n<br>\\n\\n#### Stack (\\u5229\\u7528Flag)\\n\\n\\u6BCF\\u6B21\\u5F80Stack\\u91CC\\u9762\\u50A8\\u5B58\\u7684\\u987A\\u5E8F\\u662F\\uFF0C\\u5148\\u5B58\\u50A8\\u5F53\\u524D`root`\\uFF0C\\u7136\\u540E`right`\\uFF0C\\u6700\\u540E`left`\\uFF0C\\u8FD9\\u6837\\u5F53pop\\u5230\\u6700\\u5DE6\\u8FB9\\u53F6\\u5B50\\u8282\\u70B9\\u7684\\u65F6\\u5019\\uFF0C\\u5C31\\u4E3A\\u7B2C\\u4E00\\u4E2A`print`\\u7684\\u6570\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u6BCF\\u6B21`pop`\\u5B8C\\u4E4B\\u540E\\u7684`root`\\u4E4B\\u540E\\u8FD8\\u4F1A\\u7528\\u5230\\uFF0C\\u6240\\u4EE5\\u8FD9\\u91CC\\u5229\\u7528flag\\uFF0C\\u6BCF\\u6B21\\u53CA\\u65F6\\u4F7F\\u7528\\u5B8C`root`\\u4E5F\\u5C06root\\u91CD\\u65B0\\u653E\\u56DEstack\\uFF0C\\u5728\\u4E4B\\u540Epop\\u8FC7\\u7A0B\\u4E2D\\u518D\\u68C0\\u67E5flag\\uFF0C\\u5982\\u679Cvisited\\u8FC7\\uFF0C\\u5219\\u4E0D\\u518D\\u653E\\u56DEstack\\u3002\\n\\n```\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n    \\n    def dfs(self, root):\\n        if not root:\\n            return \\n        self.dfs(root.left)\\n        self.dfs(root.right) \\n        self.res.append(root.val)\\n```\n```python\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        stack, res = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                res.append(root.val)    \\n                root = root.right     #\\u5148\\u52A0\\u53F3\\u8FB9\\uFF0C\\u5728\\u5DE6\\u8FB9\\u3002\\n            else:\\n                node = stack.pop()\\n                root = node.left\\n        return res[::-1]     #\\u8FD4\\u56DEReversed\\u7684list\\n```\n```\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45853,
                "title": "accepted-just-a-reversal-of-a-modified-pre-order-traversal",
                "content": "This is my accepted code. I found out that pre-order traversal is root-left-right, and post order is left-right-root. I modified the code for pre-order a little to make it root-right-left, and then reverse the output. I think others would have thought of it already, but anyways here's my code... \\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @return a list of integers\\n    def postorderTraversal(self, root):\\n        traversalInt = list()\\n        if root!=None:\\n            traversal = list()\\n            traversal.append(root)\\n            \\n            while len(traversal)>0:\\n                probe = traversal[0]\\n                traversalInt.append(probe.val)\\n                traversal.remove(probe)\\n                if (probe.left != None):\\n                    traversal.insert(0,probe.left)\\n                if (probe.right != None):\\n                    traversal.insert(0,probe.right)\\n        return traversalInt[::-1]",
                "solutionTags": [],
                "code": "This is my accepted code. I found out that pre-order traversal is root-left-right, and post order is left-right-root. I modified the code for pre-order a little to make it root-right-left, and then reverse the output. I think others would have thought of it already, but anyways here's my code... \\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @return a list of integers\\n    def postorderTraversal(self, root):\\n        traversalInt = list()\\n        if root!=None:\\n            traversal = list()\\n            traversal.append(root)\\n            \\n            while len(traversal)>0:\\n                probe = traversal[0]\\n                traversalInt.append(probe.val)\\n                traversal.remove(probe)\\n                if (probe.left != None):\\n                    traversal.insert(0,probe.left)\\n                if (probe.right != None):\\n                    traversal.insert(0,probe.right)\\n        return traversalInt[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 880981,
                "title": "iterative-recursive-js-solutions",
                "content": "```\\n// Iterative Solution\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    let stack = [], res = [];\\n    stack.push(root);\\n    while (stack.length) {\\n        let node = stack[stack.length-1];\\n        if (node.left) {\\n            stack.push(node.left);\\n            node.left = null;\\n        }\\n        else if (node.right) {\\n            stack.push(node.right);\\n            node.right = null;\\n        }\\n        else res.push(stack.pop().val);\\n    }\\n    return res;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```\\n\\n```\\n// Recursive Solution\\nvar postorderTraversal = function(root) {\\n    let res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        traverse(node.right);\\n        res.push(node.val);\\n    }\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Iterative Solution\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    let stack = [], res = [];\\n    stack.push(root);\\n    while (stack.length) {\\n        let node = stack[stack.length-1];\\n        if (node.left) {\\n            stack.push(node.left);\\n            node.left = null;\\n        }\\n        else if (node.right) {\\n            stack.push(node.right);\\n            node.right = null;\\n        }\\n        else res.push(stack.pop().val);\\n    }\\n    return res;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```\n```\\n// Recursive Solution\\nvar postorderTraversal = function(root) {\\n    let res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        traverse(node.right);\\n        res.push(node.val);\\n    }\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941817,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var res: [Int] = []\\n        \\n        func postOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            postOrder(root.left)\\n            postOrder(root.right)\\n            res.append(root.val)\\n        }\\n        \\n        postOrder(root)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var res: [Int] = []\\n        \\n        func postOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            postOrder(root.left)\\n            postOrder(root.right)\\n            res.append(root.val)\\n        }\\n        \\n        postOrder(root)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245727,
                "title": "c-preorder-inorder-postorder-morris-traversal",
                "content": "O(n) time and O(1) space\\nThe basic idea is the postorder traversal can be considered as a reverse process of preorder traversal. Therefore, we just need to change all left child to right child and always insert elements at the beginning of the vector. \\n\\n* **PostOrder**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        TreeNode* current = root;\\n        vector<int> values;\\n        while (current != NULL){\\n            if (current->right == NULL){\\n                // Always insert at the beginning\\n                values.insert(values.begin(), current->val);\\n                current = current->left; // Reverse of preorder traversal\\n            }else{\\n                TreeNode* predecessor = findPredecessor(current);\\n                if (predecessor->left == NULL){\\n                    // Link to current\\n                    predecessor->left = current;\\n                    values.insert(values.begin(), current->val);\\n                    current = current->right;   // Reverse of preorder\\n                }else{\\n                    predecessor->left = NULL;\\n                    current = current->left;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        // Reverse of preorder traversal\\n        TreeNode* predecessor = current->right; \\n        while (predecessor->left != NULL && predecessor->left != current){\\n            predecessor = predecessor->left;\\n        }\\n        return predecessor;\\n    }\\n};\\n```\\n* **PreOrder**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> values;\\n        TreeNode *current = root;\\n        while(current != NULL){\\n            if (current->left == NULL){\\n                values.push_back(current->val);\\n                current = current->right;\\n            }else{\\n                TreeNode *predecessor = findPredecessor(current);\\n                if (predecessor->right == NULL){\\n                    predecessor->right = current;\\n                    values.push_back(current->val);\\n                    current = current->left;\\n                }else{\\n                    predecessor->right = NULL;\\n                    current = current->right;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        TreeNode* predecessor = current->left;\\n        while(predecessor->right != NULL && predecessor->right != current){\\n            predecessor = predecessor->right;\\n        }\\n        return predecessor;\\n    }\\n};\\n```\\n* **InOrder**\\nThe difference between inorder and preorder is the place for inserting elements to the vector.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> values;\\n        TreeNode *current = root;\\n        while (current != NULL){\\n            if (current->left == NULL){\\n                values.push_back(current->val);\\n                current = current->right;\\n            }else{\\n                TreeNode* preDecessor = findPredecessor(current);\\n                if (preDecessor->right == NULL){\\n                    preDecessor->right = current;\\n                    current = current->left;\\n                }else{\\n                    preDecessor->right = NULL;\\n                    values.push_back(current->val);\\n                    current = current->right;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        TreeNode* preDecessor = current->left;\\n        while (preDecessor->right != NULL && preDecessor->right != current){\\n            preDecessor = preDecessor->right;\\n        }\\n        return preDecessor;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        TreeNode* current = root;\\n        vector<int> values;\\n        while (current != NULL){\\n            if (current->right == NULL){\\n                // Always insert at the beginning\\n                values.insert(values.begin(), current->val);\\n                current = current->left; // Reverse of preorder traversal\\n            }else{\\n                TreeNode* predecessor = findPredecessor(current);\\n                if (predecessor->left == NULL){\\n                    // Link to current\\n                    predecessor->left = current;\\n                    values.insert(values.begin(), current->val);\\n                    current = current->right;   // Reverse of preorder\\n                }else{\\n                    predecessor->left = NULL;\\n                    current = current->left;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        // Reverse of preorder traversal\\n        TreeNode* predecessor = current->right; \\n        while (predecessor->left != NULL && predecessor->left != current){\\n            predecessor = predecessor->left;\\n        }\\n        return predecessor;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> values;\\n        TreeNode *current = root;\\n        while(current != NULL){\\n            if (current->left == NULL){\\n                values.push_back(current->val);\\n                current = current->right;\\n            }else{\\n                TreeNode *predecessor = findPredecessor(current);\\n                if (predecessor->right == NULL){\\n                    predecessor->right = current;\\n                    values.push_back(current->val);\\n                    current = current->left;\\n                }else{\\n                    predecessor->right = NULL;\\n                    current = current->right;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        TreeNode* predecessor = current->left;\\n        while(predecessor->right != NULL && predecessor->right != current){\\n            predecessor = predecessor->right;\\n        }\\n        return predecessor;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> values;\\n        TreeNode *current = root;\\n        while (current != NULL){\\n            if (current->left == NULL){\\n                values.push_back(current->val);\\n                current = current->right;\\n            }else{\\n                TreeNode* preDecessor = findPredecessor(current);\\n                if (preDecessor->right == NULL){\\n                    preDecessor->right = current;\\n                    current = current->left;\\n                }else{\\n                    preDecessor->right = NULL;\\n                    values.push_back(current->val);\\n                    current = current->right;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        TreeNode* preDecessor = current->left;\\n        while (preDecessor->right != NULL && preDecessor->right != current){\\n            preDecessor = preDecessor->right;\\n        }\\n        return preDecessor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45793,
                "title": "a-java-simple-solution-based-on-preorder-traversal",
                "content": "Postorder traversal, which is in Left-Right-Root order. We can observe that the preorder traversal is in Root-Left-Right order, which means if we swap the order of left and right subtree when pushing into stack, we'll get Root-Right-Left, a new traversal.\\n\\nIt is just the opposite way of postorder one. And that's why the following code works.\\n\\n    public class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> result = new LinkedList<Integer>();\\n        if(root == null) return result;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            root = stack.pop();\\n            result.addFirst(root.val);\\n            if(root.left != null){\\n                stack.push(root.left);\\n            }\\n            if(root.right != null){\\n                stack.push(root.right);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> result = new LinkedList<Integer>();\\n        if(root == null) return result;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            root = stack.pop();\\n            result.addFirst(root.val);\\n            if(root.left != null){\\n                stack.push(root.left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 332286,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Please see and vote for my solutions for these similar problems.\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/332283/Python-recursive-and-iterative-solutions)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/332277/Python-recursive-and-iterative-solutions)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/332286/Python-recursive-and-iterative-solutions)\\n\\nRecursive solution:\\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            dfs(node.right)\\n            post_order.append(node.val)\\n        \\n        post_order = []\\n        dfs(root)\\n        return post_order\\n```\\n\\nIterative solution 1: use a stack and a hashset visited\\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        post_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_next = True\\n            if top.right and top.right not in visited:\\n                stack.append(top.right)\\n                visited.add(top.right)\\n                no_next = False\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_next = False\\n            if no_next:\\n                post_order.append(top.val)\\n\\t\\t\\t\\tstack.pop()\\n        return post_order\\n```\\n\\nIterative solution 2: use a stack and two pointers\\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        post_order, stack = [], []\\n        prev, p = None, root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                top = stack[-1]\\n                if top.right and top.right != prev:\\n                    p = top.right\\n                else:\\n                    post_order.append(top.val)\\n                    prev = top\\n                    stack.pop()\\n        return post_order\\n```",
                "solutionTags": [],
                "code": "```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            dfs(node.right)\\n            post_order.append(node.val)\\n        \\n        post_order = []\\n        dfs(root)\\n        return post_order\\n```\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        post_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_next = True\\n            if top.right and top.right not in visited:\\n                stack.append(top.right)\\n                visited.add(top.right)\\n                no_next = False\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_next = False\\n            if no_next:\\n                post_order.append(top.val)\\n\\t\\t\\t\\tstack.pop()\\n        return post_order\\n```\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        post_order, stack = [], []\\n        prev, p = None, root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                top = stack[-1]\\n                if top.right and top.right != prev:\\n                    p = top.right\\n                else:\\n                    post_order.append(top.val)\\n                    prev = top\\n                    stack.pop()\\n        return post_order\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2356012,
                "title": "python-iterative-solution-no-reversal-concise-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        s = [root]\\n        res = []        \\n        \\n        while s:\\n            cur = s[-1]\\n            if not cur.left and not cur.right:\\n                s.pop()\\n                res.append(cur.val)\\n\\n            if cur.right:\\n                s.append(cur.right)\\n                cur.right = None\\n            \\n            if cur.left:\\n                s.append(cur.left)\\n                cur.left = None\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        s = [root]\\n        res = []        \\n        \\n        while s:\\n            cur = s[-1]\\n            if not cur.left and not cur.right:\\n                s.pop()\\n                res.append(cur.val)\\n\\n            if cur.right:\\n                s.append(cur.right)\\n                cur.right = None\\n            \\n            if cur.left:\\n                s.append(cur.left)\\n                cur.left = None\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404980,
                "title": "binary-tree-postorder-traversal-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> output = new ArrayList<>();\\n        postorder(root, output);\\n        return output;\\n    }\\n    \\n    public void postorder(TreeNode root,List<Integer> output){\\n        if(root == null){\\n            return;\\n        }\\n        postorder(root.left, output);\\n        postorder(root.right, output);\\n        output.add(root.val);\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE .\\nHappy Coding and keep up the good work :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> output = new ArrayList<>();\\n        postorder(root, output);\\n        return output;\\n    }\\n    \\n    public void postorder(TreeNode root,List<Integer> output){\\n        if(root == null){\\n            return;\\n        }\\n        postorder(root.left, output);\\n        postorder(root.right, output);\\n        output.add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357925,
                "title": "python-easy-template-for-iterative-traversal-preorder-inorder-postorder",
                "content": "This is a simple solution using with just one stack and a while loop with `O(n)` complexity. Almost as simple as the recursive solution and inspired by [autekwing](https://leetcode.com/autekwing/) comment [here](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31381/Python-recursive-and-iterative-solutions./30044).\\n\\nTemplate:\\n```\\ndef iterativeTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n\\t\\t\\t\\t# pop the stack\\n                # append to answer list\\n\\t\\t\\t\\t# update node to go right\\n                \\n        return ans            \\n```\\n\\nActual code with with runtime that beats more than 70% of submissions:\\n\\nPostorder\\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            elif stack[-1].right:\\n                root = stack[-1].right\\n                stack[-1].right = None\\n            else:\\n                ans.append(stack.pop().val)\\n                \\n        return ans            \\n```\\n\\nInorder\\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        res = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                curr = stack.pop()\\n                res.append(curr.val)\\n                root = curr.right\\n                \\n        return res\\n```\\n\\nPreorder\\n```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n\\t\\t\\n        while stack or root:\\n            if root:\\n                ans.append(root.val)\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                root = node.right\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef iterativeTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n\\t\\t\\t\\t# pop the stack\\n                # append to answer list\\n\\t\\t\\t\\t# update node to go right\\n                \\n        return ans            \\n```\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            elif stack[-1].right:\\n                root = stack[-1].right\\n                stack[-1].right = None\\n            else:\\n                ans.append(stack.pop().val)\\n                \\n        return ans            \\n```\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        res = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                curr = stack.pop()\\n                res.append(curr.val)\\n                root = curr.right\\n                \\n        return res\\n```\n```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n\\t\\t\\n        while stack or root:\\n            if root:\\n                ans.append(root.val)\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                root = node.right\\n                \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 287305,
                "title": "java-solution-without-using-linked-list-or-without-reversing",
                "content": "The idea is a small extension to Inorder iterative traversal.\\n\\nHere\\'s the iterative inorder traversal:\\n```\\npublic List < Integer > inorderTraversal(TreeNode root) {\\n        List < Integer > res = new ArrayList < > ();\\n        Stack < TreeNode > stack = new Stack < > ();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n```\\nFor post order traversal:\\nSo, while moving to the left most node, we also add the curr roots right to the stack along with the curr node.\\nThen when we reach the left most node, if it doesn\\'t have any right node (i.e it is a leaf node), we add it to result and set curr to null. \\n\\nElse, if the curr node\\'s right node is same as the stack\\'s top., this means that the current\\'s right tree is yet to be processed. So, before processing curr, we have to process its right subtree., so, we pop the right node from stack, push curr to the stack and point curr to its right node and continue with processing.\\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n\\n        List<Integer> res = new ArrayList<>();\\n\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n\\t\\t\\t    // push right on to stack before curr\\n                if (curr.right != null) stack.push(curr.right);\\n\\t\\t\\t\\t//push curr onto stack and move left\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n\\n            curr = stack.pop();\\n\\n            // if curr\\'s right is at the top of stack i.e, it is not yet processed\\n            if (!stack.isEmpty() && curr.right == stack.peek()) {\\n\\t\\t\\t    //pop its right from stack\\n                stack.pop();\\n\\t\\t\\t\\t//push curr to stack to process it in future\\n                stack.push(curr);\\n\\t\\t\\t\\t//point curr to its right\\n                curr = curr.right;\\n            }\\n            else {\\n\\t\\t\\t    // if curr is left most and doesnt have any right or if its right has already been processed, process curr and set it to null\\n                res.add(curr.val);\\n                curr = null;\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List < Integer > inorderTraversal(TreeNode root) {\\n        List < Integer > res = new ArrayList < > ();\\n        Stack < TreeNode > stack = new Stack < > ();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n```\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n\\n        List<Integer> res = new ArrayList<>();\\n\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n\\t\\t\\t    // push right on to stack before curr\\n                if (curr.right != null) stack.push(curr.right);\\n\\t\\t\\t\\t//push curr onto stack and move left\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n\\n            curr = stack.pop();\\n\\n            // if curr\\'s right is at the top of stack i.e, it is not yet processed\\n            if (!stack.isEmpty() && curr.right == stack.peek()) {\\n\\t\\t\\t    //pop its right from stack\\n                stack.pop();\\n\\t\\t\\t\\t//push curr to stack to process it in future\\n                stack.push(curr);\\n\\t\\t\\t\\t//point curr to its right\\n                curr = curr.right;\\n            }\\n            else {\\n\\t\\t\\t    // if curr is left most and doesnt have any right or if its right has already been processed, process curr and set it to null\\n                res.add(curr.val);\\n                curr = null;\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45806,
                "title": "python-iterative-solution",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer[]}\\n        def postorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            result, queue = [], [(root, False)]\\n            while queue:\\n                curNode, visited = queue.pop()\\n                if curNode:\\n                    if visited:\\n                        result.append(curNode.val)\\n                    else:\\n                        queue.append((curNode, True))\\n                        queue.append((curNode.right, False))\\n                        queue.append((curNode.left, False))\\n    \\n            return result",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 45557,
                "title": "my-accepted-code-of-binary-tree-postorder-traversal",
                "content": "**Method 1: Using one stack and will change the input data. Consume time 36 ms** \\n\\n    #include <iostream>\\n    #include <vector>\\n    #include <stack>\\n    using namespace std;\\n    \\n    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n    \\t\\tvector<int> vec;\\n    \\t\\tif(root == NULL)\\n    \\t\\t\\treturn vec;\\n    \\n    \\t\\ts.push(root);\\n    \\t\\twhile(!s.empty())\\n    \\t\\t{\\n    \\t\\t\\tTreeNode* n = s.top();\\n    \\t\\t\\tif(n->right)\\n    \\t\\t\\t\\ts.push(n->right);\\n    \\t\\t\\tif(n->left)\\n    \\t\\t\\t\\ts.push(n->left);\\n    \\t\\t\\tn->left = NULL;\\n    \\t\\t\\tn->right = NULL;\\n    \\n    \\t\\t\\tn = s.top();\\n    \\t\\t\\tif(n->left == NULL && n->right == NULL)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tvec.push_back(n->val);\\n    \\t\\t\\t\\ts.pop();\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn vec;\\n        }\\n    };\\n\\n**Method 2: Using two stacks and do not change the input data. Consume time 8ms**\\n\\n    #include <iostream>\\n    #include <vector>\\n    #include <stack>\\n    using namespace std;\\n    \\n    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode *root) {\\n             stack<TreeNode*> s,out;\\n    \\t\\tvector<int> vec;\\n    \\t\\tif(root == NULL)\\n    \\t\\t\\treturn vec;\\n    \\n    \\t\\ts.push(root);\\n    \\t\\twhile(!s.empty())\\n    \\t\\t{\\n    \\t\\t\\tTreeNode* node = s.top();\\n    \\t\\t\\ts.pop();\\n    \\t\\t\\tout.push(node);\\n    \\t\\t\\tif(node->left)\\n    \\t\\t\\t\\ts.push(node->left);\\n    \\t\\t\\tif(node->right)\\n    \\t\\t\\t\\ts.push(node->right);\\n    \\t\\t}\\n    \\n    \\t\\twhile(!out.empty())\\n    \\t\\t{\\n    \\t\\t\\tvec.push_back(out.top()->val);\\n    \\t\\t\\tout.pop();\\n    \\t\\t}\\n    \\t\\treturn vec;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n    \\t\\tvector<int> vec;\\n    \\t\\tif(root == NULL)\\n    \\t\\t\\treturn vec;\\n    \\n    \\t\\ts.push(root);\\n    \\t\\twhile(!s.empty())\\n    \\t\\t{\\n    \\t\\t\\tTreeNode* n = s.top();\\n    \\t\\t\\tif(n->right)\\n    \\t\\t\\t\\ts.push(n->right);\\n    \\t\\t\\tif(n->left)\\n    \\t\\t\\t\\ts.push(n->left);\\n    \\t\\t\\tn->left = NULL;\\n    \\t\\t\\tn->right = NULL;\\n    \\n    \\t\\t\\tn = s.top();\\n    \\t\\t\\tif(n->left == NULL && n->right == NULL)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tvec.push_back(n->val);\\n    \\t\\t\\t\\ts.pop();\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1038517,
                "title": "javascript-2-solutions-stack-recursive-easy-to-understand",
                "content": "**Stack Solution**\\n```\\nvar postorderTraversal = function(root) {\\n    if(!root) return [];\\n\\n    const stack = [root];\\n    const result = [];\\n    while(stack.length > 0) {\\n        const node = stack.pop();\\n        result.push(node.val);\\n        if(node.left) stack.push(node.left);\\n        if(node.right) stack.push(node.right);\\n    }\\n    \\n    return result.reverse();\\n};\\n```\\n\\n**Recursive Solution**\\n```\\nvar postorderTraversal = function(root) {\\n    const result = [];\\n    const recursive = (node) => {\\n        if(!node) return;\\n\\n        if(node.left) recursive(node.left);\\n        if(node.right) recursive(node.right);\\n        result.push(node.val);\\n    }\\n\\n    recursive(root);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nvar postorderTraversal = function(root) {\\n    if(!root) return [];\\n\\n    const stack = [root];\\n    const result = [];\\n    while(stack.length > 0) {\\n        const node = stack.pop();\\n        result.push(node.val);\\n        if(node.left) stack.push(node.left);\\n        if(node.right) stack.push(node.right);\\n    }\\n    \\n    return result.reverse();\\n};\\n```\n```\\nvar postorderTraversal = function(root) {\\n    const result = [];\\n    const recursive = (node) => {\\n        if(!node) return;\\n\\n        if(node.left) recursive(node.left);\\n        if(node.right) recursive(node.right);\\n        result.push(node.val);\\n    }\\n\\n    recursive(root);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45818,
                "title": "sharing-my-implementation-and-looking-for-an-even-more-concise-one",
                "content": "I have checked many implementations of iterative solutions to this problem; many of them seem to be rather verbose. After some investigations, I have come up with this following solution:\\n\\n    vector<int> postorderTraversal(TreeNode *root) {\\n        stack<TreeNode*> s;\\n        TreeNode* cur = root;\\n        vector<int> temp;\\n        while(true)\\n        {\\n            if (cur == NULL)  // If the current branch is finished, then go back to the most recent unvisited branch\\n            {\\n                if (!s.empty()) {cur = s.top(); s.pop(); continue;} // Checked the first unvisited branch\\n                else break;\\n            }\\n            temp.push_back(cur->val); // Add the current value to the FRONT of list\\n            s.push(cur->left);         // Push the left child to the stack\\n            cur = cur->right;          // Go the right child\\n        }\\n        // Don't forget to reverse the 'right-to-left' pre-order traversal!\\n        return vector<int>(temp.rbegin(), temp.rend()); \\n    }\\n\\nThe idea is to exploit the fact that Post-order Traversal is equivalent to the REVERSE of a 'right-to-left' (i.e. traverse the right children then the left ones) pre-order traversal. For example, for the following tree:\\n\\n           A\\n          / \\\\\\n         B   C\\n        / \\\\\\n       D   E\\n\\npost-order: D E B C A\\n\\n'right-to-left' pre-order: A C B E D \\n\\nAs for the pre-order traversal, we initialize the current node to the root. Then we keep adding the value of the current node to the traversal list, and then push its left child to a stack, and set its right child as the current node. That way, each element in the stack represents the root of a branch that we should visit at later time, with the top element being the first one that we visit as soon as we get the chance to.\\n\\nIf we find the current node is NULL, it means we have reached the end of a branch, then we should visit a new branch beginning at the top of the stack. If the top element of the stack is also NULL, it means this branch does not contain anything, then we should pop it out, then check the new top element until it is no longer NULL. If the stack turns empty before we find a non-NULL node in it, then we have visited all the nodes in the tree.\\n \\nAnd it boils down to this simple iterative rule:\\n\\n------------\\n\\nIn each iteration\\n\\n1. If the current node is not NULL, then \\n\\n  A) add its value to the traversal list, and \\n\\n  B) push its LEFT child to stack, and \\n\\n  C) go to its RIGHT child. \\n\\n2. If the current node is NULL, then set the current node to the top of the stack (terminate if the stack is already empty).\\n\\n-------------\\n\\n Implementation-wise, this is the most concise solution I have come up so far. And the code can be applied almost directly to a similar problem ('Binary Tree Pre-Order Traversal') with little modification. \\nI really would like to know if there is any better algorithm that would result in an even more concise implementation than this one. Any comments/suggestions are welcome!",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "I have checked many implementations of iterative solutions to this problem; many of them seem to be rather verbose. After some investigations, I have come up with this following solution:\\n\\n    vector<int> postorderTraversal(TreeNode *root) {\\n        stack<TreeNode*> s;\\n        TreeNode* cur = root;\\n        vector<int> temp;\\n        while(true)\\n        {\\n            if (cur == NULL)  // If the current branch is finished, then go back to the most recent unvisited branch\\n            {\\n                if (!s.empty()) {cur = s.top(); s.pop(); continue;} // Checked the first unvisited branch\\n                else break;\\n            }\\n            temp.push_back(cur->val); // Add the current value to the FRONT of list\\n            s.push(cur->left);         // Push the left child to the stack\\n            cur = cur->right;          // Go the right child\\n        }\\n        // Don't forget to reverse the 'right-to-left' pre-order traversal!\\n        return vector<int>(temp.rbegin(), temp.rend()); \\n    }\\n\\nThe idea is to exploit the fact that Post-order Traversal is equivalent to the REVERSE of a 'right-to-left' (i.e. traverse the right children then the left ones) pre-order traversal. For example, for the following tree:\\n\\n           A\\n          / \\\\\\n         B   C\\n        / \\\\\\n       D   E\\n\\npost-order: D E B C A\\n\\n'right-to-left' pre-order: A C B E D \\n\\nAs for the pre-order traversal, we initialize the current node to the root. Then we keep adding the value of the current node to the traversal list, and then push its left child to a stack, and set its right child as the current node. That way, each element in the stack represents the root of a branch that we should visit at later time, with the top element being the first one that we visit as soon as we get the chance to.\\n\\nIf we find the current node is NULL, it means we have reached the end of a branch, then we should visit a new branch beginning at the top of the stack. If the top element of the stack is also NULL, it means this branch does not contain anything, then we should pop it out, then check the new top element until it is no longer NULL. If the stack turns empty before we find a non-NULL node in it, then we have visited all the nodes in the tree.\\n \\nAnd it boils down to this simple iterative rule:\\n\\n------------\\n\\nIn each iteration\\n\\n1. If the current node is not NULL, then \\n\\n  A) add its value to the traversal list, and \\n\\n  B) push its LEFT child to stack, and \\n\\n  C) go to its RIGHT child. \\n\\n2. If the current node is NULL, then set the current node to the top of the stack (terminate if the stack is already empty).\\n\\n-------------\\n\\n Implementation-wise, this is the most concise solution I have come up so far. And the code can be applied almost directly to a similar problem ('Binary Tree Pre-Order Traversal') with little modification. \\nI really would like to know if there is any better algorithm that would result in an even more concise implementation than this one. Any comments/suggestions are welcome!",
                "codeTag": "Unknown"
            },
            {
                "id": 1003772,
                "title": "simple-one-stack",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\t\\t# Stack of nodes to process. \"True\" only when children trees have been traversed.\\t\\n        stack = [(root, False)]\\n        result = []\\n        while stack:\\n            node, done = stack.pop()\\n            if done:\\n                result.append(node.val)\\n            else:\\n\\t\\t\\t    # For post-order traversal, need to first visit left then right before node is \"done\", so add them in reverse order to the stack.\\n\\t\\t\\t\\t# By changing the order here we could achieve pre- or in-order as well.\\n                stack.append((node, True))\\n                if node.right:\\n                    stack.append((node.right, False))\\n                if node.left:\\n                    stack.append((node.left, False))\\n        return result                    \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\t\\t# Stack of nodes to process. \"True\" only when children trees have been traversed.\\t\\n        stack = [(root, False)]\\n        result = []\\n        while stack:\\n            node, done = stack.pop()\\n            if done:\\n                result.append(node.val)\\n            else:\\n\\t\\t\\t    # For post-order traversal, need to first visit left then right before node is \"done\", so add them in reverse order to the stack.\\n\\t\\t\\t\\t# By changing the order here we could achieve pre- or in-order as well.\\n                stack.append((node, True))\\n                if node.right:\\n                    stack.append((node.right, False))\\n                if node.left:\\n                    stack.append((node.left, False))\\n        return result                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 45548,
                "title": "simple-javascript-solution",
                "content": "A postorder traversal can be easily reversed by a preorder traversal like this:\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    \\n    var result = [], stack = [root];\\n    \\n    while (stack.length) {\\n        var node = stack.pop();\\n        // insert the node val to the front\\n        result.unshift(node.val);\\n\\n        if (node.left) stack.push(node.left); // left first\\n        if (node.right) stack.push(node.right); // then right\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    \\n    var result = [], stack = [root];\\n    \\n    while (stack.length) {\\n        var node = stack.pop();\\n        // insert the node val to the front\\n        result.unshift(node.val);\\n\\n        if (node.left) stack.push(node.left); // left first\\n        if (node.right) stack.push(node.right); // then right\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45866,
                "title": "my-accepted-java-solution",
                "content": "Straightforward thought:\\nYou will meet a node three times from a stack.\\nFor the first time, push the left. The second time, push the right, The third time you meet it, move it to result.\\n\\n\\tclass TreeNodeStack {\\n\\t\\tTreeNode node;\\n\\t\\tint count;\\n\\n\\t\\tTreeNodeStack(TreeNode node) {\\n\\t\\t\\tthis.node = node;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic List<Integer> postorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> result = new ArrayList<Integer>();\\n\\t\\tDeque<TreeNodeStack> stack = new ArrayDeque<TreeNodeStack>();\\n\\t\\tstack.add(new TreeNodeStack(root));\\n\\t\\twhile (stack.size() > 0) {\\n\\t\\t\\tTreeNodeStack s = stack.peekLast();\\n\\t\\t\\ts.count++;\\n\\t\\t\\tif (s.node == null) {\\n\\t\\t\\t\\tstack.pollLast();\\n\\t\\t\\t}\\n\\t\\t\\telse if(s.count==1){\\n\\t\\t\\t\\tstack.add(new TreeNodeStack(s.node.left));\\n\\t\\t\\t}\\n\\t\\t\\telse if(s.count==2){\\n\\t\\t\\t\\tstack.add(new TreeNodeStack(s.node.right));\\n\\t\\t\\t}\\n\\t\\t\\telse if (s.count == 3) {\\n\\t\\t\\t\\tstack.pollLast();\\n\\t\\t\\t\\tresult.add(s.node.val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "Straightforward thought:\\nYou will meet a node three times from a stack.\\nFor the first time, push the left. The second time, push the right, The third time you meet it, move it to result.\\n\\n\\tclass TreeNodeStack {\\n\\t\\tTreeNode node;\\n\\t\\tint count;\\n\\n\\t\\tTreeNodeStack(TreeNode node) {\\n\\t\\t\\tthis.node = node;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic List<Integer> postorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> result = new ArrayList<Integer>();\\n\\t\\tDeque<TreeNodeStack> stack = new ArrayDeque<TreeNodeStack>();\\n\\t\\tstack.add(new TreeNodeStack(root));\\n\\t\\twhile (stack.size() > 0) {\\n\\t\\t\\tTreeNodeStack s = stack.peekLast();\\n\\t\\t\\ts.count++;\\n\\t\\t\\tif (s.node == null) {\\n\\t\\t\\t\\tstack.pollLast();\\n\\t\\t\\t}\\n\\t\\t\\telse if(s.count==1){\\n\\t\\t\\t\\tstack.add(new TreeNodeStack(s.node.left));\\n\\t\\t\\t}\\n\\t\\t\\telse if(s.count==2){\\n\\t\\t\\t\\tstack.add(new TreeNodeStack(s.node.right));\\n\\t\\t\\t}\\n\\t\\t\\telse if (s.count == 3) {\\n\\t\\t\\t\\tstack.pollLast();\\n\\t\\t\\t\\tresult.add(s.node.val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2386026,
                "title": "easiest-traversal-without-stack-queue-100-postorder",
                "content": "## **Using This Solution We Can Make Postorder Traversal In Binary Tree Without Using Stack And Queue.**\\n\\n##### Global Declaration Of Ans Vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        v.push_back(root->val);\\n        return v;\\n    }\\n};\\n```\\n\\n##### Pass By Reference Ans Vector.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return;\\n        helper(root->left,ans);\\n        helper(root->right,ans);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Like & UpVote If You Get My Intuition Also Comment If You Have Any Query..**",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        v.push_back(root->val);\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return;\\n        helper(root->left,ans);\\n        helper(root->right,ans);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151213,
                "title": "short-simple-python-solution-beats-98-98",
                "content": "Here is the simple logic:\\n* If you are confused every time with preorder, inorder or postorder traversal just remember this typical 2 lines of code where tree is visited from left to right.\\n```\\n# Preorder means just b4 recursions w/o visiting left and right branches\\ndfs(node.left)\\n# Inorder means after visiting left branch\\ndfs(node.right)\\n# Postorder means after visiting left and right branches\\n```\\n* Now it looks clear.\\n* Basically, the question is asking putting children nodes first and then the parent node in the order of left - right - node. \\n* We can do this exactly by DFS traversal from right to left and then reverse the order.\\n```\\nclass Solution:\\n    def postorderTraversal(self, root):\\n        ret, stack = [], root and [root]\\n        while stack:\\n            node = stack.pop()\\n            ret.append(node.val)\\n            stack += [child for child in (node.left, node.right) if child]\\n        return ret[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\n# Preorder means just b4 recursions w/o visiting left and right branches\\ndfs(node.left)\\n# Inorder means after visiting left branch\\ndfs(node.right)\\n# Postorder means after visiting left and right branches\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root):\\n        ret, stack = [], root and [root]\\n        while stack:\\n            node = stack.pop()\\n            ret.append(node.val)\\n            stack += [child for child in (node.left, node.right) if child]\\n        return ret[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905483,
                "title": "python-iterative-solution",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        result=[]\\n        stack=[]\\n        while root or stack:\\n            while root:\\n                stack.append(root) # push nodes into the stack\\n                root=root.left if root.left else root.right\\n            root=stack.pop()\\n            result.append(root.val) #Deal with the root node whenever it is popped from stack\\n            if stack and stack[len(stack)-1].left==root: #check whether it has been traversed \\n                root=stack[len(stack)-1].right\\n            else:\\n                root=None #Force to quit the loop\\n        return(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        result=[]\\n        stack=[]\\n        while root or stack:\\n            while root:\\n                stack.append(root) # push nodes into the stack\\n                root=root.left if root.left else root.right\\n            root=stack.pop()\\n            result.append(root.val) #Deal with the root node whenever it is popped from stack\\n            if stack and stack[len(stack)-1].left==root: #check whether it has been traversed \\n                root=stack[len(stack)-1].right\\n            else:\\n                root=None #Force to quit the loop\\n        return(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805637,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        TreeNode* last = NULL;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            } else {\\n                TreeNode* node = todo.top();\\n                if (node -> right && last != node -> right) {\\n                    root = node -> right;\\n                } else {\\n                    nodes.push_back(node -> val);\\n                    last = node;\\n                    todo.pop();\\n                }\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        TreeNode* last = NULL;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            } else {\\n                TreeNode* node = todo.top();\\n                if (node -> right && last != node -> right) {\\n                    root = node -> right;\\n                } else {\\n                    nodes.push_back(node -> val);\\n                    last = node;\\n                    todo.pop();\\n                }\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373617,
                "title": "python-elegant-short-dfs-bfs-based-on-generators",
                "content": "# BFS solution:\\n```\\nfrom typing import List, Optional\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n)\\n\\tMemory: O(n)\\n\\t\"\"\"\\n\\n\\tdef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\tif root is None:\\n\\t\\t\\treturn []\\n\\n\\t\\tpostorder = []\\n\\t\\tstack = [root]\\n\\n\\t\\twhile stack:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tpostorder.append(node.val)\\n\\t\\t\\tif node.left is not None:\\n\\t\\t\\t\\tstack.append(node.left)\\n\\t\\t\\tif node.right is not None:\\n\\t\\t\\t\\tstack.append(node.right)\\n\\n\\t\\treturn postorder[::-1]\\n```\\n# DFS solution:\\n```\\nfrom typing import List, Optional\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n)\\n\\tMemory: O(n)\\n\\t\"\"\"\\n\\n\\tdef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\treturn list(self.postorder_generator(root))\\n\\n\\t@classmethod\\n\\tdef postorder_generator(cls, tree: Optional[TreeNode]):\\n\\t\\tif tree is not None:\\n\\t\\t\\tyield from cls.postorder_generator(tree.left)\\n\\t\\t\\tyield from cls.postorder_generator(tree.right)\\n\\t\\t\\tyield tree.val\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom typing import List, Optional\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n)\\n\\tMemory: O(n)\\n\\t\"\"\"\\n\\n\\tdef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\tif root is None:\\n\\t\\t\\treturn []\\n\\n\\t\\tpostorder = []\\n\\t\\tstack = [root]\\n\\n\\t\\twhile stack:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tpostorder.append(node.val)\\n\\t\\t\\tif node.left is not None:\\n\\t\\t\\t\\tstack.append(node.left)\\n\\t\\t\\tif node.right is not None:\\n\\t\\t\\t\\tstack.append(node.right)\\n\\n\\t\\treturn postorder[::-1]\\n```\n```\\nfrom typing import List, Optional\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n)\\n\\tMemory: O(n)\\n\\t\"\"\"\\n\\n\\tdef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\treturn list(self.postorder_generator(root))\\n\\n\\t@classmethod\\n\\tdef postorder_generator(cls, tree: Optional[TreeNode]):\\n\\t\\tif tree is not None:\\n\\t\\t\\tyield from cls.postorder_generator(tree.left)\\n\\t\\t\\tyield from cls.postorder_generator(tree.right)\\n\\t\\t\\tyield tree.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556668,
                "title": "recursive-iterative-using-1-stack-2-stacks-both-easy-soln-c",
                "content": "Recursive:\\n```\\n\\t class Solution {\\n\\tpublic:\\n\\t\\tvector<int> postorderTraversal(TreeNode* root) \\n\\t\\t{\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tPostOrder(root,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tvoid PostOrder(TreeNode* root, vector<int>& ans)\\n\\t\\t{\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tPostOrder(root->left,ans);\\n\\t\\t\\tPostOrder(root->right,ans);\\n\\t\\t\\tans.push_back(root->val);\\n\\t\\t}\\n\\t};\\n```\\nIterative (Two Stacks):\\n```\\t\\n\\tclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        stack<TreeNode*>s1;\\n        stack<TreeNode*>s2;\\n        s1.push(root);\\n        while(!s1.empty())\\n        {\\n            root = s1.top();\\n            s2.push(root);\\n            s1.pop();\\n            if(root->left)s1.push(root->left);\\n            if(root->right)s1.push(root->right);\\n        }\\n        while(!s2.empty())\\n        {\\n            ans.push_back(s2.top()->val);\\n            s2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIterative (One Stack):\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        TreeNode* curr = root;\\n        stack<TreeNode*> s;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        while(curr!=NULL || !s.empty())\\n        {\\n            if(curr!=NULL)\\n            {\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else\\n            {\\n                TreeNode* temp = s.top()->right;\\n                if(temp !=NULL)\\n                {\\n                    curr = temp;\\n                }\\n                else\\n                {\\n                    temp = s.top();\\n                    s.pop();\\n                    ans.push_back(temp->val);\\n                    while(!s.empty() && temp == s.top()->right)\\n                    {\\n                        temp = s.top();\\n                        s.pop();\\n                        ans.push_back(temp->val);\\n                    }     \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\t class Solution {\\n\\tpublic:\\n\\t\\tvector<int> postorderTraversal(TreeNode* root) \\n\\t\\t{\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tPostOrder(root,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tvoid PostOrder(TreeNode* root, vector<int>& ans)\\n\\t\\t{\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tPostOrder(root->left,ans);\\n\\t\\t\\tPostOrder(root->right,ans);\\n\\t\\t\\tans.push_back(root->val);\\n\\t\\t}\\n\\t};\\n```\n```\\t\\n\\tclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        stack<TreeNode*>s1;\\n        stack<TreeNode*>s2;\\n        s1.push(root);\\n        while(!s1.empty())\\n        {\\n            root = s1.top();\\n            s2.push(root);\\n            s1.pop();\\n            if(root->left)s1.push(root->left);\\n            if(root->right)s1.push(root->right);\\n        }\\n        while(!s2.empty())\\n        {\\n            ans.push_back(s2.top()->val);\\n            s2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        TreeNode* curr = root;\\n        stack<TreeNode*> s;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        while(curr!=NULL || !s.empty())\\n        {\\n            if(curr!=NULL)\\n            {\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else\\n            {\\n                TreeNode* temp = s.top()->right;\\n                if(temp !=NULL)\\n                {\\n                    curr = temp;\\n                }\\n                else\\n                {\\n                    temp = s.top();\\n                    s.pop();\\n                    ans.push_back(temp->val);\\n                    while(!s.empty() && temp == s.top()->right)\\n                    {\\n                        temp = s.top();\\n                        s.pop();\\n                        ans.push_back(temp->val);\\n                    }     \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342471,
                "title": "python-clean-iterative-dfs",
                "content": "### Simple\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root: \\n            return []\\n        postorder, stack = [], [root]\\n        while stack:\\n            node = stack.pop()\\n            if not node: \\n                continue\\n            postorder.append(node.val)\\n            stack.append(node.left)\\n            stack.append(node.right)\\n        return postorder[::-1]\\n```\\n### Runtime Optimal\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        post_order, stack = [], []\\n        node = root\\n        while stack or node:\\n            while node:\\n                if node.right:\\n                    stack.append(node.right)\\n                stack.append(node)\\n                node = node.left\\n            last = stack.pop()\\n            if last.right and stack and last.right == stack[-1]:\\n                node = stack.pop()\\n                stack.append(last)\\n            else:\\n                post_order.append(last.val)\\n        return post_order\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root: \\n            return []\\n        postorder, stack = [], [root]\\n        while stack:\\n            node = stack.pop()\\n            if not node: \\n                continue\\n            postorder.append(node.val)\\n            stack.append(node.left)\\n            stack.append(node.right)\\n        return postorder[::-1]\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        post_order, stack = [], []\\n        node = root\\n        while stack or node:\\n            while node:\\n                if node.right:\\n                    stack.append(node.right)\\n                stack.append(node)\\n                node = node.left\\n            last = stack.pop()\\n            if last.right and stack and last.right == stack[-1]:\\n                node = stack.pop()\\n                stack.append(last)\\n            else:\\n                post_order.append(last.val)\\n        return post_order\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304192,
                "title": "post-order-traversal-with-a-iterator",
                "content": "There isn\\'t seem to be a solution with iterator, so I came up with my own binary tree post-order traversal iterator. \\nTime complexity for next() is O(height)\\nSpace complexity is also O(height)\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    class BSTIterator {\\n        Deque<TreeNode> stack = new ArrayDeque();\\n        TreeNode lastNode = null;\\n        \\n        public BSTIterator(TreeNode root) {\\n            pushAll(root);\\n        }\\n        \\n        private void pushAll(TreeNode cursor) {\\n            while(cursor != null) {\\n                stack.offerFirst(cursor);\\n                if(cursor.left!=null) cursor = cursor.left;\\n                else if(cursor.right!=null) cursor = cursor.right;\\n                else cursor = null;\\n            }\\n        }\\n\\n        public TreeNode next() {\\n            TreeNode cur = stack.peekFirst();\\n            if(cur == null) return null;\\n            if(lastNode == cur.right){\\n                lastNode = cur;\\n                return stack.pollFirst();\\n            } else {\\n                pushAll(cur.right);\\n                lastNode = stack.pollFirst();\\n                return lastNode;\\n            }\\n        }\\n\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    }\\n    \\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        if(root == null) return Arrays.asList();\\n        ArrayList<Integer> result = new ArrayList();\\n        BSTIterator iterator = new BSTIterator(root);\\n        while(iterator.hasNext()){\\n            result.add(iterator.next().val);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    class BSTIterator {\\n        Deque<TreeNode> stack = new ArrayDeque();\\n        TreeNode lastNode = null;\\n        \\n        public BSTIterator(TreeNode root) {\\n            pushAll(root);\\n        }\\n        \\n        private void pushAll(TreeNode cursor) {\\n            while(cursor != null) {\\n                stack.offerFirst(cursor);\\n                if(cursor.left!=null) cursor = cursor.left;\\n                else if(cursor.right!=null) cursor = cursor.right;\\n                else cursor = null;\\n            }\\n        }\\n\\n        public TreeNode next() {\\n            TreeNode cur = stack.peekFirst();\\n            if(cur == null) return null;\\n            if(lastNode == cur.right){\\n                lastNode = cur;\\n                return stack.pollFirst();\\n            } else {\\n                pushAll(cur.right);\\n                lastNode = stack.pollFirst();\\n                return lastNode;\\n            }\\n        }\\n\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    }\\n    \\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        if(root == null) return Arrays.asList();\\n        ArrayList<Integer> result = new ArrayList();\\n        BSTIterator iterator = new BSTIterator(root);\\n        while(iterator.hasNext()){\\n            result.add(iterator.next().val);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068200,
                "title": "c-iterative-100-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\nvector<int> Solution::postorderTraversal(TreeNode* root) {\\n    vector<int> v;\\n    if (root == NULL) \\n        return v; \\n  \\n    // Create two stacks \\n    stack<TreeNode *> s1, s2; \\n  \\n    // push root to first stack \\n    s1.push(root); \\n    TreeNode* node; \\n    // Run while first stack is not empty \\n    while (!s1.empty()) { \\n        // Pop an item from s1 and push it to s2 \\n        node = s1.top(); \\n        s1.pop(); \\n        s2.push(node); \\n  \\n        // Push left and right children \\n        // of removed item to s1 \\n        if (node->left) \\n            s1.push(node->left); \\n        if (node->right) \\n            s1.push(node->right); \\n    }\\n    \\n    while (!s2.empty()) { \\n        node = s2.top(); \\n        s2.pop(); \\n        v.push_back(node->val); \\n    } \\n    \\n    return v;   \\n}\\n};\\n```\\n**Plz upvote it..**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> Solution::postorderTraversal(TreeNode* root) {\\n    vector<int> v;\\n    if (root == NULL) \\n        return v; \\n  \\n    // Create two stacks \\n    stack<TreeNode *> s1, s2; \\n  \\n    // push root to first stack \\n    s1.push(root); \\n    TreeNode* node; \\n    // Run while first stack is not empty \\n    while (!s1.empty()) { \\n        // Pop an item from s1 and push it to s2 \\n        node = s1.top(); \\n        s1.pop(); \\n        s2.push(node); \\n  \\n        // Push left and right children \\n        // of removed item to s1 \\n        if (node->left) \\n            s1.push(node->left); \\n        if (node->right) \\n            s1.push(node->right); \\n    }\\n    \\n    while (!s2.empty()) { \\n        node = s2.top(); \\n        s2.pop(); \\n        v.push_back(node->val); \\n    } \\n    \\n    return v;   \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584697,
                "title": "python-same-iterative-code-for-inorder-preorder-postorder-traversal",
                "content": "The official iterative solutions are very different for inorder, preorder, postorder traversals. My way is more universal and fits all three problems with same code, only changes on stack appending order.\\nBasic idea is, If the end of the stack is a number, append it to result array. If it is not a number, but a node, then push the node\\'s children back to stack and pop again.\\n\\nSame code for 3 problems.\\n\\nPostorder:\\n```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.val, node.right, node.left])\\n        return res\\n```\\n\\nInorder:\\n```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.right, node.val, node.left])\\n        return res\\n```\\n\\nPreorder:\\n```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.right, node.left, node.val])\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.val, node.right, node.left])\\n        return res\\n```\n```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.right, node.val, node.left])\\n        return res\\n```\n```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.right, node.left, node.val])\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478112,
                "title": "iterative-solution-using-one-stack-beats-99-25-solutions-in-runtime",
                "content": "Psuedocode:\\n\\nwhile curr node exists , keep pushing in stack and keep makking curr = curr.left\\n\\nwhen curr is null, \\n\\tif(stackTop.right is exists) -> make curr = curr.right since its unvisited\\n\\tif(stackTop.right does not exist) -> \\n\\t\\tpop the curr top from stack\\n\\t\\twhile the popped el is right child of stack\\'s top and stack is not empty, keep popping\\n\\t\\t\\n\\t\\tnow either stack is empty or popped el was the left child\\n\\t\\t  if stack empty -> make curr null -> as traversal is done\\n\\t\\t  if it was the left child -> we need to set the curr to stackpop.right\\n\\t\\t  \\nWorking code:\\n```\\nvar postorderTraversal = function(root) {\\n    if(root == null) return [];\\n    let curr = root;\\n    let stack = [];\\n    let result = [];\\n    let prev = null;\\n    while(curr || stack.length) {\\n        if(curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        } else {\\n            curr = stack[stack.length - 1];  //peek for top\\n            if(curr.right) {\\n                curr = curr.right;\\n            }\\n            else { //right of top does not exist, so need to pop\\n                curr = stack.pop();\\n                result.push(curr.val);\\n                while(stack.length && curr == stack[stack.length -1].right) {  //while last popped el is top\\'s right child, visit it\\n                    curr = stack.pop();\\n                    result.push(curr.val);\\n                }\\n                if(stack.length) { //end case, this cond will break is stack is empty\\n                    curr = stack[stack.length - 1].right; \\n                } else {\\n                    curr = null;\\n                }\\n            }                \\n\\n        }\\n    }\\n    return result;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar postorderTraversal = function(root) {\\n    if(root == null) return [];\\n    let curr = root;\\n    let stack = [];\\n    let result = [];\\n    let prev = null;\\n    while(curr || stack.length) {\\n        if(curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        } else {\\n            curr = stack[stack.length - 1];  //peek for top\\n            if(curr.right) {\\n                curr = curr.right;\\n            }\\n            else { //right of top does not exist, so need to pop\\n                curr = stack.pop();\\n                result.push(curr.val);\\n                while(stack.length && curr == stack[stack.length -1].right) {  //while last popped el is top\\'s right child, visit it\\n                    curr = stack.pop();\\n                    result.push(curr.val);\\n                }\\n                if(stack.length) { //end case, this cond will break is stack is empty\\n                    curr = stack[stack.length - 1].right; \\n                } else {\\n                    curr = null;\\n                }\\n            }                \\n\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45711,
                "title": "java-recursive-and-iterative-solutions",
                "content": "       \\n    // recursively\\n    public List<Integer> postorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> ret) {\\n        if (root != null) {\\n            dfs(root.left, ret);\\n            dfs(root.right, ret);\\n            ret.add(root.val);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        Deque<TreeNode> stack = new LinkedList<>();\\n        stack.push(root);\\n        List<Integer> ret = new ArrayList<>();\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            if (node != null) {\\n                ret.add(node.val);\\n                stack.push(node.left);\\n                stack.push(node.right);\\n            }\\n        }\\n        Collections.reverse(ret);\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "       \\n    // recursively\\n    public List<Integer> postorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> ret) {\\n        if (root != null) {\\n            dfs(root.left, ret);\\n            dfs(root.right, ret);\\n            ret.add(root.val);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        Deque<TreeNode> stack = new LinkedList<>();\\n        stack.push(root);\\n        List<Integer> ret = new ArrayList<>();\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            if (node != null) {\\n                ret.add(node.val);\\n                stack.push(node.left);\\n                stack.push(node.right);\\n            }\\n        }\\n        Collections.reverse(ret);\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45784,
                "title": "share-my-simple-neat-cpp-solution-0-ms-use-stack-without-changing-tree-easy-to-understand",
                "content": "    vector<int> postorderTraversal(TreeNode *root)\\n    {\\n        vector<int> result;\\n        if (!root) return result;\\t\\n        stack<TreeNode *> stk;\\n        stk.push(root);\\n        TreeNode *pre = root;\\n        while (!stk.empty())\\n        {\\n        \\tTreeNode *i_root = stk.top();\\n        \\tif (i_root->left && i_root->left != pre && i_root->right != pre)\\n        \\t{\\n        \\t\\tstk.push(i_root->left);\\t\\t\\t//push left child\\n        \\t}\\n        \\telse if (i_root->right && i_root->right != pre)\\n        \\t{\\t\\n        \\t\\tstk.push(i_root->right);\\t\\t//push right child\\n        \\t}\\n        \\telse\\n        \\t{\\n        \\t\\tresult.push_back(i_root->val);\\t//record root\\n        \\t\\tpre = stk.top();\\n        \\t\\tstk.pop();\\t\\t\\t\\t\\t\\t//stack pop\\n        \\t}\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> postorderTraversal(TreeNode *root)\\n    {\\n        vector<int> result;\\n        if (!root) return result;\\t\\n        stack<TreeNode *> stk;\\n        stk.push(root);\\n        TreeNode *pre = root;\\n        while (!stk.empty())\\n        {\\n        \\tTreeNode *i_root = stk.top();\\n        \\tif (i_root->left && i_root->left != pre && i_root->right != pre)\\n        \\t{\\n        \\t\\tstk.push(i_root->left);\\t\\t\\t//push left child\\n        \\t}\\n        \\telse if (i_root->right && i_root->right != pre)\\n        \\t{\\t\\n        \\t\\tstk.push(i_root->right);\\t\\t//push right child\\n        \\t}\\n        \\telse\\n        \\t{\\n        \\t\\tresult.push_back(i_root->val);\\t//record root\\n        \\t\\tpre = stk.top();\\n        \\t\\tstk.pop();\\t\\t\\t\\t\\t\\t//stack pop\\n        \\t}\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45814,
                "title": "share-my-easy-understanding-c-solution-2ms",
                "content": "    //use a stack\\n    //stack pop order:root,right,left\\n    //reverse the result\\n    class Solution {\\n    public:\\n    \\tvector<int> postorderTraversal(TreeNode* root) {\\n    \\t\\tvector<int> res;\\n    \\t\\tstack<TreeNode*> tree;\\n    \\t\\tTreeNode* tmp;\\n    \\t\\tif(!root)\\n    \\t\\t\\treturn res;\\n    \\t\\ttree.push(root);\\n    \\t\\twhile(!tree.empty()){\\n    \\t\\t\\ttmp=tree.top();\\n    \\t\\t\\ttree.pop();\\n    \\t\\t\\tres.push_back(tmp->val);\\n    \\t\\t\\tif(tmp->left)\\n    \\t\\t\\t\\ttree.push(tmp->left);\\n    \\t\\t\\tif(tmp->right)\\n    \\t\\t\\t\\ttree.push(tmp->right);\\n    \\t\\t}\\n    \\t\\treverse(res.begin(),res.end());\\n    \\t\\treturn res;\\n    \\t}\\t\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvector<int> postorderTraversal(TreeNode* root) {\\n    \\t\\tvector<int> res;\\n    \\t\\tstack<TreeNode*> tree;\\n    \\t\\tTreeNode* tmp;\\n    \\t\\tif(!root)\\n    \\t\\t\\treturn res;\\n    \\t\\ttree.push(root);\\n    \\t\\twhile(!tree.empty()){\\n    \\t\\t\\ttmp=tree.top();\\n    \\t\\t\\ttree.pop();\\n    \\t\\t\\tres.push_back(tmp->val);\\n    \\t\\t\\tif(tmp->left)\\n    \\t\\t\\t\\ttree.push(tmp->left);\\n    \\t\\t\\tif(tmp->right)\\n    \\t\\t\\t\\ttree.push(tmp->right);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 728983,
                "title": "c-clean-and-minimal-modification-for-iterative-version-of-tree-preorder-inorder-and-postorder",
                "content": "* preorder \\n```c++\\n/**\\nformat:\\n    L0\\n   L1\\n  L2\\n L3 R1\\n \\n1. put all of the leftmost branch to stk.\\n    a. preorder: report node before entering stk\\n2. move to the right branch of the top node in the stk      \\n\\nT: O(n)\\nS: O(h), in average; O(n) in worst case\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        vector<int> res;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                res.push_back(crt->val);\\n                stk.push(crt);\\n                crt = crt->left;\\n            }\\n            if(!stk.empty()) {\\n                crt = stk.top()->right;\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n* inorder \\n\\t* only one line different from that of preorder version. \\n```c++\\n/**\\nformat: \\n1. put leftmost node in the stack\\n2. for inorder traversal, report the node once picking it from the stack\\n3. move to the right branch \\n\\nT: O(N)\\nS: O(h) in average; O(N) in worst case \\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode*> stk;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                stk.push(crt);\\n                crt = crt->left;\\n            }\\n            if(!stk.empty()) {\\n                // only this line is different from that of preorder \\n                res.push_back(stk.top()->val);\\n                crt = stk.top()->right;\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n* postorder \\n\\t* onlye one line different from that of preorder version\\n\\t* reverse the sequence \\n\\n```c++\\n/**\\npostorder \\n= left, right, root\\npreorder\\n= root, left, right\\n\\nmodifty preorder\\n= root, right, right\\n\\n1. do by modifoed preorder \\n2. reverse the result \\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        vector<int> res;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                res.push_back(crt->val);\\n                stk.push(crt);\\n                // only this line is different from that of preorder \\n                crt = crt->right;\\n            }\\n            if(!stk.empty()) {\\n                crt = stk.top()->left;\\n                stk.pop();\\n            }\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n/**\\nformat:\\n    L0\\n   L1\\n  L2\\n L3 R1\\n \\n1. put all of the leftmost branch to stk.\\n    a. preorder: report node before entering stk\\n2. move to the right branch of the top node in the stk      \\n\\nT: O(n)\\nS: O(h), in average; O(n) in worst case\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        vector<int> res;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                res.push_back(crt->val);\\n                stk.push(crt);\\n                crt = crt->left;\\n            }\\n            if(!stk.empty()) {\\n                crt = stk.top()->right;\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```c++\\n/**\\nformat: \\n1. put leftmost node in the stack\\n2. for inorder traversal, report the node once picking it from the stack\\n3. move to the right branch \\n\\nT: O(N)\\nS: O(h) in average; O(N) in worst case \\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode*> stk;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                stk.push(crt);\\n                crt = crt->left;\\n            }\\n            if(!stk.empty()) {\\n                // only this line is different from that of preorder \\n                res.push_back(stk.top()->val);\\n                crt = stk.top()->right;\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```c++\\n/**\\npostorder \\n= left, right, root\\npreorder\\n= root, left, right\\n\\nmodifty preorder\\n= root, right, right\\n\\n1. do by modifoed preorder \\n2. reverse the result \\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        vector<int> res;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                res.push_back(crt->val);\\n                stk.push(crt);\\n                // only this line is different from that of preorder \\n                crt = crt->right;\\n            }\\n            if(!stk.empty()) {\\n                crt = stk.top()->left;\\n                stk.pop();\\n            }\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634448,
                "title": "morris-traversal",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> list = new LinkedList<>();  \\n        if (root == null) {\\n            return list;\\n        }        \\n        //Use the idea of Morris Traversal, but we change the order between right and left \\n        TreeNode node = root;\\n        while (node != null) {\\n            if (node.right == null) {\\n                list.addFirst(node.val);\\n                node = node.left;  \\n            } else {\\n                TreeNode curNode = node.right;\\n                while (curNode.left != node && curNode.left != null) {\\n                    curNode = curNode.left;\\n                }\\n                if (curNode.left == node) { //second time visit, we break the link, and go to the left branch\\n                    curNode.left = null;\\n                    node = node.left;      \\n                } else { //first time visit, we connect two nodes here, and go to the right branch\\n                    curNode.left = node;\\n                    list.addFirst(node.val);\\n                    node = node.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> list = new LinkedList<>();  \\n        if (root == null) {\\n            return list;\\n        }        \\n        //Use the idea of Morris Traversal, but we change the order between right and left \\n        TreeNode node = root;\\n        while (node != null) {\\n            if (node.right == null) {\\n                list.addFirst(node.val);\\n                node = node.left;  \\n            } else {\\n                TreeNode curNode = node.right;\\n                while (curNode.left != node && curNode.left != null) {\\n                    curNode = curNode.left;\\n                }\\n                if (curNode.left == node) { //second time visit, we break the link, and go to the left branch\\n                    curNode.left = null;\\n                    node = node.left;      \\n                } else { //first time visit, we connect two nodes here, and go to the right branch\\n                    curNode.left = node;\\n                    list.addFirst(node.val);\\n                    node = node.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45703,
                "title": "my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int>res;\\n        stack<TreeNode *>stack;\\n        TreeNode * temp;\\n        if(!root)return res;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            temp=stack.top();\\n            stack.pop();\\n            res.insert(res.begin(), temp->val);\\n            if(temp->left)stack.push(temp->left);\\n            if(temp->right)stack.push(temp->right);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int>res;\\n        stack<TreeNode *>stack;\\n        TreeNode * temp;\\n        if(!root)return res;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            temp=stack.top();\\n            stack.pop();\\n            res.insert(res.begin(), temp->val);\\n            if(temp->left)stack.push(temp->left);\\n            if(temp->right)stack.push(temp->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 45817,
                "title": "accepted-tiny-java-code-by-reversing-root-right-left",
                "content": "the idea is to convert the problem to (root, right, left) with add first into the linkedlist.\\n\\n    public class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            LinkedList<Integer> result = new LinkedList<>();\\n            if (root == null)  return result;\\n            TreeNode curr = root;\\n            Stack<TreeNode> stack = new Stack<>();\\n            stack.push(curr);\\n            while (!stack.isEmpty()) {\\n                curr = stack.pop();\\n                result.addFirst(curr.val);\\n                if (curr.left != null )  stack.push(curr.left);\\n                if (curr.right !=null ) stack.push(curr.right);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            LinkedList<Integer> result = new LinkedList<>();\\n            if (root == null)  return result;\\n            TreeNode curr = root;\\n            Stack<TreeNode> stack = new Stack<>();\\n            stack.push(curr);\\n            while (!stack.isEmpty()) {\\n                curr = stack.pop();\\n                result.addFirst(curr.val);\\n                if (curr.left != null )  stack.push(curr.left);\\n                if (curr.right !=null ) stack.push(curr.right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1976373,
                "title": "c-easiest-code-with-memory-optimization-100",
                "content": "class Solution {\\n    private : vector<int>res;\\n    void postorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        postorder(root->left,res);\\n        \\n        postorder(root->right,res);\\n        res.push_back(root->val);\\n        return;\\n    }\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        postorder(root,res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    private : vector<int>res;\\n    void postorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        postorder(root->left,res);\\n        \\n        postorder(root->right,res);\\n        res.push_back(root->val);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1516080,
                "title": "python-recursive-iterative-simple-solutions",
                "content": "## Recursive Solution\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def traversal(self, root, postorder):\\n        if root:\\n            self.traversal(root.left, postorder)\\n            self.traversal(root.right, postorder)\\n            postorder.append(root.val)\\n            \\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        postorder = []\\n        self.traversal(root, postorder)\\n        return postorder\\n```\\n\\n## Iterative Solution\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        postorder = []\\n        stack = [root]\\n        visited = set()\\n        while stack:\\n            root = stack[-1]\\n            if root:\\n                if root not in visited:\\n                    visited.add(root)\\n                    stack.append(root.left)\\n                elif root.right and root.right not in visited:\\n                    stack.append(root.right)\\n                else:\\n                    root = stack.pop()\\n                    postorder.append(root.val)                    \\n            else:\\n                stack.pop()\\n                \\n        return postorder\\n```\\n\\n***If you liked the above solutions then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def traversal(self, root, postorder):\\n        if root:\\n            self.traversal(root.left, postorder)\\n            self.traversal(root.right, postorder)\\n            postorder.append(root.val)\\n            \\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        postorder = []\\n        self.traversal(root, postorder)\\n        return postorder\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        postorder = []\\n        stack = [root]\\n        visited = set()\\n        while stack:\\n            root = stack[-1]\\n            if root:\\n                if root not in visited:\\n                    visited.add(root)\\n                    stack.append(root.left)\\n                elif root.right and root.right not in visited:\\n                    stack.append(root.right)\\n                else:\\n                    root = stack.pop()\\n                    postorder.append(root.val)                    \\n            else:\\n                stack.pop()\\n                \\n        return postorder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315230,
                "title": "iterative-traversal",
                "content": "## Iterative Traversal\\n**PreOrder**\\n```java\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> rights = new LinkedList<>();\\n    TreeNode p = root;\\n    while(!rights.isEmpty() || p != null) {\\n        if(p != null) {\\n            ans.add(p.val);\\n            if(p.right != null) rights.push(p.right);\\n            p = p.left;\\n        } else {\\n            p = rights.pop();\\n        }\\n    }\\n    return ans;\\n}\\n```\\nIntuitively, when recursive, the stack only records the **context state** of the previous function call. In fact, the remaining context state here is the information of the **right child** of the previous node. We can use stack to keep this information.\\n\\n---\\n**InOrder**\\n```java\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> fa = new LinkedList<>();\\n    TreeNode p = root;\\n    while(!fa.isEmpty() || p != null){\\n        if(p != null) {\\n            fa.push(p);\\n            p = p.left;\\n        } else {\\n            TreeNode top = fa.pop();\\n            ans.add(top.val);\\n            p = top.right;\\n        }\\n    }\\n    return ans;\\n}\\n```\\nFor inorder traversal, the information retained by the node at the previous level is actually its **value** and **right child**, so the parent node can be kept in the stack.\\n\\n---\\n**PostOrder**\\n```java\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> fa = new LinkedList<>();\\n    TreeNode p = root;\\n    TreeNode lastReturn = null;\\n    while(!fa.isEmpty() || p != null) {\\n        if(p != null) {\\n            fa.push(p);\\n            p = p.left;\\n        } else {\\n            if(fa.peek().right == null || lastReturn == fa.peek().right) {\\n                ans.add(fa.peek().val);\\n                lastReturn = fa.pop();\\n            } else {\\n                p = fa.peek().right;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\\nThe postorder traversal is a little more complicated, because the value and the right child information of the node of previous layer are to be retained, and the **value** is to be retained until the end. Therefore, when `p==null`, it is not possible to determine whether the right subtree of the parent has been traversed, but only after the right subtree has been traversed, the value of the parent can be output. So we\\'re going to record the last node that popped up,` lastReturn`, and if it\\'s equal to the right child of the parent, that means that the right subtree has been traversed, that parent can be safely popped up, and `lastReturn` is equal to the popped up node. \\n\\n**Discussion**\\nWhy don\\'t we worry about this when we use recursive method?\\nBecause at the time of recursion, stack frame will automatically record the context information of the function, including the program execution to which step. But in our \"stack\", we simply recorded the information of the node (the value and right subtree). So we don\\'t know we execute to which step. We need to make some special judgments to know where we are currently executing.",
                "solutionTags": [],
                "code": "```java\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> rights = new LinkedList<>();\\n    TreeNode p = root;\\n    while(!rights.isEmpty() || p != null) {\\n        if(p != null) {\\n            ans.add(p.val);\\n            if(p.right != null) rights.push(p.right);\\n            p = p.left;\\n        } else {\\n            p = rights.pop();\\n        }\\n    }\\n    return ans;\\n}\\n```\n```java\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> fa = new LinkedList<>();\\n    TreeNode p = root;\\n    while(!fa.isEmpty() || p != null){\\n        if(p != null) {\\n            fa.push(p);\\n            p = p.left;\\n        } else {\\n            TreeNode top = fa.pop();\\n            ans.add(top.val);\\n            p = top.right;\\n        }\\n    }\\n    return ans;\\n}\\n```\n```java\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> fa = new LinkedList<>();\\n    TreeNode p = root;\\n    TreeNode lastReturn = null;\\n    while(!fa.isEmpty() || p != null) {\\n        if(p != null) {\\n            fa.push(p);\\n            p = p.left;\\n        } else {\\n            if(fa.peek().right == null || lastReturn == fa.peek().right) {\\n                ans.add(fa.peek().val);\\n                lastReturn = fa.pop();\\n            } else {\\n                p = fa.peek().right;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1020132,
                "title": "recursive-c-easy-understanding",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        vec.push_back(root->val);\\n        return vec;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        vec.push_back(root->val);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953213,
                "title": "easy-peasy-approach-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int>v;\\n        stack<TreeNode*>s;\\n        while(1)\\n        {\\n            while(root)\\n            {\\n                v.push_back(root->val);\\n                s.push(root);\\n                root=root->right;\\n            }\\n            if(s.empty())break;\\n            root=s.top();\\n            s.pop();\\n            root=root->left;\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int>v;\\n        stack<TreeNode*>s;\\n        while(1)\\n        {\\n            while(root)\\n            {\\n                v.push_back(root->val);\\n                s.push(root);\\n                root=root->right;\\n            }\\n            if(s.empty())break;\\n            root=s.top();\\n            s.pop();\\n            root=root->left;\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216883,
                "title": "general-iteration-for-preorder-inorder-postorder-and-for-n-ary-tree-only-one-line-change",
                "content": "since the recursion version traverse is so easy and general, why does iteration have to be so different for  different traverse(especially for postorder).\\nWe can actually simulate program stack and make iteration more general and intuitive.\\nOnly one line change can switch from one method to another \\n#### Postorder Traverse\\n```\\npublic List<Integer> postorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.val);\\n                myStack.push(node.right);\\n                myStack.push(node.left);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n```\\n\\n#### Inorder Traverse\\n```\\npublic List<Integer> inorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.right);\\n                myStack.push(node.val);\\n                myStack.push(node.left);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n```\\n\\n#### Preorder Traverse\\n```\\npublic List<Integer> preorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.right);\\n                myStack.push(node.left);\\n                myStack.push(node.val);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n \\n```\\n\\n#### 590. N-ary Tree Postorder Traversal\\n```\\npublic List<Integer> postorder(Node root) \\n\\t{\\n        List<Integer> result = new ArrayList();\\n        Stack<Object> myStack = new Stack();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object object = myStack.pop();\\n            if(object == null)\\n            {\\n                continue;\\n            }\\n            if(object instanceof Node)\\n            {\\n                Node node = (Node)object;\\n                myStack.push(node.val);\\n                List<Node> children = node.children;\\n                for(int i = children.size() - 1; i >= 0; i--)\\n                {\\n                    myStack.push(children.get(i));\\n                }\\n            }\\n            else\\n            {\\n                result.add((Integer)object);\\n            }\\n\\n        }\\n        return result;\\n\\n    }\\n```\\n#### 589. N-ary Tree Preorder Traversal\\n```\\npublic List<Integer> preorder(Node root) \\n    {\\n        List<Integer> result = new ArrayList();\\n        Stack<Object> myStack = new Stack();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object object = myStack.pop();\\n            if(object == null)\\n            {\\n                continue;\\n            }\\n            if(object instanceof Node)\\n            {\\n                Node node = (Node)object;\\n                List<Node> children = node.children;\\n                for(int i = children.size() - 1; i >= 0; i--)\\n                {\\n                    myStack.push(children.get(i));\\n                }\\n                myStack.push(node.val);\\n            }\\n            else\\n            {\\n                result.add((Integer)object);\\n            }\\n\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> postorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.val);\\n                myStack.push(node.right);\\n                myStack.push(node.left);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n```\n```\\npublic List<Integer> inorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.right);\\n                myStack.push(node.val);\\n                myStack.push(node.left);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n```\n```\\npublic List<Integer> preorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.right);\\n                myStack.push(node.left);\\n                myStack.push(node.val);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n \\n```\n```\\npublic List<Integer> postorder(Node root) \\n\\t{\\n        List<Integer> result = new ArrayList();\\n        Stack<Object> myStack = new Stack();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object object = myStack.pop();\\n            if(object == null)\\n            {\\n                continue;\\n            }\\n            if(object instanceof Node)\\n            {\\n                Node node = (Node)object;\\n                myStack.push(node.val);\\n                List<Node> children = node.children;\\n                for(int i = children.size() - 1; i >= 0; i--)\\n                {\\n                    myStack.push(children.get(i));\\n                }\\n            }\\n            else\\n            {\\n                result.add((Integer)object);\\n            }\\n\\n        }\\n        return result;\\n\\n    }\\n```\n```\\npublic List<Integer> preorder(Node root) \\n    {\\n        List<Integer> result = new ArrayList();\\n        Stack<Object> myStack = new Stack();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object object = myStack.pop();\\n            if(object == null)\\n            {\\n                continue;\\n            }\\n            if(object instanceof Node)\\n            {\\n                Node node = (Node)object;\\n                List<Node> children = node.children;\\n                for(int i = children.size() - 1; i >= 0; i--)\\n                {\\n                    myStack.push(children.get(i));\\n                }\\n                myStack.push(node.val);\\n            }\\n            else\\n            {\\n                result.add((Integer)object);\\n            }\\n\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167091,
                "title": "javascript-traversal-pre-in-post-iteration-template-inspired-by-luffyzhou-s-solution",
                "content": "I got inspired by luffyzhou\\'s python solution which only use one line change to cover the `preOrder`, `inOrder` and  `postOrder` iteration traversal.\\n\\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45539/Iterative-method-to-do-three-kinds-of-traversal-just-like-recursive-method-only-changing-one-line-code\\n\\nHere is Javascript version.\\n\\nEasy understand tips:\\n* PreOrder => currentNode - leftChild - rightChild\\n* InOrder =>  leftChild - currentNode - rightChild\\n* PostOrder => leftChild -  rightChild - currentNode\\n\\nTherefore, just need to change the order depends on these rules and reverse them, then push to stack.\\n\\nSolution for PostOrder\\nUse rule : **PostOrder => leftChild - rightChild - currentNode**\\n\\n```\\nvar postorderTraversal = function (root) {\\n  if (!root) return []\\n\\n  const result = []\\n  const stack = [{node: root, visited: false}]\\n\\n  while (stack.length) {\\n    let {\\n      node: currentNode,\\n      visited\\n    } = stack.pop()\\n\\n    if (!currentNode) continue\\n\\n    visited ?\\n      result.push(currentNode.val) :\\n      stack.push(...[\\n          {node: currentNode.left, visited: false},\\n          {node: currentNode.right, visited: false},\\n          {node: currentNode, visited: true}\\n        ].reverse()\\n      )\\n  }\\n\\n  return result\\n}\\n```\\n\\nFor InOrder, change the array which stack push as: \\n\\n```\\n[\\n  {node: currentNode.left, visited: false},\\n  {node: currentNode, visited: true},\\n  {node: currentNode.right, visited: false}\\n]\\n```\\n\\nFor PreOrder, change the array which stack push as: \\n\\n```\\n[\\n  {node: currentNode, visited: true},\\n  {node: currentNode.left, visited: false},\\n  {node: currentNode.right, visited: false}\\n]\\n```",
                "solutionTags": [],
                "code": "```\\nvar postorderTraversal = function (root) {\\n  if (!root) return []\\n\\n  const result = []\\n  const stack = [{node: root, visited: false}]\\n\\n  while (stack.length) {\\n    let {\\n      node: currentNode,\\n      visited\\n    } = stack.pop()\\n\\n    if (!currentNode) continue\\n\\n    visited ?\\n      result.push(currentNode.val) :\\n      stack.push(...[\\n          {node: currentNode.left, visited: false},\\n          {node: currentNode.right, visited: false},\\n          {node: currentNode, visited: true}\\n        ].reverse()\\n      )\\n  }\\n\\n  return result\\n}\\n```\n```\\n[\\n  {node: currentNode.left, visited: false},\\n  {node: currentNode, visited: true},\\n  {node: currentNode.right, visited: false}\\n]\\n```\n```\\n[\\n  {node: currentNode, visited: true},\\n  {node: currentNode.left, visited: false},\\n  {node: currentNode.right, visited: false}\\n]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45713,
                "title": "preorder-u3001inorder-u3001postorder-iterative-solution-by-c",
                "content": "preorder:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.push_back(root->val);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\ninorder:\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\tres.push_back(root->val);\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\n\\npostorder:\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.insert(res.begin(),root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->left;\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "preorder:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.push_back(root->val);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\ninorder:\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\tres.push_back(root->val);\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\n\\npostorder:\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.insert(res.begin(),root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->left;\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45716,
                "title": "simple-1ms-java-solution-using-o-1-extra-space-morris-traversal",
                "content": "The key to keeping the solution simple is to add the element from the **front** of the result list. Then the problem becomes a mirrored version of [Morris pre-order traversal][1]\\n\\n\\n    public class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            List<Integer> result = new LinkedList<>();\\n            while (root != null) {\\n                if (root.right == null) {\\n                    result.add(0, root.val);\\n                    root = root.left;\\n                } else {\\n                    TreeNode predecessor = root.right;\\n                    while (predecessor.left != null && predecessor.left != root) {\\n                        predecessor = predecessor.left;\\n                    }\\n                    if (predecessor.left == null) {\\n                        predecessor.left = root;\\n                        result.add(0, root.val);\\n                        root = root.right;\\n                    } else {\\n                        predecessor.left = null;\\n                        root = root.left;\\n                    }\\n                }\\n            }\\n            \\n            return result;\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/63018/morris-traversal-time-space-applied-inorder-and-postorder",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            List<Integer> result = new LinkedList<>();\\n            while (root != null) {\\n                if (root.right == null) {\\n                    result.add(0, root.val);\\n                    root = root.left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 45778,
                "title": "a-very-simple-c-solution-0-ms-runtime",
                "content": "    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) \\n        {\\n            vector<int> output;\\n            if(root == NULL)\\n                return output;\\n                \\n            stack<TreeNode*> stk;\\n            \\n            stk.push(root);\\n            while(!stk.empty())\\n            {\\n                TreeNode *t = stk.top();\\n                stk.pop();\\n                output.push_back(t->val);\\n                if(t->left)\\n                    stk.push(t->left);\\n                if(t->right)\\n                    stk.push(t->right);\\n            }\\n            \\n            reverse(output.begin(), output.end());\\n            return output;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) \\n        {\\n            vector<int> output;\\n            if(root == NULL)\\n                return output;\\n                \\n            stack<TreeNode*> stk;\\n            \\n            stk.push(root);\\n            while(!stk.empty())\\n            {\\n                TreeNode *t = stk.top();\\n                stk.pop();\\n                output.push_back(t->val);\\n                if(t->left)\\n                    stk.push(t->left);\\n                if(t->right)\\n                    stk.push(t->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 45849,
                "title": "4ms-c-simple-solution-with-explaination",
                "content": "    class Solution {\\n    public:\\n        void pushPathToLeftmostLeaf(TreeNode* n, stack<TreeNode*>& s) {\\n            while(n) {\\n                s.push(n);\\n                n = n->left != NULL ? n->left : n->right;\\n            }\\n        }\\n        // LOGIC: A good way to think about this would be \\n        // think about the stack of the recursive solution\\n        // you just have to mimick that behaviour. :)\\n        vector<int> postorderTraversal(TreeNode *root) {\\n           stack<TreeNode*> s;\\n           pushPathToLeftmostLeaf(root, s);\\n           vector<int> result;\\n           while(!s.empty()) {\\n               TreeNode* cur  = s.top();\\n               s.pop();\\n               result.push_back(cur->val);\\n               TreeNode* next = s.empty() ? NULL : s.top();\\n               // check if the cur is the left child of next\\n               // if it is, then we are yet to explore the right child\\n               // of next\\n               if (next && next->left == cur) {\\n                   pushPathToLeftmostLeaf(next->right,s);\\n               }\\n           }\\n           return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        void pushPathToLeftmostLeaf(TreeNode* n, stack<TreeNode*>& s) {\\n            while(n) {\\n                s.push(n);\\n                n = n->left != NULL ? n->left : n->right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3206647,
                "title": "145-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a stack to implement an iterative postorder traversal of the binary tree. The algorithm starts by adding the root node to the stack. Then, while the stack is not empty, it pops the next node from the stack, appends its value to the result list, and adds its left and right children to the stack (if they exist). Finally, the result list is reversed and returned as the final output.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        stack = [root]\\n        result = []\\n        \\n        while stack:\\n            node = stack.pop()\\n            result.append(node.val)\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        \\n        return result[::-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        stack = [root]\\n        result = []\\n        \\n        while stack:\\n            node = stack.pop()\\n            result.append(node.val)\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        \\n        return result[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008957,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity : $$O(N)$$\\n\\n- Space complexity : $$O(1)$$, if we don\\u2019t consider the size of the stack for function. Otherwise, $$O(H)$$ where H is the height of the tree. \\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root != NULL)\\n        {\\n            postorderTraversal(root->left);\\n            postorderTraversal(root->right);\\n            res.push_back(root->val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root != NULL)\\n        {\\n            postorderTraversal(root->left);\\n            postorderTraversal(root->right);\\n            res.push_back(root->val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816601,
                "title": "c-simple-recursive-approach",
                "content": "**Post - Order Traversal using Recursion:** \\n```\\n    void postOrder(TreeNode* root, vector<int> &ans){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        // left - right - node\\n        postOrder(root->left, ans);\\n        postOrder(root->right, ans);\\n        ans.push_back(root->val);\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n```\\n***Do upvote !!***",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n    void postOrder(TreeNode* root, vector<int> &ans){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        // left - right - node\\n        postOrder(root->left, ans);\\n        postOrder(root->right, ans);\\n        ans.push_back(root->val);\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876584,
                "title": "all-the-method-from-striver-free-ka-tree-series-recursive-1-stack-2-stack",
                "content": "# Iterative using 1 stack\\n```\\nvector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        TreeNode* curr=root,*temp;\\n        vector<int>v;\\n        while(curr or !st.empty())\\n        { if( curr!=0)\\n        {\\n            st.push(curr);\\n            curr=curr->left;\\n        }\\n        else{\\n            temp=st.top()->right;\\n            if(temp==0)\\n            {\\n                temp=st.top();\\n                st.pop();\\n                v.push_back(temp->val);\\n                while(!st.empty() and temp==st.top()->right)\\n                {\\n                    temp=st.top();\\n                    st.pop();\\n                      v.push_back(temp->val);\\n                }\\n            }\\n            else curr=temp;\\n        }\\n        }\\n        return v;\\n    }\\n```\\n# Recusive\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n   void solve(TreeNode* root)\\n    {\\n        if(root==0)\\n            return ;\\n      \\n       solve(root->left);\\n       \\n       solve(root->right);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n          solve(root);\\n        return ans;\\n    \\n    }\\n};\\n```\\n# itreative using 2 stack\\n```\\n vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int >v;\\n        stack<TreeNode*>st1;\\n        stack<TreeNode*>st2;\\n        st1.push(root);\\n        while(!st1.empty())\\n        {\\n            TreeNode* node =st1.top();\\n            st1.pop();\\n            st2.push(node);\\n            if(node->left!=0) st1.push(node->left);\\n             if(node->right!=0) st1.push(node->right);\\n        }\\n        while(st2.size())\\n        {\\n            v.push_back(st2.top()->val);\\n            st2.pop();\\n        }\\n        return v;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nvector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        TreeNode* curr=root,*temp;\\n        vector<int>v;\\n        while(curr or !st.empty())\\n        { if( curr!=0)\\n        {\\n            st.push(curr);\\n            curr=curr->left;\\n        }\\n        else{\\n            temp=st.top()->right;\\n            if(temp==0)\\n            {\\n                temp=st.top();\\n                st.pop();\\n                v.push_back(temp->val);\\n                while(!st.empty() and temp==st.top()->right)\\n                {\\n                    temp=st.top();\\n                    st.pop();\\n                      v.push_back(temp->val);\\n                }\\n            }\\n            else curr=temp;\\n        }\\n        }\\n        return v;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n   void solve(TreeNode* root)\\n    {\\n        if(root==0)\\n            return ;\\n      \\n       solve(root->left);\\n       \\n       solve(root->right);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n          solve(root);\\n        return ans;\\n    \\n    }\\n};\\n```\n```\\n vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int >v;\\n        stack<TreeNode*>st1;\\n        stack<TreeNode*>st2;\\n        st1.push(root);\\n        while(!st1.empty())\\n        {\\n            TreeNode* node =st1.top();\\n            st1.pop();\\n            st2.push(node);\\n            if(node->left!=0) st1.push(node->left);\\n             if(node->right!=0) st1.push(node->right);\\n        }\\n        while(st2.size())\\n        {\\n            v.push_back(st2.top()->val);\\n            st2.pop();\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765414,
                "title": "99-52-faster-python3-solution-recursively",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e559c721-2fc0-482a-a5dd-e71f2f205c74_1644671962.748144.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736052,
                "title": "java-this-simple-template-can-be-used-for-3-traversals",
                "content": "**Why this template?**\\nI do see other templates like this https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45551/Preorder-Inorder-and-Postorder-Iteratively-Summarization are highly voted, but the problem is that for post-order traversal, its traversal order is not really post-order. It just makes the end result look the same as post-order by reversing the list. In contrast, the following tempalte gives us a real post-order traversal. Also, the following template can provides clean code and it is very easy to understand.\\n\\n**The template**\\nFirst we define a helper class `Pair`:\\n\\n```\\nprivate class Pair {\\n    boolean visited;\\n    TreeNode node;\\n\\n    Pair(TreeNode node, boolean visited) {\\n        this.node = node;\\n        this.visited = visited;\\n    }\\n}\\n```\\n1) https://leetcode.com/problems/binary-tree-preorder-traversal/\\n\\n```\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        Stack<Pair> stack = new Stack();\\n        stack.push(new Pair(root, false));\\n        List<Integer> res = new ArrayList();\\n        while (!stack.isEmpty()) {\\n            Pair curr = stack.pop();\\n            if (curr.node == null)\\n                continue;\\n            if (curr.visited) {\\n                res.add(curr.node.val);\\n            } else {\\n                stack.push(new Pair(curr.node.right, false));      --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.left, false));       --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node, true));             --- only this block of code needs to be adujsted\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n2) https://leetcode.com/problems/binary-tree-inorder-traversal/\\n```\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        Stack<Pair> stack = new Stack();\\n        stack.push(new Pair(root, false));\\n        List<Integer> res = new ArrayList();\\n        while (!stack.isEmpty()) {\\n            Pair curr = stack.pop();\\n            if (curr.node == null)\\n                continue;\\n            if (curr.visited) {\\n                res.add(curr.node.val);\\n            } else {\\n                stack.push(new Pair(curr.node.right, false));   --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node, true));          --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.left, false));    --- only this block of code needs to be adujsted\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n3) https://leetcode.com/problems/binary-tree-postorder-traversal/\\n```\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        Stack<Pair> stack = new Stack();\\n        stack.push(new Pair(root, false));\\n        List<Integer> res = new ArrayList();\\n        while (!stack.isEmpty()) {\\n            Pair curr = stack.pop();\\n            if (curr.node == null)\\n                continue;\\n            if (curr.visited) {\\n                res.add(curr.node.val);\\n            } else {\\n                stack.push(new Pair(curr.node, true));               --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.right, false));        --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.left, false));         --- only this block of code needs to be adujsted\\n            }\\n        }\\n        return res;\\n    }\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Iterator"
                ],
                "code": "```\\nprivate class Pair {\\n    boolean visited;\\n    TreeNode node;\\n\\n    Pair(TreeNode node, boolean visited) {\\n        this.node = node;\\n        this.visited = visited;\\n    }\\n}\\n```\n```\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        Stack<Pair> stack = new Stack();\\n        stack.push(new Pair(root, false));\\n        List<Integer> res = new ArrayList();\\n        while (!stack.isEmpty()) {\\n            Pair curr = stack.pop();\\n            if (curr.node == null)\\n                continue;\\n            if (curr.visited) {\\n                res.add(curr.node.val);\\n            } else {\\n                stack.push(new Pair(curr.node.right, false));      --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.left, false));       --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node, true));             --- only this block of code needs to be adujsted\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        Stack<Pair> stack = new Stack();\\n        stack.push(new Pair(root, false));\\n        List<Integer> res = new ArrayList();\\n        while (!stack.isEmpty()) {\\n            Pair curr = stack.pop();\\n            if (curr.node == null)\\n                continue;\\n            if (curr.visited) {\\n                res.add(curr.node.val);\\n            } else {\\n                stack.push(new Pair(curr.node.right, false));   --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node, true));          --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.left, false));    --- only this block of code needs to be adujsted\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334846,
                "title": "c-solution-faster-than-100-iterative-approach-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> postOrder;\\n        if (root == NULL)\\n            return postOrder;\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            postOrder.insert(postOrder.begin(), curr->val);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n        }\\n        return postOrder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> postOrder;\\n        if (root == NULL)\\n            return postOrder;\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            postOrder.insert(postOrder.begin(), curr->val);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n        }\\n        return postOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329931,
                "title": "python-iterative-solution-with-deque",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if root is None:\\n            return []\\n        if root.left is None and root.right is None:\\n            return [root.val]\\n        \\n        stack, ret_val = list(), deque()\\n        stack.append(root)\\n        \\n        while stack:\\n            node = stack.pop()\\n            \\n            ret_val.appendleft(node.val)\\n            \\n            if node.left:\\n                stack.append(node.left)\\n            \\n            if node.right:\\n                stack.append(node.right)\\n        \\n        return ret_val\\n            \\n",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if root is None:\\n            return []\\n        if root.left is None and root.right is None:\\n            return [root.val]\\n        \\n        stack, ret_val = list(), deque()\\n        stack.append(root)\\n        \\n        while stack:\\n            node = stack.pop()\\n            \\n            ret_val.appendleft(node.val)\\n            \\n            if node.left:\\n                stack.append(node.left)\\n            \\n            if node.right:\\n                stack.append(node.right)\\n        \\n        return ret_val\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 816957,
                "title": "preorder-inorder-postorder-iterative-recursive-explanation",
                "content": "When it comes to the traversal tree problems we can make use of Stack data structure. All the three very famous tree traversals i.e preOrder, postOrder and inOrder can be solved with the help of stack data structure. In this post i\\'ll try to explain what similarities they have in common.\\n\\n<b>Consider out tree looks like this:</b>\\n```\\n\\t\\t   \\t1\\n\\t\\t\\t\\n\\t\\t2      3\\n```\\n\\nThe preOrder traversal  will be ( Root - Left - Right ) : 1 2 3\\nThe postOrder traversal will be ( Left - Right - Root ) : 2 3 1\\nThe inOrder traversal will be ( Left - Root - Right ) : 2 1 3\\n\\nA simple technique to remember is that the answer lies in the name actually, like in case of <b>in</b>Order, the in will simply mean in-between and hence the Root is in between the left and right subtree, similarly in case of <b>pre</b>Order, the pre will imply before the left and right and hence the root is before, same goes for the postOrder.\\n\\n<b>Recursive Solution</b>\\n\\nThe recursive approach is probably lot easier to write in code as recursion handles all the good work which normally people don\\'t dry-run.\\n\\n<b>postOrder</b>\\n```\\n private static void postOrder(TreeNode root){\\n        if(root == null) return;\\n        postOrder(root.left);\\n        postOrder(root.right);\\n        System.out.print(root.val+\" \");\\n    }\\n```\\n\\n<b>preOrder</b>\\n```\\n private static void preOrder(TreeNode root){\\n        if(root == null) return;\\n        System.out.print(root.val+\" \");\\n        preOrder(root.left);\\n        preOrder(root.right);\\n    }\\n```\\n\\n<b>inOrder</b>\\n```\\n private static void inOrder(TreeNode root){\\n        if(root == null) return;\\n        inOrder(root.left);\\n        System.out.print(root.val+\" \");\\n        inOrder(root.right);\\n    }\\n```\\n\\nYou can easily notice, that the only notable difference between them is the positioning of the print statement which basically denotes the root node.\\n\\n<b>Iterative Solutions</b>\\n\\n<b>postOrder</b>\\nIn case of postOrder we need to make use of two stacks, we first insert the root of node of the tree in stack1, then we push this node to the stack2 following with the check for the left subtree node and insert that node first and then for the right substree one.\\n\\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack1 = new Stack<>();\\n        Stack<TreeNode> stack2 = new Stack<>();\\n        stack1.push(root);\\n        while(!stack1.isEmpty()){\\n            TreeNode node = stack1.pop();\\n            stack2.push(node);\\n            if(node.left!=null) stack1.push(node.left);\\n            if(node.right!=null) stack1.push(node.right);\\n        }\\n        while(!stack2.isEmpty()){\\n            TreeNode node = stack2.pop();\\n            list.add(node.val);\\n        }\\n        return list;\\n    }\\n```\\n\\n<b>preOrder Iterative</b>\\nQuite simple actually, just use the LIFO property of stack, and insert the right node first then the left subtree node and you are done.\\n\\n```\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.pop();\\n            list.add(node.val);\\n            if(node.right!=null) stack.push(node.right);\\n            if(node.left!=null) stack.push(node.left);\\n        }\\n        return list;\\n    }\\n```\\n\\n<b>inOrder Iterative</b>\\nTricky! Traverse as left as you can, then consider print the leftmost then print the root and then check for the right subtree and then again go to the left subtree.\\n\\n```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root!=null){\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.pop();\\n            list.add(node.val);\\n            if(node.right!=null){\\n                node = node.right;\\n                while(node!=null){\\n                    stack.push(node);\\n                    node = node.left;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n```\\nHope this helps!",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\t\\t   \\t1\\n\\t\\t\\t\\n\\t\\t2      3\\n```\n```\\n private static void postOrder(TreeNode root){\\n        if(root == null) return;\\n        postOrder(root.left);\\n        postOrder(root.right);\\n        System.out.print(root.val+\" \");\\n    }\\n```\n```\\n private static void preOrder(TreeNode root){\\n        if(root == null) return;\\n        System.out.print(root.val+\" \");\\n        preOrder(root.left);\\n        preOrder(root.right);\\n    }\\n```\n```\\n private static void inOrder(TreeNode root){\\n        if(root == null) return;\\n        inOrder(root.left);\\n        System.out.print(root.val+\" \");\\n        inOrder(root.right);\\n    }\\n```\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack1 = new Stack<>();\\n        Stack<TreeNode> stack2 = new Stack<>();\\n        stack1.push(root);\\n        while(!stack1.isEmpty()){\\n            TreeNode node = stack1.pop();\\n            stack2.push(node);\\n            if(node.left!=null) stack1.push(node.left);\\n            if(node.right!=null) stack1.push(node.right);\\n        }\\n        while(!stack2.isEmpty()){\\n            TreeNode node = stack2.pop();\\n            list.add(node.val);\\n        }\\n        return list;\\n    }\\n```\n```\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.pop();\\n            list.add(node.val);\\n            if(node.right!=null) stack.push(node.right);\\n            if(node.left!=null) stack.push(node.left);\\n        }\\n        return list;\\n    }\\n```\n```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root!=null){\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.pop();\\n            list.add(node.val);\\n            if(node.right!=null){\\n                node = node.right;\\n                while(node!=null){\\n                    stack.push(node);\\n                    node = node.left;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 651066,
                "title": "explanation-iterative-using-stack",
                "content": "self Explanatory code { aka good coding practice } \\n```\\n    // we will maintain two stacks named as \"parent\" and \"preCompute\";\\n    // logic is to directly build postorder taversal with the help of parent stack\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        \\n        if(!root)   return {};\\n        stack<TreeNode*> parent , preCompute;\\n        parent.emplace(root);\\n        \\n        while(parent.size())\\n        {\\n            TreeNode *temp = parent.top();  \\n            parent.pop();\\n            if(temp->left)\\n                parent.emplace(temp->left);\\n            if(temp->right)\\n                parent.emplace(temp->right);\\n            preCompute.emplace(temp);                \\n        }\\n        vector<int> ans;\\n        while(preCompute.size())\\n            ans.emplace_back( preCompute.top()->val) , preCompute.pop();\\n        return ans;\\n    }\\n};\\n```\\n**related follow up question :** https://leetcode.com/problems/n-ary-tree-postorder-traversal/discuss/650999/iterative-approach-explained",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n    // we will maintain two stacks named as \"parent\" and \"preCompute\";\\n    // logic is to directly build postorder taversal with the help of parent stack\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        \\n        if(!root)   return {};\\n        stack<TreeNode*> parent , preCompute;\\n        parent.emplace(root);\\n        \\n        while(parent.size())\\n        {\\n            TreeNode *temp = parent.top();  \\n            parent.pop();\\n            if(temp->left)\\n                parent.emplace(temp->left);\\n            if(temp->right)\\n                parent.emplace(temp->right);\\n            preCompute.emplace(temp);                \\n        }\\n        vector<int> ans;\\n        while(preCompute.size())\\n            ans.emplace_back( preCompute.top()->val) , preCompute.pop();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450823,
                "title": "a-template-for-tree-traversals-pre-order-in-order-post-order-easy-to-memorize-for-interview",
                "content": "While there are many posts shareing different implementations with tree traverses, it is a bit cumbersome to memorize different implementations for different traversal types. And it requires lots of effort to ensure a bug-free implementation. \\n\\nFor better interview purpose, I would like to share my template that works uniformly for pre-order, in-order and post-order traversals. It is easily memorizable, and you can simply write it down in the whiteboard on spot.  \\n\\nThe idea is still to use a Stack to keep the traverse path. The trick in the template is to keep track of the occurances of a node. Depending the occurance, we know if it is ready to be popped for post-order, in-order, and pre-order. Below is the template:\\n\\n```\\n@AllArgsConstructor\\n class Pair {\\n        TreeNode treeNode;\\n        int visited;\\n }\\n\\n public void treeTraverse(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n\\t\\t\\tif(top.visited == 2) {\\n\\t\\t\\t\\tSystem.out.println(\"Both children has been processed\");\\n\\t\\t\\t} else if(top.visited == 1) {\\n\\t\\t\\t   System.out.println(\"Left children has been processed\");\\n\\t\\t\\t   top.visited++;\\n\\t\\t\\t   stack.push(node);\\n\\t\\t\\t   //do something\\n\\t\\t\\t} else {\\n              System.out.println(\"No children has been processed\");\\n\\t\\t\\t   top.visited++;\\n\\t\\t\\t   stack.push(node);\\n\\t\\t\\t   //do something\\n\\t\\t\\t}\\n        }\\n    }\\n```\\nSo this template push a node at most three times, and based on its occurance, we can determine the state of the traverse.\\nThe simple rule is:\\n1. visited == 0,  no children has been processed, if we print current node, it is **pre-order** traversal\\n2. visited == 1, all left children has been processed, if we print current node, it is **in-order** traversal\\n3. visited == 2, all left and right children has been processed, if we print current node, it is **post-order** traversal.\\n\\nThe completed AC code for the three variants are as below. Although they are not the fastest implementation, but they are easy to remember and bug-free.\\n\\nPost-order:\\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if (top.visited == 2) {\\n                ans.add(top.treeNode.val);\\n            } else if (top.visited == 1) {\\n                top.visited++;\\n                stack.push(top); \\n                stack.push(new Pair(top.treeNode.right, 0));\\n            } else {\\n                top.visited++;\\n                stack.push(top); \\n                stack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nIn-order:\\n```\\n public List<Integer> inorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if (top.visited == 1) {\\n                ans.add(top.treeNode.val);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.right, 0));\\n            } else {\\n                top.visited++;\\n                stack.push(top);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nPre-order:\\n```\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if(top.visited == 0) { // it is not necessary for pre-order to have this check, but here is for the integrity of template\\n                ans.add(top.treeNode.val);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.right, 0));\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nHope this would help you during the coding interview.\\n\\nP.S. In the above template, we only use one stack. Another benefit it can bring is to implement tree-iterators easily. The DFS solution in the reference solution does not provide such benefit. \\n\\n",
                "solutionTags": [],
                "code": "```\\n@AllArgsConstructor\\n class Pair {\\n        TreeNode treeNode;\\n        int visited;\\n }\\n\\n public void treeTraverse(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n\\t\\t\\tif(top.visited == 2) {\\n\\t\\t\\t\\tSystem.out.println(\"Both children has been processed\");\\n\\t\\t\\t} else if(top.visited == 1) {\\n\\t\\t\\t   System.out.println(\"Left children has been processed\");\\n\\t\\t\\t   top.visited++;\\n\\t\\t\\t   stack.push(node);\\n\\t\\t\\t   //do something\\n\\t\\t\\t} else {\\n              System.out.println(\"No children has been processed\");\\n\\t\\t\\t   top.visited++;\\n\\t\\t\\t   stack.push(node);\\n\\t\\t\\t   //do something\\n\\t\\t\\t}\\n        }\\n    }\\n```\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if (top.visited == 2) {\\n                ans.add(top.treeNode.val);\\n            } else if (top.visited == 1) {\\n                top.visited++;\\n                stack.push(top); \\n                stack.push(new Pair(top.treeNode.right, 0));\\n            } else {\\n                top.visited++;\\n                stack.push(top); \\n                stack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n public List<Integer> inorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if (top.visited == 1) {\\n                ans.add(top.treeNode.val);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.right, 0));\\n            } else {\\n                top.visited++;\\n                stack.push(top);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if(top.visited == 0) { // it is not necessary for pre-order to have this check, but here is for the integrity of template\\n                ans.add(top.treeNode.val);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.right, 0));\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333347,
                "title": "java-solution",
                "content": "**Iterative:**\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode cur = stack.pop();\\n            list.add(0, cur.val);\\n            if(cur.left != null)\\n                stack.push(cur.left);\\n            if(cur.right != null)\\n                stack.push(cur.right);\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\nRuntime: 1 ms, faster than 62.10% of Java online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 35.2 MB, less than 100.00% of Java online submissions for Binary Tree Postorder Traversal.\\n\\n**Recursive:**\\n```\\nclass Solution {\\n    List<Integer> resultList = new ArrayList<>();\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        if (root != null) {\\n            postorderTraversal(root.left);\\n            postorderTraversal(root.right);\\n            resultList.add(root.val);\\n        }\\n        return resultList;\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 34.8 MB, less than 100.00% of Java online submissions for Binary Tree Postorder Traversal.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode cur = stack.pop();\\n            list.add(0, cur.val);\\n            if(cur.left != null)\\n                stack.push(cur.left);\\n            if(cur.right != null)\\n                stack.push(cur.right);\\n        }\\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    List<Integer> resultList = new ArrayList<>();\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        if (root != null) {\\n            postorderTraversal(root.left);\\n            postorderTraversal(root.right);\\n            resultList.add(root.val);\\n        }\\n        return resultList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248025,
                "title": "super-easy-to-understand-java-code-via-using-stack-with-detailed-comments-without-tricks",
                "content": "```\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        if(root == null) return res;\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.peek(); // to get the reference of the node on top of stack\\n            if(node.left == null && node.right == null){ // if it is a leaf, add its value to result\\n                res.add(node.val);\\n                stack.pop();\\n            }else{\\n                // if it has children, do not remove it from stack\\n                // now we\\'ve got its reference, then it\\'s easy to visit its children\\n                if(node.right != null) stack.push(node.right);\\n                if(node.left != null) stack.push(node.left);\\n                // after adding its children to stack, cut off its leaves.\\n                // otherwise, the non-leaf nodes will never enter to the if branch\\n                node.right = null; \\n                node.left = null;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        if(root == null) return res;\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.peek(); // to get the reference of the node on top of stack\\n            if(node.left == null && node.right == null){ // if it is a leaf, add its value to result\\n                res.add(node.val);\\n                stack.pop();\\n            }else{\\n                // if it has children, do not remove it from stack\\n                // now we\\'ve got its reference, then it\\'s easy to visit its children\\n                if(node.right != null) stack.push(node.right);\\n                if(node.left != null) stack.push(node.left);\\n                // after adding its children to stack, cut off its leaves.\\n                // otherwise, the non-leaf nodes will never enter to the if branch\\n                node.right = null; \\n                node.left = null;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 191791,
                "title": "one-line-javascript-solution",
                "content": "```\\nvar postorderTraversal = function(root) {\\n    return !root ? [] : postorderTraversal(root.left).concat(postorderTraversal(root.right), root.val);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar postorderTraversal = function(root) {\\n    return !root ? [] : postorderTraversal(root.left).concat(postorderTraversal(root.right), root.val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45677,
                "title": "pre-order-in-order-post-order-summary",
                "content": "These three traversals are very similar if written in recursive way.  But it is not the case when trying to implement in the iterative way.  Still there are some similarities, so I've gathered the solutions to the 3 traversals as the following.  Hope this would be of some help.\\n\\nPre-order:\\n```\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        \\n        List<Integer> result = new LinkedList<>();\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        \\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                result.add(p.val);\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.pop();\\n                p = p.right;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\\nIn-order\\n```\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        List<Integer> result = new LinkedList<>();\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        \\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.pop();\\n                result.add(p.val);\\n                p = p.right;\\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n```\\nPost-order\\n```\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\n        List<Integer> result = new LinkedList<>();\\n\\n        if (root == null) {\\n            return result;\\n        }\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        TreeNode visited = null;\\n\\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.peek();\\n                if (p.right != null && p.right != visited) {\\n                    p = p.right;\\n                } else {\\n                    result.add(p.val);\\n                    visited = p;\\n                    stack.pop();\\n                    p = null;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        \\n        List<Integer> result = new LinkedList<>();\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        \\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                result.add(p.val);\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.pop();\\n                p = p.right;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\n```\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        List<Integer> result = new LinkedList<>();\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        \\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.pop();\\n                result.add(p.val);\\n                p = p.right;\\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n```\n```\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\n        List<Integer> result = new LinkedList<>();\\n\\n        if (root == null) {\\n            return result;\\n        }\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        TreeNode visited = null;\\n\\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.peek();\\n                if (p.right != null && p.right != visited) {\\n                    p = p.right;\\n                } else {\\n                    result.add(p.val);\\n                    visited = p;\\n                    stack.pop();\\n                    p = null;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45696,
                "title": "o-n-time-o-1-space-with-morris-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> result;\\n        TreeNode *curr = root, *prev = NULL;\\n        \\n        while (curr)\\n        {\\n            if (curr->right)\\n            {\\n                prev = curr->right;\\n                while (prev->left && prev->left != curr)\\n                {\\n                    prev = prev->left;\\n                }\\n                \\n                if (prev->left)\\n                {\\n                    prev->left = NULL;\\n                    curr = curr->left;\\n                }\\n                else\\n                {\\n                    prev->left = curr;\\n                    result.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n            else\\n            {\\n                result.push_back(curr->val);\\n                curr = curr->left;\\n            }\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```\\n\\nCombination of Morris Traversal and a creative postorder traversal from this post: https://discuss.leetcode.com/topic/44387/preorder-inorder-postorder-iterative-solution-by-c",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> result;\\n        TreeNode *curr = root, *prev = NULL;\\n        \\n        while (curr)\\n        {\\n            if (curr->right)\\n            {\\n                prev = curr->right;\\n                while (prev->left && prev->left != curr)\\n                {\\n                    prev = prev->left;\\n                }\\n                \\n                if (prev->left)\\n                {\\n                    prev->left = NULL;\\n                    curr = curr->left;\\n                }\\n                else\\n                {\\n                    prev->left = curr;\\n                    result.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n            else\\n            {\\n                result.push_back(curr->val);\\n                curr = curr->left;\\n            }\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45755,
                "title": "c-iterative-solution-0ms-with-a-stack",
                "content": "    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            if(root==NULL)return ret;\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            while(!st.empty())\\n            {\\n                TreeNode *curr=st.top();\\n                st.pop();\\n                if(curr->left)st.push(curr->left);\\n                if(curr->right)st.push(curr->right);\\n                ret.push_back(curr->val);\\n            }\\n            reverse(ret.begin(),ret.end());\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            if(root==NULL)return ret;\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            while(!st.empty())\\n            {\\n                TreeNode *curr=st.top();\\n                st.pop();\\n                if(curr->left)st.push(curr->left);\\n                if(curr->right)st.push(curr->right);\\n                ret.push_back(curr->val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 45799,
                "title": "my-python-accepted-solution-with-only-1-stack-simple-and-concise-doesn-t-need-to-reverse",
                "content": "We know that a node is visited immediately after it's right child node be visited, \\n\\nor it's left child node when it has no right child.\\n\\nSo:\\n\\n1. Push root in stack. \\n\\n2. While the stack is not empty:\\n\\n  If the top node of the stack is a leaf node, or the last visited node \\n\\n  is his right child (or his left child), than pop this node, and visit it.\\n\\n  Else, push this node's right child and left child into stack.\\n\\n3. Loop to 2.\\n\\nThe code:\\n\\n        def postorderTraversal(self, root):\\n        if root is None: return []\\n        \\n        s, lastVist, ret = [root], root, []\\n        while s:\\n            top = s[-1]\\n            if (top.left is None and top.right is None) or \\\\\\n                    (top.right == lastVist or top.left == lastVist):\\n                lastVist = s.pop()\\n                ret.append(lastVist.val)\\n            else:\\n                if top.right: s.append(top.right)\\n                if top.left:  s.append(top.left)\\n        \\n        return ret",
                "solutionTags": [],
                "code": "We know that a node is visited immediately after it's right child node be visited, \\n\\nor it's left child node when it has no right child.\\n\\nSo:\\n\\n1. Push root in stack. \\n\\n2. While the stack is not empty:\\n\\n  If the top node of the stack is a leaf node, or the last visited node \\n\\n  is his right child (or his left child), than pop this node, and visit it.\\n\\n  Else, push this node's right child and left child into stack.\\n\\n3. Loop to 2.\\n\\nThe code:\\n\\n        def postorderTraversal(self, root):\\n        if root is None: return []\\n        \\n        s, lastVist, ret = [root], root, []\\n        while s:\\n            top = s[-1]\\n            if (top.left is None and top.right is None) or \\\\\\n                    (top.right == lastVist or top.left == lastVist):\\n                lastVist = s.pop()\\n                ret.append(lastVist.val)\\n            else:\\n                if top.right: s.append(top.right)\\n                if top.left:  s.append(top.left)\\n        \\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 3509970,
                "title": "python-easy-recursive-iterative-both-solutions",
                "content": "**Iterative Solution:**\\n```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return \\n        a=[root]\\n        ans=[]\\n        while a:\\n            t=a.pop()\\n            ans.append(t.val)\\n            if t.left:\\n                a.append(t.left)\\n            if t.right:\\n                a.append(t.right)\\n        return ans[::-1]\\n```\\n**Recursive Solution:**\\n```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    \\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.Traversal(root.right)\\n        self.ans.append(root.val)\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Tree",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return \\n        a=[root]\\n        ans=[]\\n        while a:\\n            t=a.pop()\\n            ans.append(t.val)\\n            if t.left:\\n                a.append(t.left)\\n            if t.right:\\n                a.append(t.right)\\n        return ans[::-1]\\n```\n```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    \\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.Traversal(root.right)\\n        self.ans.append(root.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3201638,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecursive Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        postorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        postorder(root->left, nodes);\\n        postorder(root->right, nodes); \\n        nodes.push_back(root->val);   \\n    }        \\n};\\n```\\n\\n# Approach 2\\nIterative Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> postorder;\\n        if (root == NULL)\\n            return postorder;\\n        stack <TreeNode* > st;\\n        st.push(root);\\n        while (st.empty() != true) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n            postorder.push_back(curr->val);\\n            if (curr->left != NULL)\\n                st.push(curr->left);\\n            if (curr->right != NULL)\\n                st.push(curr->right);\\n        }   \\n        reverse(postorder.begin(), postorder.end()); \\n        return postorder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        postorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        postorder(root->left, nodes);\\n        postorder(root->right, nodes); \\n        nodes.push_back(root->val);   \\n    }        \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> postorder;\\n        if (root == NULL)\\n            return postorder;\\n        stack <TreeNode* > st;\\n        st.push(root);\\n        while (st.empty() != true) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n            postorder.push_back(curr->val);\\n            if (curr->left != NULL)\\n                st.push(curr->left);\\n            if (curr->right != NULL)\\n                st.push(curr->right);\\n        }   \\n        reverse(postorder.begin(), postorder.end()); \\n        return postorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575743,
                "title": "simple-recursion-golang-go",
                "content": "```\\ntype Res struct {\\n\\tRes []int\\n}\\n\\nfunc postorderTraversal(root *TreeNode) []int {\\n\\tr := Res{}\\n\\tr.traversal(root)\\n\\treturn r.Res\\n}\\n\\nfunc (r *Res) traversal(node *TreeNode) {\\n\\tif node != nil {\\n\\t\\tr.traversal(node.Left)\\n\\t\\tr.traversal(node.Right)\\n\\t\\tr.Res = append(r.Res, node.Val)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Tree"
                ],
                "code": "```\\ntype Res struct {\\n\\tRes []int\\n}\\n\\nfunc postorderTraversal(root *TreeNode) []int {\\n\\tr := Res{}\\n\\tr.traversal(root)\\n\\treturn r.Res\\n}\\n\\nfunc (r *Res) traversal(node *TreeNode) {\\n\\tif node != nil {\\n\\t\\tr.traversal(node.Left)\\n\\t\\tr.traversal(node.Right)\\n\\t\\tr.Res = append(r.Res, node.Val)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2466951,
                "title": "python-simple-solution-beats-91",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.postOrder = []\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        if root:\\n            self.postorderTraversal(root.left)\\n            self.postorderTraversal(root.right)\\n            self.postOrder.append(root.val)\\n        return self.postOrder\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.postOrder = []\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        if root:\\n            self.postorderTraversal(root.left)\\n            self.postorderTraversal(root.right)\\n            self.postOrder.append(root.val)\\n        return self.postOrder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248165,
                "title": "java-standard-iterative-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n    if(root == null) return ans;\\n      \\n    Stack<TreeNode> st = new Stack<>();\\n    st.push(root);\\n    while(!st.empty()){\\n        root = st.pop();\\n        ans.add(0, root.val);\\n        if(root.left != null) st.push(root.left);\\n        if(root.right != null) st.push(root.right);\\n    }\\n    return ans;\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n    if(root == null) return ans;\\n      \\n    Stack<TreeNode> st = new Stack<>();\\n    st.push(root);\\n    while(!st.empty()){\\n        root = st.pop();\\n        ans.add(0, root.val);\\n        if(root.left != null) st.push(root.left);\\n        if(root.right != null) st.push(root.right);\\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245063,
                "title": "easy-recursive-solution-postorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void postorder(TreeNode* root,vector<int>& ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        postorder(root->left,ans);\\n        postorder(root->right,ans);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        postorder(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void postorder(TreeNode* root,vector<int>& ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        postorder(root->left,ans);\\n        postorder(root->right,ans);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        postorder(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056621,
                "title": "binary-tree-postorder-traversal-javascript-using-recursion-or-iteration-stack",
                "content": "More about binary tree: https://sneeit.com/binary-trees-and-algorithms/?tab=documentation\\n# Approach 1: Recursion / DP\\nThe most intuitive approach is using recursion. You can read and understand the code easily\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    let ans = [];\\n    let traverse = node => {\\n        if (node.left) traverse(node.left)\\n        if (node.right) traverse(node.right)\\n        ans.push(node.val)\\n    }\\n\\n    traverse(root);\\n    return ans;\\n};\\n```\\n\\n# Approach 2: Iteration + Stack\\nI don\\'t like the solutions that reverse the answer from pre-order traversal because sometimes you will be asked to do some task following the post-order, not only about adding value to an array.\\n\\nWe will separate our trip into 3 steps:\\n1. Keep traveling on the left nodes as far as we can\\n2. If the node is a leaf, process it. Otherwise, it may be a parent node of a right node, so we need to check its right node before we processing it\\n3. If the right node of this parent node had not been processed, just repeat the step 1 and 2 from the right node. Otherwise, we processed all left and right nodes of this parent node so we just process this parent node\\n\\n```\\n\\n// stack version\\nvar postorderTraversal = function(root) {\\n    if (!root) {\\n        return [];\\n    }\\n\\n    let ans = [];\\n    let stack = [];    \\n    cur = root;\\n    pre = null;\\n    while (cur || stack.length) {      \\n        // step 1          \\n        // move along the left edges as far as we can\\n        if (cur) {\\n            stack.push(cur);\\n            cur = cur.left;\\n            continue;\\n        }\\n        \\n        // step 2\\n        // if the node is the parent of any right chid-node\\n        let last = stack[stack.length - 1];\\n        if (last.right && last.right != pre) {\\n            cur = last.right;\\n            continue;\\n        }        \\n        \\n        // step 3\\n        // most left / right nodes will be processed here first\\n        // then parents nodes\\n        ans.push(last.val);\\n\\n        // marked this node as processed \\n        // so it\\'s parent cannot add it again from the step 2\\n        pre = stack.pop();\\n    }\\n\\n    return ans;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    let ans = [];\\n    let traverse = node => {\\n        if (node.left) traverse(node.left)\\n        if (node.right) traverse(node.right)\\n        ans.push(node.val)\\n    }\\n\\n    traverse(root);\\n    return ans;\\n};\\n```\n```\\n\\n// stack version\\nvar postorderTraversal = function(root) {\\n    if (!root) {\\n        return [];\\n    }\\n\\n    let ans = [];\\n    let stack = [];    \\n    cur = root;\\n    pre = null;\\n    while (cur || stack.length) {      \\n        // step 1          \\n        // move along the left edges as far as we can\\n        if (cur) {\\n            stack.push(cur);\\n            cur = cur.left;\\n            continue;\\n        }\\n        \\n        // step 2\\n        // if the node is the parent of any right chid-node\\n        let last = stack[stack.length - 1];\\n        if (last.right && last.right != pre) {\\n            cur = last.right;\\n            continue;\\n        }        \\n        \\n        // step 3\\n        // most left / right nodes will be processed here first\\n        // then parents nodes\\n        ans.push(last.val);\\n\\n        // marked this node as processed \\n        // so it\\'s parent cannot add it again from the step 2\\n        pre = stack.pop();\\n    }\\n\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1965782,
                "title": "c-100-iterative-solution-o-n",
                "content": "```\\nint* postorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    struct TreeNode* stack[100] = {NULL};\\n    int idx = 0;\\n    // get elems in reverse order\\n    while(idx || root) {\\n        if (root) {\\n            stack[idx++] = root;\\n            res[(*returnSize)++] = root->val;\\n            root = root->right;\\n        } else {\\n            struct TreeNode* node = stack[--idx];\\n            root = node->left;\\n        }\\n    }\\n\\t// reverse array\\n    for (int i = 0, j = *returnSize - 1; i < j; i++, j--) {\\n        int t = res[j];\\n        res[j] = res[i];\\n        res[i] = t;\\n    }\\n    return res;\\n}\\n``` \\n***If this was helpful, don\\'t hesitate to upvote! :)***\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* postorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    struct TreeNode* stack[100] = {NULL};\\n    int idx = 0;\\n    // get elems in reverse order\\n    while(idx || root) {\\n        if (root) {\\n            stack[idx++] = root;\\n            res[(*returnSize)++] = root->val;\\n            root = root->right;\\n        } else {\\n            struct TreeNode* node = stack[--idx];\\n            root = node->left;\\n        }\\n    }\\n\\t// reverse array\\n    for (int i = 0, j = *returnSize - 1; i < j; i++, j--) {\\n        int t = res[j];\\n        res[j] = res[i];\\n        res[i] = t;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1964358,
                "title": "python-recursive-iterative-with-last-visited-node-no-cheating",
                "content": "**Recursive**\\n```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\tdef postorder(root):\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\tpostorder(root.left)\\n\\t\\tpostorder(root.right)\\n\\t\\tres.append(root.val)\\n\\n\\tpostorder(root)\\n```\\n\\n**Iterative with stack and last_visited_node:**\\nSubtree nodes visit sequence: Left-Right-Process Node (post-order)\\n![image](https://assets.leetcode.com/users/images/cb430b62-e30d-46e7-8b99-7203bb6b2d2f_1650385773.740851.png)\\nWhen we traverse the tree we need to take care about 3 cases:\\n\\n1. Node 5 **without right subtree**. We got here from 2. We check in \"visited nodes stack\" if the right subtree is missing -> remember last visited node 5 and pop it, return to parent node 2.\\n2. **Right subtree was visited**: Node 3 we got here from 1. This one is interesting: in order to avoid entering a never ending loop (1 -> 3 -> 1 -> 3) we need to check if we visited the node 3 last time ->  remember last visited node 3 and pop it, return to parent node 1. If we had visited 3, pop node 1 - remember last visited node 1 and pop it\\n3. **Right subtree was not visited**: visit right subtree\\n\\n```\\nstack = deque()\\nnode = root\\nlast_visited_node = None\\nwhile node or stack:\\n\\twhile node:\\n\\t\\tstack.append(node)\\n\\t\\tnode = node.left\\n\\t# no right subtree, right subtree was visited\\n\\tif stack[-1].right in [None, last_visited_node]:\\n\\t\\tres.append(stack[-1].val)\\n\\t\\tlast_visited_node = stack.pop()\\n\\t# right subtree was not visited\\n\\telse:\\n\\t\\tnode = stack[-1].right\\n\\nreturn res\\n```\\n\\nP.S. After years of Java, Python is such fun (with crutches, but it is still fun)\\nP.P.S. How to remember iterative pre/in order?\\n```\\nclass Solution:\\n    def traversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = deque()\\n        node = root\\n        res = []\\n        while node or stack:\\n            while node:\\n                res.append(node.val) # <--- pre order\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n\\t\\t\\tres.append(node.val) # <--- in order\\n            node = node.right\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\tdef postorder(root):\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\tpostorder(root.left)\\n\\t\\tpostorder(root.right)\\n\\t\\tres.append(root.val)\\n\\n\\tpostorder(root)\\n```\n```\\nstack = deque()\\nnode = root\\nlast_visited_node = None\\nwhile node or stack:\\n\\twhile node:\\n\\t\\tstack.append(node)\\n\\t\\tnode = node.left\\n\\t# no right subtree, right subtree was visited\\n\\tif stack[-1].right in [None, last_visited_node]:\\n\\t\\tres.append(stack[-1].val)\\n\\t\\tlast_visited_node = stack.pop()\\n\\t# right subtree was not visited\\n\\telse:\\n\\t\\tnode = stack[-1].right\\n\\nreturn res\\n```\n```\\nclass Solution:\\n    def traversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = deque()\\n        node = root\\n        res = []\\n        while node or stack:\\n            while node:\\n                res.append(node.val) # <--- pre order\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n\\t\\t\\tres.append(node.val) # <--- in order\\n            node = node.right\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948311,
                "title": "python-easy-to-understand-iterative-solution-using-visited",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        if not root:\\n            return []\\n        \\n        res=[]\\n        stack=[(root,False)]\\n        \\n        while stack:\\n            node,visited=stack.pop()\\n            if visited:\\n                res.append(node.val)\\n            else:\\n                stack.append((node,True))\\n                if node.right:\\n                    stack.append((node.right,False))\\n                if node.left:\\n                    stack.append((node.left,False))\\n            \\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        if not root:\\n            return []\\n        \\n        res=[]\\n        stack=[(root,False)]\\n        \\n        while stack:\\n            node,visited=stack.pop()\\n            if visited:\\n                res.append(node.val)\\n            else:\\n                stack.append((node,True))\\n                if node.right:\\n                    stack.append((node.right,False))\\n                if node.left:\\n                    stack.append((node.left,False))\\n            \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684118,
                "title": "easy-python-solution-using-recursion",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def postorder(root):\\n            if root!=None:\\n                postorder(root.left)\\n                postorder(root.right)\\n                arr.append(root.val)\\n            return arr\\n        arr = []\\n        return postorder(root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def postorder(root):\\n            if root!=None:\\n                postorder(root.left)\\n                postorder(root.right)\\n                arr.append(root.val)\\n            return arr\\n        arr = []\\n        return postorder(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633799,
                "title": "java-morris-traversal-time-o-n-space-o-1-postorder",
                "content": "The Idea here is to follow similar approach as we follow in inorder with minor changes. First lets have a dummy node and make whole tree as left child of dummy node and make right child empty. [ why? Bec if we assume there is no right child of root then prinitng left child and then root become postorder traversal. Now what next? Are we finished, No... only performing inorder on new tree does not make any sense, it still printing inorder traversal of original tree followed by dummy node.\\n\\nNow closely observe inner else block, this the piece of code which require attention. Since this temporarily extended tree is the subject of traversal as in in-order traversal except that in the inner else clause, after finding a temporary parent, nodes between curr.left (included) and curr (excluded) extended to the right in a modified tree are processed in the reverse order. To process them in constant time, the chain of nodes is scanned down and right references are reversed to refer to parents of nodes. Then the same chain is scanned upward, each node is visited, and the right references are restored to their original setting.\\n\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n   //taking dummy node and assigning it\\'s left subtree to the original tree     \\n        TreeNode dummy = new TreeNode(-1);\\n        dummy.left = root;\\n        \\n        TreeNode curr = dummy;\\n        \\n        while(curr!=null) {\\n            if(curr.left == null){\\n\\t\\t\\t// If there is no left subtree then we are moving to right subtree\\n                curr = curr.right;\\n            } else{\\n                TreeNode pred = curr.left;\\n\\t\\t\\t\\t//finding predeccsor of curr node\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n\\t\\t\\t\\t// if predeccsor\\'s right was not pointing to curr then assigning it\\'s right to curr and moving left\\n                if(pred.right == null){\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }else{\\n                    TreeNode prev = curr;\\n                    TreeNode middle = prev.left;\\n                    // reversing the nodes between prev.left to pred (both incl)\\n                    while(middle != curr){\\n                       TreeNode last = middle.right;\\n                        middle.right = prev;\\n                        prev = middle;\\n                        middle = last;\\n                    }\\n                    // restoring the nodes between prev.left to pred (both incl) and adding them one by one to result list\\n                    middle = pred;\\n                    prev = curr;\\n                    while(middle != curr){\\n                        ans.add(middle.val);\\n                        TreeNode last = middle.right;\\n                        middle.right = prev;\\n                        prev = middle;\\n                        middle = last;\\n                    }\\n\\t\\t\\t\\t\\t\\n                    pred.right = null;\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        dummy.left = null;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n   //taking dummy node and assigning it\\'s left subtree to the original tree     \\n        TreeNode dummy = new TreeNode(-1);\\n        dummy.left = root;\\n        \\n        TreeNode curr = dummy;\\n        \\n        while(curr!=null) {\\n            if(curr.left == null){\\n\\t\\t\\t// If there is no left subtree then we are moving to right subtree\\n                curr = curr.right;\\n            } else{\\n                TreeNode pred = curr.left;\\n\\t\\t\\t\\t//finding predeccsor of curr node\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n\\t\\t\\t\\t// if predeccsor\\'s right was not pointing to curr then assigning it\\'s right to curr and moving left\\n                if(pred.right == null){\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }else{\\n                    TreeNode prev = curr;\\n                    TreeNode middle = prev.left;\\n                    // reversing the nodes between prev.left to pred (both incl)\\n                    while(middle != curr){\\n                       TreeNode last = middle.right;\\n                        middle.right = prev;\\n                        prev = middle;\\n                        middle = last;\\n                    }\\n                    // restoring the nodes between prev.left to pred (both incl) and adding them one by one to result list\\n                    middle = pred;\\n                    prev = curr;\\n                    while(middle != curr){\\n                        ans.add(middle.val);\\n                        TreeNode last = middle.right;\\n                        middle.right = prev;\\n                        prev = middle;\\n                        middle = last;\\n                    }\\n\\t\\t\\t\\t\\t\\n                    pred.right = null;\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        dummy.left = null;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570079,
                "title": "recursion-time-complexity-space-complexity-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        doTraversal(nodeVec,temp->right);\\n        nodeVec.push_back(temp->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        doTraversal(nodeVec,temp->right);\\n        nodeVec.push_back(temp->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441602,
                "title": "python-iterative-explained",
                "content": "## IterativeSolution\\nTo traverse a binary list in postOrder using iteration, you need two lists:\\n1.  todo_stack: list of nodes that have not yet been added to the value list\\n2.  tree_vals: list of results\\n\\n### Steps:\\nThe steps section details the logic behind the code. \\n\\nFirst, instantiate two lists, and add rootNode to todo_stack. Then:\\n1. Repeat until todo_stack is empty\\n1. node = todo_stack.pop()\\n1. If node.left == None and node.right == None:\\n\\t1. tree_vals.append(node.val)\\n1. else:\\n\\t1. todo_stack += [node, node.right, node.left]\\n    \\n\\n#### Notes on each step\\n    1. Will continue through all nodes\\n    2. Take the last node from the stack - because pop() takes the last element, order adding to the list is important\\n    3. If the node has no children, or its children have already been accessed, add value to results\\n    4. If the node has children, add all nodes back to the stack. \\n        - Set the root pointers to None. Otherwise there will be an infinite loop\\n        - Order is important here, it must go: root -> right -> left\\n\\n### Complexity analysis\\n\\n#### Time complexity\\nO(N) - must read each value in the binary tree\\n\\n#### Space complexity\\nO(N) - the todo_stack may technically hold all nodes in some binary trees, e.g., all nodes are left children.\\n\\n## Python code\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> list:\\n\\t\\tif not root: return [] \\n        \\n        tree_vals, todo_stack = [], [root]\\n\\n        while todo_stack:\\n            node = todo_stack.pop()\\n\\n            if node.left == None and node.right == None:\\n                tree_vals.append(node.val)\\n            else:\\n                left, right, node.left, node.right = node.left, node.right, None, None\\n                todo_stack += [x for x in [node, right, left] if x != None]  \\n        \\n        return tree_vals\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> list:\\n\\t\\tif not root: return [] \\n        \\n        tree_vals, todo_stack = [], [root]\\n\\n        while todo_stack:\\n            node = todo_stack.pop()\\n\\n            if node.left == None and node.right == None:\\n                tree_vals.append(node.val)\\n            else:\\n                left, right, node.left, node.right = node.left, node.right, None, None\\n                todo_stack += [x for x in [node, right, left] if x != None]  \\n        \\n        return tree_vals\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 327899,
                "title": "c-100-beat-koderz-kamp-o-n-time-complexity-o-n-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> aResult;\\n        stack<TreeNode*> aStack;\\n        TreeNode *aNode = root;\\n        while (aStack.size() > 0 || aNode != NULL) {\\n            if (aNode == NULL) {\\n                aNode = aStack.top()->left;\\n                aStack.pop();\\n            } else {\\n                aStack.push(aNode);\\n                aResult.push_back(aNode->val);\\n                aNode = aNode->right;\\n            }\\n        }\\n        reverse(aResult.begin(), aResult.end());\\n        return aResult;\\n    }\\n};\\n```\\n\\nThis is the fastest way to do it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> aResult;\\n        stack<TreeNode*> aStack;\\n        TreeNode *aNode = root;\\n        while (aStack.size() > 0 || aNode != NULL) {\\n            if (aNode == NULL) {\\n                aNode = aStack.top()->left;\\n                aStack.pop();\\n            } else {\\n                aStack.push(aNode);\\n                aResult.push_back(aNode->val);\\n                aNode = aNode->right;\\n            }\\n        }\\n        reverse(aResult.begin(), aResult.end());\\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45538,
                "title": "here-is-my-java-solution-which-don-t-need-to-reverse",
                "content": "    \\n  The only extra way different with Inorder or preorder way , is how to treat current node. In that two ways, we directly store current node into list, but in postorder, we need to peek current node first, to see whether it has right node, if it is, we process right node first , and then come back.\\n      So we need extra variable peek  to record current node( we will go back , but now we need to go right first),  and varaible last to see whether right node is treated, so when we go back to its parent, we don't need to go back right node again.\\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        \\n        if(root == null) {return result;}\\n        TreeNode node = root;\\n        TreeNode last = null;\\n        while(node != null || !stack.isEmpty()) {\\n            while(node != null) {\\n                stack.push(node);\\n                node = node.left;\\n            } \\n                TreeNode peek = stack.peek();\\n               if(peek.right != null && last != peek.right) { //Turning into right node\\n                   node = peek.right;\\n               } else {\\n                  peek = stack.pop();\\n                   result.add(peek.val);\\n                   last = peek;\\n               }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        \\n        if(root == null) {return result;}\\n        TreeNode node = root;\\n        TreeNode last = null;\\n        while(node != null || !stack.isEmpty()) {\\n            while(node != null) {\\n                stack.push(node);\\n                node = node.left;\\n            } \\n                TreeNode peek = stack.peek();\\n               if(peek.right != null && last != peek.right) { //Turning into right node\\n                   node = peek.right;\\n               } else {\\n                  peek = stack.pop();\\n                   result.add(peek.val);\\n                   last = peek;\\n               }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45552,
                "title": "the-simplest-iterative-morris-solutions-postorder-is-symmetric-to-the-preorder",
                "content": "I have noticed that the postorder traversal is left-right symmetric to the preorder traversal!\\nThus, when conducting postorder traversal, you first visit parent node, then the right child tree, last the left child tree.\\nHowever, to get a right answer,  you need to inverse the result!\\nI have tested the code on OJ, they are accepted!\\n\\nIterative Traversal\\n```\\nvector<int> postorderTraversal(TreeNode* root) {\\n    vector<int> nums;\\n    stack<TreeNode* > stnode;\\n    while (root || !stnode.empty()) {\\n        if (!root) {\\n            root = stnode.top();\\n            stnode.pop();\\n        }\\n        nums.push_back(root->val);\\n        if (root->left) stnode.push(root->left);\\n        root = root->right;\\n    }\\n    return vector<int>(nums.rbegin(), nums.rend()) \\n} \\n```\\n\\nMorris Traversal\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nums;\\n        TreeNode* cur = nullptr;\\n\\n        while (root) {\\n            if (root->right) {\\n                cur = root->right;\\n                while (cur->left && cur->left != root) {\\n                    cur = cur->left;\\n                }\\n                if (cur->left == root) {\\n                    cur->left = nullptr;\\n                    root = root->left;\\n                } else {\\n                    nums.push_back(root->val);\\n                    cur->left = root;\\n                    root = root->right;\\n                }\\n            } else {\\n                nums.push_back(root->val);\\n                root = root->left;\\n            }\\n        }\\n        return vector<int>(nums.rbegin(), nums.rend());\\n    } \\n}\\n```\\n\\nYou can see the summary of all methods at here: http://blog.csdn.net/yc461515457/article/details/78082042",
                "solutionTags": [],
                "code": "```\\nvector<int> postorderTraversal(TreeNode* root) {\\n    vector<int> nums;\\n    stack<TreeNode* > stnode;\\n    while (root || !stnode.empty()) {\\n        if (!root) {\\n            root = stnode.top();\\n            stnode.pop();\\n        }\\n        nums.push_back(root->val);\\n        if (root->left) stnode.push(root->left);\\n        root = root->right;\\n    }\\n    return vector<int>(nums.rbegin(), nums.rend()) \\n} \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nums;\\n        TreeNode* cur = nullptr;\\n\\n        while (root) {\\n            if (root->right) {\\n                cur = root->right;\\n                while (cur->left && cur->left != root) {\\n                    cur = cur->left;\\n                }\\n                if (cur->left == root) {\\n                    cur->left = nullptr;\\n                    root = root->left;\\n                } else {\\n                    nums.push_back(root->val);\\n                    cur->left = root;\\n                    root = root->right;\\n                }\\n            } else {\\n                nums.push_back(root->val);\\n                root = root->left;\\n            }\\n        }\\n        return vector<int>(nums.rbegin(), nums.rend());\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45697,
                "title": "c-tree-traversals-simple-and-easy-to-understand-preorder-inorder-and-postorder",
                "content": "Preorder :\\n \\n\\n    \\u200bvector<int> preorderTraversal(TreeNode* root) {\\n                stack<TreeNode* > S;\\n                vector<int> V;\\n                if(!root)\\n                    return V;\\n                S.push(root);\\n                while(!S.empty()){\\n                    TreeNode* temp = S.top();\\n                    V.push_back(temp->val);\\n                    S.pop();\\n                    if(temp->right)\\n                        S.push(temp->right);\\n                    if(temp->left)\\n                        S.push(temp->left);\\n                }\\n                return V;\\n            }\\n\\n\\n\\u200b\\n\\u200bInorder :\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n            stack<TreeNode*> S;\\n            vector<int> V;\\n            while(root || !S.empty()){\\n                while(root){\\n                    S.push(root);\\n                    root = root->left;\\n                }\\n                root = S.top();\\n                S.pop();\\n                V.push_back(root->val);\\n                root = root->right;\\n            }\\n            return V;\\n        }\\u200b\\n\\n \\n\\u200bPostorder :\\u200b\\n\\n    \\u200bvector<int> postorderTraversal(TreeNode* root) {\\n                stack<TreeNode*> S;\\n                vector<int> V;\\n                TreeNode *lastNode = NULL, *topNode;\\n                while(root || !S.empty()){\\n                    while(root){\\n                        S.push(root);\\n                        root = root->left;\\n                    }\\n                    topNode = S.top();\\n                    if(topNode->right && topNode->right != lastNode){\\n                        root = topNode->right;\\n                    }\\n                    else{\\n                        V.push_back(topNode->val);\\n                        lastNode = S.top();\\n                        S.pop();\\n                    }\\n                }\\n                return V;\\n            }\\u200b",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "Preorder :\\n \\n\\n    \\u200bvector<int> preorderTraversal(TreeNode* root) {\\n                stack<TreeNode* > S;\\n                vector<int> V;\\n                if(!root)\\n                    return V;\\n                S.push(root);\\n                while(!S.empty()){\\n                    TreeNode* temp = S.top();\\n                    V.push_back(temp->val);\\n                    S.pop();\\n                    if(temp->right)\\n                        S.push(temp->right);\\n                    if(temp->left)\\n                        S.push(temp->left);\\n                }\\n                return V;\\n            }\\n\\n\\n\\u200b\\n\\u200bInorder :\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n            stack<TreeNode*> S;\\n            vector<int> V;\\n            while(root || !S.empty()){\\n                while(root){\\n                    S.push(root);\\n                    root = root->left;\\n                }\\n                root = S.top();\\n                S.pop();\\n                V.push_back(root->val);\\n                root = root->right;\\n            }\\n            return V;\\n        }\\u200b\\n\\n \\n\\u200bPostorder :\\u200b\\n\\n    \\u200bvector<int> postorderTraversal(TreeNode* root) {\\n                stack<TreeNode*> S;\\n                vector<int> V;\\n                TreeNode *lastNode = NULL, *topNode;\\n                while(root || !S.empty()){\\n                    while(root){\\n                        S.push(root);\\n                        root = root->left;\\n                    }\\n                    topNode = S.top();\\n                    if(topNode->right && topNode->right != lastNode){\\n                        root = topNode->right;\\n                    }\\n                    else{\\n                        V.push_back(topNode->val);\\n                        lastNode = S.top();\\n                        S.pop();\\n                    }\\n                }\\n                return V;\\n            }\\u200b",
                "codeTag": "Unknown"
            },
            {
                "id": 45698,
                "title": "python-simple-iterative-solution-no-reversal-easy-to-understand-44ms",
                "content": "<br>\\n`stack` contains the node and the visited status of this node `[node, status]`. (only valid nodes will be added to the stack) <br><br>\\nThere are three different `status` when we see a node: <br><br>\\n`-1`: haven't visited the left child yet  => add its left child to stack (if it has one) <br>\\n`0`: already visited its left child => add its right child to stack (if it has one)<br>\\n`1`: already visited both its left and right child  => pop and append it to the result <br>\\n<br>\\nIn each loop, we use `stack[-1][1] += 1` to update the status of this node\\n\\n<br>\\n\\n\\n    def postorderTraversal(self, root):\\n        if not root:\\n            return []\\n        ans, stack = [], [[root, -1]]\\n\\n        while stack:\\n            node, status = stack[-1]\\n            stack[-1][1] += 1\\n            if status == -1 and node.left:\\n                stack.append([node.left, -1])\\n            elif status == 0 and node.right:\\n                stack.append([node.right, -1])\\n            elif status == 1:\\n                ans.append(stack.pop()[0].val)\\n\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "<br>\\n`stack` contains the node and the visited status of this node `[node, status]`. (only valid nodes will be added to the stack) <br><br>\\nThere are three different `status` when we see a node: <br><br>\\n`-1`: haven't visited the left child yet  => add its left child to stack (if it has one) <br>\\n`0`: already visited its left child => add its right child to stack (if it has one)<br>\\n`1`: already visited both its left and right child  => pop and append it to the result <br>\\n<br>\\nIn each loop, we use `stack[-1][1] += 1` to update the status of this node\\n\\n<br>\\n\\n\\n    def postorderTraversal(self, root):\\n        if not root:\\n            return []\\n        ans, stack = [], [[root, -1]]\\n\\n        while stack:\\n            node, status = stack[-1]\\n            stack[-1][1] += 1\\n            if status == -1 and node.left:\\n                stack.append([node.left, -1])\\n            elif status == 0 and node.right:\\n                stack.append([node.right, -1])\\n            elif status == 1:\\n                ans.append(stack.pop()[0].val)\\n\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 45722,
                "title": "share-my-c-solution-with-no-flag-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            \\n            if (root == NULL)\\n                return ret;\\n            \\n            TreeNode *cur = root;\\n            TreeNode *pre = NULL;\\n            s.push(cur);\\n            \\n            while (!s.empty())\\n            {\\n                cur = s.top();\\n                if ( (cur->left == NULL && cur->right == NULL) || (pre != NULL && (pre == cur->right || pre == cur->left)) )\\n                {\\n                    ret.push_back(cur->val);\\n                    s.pop();\\n                    pre = cur;\\n                }\\n                else\\n                {\\n                    if (cur->right != NULL)\\n                        s.push(cur->right);\\n                    if (cur->left != NULL)\\n                        s.push(cur->left);\\n                }\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            \\n            if (root == NULL)\\n                return ret;\\n            \\n            TreeNode *cur = root;\\n            TreeNode *pre = NULL;\\n            s.push(cur);\\n            \\n            while (!s.empty())\\n            {\\n                cur = s.top();\\n                if ( (cur->left == NULL && cur->right == NULL) || (pre != NULL && (pre == cur->right || pre == cur->left)) )\\n                {\\n                    ret.push_back(cur->val);\\n                    s.pop();\\n                    pre = cur;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 45719,
                "title": "java-solution-no-need-to-reverse-the-list",
                "content": "    public class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> R = new LinkedList<Integer>();\\n        if (root == null) return R;\\n        Stack<TreeNode> S = new Stack();\\n        S.push(root);\\n        while (!S.empty()) {\\n            TreeNode node = S.pop();\\n            R.add(0, node.val);\\n            if (node.left != null) S.push(node.left);\\n            if (node.right != null) S.push(node.right);\\n        }\\n        return R;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> R = new LinkedList<Integer>();\\n        if (root == null) return R;\\n        Stack<TreeNode> S = new Stack();\\n        S.push(root);\\n        while (!S.empty()) {\\n            TreeNode node = S.pop();\\n            R.add(0, node.val);\\n            if (node.left != null) S.push(node.left);\\n            if (node.right != null) S.push(node.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 45756,
                "title": "simple-javascript-why-is-this-problem-marked-as-hard",
                "content": "This problem is the symetrical of binary-tree-preorder-traversal/ , a question  marked as \"medium\"\\n\\nin consequence here is a simple solution in JS :\\n\\n    var postorderTraversal = function(root) {\\n        var to_visit = [];\\n        var visited = [];\\n        to_visit.push(root);\\n            while(to_visit.length > 0) {\\n                var current = to_visit.pop();\\n                if(current !==null) {\\n                    visited.push(current.val);\\n                    to_visit.push(current.left);\\n                    to_visit.push(current.right);\\n                   \\n                }\\n            }\\n        visited.reverse();\\n        return visited;\\n    };",
                "solutionTags": [],
                "code": "This problem is the symetrical of binary-tree-preorder-traversal/ , a question  marked as \"medium\"\\n\\nin consequence here is a simple solution in JS :\\n\\n    var postorderTraversal = function(root) {\\n        var to_visit = [];\\n        var visited = [];\\n        to_visit.push(root);\\n            while(to_visit.length > 0) {\\n                var current = to_visit.pop();\\n                if(current !==null) {\\n                    visited.push(current.val);\\n                    to_visit.push(current.left);\\n                    to_visit.push(current.right);\\n                   \\n                }\\n            }\\n        visited.reverse();\\n        return visited;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 45757,
                "title": "postorder-traversal-java-solution-both-recursion-and-iteration",
                "content": "    // recursive\\n    public class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (root == null) return result;\\n            postordtree(result, root);\\n            return result;\\n        }\\n        private void postordtree(List<Integer> result, TreeNode node){\\n            if (node.left != null) postordtree(result, node.left);\\n            if (node.right != null) postordtree(result, node.right);\\n            result.add(node.val);\\n        }\\n    }\\n    \\n    // iterative\\n    public class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            // https://en.wikipedia.org/wiki/Tree_traversal\\n            // iterative\\n            List<Integer> result = new ArrayList<Integer>();\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            TreeNode last = null;\\n            TreeNode peeknode = null;\\n            while (!stack.isEmpty() || root != null){\\n                if (root != null){\\n                    stack.push(root);\\n                    root = root.left;\\n                    // traverse to the leftmost\\n                }\\n                else{\\n                    peeknode = stack.peek();\\n                    if(peeknode.right != null && last != peeknode.right) root = peeknode.right;\\n                    else{\\n                        result.add(peeknode.val);\\n                        last = stack.pop();\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (root == null) return result;\\n            postordtree(result, root);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 45759,
                "title": "the-key-is-to-reversely-add-element",
                "content": "The key to simply this problem is to always add number to the beginning of the list. Then postorder becomes very similar to preorder. (becomes head->right->left).\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\n\\t\\tList<Integer> ans = new LinkedList<Integer>();\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn ans;\\n\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\n\\t\\tstack.push(root);\\n\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode current = stack.pop();\\n\\t\\t\\tans.add(0, current.val);\\n\\t\\t\\tif (current.left != null)\\n\\t\\t\\t\\tstack.push(current.left);\\n\\t\\t\\tif (current.right != null)\\n\\t\\t\\t\\tstack.push(current.right);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}",
                "solutionTags": [],
                "code": "The key to simply this problem is to always add number to the beginning of the list. Then postorder becomes very similar to preorder. (becomes head->right->left).\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\n\\t\\tList<Integer> ans = new LinkedList<Integer>();\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn ans;\\n\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\n\\t\\tstack.push(root);\\n\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode current = stack.pop();\\n\\t\\t\\tans.add(0, current.val);\\n\\t\\t\\tif (current.left != null)\\n\\t\\t\\t\\tstack.push(current.left);\\n\\t\\t\\tif (current.right != null)\\n\\t\\t\\t\\tstack.push(current.right);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 45760,
                "title": "python-o-1-and-o-n-space-solutions-morris-traversal-and-stack",
                "content": " \\nTravers the tree with right-to-left preorder traversal and just reverse the result:\\n\\n    def postorderTraversal(self, root):\\n        ans = []\\n        while root:\\n            ans.append(root.val)\\n            if root.right:\\n                dum = root.right\\n                while dum.left:\\n                    dum = dum.left\\n                dum.left = root.left\\n                root = root.right\\n            else:\\n                root = root.left\\n        return ans[::-1]\\n\\n\\n----------\\n\\nThe same idea using stack:\\n\\n    def postorderTraversal(self, root):\\n        ans, stack = [], [root]\\n        while stack:\\n            tmp = stack.pop()\\n            if tmp:\\n                ans.append(tmp.val)\\n                stack.append(tmp.left)\\n                stack.append(tmp.right)\\n        return ans[::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": " \\nTravers the tree with right-to-left preorder traversal and just reverse the result:\\n\\n    def postorderTraversal(self, root):\\n        ans = []\\n        while root:\\n            ans.append(root.val)\\n            if root.right:\\n                dum = root.right\\n                while dum.left:\\n                    dum = dum.left\\n                dum.left = root.left\\n                root = root.right\\n            else:\\n                root = root.left\\n        return ans[::-1]\\n\\n\\n----------\\n\\nThe same idea using stack:\\n\\n    def postorderTraversal(self, root):\\n        ans, stack = [], [root]\\n        while stack:\\n            tmp = stack.pop()\\n            if tmp:\\n                ans.append(tmp.val)\\n                stack.append(tmp.left)\\n                stack.append(tmp.right)\\n        return ans[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 3264420,
                "title": "c-solution-using-recursion-run-time-0ms",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode* root, vector<int>& ans) { // LRN\\n        if(root == NULL) {\\n            return;\\n        }\\n\\n        solve(root->left, ans);\\n        solve(root->right, ans);\\n        ans.push_back(root->val);\\n    }\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode* root, vector<int>& ans) { // LRN\\n        if(root == NULL) {\\n            return;\\n        }\\n\\n        solve(root->left, ans);\\n        solve(root->right, ans);\\n        ans.push_back(root->val);\\n    }\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202483,
                "title": "c-easy-solution-recursion-beats-100",
                "content": "# Intuition\\nRecursive Solution\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void postorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        postorder(root->left,vct);\\n        postorder(root->right,vct);\\n        vct.push_back(root->val);\\n    }\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        postorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void postorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        postorder(root->left,vct);\\n        postorder(root->right,vct);\\n        vct.push_back(root->val);\\n    }\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        postorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053484,
                "title": "c-short-simple-recursion",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> v;\\nvoid postorder(TreeNode* root){\\n    if(root==nullptr){return;}\\n        postorder(root->left);\\n        postorder(root->right);\\n        v.push_back(root->val);\\n    }\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        postorder(root);\\n        return v;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> v;\\nvoid postorder(TreeNode* root){\\n    if(root==nullptr){return;}\\n        postorder(root->left);\\n        postorder(root->right);\\n        v.push_back(root->val);\\n    }\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        postorder(root);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032261,
                "title": "beats-100-java",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    void postorder(ArrayList<Integer>ans,TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        postorder(ans,root.left);\\n        postorder(ans,root.right);\\n        ans.add(root.val);\\n    }\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        \\n        ArrayList<Integer>ans=new ArrayList<>();\\n\\n        postorder(ans,root);\\n\\n        return ans; \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    void postorder(ArrayList<Integer>ans,TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        postorder(ans,root.left);\\n        postorder(ans,root.right);\\n        ans.add(root.val);\\n    }\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        \\n        ArrayList<Integer>ans=new ArrayList<>();\\n\\n        postorder(ans,root);\\n\\n        return ans; \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882770,
                "title": "java-iterative-postorder-traversal-with-detailed-thought-process",
                "content": "# Intuition\\nAt first glance, this is similar to iterative implementation of preorder and inorder traversal. \\n\\nWe use a stack to temporarily store the nodes that we\\'ve **not yet finished visiting**, and pop it off from stack when we ***fully finished*** visiting it. \\n\\nSince **postorder** traversal is defined as ***Left -> Right -> Root***,  we consider a node as being ***fully visited*** only after we finish visiting both its left and right subtree. \\n\\nInitially, when we encounter a node ```N```, we push it onto stack and start visiting its left subtree by moving as far left as possible. One important observation is that, the moment when we finish visiting ```N```\\'s left subtree, node ```N``` **must be on the stack top**. At this time, however, we\\'re not yet ready to pop it from stack since we haven\\'t visited its right subtree yet. \\nWe start visiting its right subtree. Once we\\'re done, node ```N``` **must appear on the stack top once again**. At this point, we know we\\'ve ***fully visited*** node ```N```, so we can pop it from stack and record its value in the result list. \\n\\nA problem is, when we see node ```N``` on the stack top (via ```stack.peek()```), how can we tell if this is the **first time** we see it (case 1, meaning we\\'ve just visited its left subtree, case 2), or the **second time** (case 2, meaning we\\'ve finishing visiting both its left and right subtree)? This is crucial to know, since:\\n- **Case 1**: we still need to continue visiting its right subtree, whereas\\n- **Case 2**: we can finish visiting it and pop it from stack.\\n\\nTo do so, we use a ```HashSet``` to keep track of the nodes that have been ***peeked***. Since the ```add()``` method of hashset returns false when the element we try to add is already in the set, we can exploit this fact to distinguish between case 1 and 2 when we peek a node from stack, and thus determine what to do next. \\n\\nThe illustration below may help understanding:\\n\\n```\\n     1\\n   /   \\\\\\n  2     3\\n / \\\\\\n.. ..\\n```\\n\\nImporant timestamps:\\n```\\n- t1: [1] //start visiting 1\\n- t2: [1 2] //push 2 (i.e., 1\\'s left child) onto stack\\n\\n... //move as far left as possible from 2\\n\\n- ta: [1 2 <left children of 2...>]\\n\\n... \\n\\n- tb: [1 2] //finish visiting left subtree of 2\\n            //note that 2 is on stack top\\n            //we add it to the set of peeked nodes (case 1)\\n\\n- t(b+1): [1 2 <right children of 2...>] //visiting right subtree of 2\\n\\n...\\n\\n- td: [1 2] //finish visiting right subtree of 2\\n            //note that 2 is on stack top again\\n            //we also find it in the peeked nodes set (case 2)\\n            //so we know we finished visiting it and pop it from stack\\n\\n- t(d+1): [1] \\n//continue to visit right subtree of 1...\\n...\\n```\\n\\n# Approach\\n\\n1. Create an empty stack and a empty hashset.\\n2. Keep moving down to the left (```curr = curr.left```) and push ```curr``` node onto stack, until ```curr``` becomes null.\\n3. Peek the node on the stack top (```stack.peek()```)\\n    - If the node already exists in the peeked nodes set (```peeked.add(curr)``` returns false), pop it from stack and add it to the result list. Set ```curr = null``` to avoid revisiting the right subtree)\\n    - Else, add the node to the peeked set and start visiting its right subtree ```curr = curr.right```\\n\\n4. Repeat Step 2 and 3 while ```stack``` is not empty and ```curr``` is not ```null```.\\n\\n# Complexity\\n- Time complexity: *O(n)*\\n\\n- Space complexity: *O(n)*\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public List<Integer> postorderTraversal(TreeNode root) {\\n          List<Integer> res = new ArrayList<>();\\n          Stack<TreeNode> stack = new Stack<>();\\n          Set<TreeNode> peeked = new HashSet<>();\\n          TreeNode curr = root;\\n\\n          while (curr != null || !stack.isEmpty()) {\\n             //visiting the left subtree of node N\\n              while (curr != null) {\\n                  stack.push(curr);\\n                  curr = curr.left;\\n              }        \\n\\n              //at this point we\\'ve finished visiting the left subtree\\n              //of node N, and we\\'re sure N must be on the stack top \\n              //i.e., stack.peek() must return node N\\n              curr = stack.peek();\\n              \\n              //check if we\\'ve already visited the right subtree\\n              //of node N\\n              if (!peeked.add(curr)) {\\n              //right subtree of node N has already been visited, \\n              //meaning we\\'ve \"fully visited\" curr and can pop it \\n              //from stack and add its value to the result list\\n                  res.add(stack.pop().val);    \\n                  curr = null; //avoid revisiting the right subtree\\n              } else {\\n              //right subtree of N hasn\\'t been visited yet\\n              //so we start visiting it\\n                  curr = curr.right;\\n              }\\n          }\\n          return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Tree",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```N```\n```N```\n```N```\n```N```\n```N```\n```N```\n```stack.peek()```\n```HashSet```\n```add()```\n```\\n     1\\n   /   \\\\\\n  2     3\\n / \\\\\\n.. ..\\n```\n```\\n- t1: [1] //start visiting 1\\n- t2: [1 2] //push 2 (i.e., 1\\'s left child) onto stack\\n\\n... //move as far left as possible from 2\\n\\n- ta: [1 2 <left children of 2...>]\\n\\n... \\n\\n- tb: [1 2] //finish visiting left subtree of 2\\n            //note that 2 is on stack top\\n            //we add it to the set of peeked nodes (case 1)\\n\\n- t(b+1): [1 2 <right children of 2...>] //visiting right subtree of 2\\n\\n...\\n\\n- td: [1 2] //finish visiting right subtree of 2\\n            //note that 2 is on stack top again\\n            //we also find it in the peeked nodes set (case 2)\\n            //so we know we finished visiting it and pop it from stack\\n\\n- t(d+1): [1] \\n//continue to visit right subtree of 1...\\n...\\n```\n```curr = curr.left```\n```curr```\n```curr```\n```stack.peek()```\n```peeked.add(curr)```\n```curr = null```\n```curr = curr.right```\n```stack```\n```curr```\n```null```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public List<Integer> postorderTraversal(TreeNode root) {\\n          List<Integer> res = new ArrayList<>();\\n          Stack<TreeNode> stack = new Stack<>();\\n          Set<TreeNode> peeked = new HashSet<>();\\n          TreeNode curr = root;\\n\\n          while (curr != null || !stack.isEmpty()) {\\n             //visiting the left subtree of node N\\n              while (curr != null) {\\n                  stack.push(curr);\\n                  curr = curr.left;\\n              }        \\n\\n              //at this point we\\'ve finished visiting the left subtree\\n              //of node N, and we\\'re sure N must be on the stack top \\n              //i.e., stack.peek() must return node N\\n              curr = stack.peek();\\n              \\n              //check if we\\'ve already visited the right subtree\\n              //of node N\\n              if (!peeked.add(curr)) {\\n              //right subtree of node N has already been visited, \\n              //meaning we\\'ve \"fully visited\" curr and can pop it \\n              //from stack and add its value to the result list\\n                  res.add(stack.pop().val);    \\n                  curr = null; //avoid revisiting the right subtree\\n              } else {\\n              //right subtree of N hasn\\'t been visited yet\\n              //so we start visiting it\\n                  curr = curr.right;\\n              }\\n          }\\n          return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850155,
                "title": "easy-clear-and-recursive-solution-javascript",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    const result = [];\\n    postorderTraversalHelper(root, result)\\n    return result;\\n   \\n};\\n\\nconst postorderTraversalHelper = (root, result) => {\\n    if(!root) return;\\n    postorderTraversalHelper(root.left, result)\\n    postorderTraversalHelper(root.right, result)\\n    result.push(root.val)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    const result = [];\\n    postorderTraversalHelper(root, result)\\n    return result;\\n   \\n};\\n\\nconst postorderTraversalHelper = (root, result) => {\\n    if(!root) return;\\n    postorderTraversalHelper(root.left, result)\\n    postorderTraversalHelper(root.right, result)\\n    result.push(root.val)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2827140,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716345,
                "title": "js-2-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/binary-tree-postorder-traversal.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    let res = []; // use res as another stack\\n    // empty tree case:\\n    if (root === null) return res;\\n    let stack = [];\\n    \\n    // postorder visit: left, right, root\\n    stack.push(root);\\n    while (stack.length !== 0) { \\n        let cur = stack.pop();\\n        // treat it as stack, store them in reverse order:\\n        // i.e root, left, right\\n        res.push(cur.val); \\n        if (cur.left) stack.push(cur.left);\\n        if (cur.right) stack.push(cur.right);\\n    }\\n    \\n    // we can pop all elements one by one, or just reverse them\\n    return res.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    let res = []; // use res as another stack\\n    // empty tree case:\\n    if (root === null) return res;\\n    let stack = [];\\n    \\n    // postorder visit: left, right, root\\n    stack.push(root);\\n    while (stack.length !== 0) { \\n        let cur = stack.pop();\\n        // treat it as stack, store them in reverse order:\\n        // i.e root, left, right\\n        res.push(cur.val); \\n        if (cur.left) stack.push(cur.left);\\n        if (cur.right) stack.push(cur.right);\\n    }\\n    \\n    // we can pop all elements one by one, or just reverse them\\n    return res.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547496,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Iterative Using Stack***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(log(N))***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        \\n        // res will store the reverse postorder traversal of the tree\\n        \\n        vector<int> res;\\n        \\n        // stack will store the address of the node\\n        \\n        stack<TreeNode*> st;\\n        \\n        TreeNode* curr = root;\\n        \\n        while(!st.empty() || curr)\\n        {\\n            while(curr)\\n            {\\n                res.push_back(curr -> val);\\n                \\n                st.push(curr);\\n                \\n                curr = curr -> right;\\n            }\\n            \\n            // move the curr to the left\\n            \\n            if(!st.empty())\\n            {\\n                curr = st.top();\\n                \\n                st.pop();\\n                \\n                curr = curr -> left;\\n            }\\n        }\\n        \\n        // reverse the res array\\n        \\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        \\n        // res will store the reverse postorder traversal of the tree\\n        \\n        vector<int> res;\\n        \\n        // stack will store the address of the node\\n        \\n        stack<TreeNode*> st;\\n        \\n        TreeNode* curr = root;\\n        \\n        while(!st.empty() || curr)\\n        {\\n            while(curr)\\n            {\\n                res.push_back(curr -> val);\\n                \\n                st.push(curr);\\n                \\n                curr = curr -> right;\\n            }\\n            \\n            // move the curr to the left\\n            \\n            if(!st.empty())\\n            {\\n                curr = st.top();\\n                \\n                st.pop();\\n                \\n                curr = curr -> left;\\n            }\\n        }\\n        \\n        // reverse the res array\\n        \\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447514,
                "title": "3-different-approaches-c-solution-recursion-two-stacks-single-stack",
                "content": "**1. Recursive approach:**\\n\\n```\\nvoid postorder(TreeNode* root, vector<int> &result){\\n\\tif(root == NULL)\\n\\t\\treturn;\\n\\telse{\\n\\t\\tpostorder(root->left,result);\\n\\t\\tpostorder(root->right,result);\\n\\t\\tresult.push_back(root->val);\\n\\t}\\n}\\nvector<int> postorderTraversal(TreeNode* root) {\\n\\tvector<int> result;\\n\\tpostorder(root, result);\\n\\treturn result;\\n}\\n```\\n\\n**2. Iterative approach (Using 2 stacks):**\\n\\n```\\nvector<int> postorderTraversal(TreeNode* root){\\n\\tvector<int> res;\\n\\tif(root == NULL)\\n\\t\\treturn res;\\n\\tstack<TreeNode*> st1, st2;\\n\\tst1.push(root);\\n\\tTreeNode* node;\\n\\twhile(!st1.empty()){\\n\\t\\tnode = st1.top();\\n\\t\\tst1.pop();\\n\\t\\tst2.push(node);\\n\\t\\tif(node->left != NULL)\\n\\t\\t\\tst1.push(node->left);\\n\\t\\tif(node->right != NULL)\\n\\t\\t\\tst1.push(node->right);\\n\\t}\\n\\twhile(!st2.empty()){\\n\\t\\tnode = st2.top();\\n\\t\\tres.push_back(node->val);\\n\\t\\tst2.pop();\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n**3. Iterative approach (Using 1 stack):**\\n```\\nvector<int> postorderTraversal(TreeNode* root){\\n\\tvector<int> res;\\n\\tif(root == NULL)\\n\\t\\treturn res;\\n\\tstack<TreeNode*> st;\\n\\tst.push(root);\\n\\twhile(!st.empty()){\\n\\t\\tTreeNode* temp = st.top();\\n\\t\\tres.push_back(temp->val);\\n\\t\\tst.pop();\\n\\t\\tif(temp->left)\\n\\t\\t\\tst.push(temp->left);\\n\\t\\tif(temp->right)\\n\\t\\t\\tst.push(temp->right);\\n\\t}\\n\\treverse(res.begin(), res.end());\\n\\treturn res;\\n}\\n```\\n<br></br>\\n**Please upvote if helpful.**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvoid postorder(TreeNode* root, vector<int> &result){\\n\\tif(root == NULL)\\n\\t\\treturn;\\n\\telse{\\n\\t\\tpostorder(root->left,result);\\n\\t\\tpostorder(root->right,result);\\n\\t\\tresult.push_back(root->val);\\n\\t}\\n}\\nvector<int> postorderTraversal(TreeNode* root) {\\n\\tvector<int> result;\\n\\tpostorder(root, result);\\n\\treturn result;\\n}\\n```\n```\\nvector<int> postorderTraversal(TreeNode* root){\\n\\tvector<int> res;\\n\\tif(root == NULL)\\n\\t\\treturn res;\\n\\tstack<TreeNode*> st1, st2;\\n\\tst1.push(root);\\n\\tTreeNode* node;\\n\\twhile(!st1.empty()){\\n\\t\\tnode = st1.top();\\n\\t\\tst1.pop();\\n\\t\\tst2.push(node);\\n\\t\\tif(node->left != NULL)\\n\\t\\t\\tst1.push(node->left);\\n\\t\\tif(node->right != NULL)\\n\\t\\t\\tst1.push(node->right);\\n\\t}\\n\\twhile(!st2.empty()){\\n\\t\\tnode = st2.top();\\n\\t\\tres.push_back(node->val);\\n\\t\\tst2.pop();\\n\\t}\\n\\treturn res;\\n}\\n```\n```\\nvector<int> postorderTraversal(TreeNode* root){\\n\\tvector<int> res;\\n\\tif(root == NULL)\\n\\t\\treturn res;\\n\\tstack<TreeNode*> st;\\n\\tst.push(root);\\n\\twhile(!st.empty()){\\n\\t\\tTreeNode* temp = st.top();\\n\\t\\tres.push_back(temp->val);\\n\\t\\tst.pop();\\n\\t\\tif(temp->left)\\n\\t\\t\\tst.push(temp->left);\\n\\t\\tif(temp->right)\\n\\t\\t\\tst.push(temp->right);\\n\\t}\\n\\treverse(res.begin(), res.end());\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2050084,
                "title": "python-100-easy-solution",
                "content": "\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            self.dfs(node.right, res)\\n            res.append(node.val)\\n\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            self.dfs(node.right, res)\\n            res.append(node.val)\\n\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2026593,
                "title": "java-iterative",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new LinkedList();\\n        Stack<TreeNode> stack = new Stack();\\n        \\n        TreeNode current = root;\\n        \\n        if (current != null) {\\n            stack.push(current);\\n        }\\n        \\n        while(!stack.isEmpty()) {\\n            current = stack.pop();\\n            result.add(0, current.val);\\n            \\n            if (current.left != null) stack.push(current.left);\\n            if (current.right != null) stack.push(current.right);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new LinkedList();\\n        Stack<TreeNode> stack = new Stack();\\n        \\n        TreeNode current = root;\\n        \\n        if (current != null) {\\n            stack.push(current);\\n        }\\n        \\n        while(!stack.isEmpty()) {\\n            current = stack.pop();\\n            result.add(0, current.val);\\n            \\n            if (current.left != null) stack.push(current.left);\\n            if (current.right != null) stack.push(current.right);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955798,
                "title": "java-recursive-dfs-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        postorder(root, result);\\n        return result;\\n    }\\n    \\n    public void postorder(TreeNode root, List<Integer> result){\\n        if(root == null){\\n            return;\\n        }\\n        postorder(root.left, result);\\n        postorder(root.right, result);\\n        result.add(root.val);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        postorder(root, result);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1848791,
                "title": "iterative-w-thinking-process-easy-understanding",
                "content": "**Thinking Process:**\\nWe have done #144 preOrderTraversal.\\nIt gave us hint that if mid is the first one, the problem is easy to deal with.\\nPostOrder print left right middle, therefore we reverse the output order => mid right left\\nIn the end, we reverse the vector and get the right answer!\\n\\n```cpp\\nclass Solution {\\npublic:\\n  vector<int> postorderTraversal(TreeNode *root) {\\n    vector<int> res;\\n    stack<TreeNode *> todo;\\n    if (root)\\n      todo.push(root);\\n    // l r m -> reverse m r l\\n    while (todo.size()) {\\n      root = todo.top();\\n      todo.pop();\\n      res.push_back(root->val);\\n      if (root->left)\\n        todo.push(root->left);\\n      if (root->right)\\n        todo.push(root->right);\\n    }\\n    return reverse(res.begin(), res.end());\\n  }\\n};\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 8.2 MB, less than 98.57% of C++ online submissions for Binary Tree Postorder Traversal.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n  vector<int> postorderTraversal(TreeNode *root) {\\n    vector<int> res;\\n    stack<TreeNode *> todo;\\n    if (root)\\n      todo.push(root);\\n    // l r m -> reverse m r l\\n    while (todo.size()) {\\n      root = todo.top();\\n      todo.pop();\\n      res.push_back(root->val);\\n      if (root->left)\\n        todo.push(root->left);\\n      if (root->right)\\n        todo.push(root->right);\\n    }\\n    return reverse(res.begin(), res.end());\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629702,
                "title": "iterative-postorder-traversal-using-stack-c-in-o-n-and-efficient",
                "content": "## Postorder Iterative\\nPostorder traversal is first left then right then parent i.e. **L R P**\\nL --> Left\\nR --> Right\\nP --> Parent\\n* We have to get **L R P** but we can get **P R L** easily then we can reverse the **ans vector** we will get **L R P**.\\n* In **stack** push first **root** then run **while loop** till **stack** is **not empty**. Inside while every iteration take top of stack node i.e. **curr = stk.top()** and then **pop** stack.\\n* First **push_back** value of **curr** in **ans** vector then **push left** in stack after that **push right** in stack if left and right are **not NULL**.\\n* *Why are we pushing left then right ?* Ans: Because when we **pop** from **stack** it will give **right** then **left** and our desire is **P R L** only. If we push **L** then **R** stack will give reverse **R** then **L**.\\n\\n```\\n\\tvector<int> postorderTraversal(TreeNode* root) {\\n\\t\\tvector<int> ans;\\n\\t\\tif(root==NULL)\\n\\t\\t\\treturn ans;\\n\\n\\t\\tTreeNode* curr;\\n\\t\\tstack<TreeNode*> st;\\n\\t\\tst.push(root);\\n\\t\\twhile(!st.empty()){\\n\\t\\t\\tcurr = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tans.push_back(curr->val); // Take ans\\n\\t\\t\\tif(curr->left)  // Push left first\\n\\t\\t\\t\\tst.push(curr->left);\\n\\t\\t\\tif(curr->right)  // Push right first\\n\\t\\t\\t\\tst.push(curr->right);\\n\\t\\t}\\n\\t\\treverse(ans.begin(),ans.end()); // reverse ans to get L R P\\n\\t\\treturn ans;\\n\\t}\\n```\\n\\n## Preorder Iterative\\n* Preorder is **P L R**.\\n* For this we first take ans of curr then we can push right (**R**) in stack then push left (**L**) in **stack** that makes pop in reverse order that is **L** then **R**.\\n* Here no need to reverse ans because our desire goal is **P L R** only.\\n\\nDo it by yourself.",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n\\tvector<int> postorderTraversal(TreeNode* root) {\\n\\t\\tvector<int> ans;\\n\\t\\tif(root==NULL)\\n\\t\\t\\treturn ans;\\n\\n\\t\\tTreeNode* curr;\\n\\t\\tstack<TreeNode*> st;\\n\\t\\tst.push(root);\\n\\t\\twhile(!st.empty()){\\n\\t\\t\\tcurr = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tans.push_back(curr->val); // Take ans\\n\\t\\t\\tif(curr->left)  // Push left first\\n\\t\\t\\t\\tst.push(curr->left);\\n\\t\\t\\tif(curr->right)  // Push right first\\n\\t\\t\\t\\tst.push(curr->right);\\n\\t\\t}\\n\\t\\treverse(ans.begin(),ans.end()); // reverse ans to get L R P\\n\\t\\treturn ans;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576853,
                "title": "java-morris-iterator-o-n-time-o-1-space",
                "content": "Actrually, the post order traversal is very similar to the preorder traversal. We can modify the morris iterator of the preorder, use head insertion to build the path.\\n```\\npublic List<Integer> postTraversal(TreeNode root) {\\n  LinkedList<Integer> re = new LinkedList<>();\\n  if(root == null) return re;\\n  \\n  TreeNode cur = root;\\n  while(cur != null) {\\n    if(cur.right != null) {\\n      TreeNode p = cur.right;\\n      while(p.left != null) p = p.left;\\n      p.left = cur.left;\\n      cur.left = cur.right;\\n      cur.right = null;\\n    }\\n    else {\\n      re.addFirst(cur.val);\\n      cur = cur.left;\\n    }\\n  }\\n  \\n  return re;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> postTraversal(TreeNode root) {\\n  LinkedList<Integer> re = new LinkedList<>();\\n  if(root == null) return re;\\n  \\n  TreeNode cur = root;\\n  while(cur != null) {\\n    if(cur.right != null) {\\n      TreeNode p = cur.right;\\n      while(p.left != null) p = p.left;\\n      p.left = cur.left;\\n      cur.left = cur.right;\\n      cur.right = null;\\n    }\\n    else {\\n      re.addFirst(cur.val);\\n      cur = cur.left;\\n    }\\n  }\\n  \\n  return re;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1566245,
                "title": "3-approach-c-easy-solution-recursive-100-faster-iterative",
                "content": "**Two Stack**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n          vector<int> v;\\n        if(!root)return v;\\n        stack<TreeNode*> st1;\\n        stack<TreeNode*> st2;\\n        \\n        st1.push(root);\\n        while(!st1.empty()){\\n            TreeNode* node=st1.top();\\n            st1.pop();\\n            st2.push(node);\\n            if(node->left)st1.push(node->left);\\n            if(node->right)st1.push(node->right);\\n        }\\n        while(!st2.empty()){\\n            v.push_back(st2.top()->val);\\n            st2.pop();\\n        }\\n       return v;\\n    }\\n};\\n```\\n\\n**One Stack**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n          vector<int> v;\\n        if(!root)return v;\\n        stack<TreeNode*> st;\\n        TreeNode* node=root;\\n        while(node || !st.empty()){\\n            while(node){\\n                st.push(node);\\n                node=node->left;\\n            }\\n            auto t=st.top()->right;\\n            if(t)node=t;\\n            else{\\n                auto t=st.top();\\n                st.pop();\\n                v.push_back(t->val);\\n                while(!st.empty() and t==st.top()->right){\\n                    t=st.top();\\n                    st.pop();\\n                    v.push_back(t->val);\\n                }\\n            }\\n        }\\n       return v;\\n    }\\n};\\n```\\n\\n\\n\\n**Recursive** \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root==NULL)return v;\\n        \\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        v.push_back(root->val);\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n          vector<int> v;\\n        if(!root)return v;\\n        stack<TreeNode*> st1;\\n        stack<TreeNode*> st2;\\n        \\n        st1.push(root);\\n        while(!st1.empty()){\\n            TreeNode* node=st1.top();\\n            st1.pop();\\n            st2.push(node);\\n            if(node->left)st1.push(node->left);\\n            if(node->right)st1.push(node->right);\\n        }\\n        while(!st2.empty()){\\n            v.push_back(st2.top()->val);\\n            st2.pop();\\n        }\\n       return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n          vector<int> v;\\n        if(!root)return v;\\n        stack<TreeNode*> st;\\n        TreeNode* node=root;\\n        while(node || !st.empty()){\\n            while(node){\\n                st.push(node);\\n                node=node->left;\\n            }\\n            auto t=st.top()->right;\\n            if(t)node=t;\\n            else{\\n                auto t=st.top();\\n                st.pop();\\n                v.push_back(t->val);\\n                while(!st.empty() and t==st.top()->right){\\n                    t=st.top();\\n                    st.pop();\\n                    v.push_back(t->val);\\n                }\\n            }\\n        }\\n       return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root==NULL)return v;\\n        \\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        v.push_back(root->val);\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517885,
                "title": "preorder-postorder-inorder-iterative-with-few-lines-changed-easy-to-remember",
                "content": "**Pre Order**\\n\\n```\\nvector<int> preorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root || !s.empty()){\\n\\t\\t\\t// Order - Root Left Right\\n\\t\\t\\t// i.e Push current root and go the its  left\\n            while(root){\\n                ans.push_back(root->val);\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            root = root->right;\\n        }\\n        return ans;\\n}\\n```\\n\\n**Post Order**\\n```\\nvector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root || !s.empty()){\\n            // Through this while loop the order we will get -> Root Right Left\\n            while(root){\\n                ans.push_back(root->val);\\n                s.push(root);\\n                root=root->right; // In preorder we go to left of root, but here we go to the right\\n            }\\n            root = s.top();\\n            s.pop();\\n            root=root->left;\\n        }\\n\\t\\t// Current order in vector -> Root Right Left\\n        // Reverse the vector, so the order becomes -> Left Right Root\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n}\\n```\\n\\n**In Order**\\n\\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root||!s.empty()){\\n            while(root){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n\\t\\t\\t// We are pushing the value not in the above while loop because Left comes first then Root will come\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvector<int> preorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root || !s.empty()){\\n\\t\\t\\t// Order - Root Left Right\\n\\t\\t\\t// i.e Push current root and go the its  left\\n            while(root){\\n                ans.push_back(root->val);\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            root = root->right;\\n        }\\n        return ans;\\n}\\n```\n```\\nvector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root || !s.empty()){\\n            // Through this while loop the order we will get -> Root Right Left\\n            while(root){\\n                ans.push_back(root->val);\\n                s.push(root);\\n                root=root->right; // In preorder we go to left of root, but here we go to the right\\n            }\\n            root = s.top();\\n            s.pop();\\n            root=root->left;\\n        }\\n\\t\\t// Current order in vector -> Root Right Left\\n        // Reverse the vector, so the order becomes -> Left Right Root\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n}\\n```\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root||!s.empty()){\\n            while(root){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n\\t\\t\\t// We are pushing the value not in the above while loop because Left comes first then Root will come\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401746,
                "title": "easy-fast-python-recursive-solution-3-lines-of-code",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335737,
                "title": "java-postorder-traversal-using-stack-iterative-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        if(root!=null) stack.push(root);\\n        while(!stack.isEmpty())\\n        {\\n             TreeNode temp = stack.peek();\\n             if(temp.left!=null){\\n                     TreeNode temp1 = temp.left;\\n                    \\n                     stack.push(temp1); \\n                      temp.left=null;\\n             }else if(temp.right!=null){\\n                     TreeNode temp2 = temp.right;\\n                    \\n                     stack.push(temp2); \\n                      temp.right=null;\\n             }\\n                else{\\n                       stack.pop();\\n                        ans.add(temp.val);\\n                }\\n                \\n        }\\n            return ans; \\n        }\\n           \\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        if(root!=null) stack.push(root);\\n        while(!stack.isEmpty())\\n        {\\n             TreeNode temp = stack.peek();\\n             if(temp.left!=null){\\n                     TreeNode temp1 = temp.left;\\n                    \\n                     stack.push(temp1); \\n                      temp.left=null;\\n             }else if(temp.right!=null){\\n                     TreeNode temp2 = temp.right;\\n                    \\n                     stack.push(temp2); \\n                      temp.right=null;\\n             }\\n                else{\\n                       stack.pop();\\n                        ans.add(temp.val);\\n                }\\n                \\n        }\\n            return ans; \\n        }\\n           \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305124,
                "title": "simple-cpp-iterative-solution",
                "content": "```\\nvector<int> postorderTraversal(TreeNode* root) {\\n       vector<int> v;\\n        if(!root)\\n            return v;\\n        stack<TreeNode*> s;\\n        \\n        s.push(root);\\n        while(!s.empty()){\\n            root=s.top();\\n            s.pop();\\n            v.push_back(root->val);\\n            if(root->left)\\n                s.push(root->left);\\n            if(root->right)\\n                s.push(root->right);\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> postorderTraversal(TreeNode* root) {\\n       vector<int> v;\\n        if(!root)\\n            return v;\\n        stack<TreeNode*> s;\\n        \\n        s.push(root);\\n        while(!s.empty()){\\n            root=s.top();\\n            s.pop();\\n            v.push_back(root->val);\\n            if(root->left)\\n                s.push(root->left);\\n            if(root->right)\\n                s.push(root->right);\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270415,
                "title": "c-iterative-solution-faster-than-100-0",
                "content": "class Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        TreeNode* curr=NULL;\\n        vector<int>v;\\n       if(!root)\\n           return v;\\n        curr=root;\\n        stack<TreeNode*>s;\\n       \\n        while(1){\\n            if(curr){\\n                 s.push(curr);\\n                 curr=curr->left;\\n            }\\n            else{\\n                if(s.empty())\\n                    break;\\n                else{\\n                    if(s.top()->right==NULL){\\n                        curr = s.top();\\n                        s.pop();\\n                        v.push_back(curr->val);\\n                    while(s.size()>0 && s.top()->right==curr){\\n                      curr=s.top();\\n                      v.push_back(curr->val);\\n                      s.pop();\\n                     }\\n                    }\\n                    if(!s.empty()){\\n                    curr=s.top()->right;\\n                    }\\n                    else\\n                    curr=NULL;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        TreeNode* curr=NULL;\\n        vector<int>v;\\n       if(!root)\\n           return v;\\n        curr=root;\\n        stack<TreeNode*>s;\\n       \\n        while(1){\\n            if(curr){\\n                 s.push(curr);\\n                 curr=curr->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1267947,
                "title": "iterative-recursive-solution-in-java",
                "content": "Recursive Solution\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 37 MB, less than 79.83% of Java online submissions for Binary Tree Postorder Traversal.**\\n```\\nclass Solution {\\n    private List<Integer> arr = new ArrayList();\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        postOrder(root);\\n        return arr;\\n    }\\n    public void postOrder(TreeNode root){\\n        if(root!=null){\\n            postOrder(root.left);\\n            postOrder(root.right);\\n            arr.add(root.val);\\n        }\\n    }\\n}\\n```\\nIterative Solution\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 37.1 MB, less than 67.17% of Java online submissions for Binary Tree Postorder Traversal.**\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {        \\n        Stack<TreeNode> stk1 = new Stack();\\n        Stack<TreeNode> stk2 = new Stack();\\n        ArrayList<Integer> result = new ArrayList();\\n        \\n        if(root == null) return result;\\n\\n        stk1.push(root);\\n        TreeNode temp = root;\\n        \\n        while(!stk1.isEmpty()){\\n            temp = stk1.pop();\\n            if(temp.left != null)stk1.push(temp.left);\\n            if(temp.right != null)stk1.push(temp.right);\\n            stk2.push(temp);\\n        }\\n        \\n        while(!stk2.isEmpty()){\\n            result.add(stk2.pop().val);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private List<Integer> arr = new ArrayList();\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        postOrder(root);\\n        return arr;\\n    }\\n    public void postOrder(TreeNode root){\\n        if(root!=null){\\n            postOrder(root.left);\\n            postOrder(root.right);\\n            arr.add(root.val);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {        \\n        Stack<TreeNode> stk1 = new Stack();\\n        Stack<TreeNode> stk2 = new Stack();\\n        ArrayList<Integer> result = new ArrayList();\\n        \\n        if(root == null) return result;\\n\\n        stk1.push(root);\\n        TreeNode temp = root;\\n        \\n        while(!stk1.isEmpty()){\\n            temp = stk1.pop();\\n            if(temp.left != null)stk1.push(temp.left);\\n            if(temp.right != null)stk1.push(temp.right);\\n            stk2.push(temp);\\n        }\\n        \\n        while(!stk2.isEmpty()){\\n            result.add(stk2.pop().val);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971392,
                "title": "iterative-5-line-python-3-8-solution-w-stack",
                "content": "* Leading `None` in `stack` prevents `IndexError` throwed by `.pop()` on empty list\\n* Generator expression in `extend` filters out `None` (could be made using `filter` but GE looks cleaner)\\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\tstack, result = [None, root], []\\n\\n\\twhile cur := stack.pop():\\n\\t\\tresult.append(cur.val)\\n\\t\\tstack.extend(x for x in (cur.left, cur.right) if x)\\n\\n\\treturn result[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\tstack, result = [None, root], []\\n\\n\\twhile cur := stack.pop():\\n\\t\\tresult.append(cur.val)\\n\\t\\tstack.extend(x for x in (cur.left, cur.right) if x)\\n\\n\\treturn result[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 961894,
                "title": "extremely-simple-post-morris-traversal-pre-in-post-order-summary",
                "content": "There are a lot of introductions about how Morris Traversal works. It is a beautiful algorithm which takes only O(1) space complexity while still maintaining O(n) time complexity. Here I summarized how Morris Traversal is implemented w.r.t. all three orders. \\n\\n**Pre-Order:**\\n```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n       \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\tres.append(root.val) \\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.right = None \\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\\n**In-Order**: \\n\\nCompared to Pre-Order implementation, the change is just one line as maked \"***\"\\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n  \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres.append(root.val)    # ***\\n\\t\\t\\t\\ttemp.right = None\\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\\n**Post-Order:**\\n\\nI saw many implementations for the Post-Order to be very complex and hard to remember. Here I provide a simple version. It is very similar to the pre-order one, except that now we are doing everything reversely. By this I mean we go along the direction of right child and link the leftmost child on the right sub tree to the root. Then we leftappend the val to the result. \\n\\nTHAT`S IT!!\\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\t\\n\\tres = deque()\\n\\n\\twhile root:\\n\\t\\tif root.right:\\n\\t\\t\\ttemp = root.right\\n\\t\\t\\twhile temp.left and temp.left != root:\\n\\t\\t\\t\\ttemp = temp.left\\n\\t\\t\\tif not temp.left:\\n\\t\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\t\\ttemp.left = root\\n\\t\\t\\t\\troot = root.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.left = None\\n\\t\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\troot = root.left\\n\\n\\treturn res\\n```\\n\\nHope you like it. Cheers.",
                "solutionTags": [],
                "code": "```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n       \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\tres.append(root.val) \\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.right = None \\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n  \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres.append(root.val)    # ***\\n\\t\\t\\t\\ttemp.right = None\\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\t\\n\\tres = deque()\\n\\n\\twhile root:\\n\\t\\tif root.right:\\n\\t\\t\\ttemp = root.right\\n\\t\\t\\twhile temp.left and temp.left != root:\\n\\t\\t\\t\\ttemp = temp.left\\n\\t\\t\\tif not temp.left:\\n\\t\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\t\\ttemp.left = root\\n\\t\\t\\t\\troot = root.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.left = None\\n\\t\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\troot = root.left\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 912195,
                "title": "java-100-fast-iterative-and-recursive",
                "content": "If you found the solution helpful, kindly upvote. :)\\n\\n**Iterative Solution**\\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res= new ArrayList<>();\\n        if(root==null) return res;\\n        Stack<TreeNode> st= new Stack<>();\\n        \\n        st.push(root);\\n        while(!st.isEmpty()){\\n            TreeNode curr= st.pop();\\n        //Take a node and put it in the front of the array\\n            res.add(0,curr.val);\\n            if(curr.left!=null)\\n                st.push(curr.left);\\n            if(curr.right!=null)\\n                st.push(curr.right);\\n        }\\n        return res;\\n    }\\n```\\n\\t\\n\\t\\n**Recursive Solution**\\n```\\n\\tprivate void postorder(TreeNode root, List<Integer> result) {\\n\\t\\tif(root== null)\\n\\t\\t\\treturn;\\n\\n\\t\\t//First traverse left, then right\\n\\t\\tpostorder(root.left, result);\\n\\t\\tpostorder(root.right, result);\\n\\t\\t//Add the root value\\n\\t\\tresult.add(root.val);\\n\\t\\t\\n\\t}\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res= new ArrayList<>();\\n        if(root==null) return res;\\n        Stack<TreeNode> st= new Stack<>();\\n        \\n        st.push(root);\\n        while(!st.isEmpty()){\\n            TreeNode curr= st.pop();\\n        //Take a node and put it in the front of the array\\n            res.add(0,curr.val);\\n            if(curr.left!=null)\\n                st.push(curr.left);\\n            if(curr.right!=null)\\n                st.push(curr.right);\\n        }\\n        return res;\\n    }\\n```\n```\\n\\tprivate void postorder(TreeNode root, List<Integer> result) {\\n\\t\\tif(root== null)\\n\\t\\t\\treturn;\\n\\n\\t\\t//First traverse left, then right\\n\\t\\tpostorder(root.left, result);\\n\\t\\tpostorder(root.right, result);\\n\\t\\t//Add the root value\\n\\t\\tresult.add(root.val);\\n\\t\\t\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 886844,
                "title": "python-16ms-classic-implementation",
                "content": "Runtime: 16 ms, faster than 99.67% of Python3 online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 14.1 MB, less than 99.98% of Python3 online submissions for Binary Tree Postorder Traversal.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        self.ans=[]\\n        def postorder(root):\\n            if root is None:\\n                return\\n            postorder(root.left)\\n            postorder(root.right)\\n            self.ans.append(root.val)\\n        postorder(root)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        self.ans=[]\\n        def postorder(root):\\n            if root is None:\\n                return\\n            postorder(root.left)\\n            postorder(root.right)\\n            self.ans.append(root.val)\\n        postorder(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853214,
                "title": "simple-golang-iterative-solution",
                "content": "```\\n\\nfunc postorderTraversal(root *TreeNode) []int {\\n\\tvar res []int\\n\\tif root == nil {\\n\\t\\treturn res\\n\\t}\\n\\n\\tstack := list.New()\\n\\tstack.PushFront(root)\\n\\tfor stack.Len() > 0 {\\n\\t\\te := stack.Front()\\n\\t\\tstack.Remove(e)\\n\\t\\tnode := e.Value.(*TreeNode)\\n\\t\\tres = append([]int{node.Val}, res...)\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tstack.PushFront(node.Left)\\n\\t\\t}\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tstack.PushFront(node.Right)\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc postorderTraversal(root *TreeNode) []int {\\n\\tvar res []int\\n\\tif root == nil {\\n\\t\\treturn res\\n\\t}\\n\\n\\tstack := list.New()\\n\\tstack.PushFront(root)\\n\\tfor stack.Len() > 0 {\\n\\t\\te := stack.Front()\\n\\t\\tstack.Remove(e)\\n\\t\\tnode := e.Value.(*TreeNode)\\n\\t\\tres = append([]int{node.Val}, res...)\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tstack.PushFront(node.Left)\\n\\t\\t}\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tstack.PushFront(node.Right)\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 801658,
                "title": "c-using-two-stacks",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(!root)return vector<int>{};\\n        stack<TreeNode*> s1,s2;\\n        s1.push(root);\\n        while(s1.size()!=0){\\n            TreeNode* t=s1.top();s1.pop();\\n            s2.push(t);\\n            if(t->left)s1.push(t->left);\\n            if(t->right)s1.push(t->right);\\n        }\\n        vector<int> ans;\\n        while(s2.size()!=0){\\n            ans.push_back(s2.top()->val);\\n            s2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(!root)return vector<int>{};\\n        stack<TreeNode*> s1,s2;\\n        s1.push(root);\\n        while(s1.size()!=0){\\n            TreeNode* t=s1.top();s1.pop();\\n            s2.push(t);\\n            if(t->left)s1.push(t->left);\\n            if(t->right)s1.push(t->right);\\n        }\\n        vector<int> ans;\\n        while(s2.size()!=0){\\n            ans.push_back(s2.top()->val);\\n            s2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717360,
                "title": "an-easy-to-understand-method-by-recording-the-counter-of-how-many-times-we-saw-current-node",
                "content": "The intuition is that when we first meet one node, we need to push it into the stack(meanwhile we create a counter initialized at zero) , and the second time is when we get back from the left subtree, we increase the counter. When we encounter it the third, we got to traverse this node. \\nSo each time we encounter one node, we can check the counter, if it is 0, we go to the right subtree. Or if it is 1, this is the time that we need to visit current node. \\n```\\nclass Solution {\\n    class TreeNodeWithCount {\\n        public final TreeNode node;\\n        public int count;\\n        public TreeNodeWithCount(TreeNode p) {\\n            node = p;\\n            count = 0;\\n        }\\n    }\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        TreeNode p = root;\\n        Deque<TreeNodeWithCount> stack = new ArrayDeque<>();\\n        List<Integer> ans = new ArrayList<>();\\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                stack.push(new TreeNodeWithCount(p));\\n                p = p.left;\\n            } else {\\n                if (stack.peek().count == 1) {\\n                    p = stack.pop().node;\\n                    ans.add(p.val);\\n                    p = null;\\n                } else if (stack.peek().count == 0) {\\n                    stack.peek().count++;\\n                    p = stack.peek().node.right;\\n                } \\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TreeNodeWithCount {\\n        public final TreeNode node;\\n        public int count;\\n        public TreeNodeWithCount(TreeNode p) {\\n            node = p;\\n            count = 0;\\n        }\\n    }\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        TreeNode p = root;\\n        Deque<TreeNodeWithCount> stack = new ArrayDeque<>();\\n        List<Integer> ans = new ArrayList<>();\\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                stack.push(new TreeNodeWithCount(p));\\n                p = p.left;\\n            } else {\\n                if (stack.peek().count == 1) {\\n                    p = stack.pop().node;\\n                    ans.add(p.val);\\n                    p = null;\\n                } else if (stack.peek().count == 0) {\\n                    stack.peek().count++;\\n                    p = stack.peek().node.right;\\n                } \\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713506,
                "title": "python-3-two-liner-fast-and-simple",
                "content": "```\\n        if not root: return []\\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n        if not root: return []\\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662042,
                "title": "python-91-4-speed-with-two-stacks",
                "content": "```\\n  def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root] if root else None\\n        res = []\\n        \\n        while stack:\\n\\t\\t\\t# pop top of first stack and push it to the second\\n            curr = stack.pop()\\n            res.append(curr.val)\\n            \\n\\t\\t\\t# traverse\\n            if curr.left:\\n                stack.append(curr.left)\\n                \\n            if curr.right:\\n                stack.append(curr.right)\\n\\t\\t\\t\\t\\n        # reversed second stack gives us our answer        \\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n  def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root] if root else None\\n        res = []\\n        \\n        while stack:\\n\\t\\t\\t# pop top of first stack and push it to the second\\n            curr = stack.pop()\\n            res.append(curr.val)\\n            \\n\\t\\t\\t# traverse\\n            if curr.left:\\n                stack.append(curr.left)\\n                \\n            if curr.right:\\n                stack.append(curr.right)\\n\\t\\t\\t\\t\\n        # reversed second stack gives us our answer        \\n        return res[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 490751,
                "title": "python-easy-iterative-stack-solution-can-be-generalized-to-inorder-preorder-postorder",
                "content": "InOrder\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        inorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if node:\\n                if visited:\\n                    inorder.append(node.val)\\n                else:\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return inorder\\n```\\n\\nPreOrder\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        preorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if not node:\\n                continue\\n            if visited:\\n                preorder.append(node.val)\\n            else:\\n                stack.append((node.right, False))\\n                stack.append((node.left, False))\\n                stack.append((node, True))\\n        return preorder\\n```\\n\\nPostOrder\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        postorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if node:\\n                if visited:\\n                    postorder.append(node.val)\\n                else:\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return postorder\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        inorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if node:\\n                if visited:\\n                    inorder.append(node.val)\\n                else:\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return inorder\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        preorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if not node:\\n                continue\\n            if visited:\\n                preorder.append(node.val)\\n            else:\\n                stack.append((node.right, False))\\n                stack.append((node.left, False))\\n                stack.append((node, True))\\n        return preorder\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        postorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if node:\\n                if visited:\\n                    postorder.append(node.val)\\n                else:\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return postorder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327919,
                "title": "swift-o-n-speed-o-n-memory-non-recursive-in-place-solution-koderz-kamp-memorize",
                "content": "```\\nclass Solution {\\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\\n        \\n        var stack = [TreeNode]()\\n        var node = root\\n        var result = [Int]()\\n        \\n        while node != nil || stack.count > 0 {\\n            if node === nil {\\n                node = stack.removeLast().left\\n            } else {   \\n                result.append(node!.val)\\n                stack.append(node!)\\n                node = node!.right\\n            }\\n        }\\n        \\n        result.reverse()\\n        return result\\n    }\\n}\\n```\\n\\nMemorize this algorithm. That\\'s it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\\n        \\n        var stack = [TreeNode]()\\n        var node = root\\n        var result = [Int]()\\n        \\n        while node != nil || stack.count > 0 {\\n            if node === nil {\\n                node = stack.removeLast().left\\n            } else {   \\n                result.append(node!.val)\\n                stack.append(node!)\\n                node = node!.right\\n            }\\n        }\\n        \\n        result.reverse()\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290375,
                "title": "c-stack",
                "content": "```\\npublic class Solution {\\n    public IList<int> PostorderTraversal(TreeNode root) {\\n        var result = new List<int>();\\n\\n        if (root == null) return result;\\n\\n        var stack = new Stack<TreeNode>();\\n        stack.Push(root);\\n\\n        while (stack.Any()) {\\n            var cur = stack.Pop();\\n            result.Add(cur.val);\\n\\n            if (cur.left != null) {\\n                stack.Push(cur.left);\\n            }\\n\\n            if (cur.right != null) {\\n                stack.Push(cur.right);\\n            }\\n        }\\n\\n        result.Reverse();\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> PostorderTraversal(TreeNode root) {\\n        var result = new List<int>();\\n\\n        if (root == null) return result;\\n\\n        var stack = new Stack<TreeNode>();\\n        stack.Push(root);\\n\\n        while (stack.Any()) {\\n            var cur = stack.Pop();\\n            result.Add(cur.val);\\n\\n            if (cur.left != null) {\\n                stack.Push(cur.left);\\n            }\\n\\n            if (cur.right != null) {\\n                stack.Push(cur.right);\\n            }\\n        }\\n\\n        result.Reverse();\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568691,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568044,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1565965,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1569268,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568036,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1573165,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568968,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1749801,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1575279,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1572894,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568691,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568044,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1565965,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1569268,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568036,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1573165,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568968,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1749801,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1575279,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1572894,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1572373,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1572034,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1571311,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1575997,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1567214,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 2040516,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1962979,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1958174,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1801932,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1762364,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Shortest Word Distance III",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1569241,
                "content": [
                    {
                        "username": "sukrutha",
                        "content": "why is distance between \"makes\" and \"makes\" 3 ? and not 2 ? Since, distance between \"makes\" and \"coding\" is 1 , in the example"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "This illustration tries to clear the air.\\n\\n![makes](https://user-images.githubusercontent.com/81853910/229451322-e05498d0-a413-4628-b389-9938ec53ae97.png)\\n"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Because it takes the minimum distance between \"makes\" and \"coding\". They are two \"makes\" in the wordsDict and in the first example it takes \"coding\" and the last \"makes\" (indice 4 - indice 3 = 1)"
                    },
                    {
                        "username": "human292",
                        "content": "agreed, having trouble making any sense of this problem"
                    },
                    {
                        "username": "sanjayts",
                        "content": "Isn't the constraint `1 <= wordsDict.length <= 105` incorrect (the length can never be 1) given that we can't have repeated words with a single word wordsDict?"
                    },
                    {
                        "username": "user7363AQ",
                        "content": "If you are struggling with how the distance work, remember distance is the length between two points. The first example returns \"coding\" and the \"makes\" at the last index, so the distance is 4-3 = 1. The second example returns 4 - 1 = 3."
                    },
                    {
                        "username": "el_rookie",
                        "content": "This should be an easy. The solution is almost identical to Shortest Distance I."
                    }
                ]
            },
            {
                "id": 1836417,
                "content": [
                    {
                        "username": "sukrutha",
                        "content": "why is distance between \"makes\" and \"makes\" 3 ? and not 2 ? Since, distance between \"makes\" and \"coding\" is 1 , in the example"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "This illustration tries to clear the air.\\n\\n![makes](https://user-images.githubusercontent.com/81853910/229451322-e05498d0-a413-4628-b389-9938ec53ae97.png)\\n"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Because it takes the minimum distance between \"makes\" and \"coding\". They are two \"makes\" in the wordsDict and in the first example it takes \"coding\" and the last \"makes\" (indice 4 - indice 3 = 1)"
                    },
                    {
                        "username": "human292",
                        "content": "agreed, having trouble making any sense of this problem"
                    },
                    {
                        "username": "sanjayts",
                        "content": "Isn't the constraint `1 <= wordsDict.length <= 105` incorrect (the length can never be 1) given that we can't have repeated words with a single word wordsDict?"
                    },
                    {
                        "username": "user7363AQ",
                        "content": "If you are struggling with how the distance work, remember distance is the length between two points. The first example returns \"coding\" and the \"makes\" at the last index, so the distance is 4-3 = 1. The second example returns 4 - 1 = 3."
                    },
                    {
                        "username": "el_rookie",
                        "content": "This should be an easy. The solution is almost identical to Shortest Distance I."
                    }
                ]
            },
            {
                "id": 1850148,
                "content": [
                    {
                        "username": "sukrutha",
                        "content": "why is distance between \"makes\" and \"makes\" 3 ? and not 2 ? Since, distance between \"makes\" and \"coding\" is 1 , in the example"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "This illustration tries to clear the air.\\n\\n![makes](https://user-images.githubusercontent.com/81853910/229451322-e05498d0-a413-4628-b389-9938ec53ae97.png)\\n"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Because it takes the minimum distance between \"makes\" and \"coding\". They are two \"makes\" in the wordsDict and in the first example it takes \"coding\" and the last \"makes\" (indice 4 - indice 3 = 1)"
                    },
                    {
                        "username": "human292",
                        "content": "agreed, having trouble making any sense of this problem"
                    },
                    {
                        "username": "sanjayts",
                        "content": "Isn't the constraint `1 <= wordsDict.length <= 105` incorrect (the length can never be 1) given that we can't have repeated words with a single word wordsDict?"
                    },
                    {
                        "username": "user7363AQ",
                        "content": "If you are struggling with how the distance work, remember distance is the length between two points. The first example returns \"coding\" and the \"makes\" at the last index, so the distance is 4-3 = 1. The second example returns 4 - 1 = 3."
                    },
                    {
                        "username": "el_rookie",
                        "content": "This should be an easy. The solution is almost identical to Shortest Distance I."
                    }
                ]
            },
            {
                "id": 1991700,
                "content": [
                    {
                        "username": "sukrutha",
                        "content": "why is distance between \"makes\" and \"makes\" 3 ? and not 2 ? Since, distance between \"makes\" and \"coding\" is 1 , in the example"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "This illustration tries to clear the air.\\n\\n![makes](https://user-images.githubusercontent.com/81853910/229451322-e05498d0-a413-4628-b389-9938ec53ae97.png)\\n"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Because it takes the minimum distance between \"makes\" and \"coding\". They are two \"makes\" in the wordsDict and in the first example it takes \"coding\" and the last \"makes\" (indice 4 - indice 3 = 1)"
                    },
                    {
                        "username": "human292",
                        "content": "agreed, having trouble making any sense of this problem"
                    },
                    {
                        "username": "sanjayts",
                        "content": "Isn't the constraint `1 <= wordsDict.length <= 105` incorrect (the length can never be 1) given that we can't have repeated words with a single word wordsDict?"
                    },
                    {
                        "username": "user7363AQ",
                        "content": "If you are struggling with how the distance work, remember distance is the length between two points. The first example returns \"coding\" and the \"makes\" at the last index, so the distance is 4-3 = 1. The second example returns 4 - 1 = 3."
                    },
                    {
                        "username": "el_rookie",
                        "content": "This should be an easy. The solution is almost identical to Shortest Distance I."
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Vowels of a String",
        "question_content": "<p>Given a string <code>s</code>, reverse only all the vowels in the string and return it.</p>\n\n<p>The vowels are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>, and they can appear in both lower and upper cases, more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"hello\"\n<strong>Output:</strong> \"holle\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"leetcode\"\n<strong>Output:</strong> \"leotcede\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consist of <strong>printable ASCII</strong> characters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 81225,
                "title": "java-standard-two-pointer-solution",
                "content": "In the inner while loop, don't forget the condition \"start less than end\" while incrementing start  and decrementing end. This is my friend's google phone interview question. Cheers!\\n// update! May use a HashSet<Character> to reduce the look up time to O(1)\\n\\n    public class Solution {\\n    public String reverseVowels(String s) {\\n        if(s == null || s.length()==0) return s;\\n        String vowels = \"aeiouAEIOU\";\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length()-1;\\n        while(start<end){\\n            \\n            while(start<end && !vowels.contains(chars[start]+\"\")){\\n                start++;\\n            }\\n            \\n            while(start<end && !vowels.contains(chars[end]+\"\")){\\n                end--;\\n            }\\n            \\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n            \\n            start++;\\n            end--;\\n        }\\n        return new String(chars);\\n    }\\n   }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public String reverseVowels(String s) {\\n        if(s == null || s.length()==0) return s;\\n        String vowels = \"aeiouAEIOU\";\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length()-1;\\n        while(start<end){\\n            \\n            while(start<end && !vowels.contains(chars[start]+\"\")){\\n                start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 81240,
                "title": "super-clean-c-solution-using-find-first-of-and-find-last-of",
                "content": "    class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            int i = 0, j = s.size() - 1;\\n            while (i < j) {\\n                i = s.find_first_of(\"aeiouAEIOU\", i);\\n                j = s.find_last_of(\"aeiouAEIOU\", j);\\n                if (i < j) {\\n                    swap(s[i++], s[j--]);\\n                }\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            int i = 0, j = s.size() - 1;\\n            while (i < j) {\\n                i = s.find_first_of(\"aeiouAEIOU\", i);\\n                j = s.find_last_of(\"aeiouAEIOU\", j);\\n                if (i < j) {\\n                    swap(s[i++], s[j--]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3723102,
                "title": "easy-solution-with-simple-explanation-using-two-pointer",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe goal of the problem is to reverse the order of vowels in a given string while keeping the non-vowel characters in their original positions. To achieve this, we can use two pointers technique: one pointer starting from the beginning of the string and another starting from the end. We will move these pointers towards each other, swapping the vowels they point to until they meet in the middle of the string.\\n\\n# Approach\\n1. Convert the input string s to an array of characters word. This step is necessary because strings are immutable in Java, and we need to modify the vowels\\' positions.\\n\\n1. Initialize two pointers, start and end, to the first and last characters of the string, respectively.\\n\\n1. Create a String variable vowels containing all the vowel characters (both lowercase and uppercase).\\n\\n1. Use a while loop to iterate until start is no longer less than end. This loop ensures that the pointers will not cross each other, and we process the characters in the middle of the string only once.\\n\\n**Inside the loop:**\\n1. Move the start pointer towards the end of the string until it points to a vowel character. We do this by using the indexOf method to find the index of the character in the vowels string. If the character is not a vowel, we keep moving the start pointer.\\n\\n1. Similarly, move the end pointer towards the beginning of the string until it points to a vowel character. Again, we use the indexOf method to check if the character is a vowel and keep moving the end pointer if it is not.\\n\\n1. Swap the vowels found at the start and end positions in the word array.\\n\\n1. Move the start pointer one step ahead and the end pointer one step back to continue searching for more vowels.\\n\\nAfter the loop finishes, the word array will contain the string with the reversed vowels. Convert the character array back to a String and return the result.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is $$O(n)$$, where n is the length of the input string s. The two pointers start and end move towards each other, and each character is processed once.\\n\\n- Space complexity:\\nThe space complexity of this solution is $$O(n)$$ because we create a character array word to store the characters of the input string. The space used is proportional to the length of the input string. Other than that, we use a constant amount of extra space for the vowels string and a few integer variables, which doesn\\'t depend on the input size.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] word = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n        \\n        while (start < end) {\\n            // Move start pointer until it points to a vowel\\n            while (start < end && vowels.indexOf(word[start]) == -1) {\\n                start++;\\n            }\\n            \\n            // Move end pointer until it points to a vowel\\n            while (start < end && vowels.indexOf(word[end]) == -1) {\\n                end--;\\n            }\\n            \\n            // Swap the vowels\\n            char temp = word[start];\\n            word[start] = word[end];\\n            word[end] = temp;\\n            \\n            // Move the pointers towards each other\\n            start++;\\n            end--;\\n        }\\n        \\n        String answer = new String(word);\\n        return answer;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        # Convert the input string to a character array.\\n        word = list(s)\\n        start = 0\\n        end = len(s) - 1\\n        vowels = \"aeiouAEIOU\"\\n        \\n        # Loop until the start pointer is no longer less than the end pointer.\\n        while start < end:\\n            # Move the start pointer towards the end until it points to a vowel.\\n            while start < end and vowels.find(word[start]) == -1:\\n                start += 1\\n            \\n            # Move the end pointer towards the start until it points to a vowel.\\n            while start < end and vowels.find(word[end]) == -1:\\n                end -= 1\\n            \\n            # Swap the vowels found at the start and end positions.\\n            word[start], word[end] = word[end], word[start]\\n            \\n            # Move the pointers towards each other for the next iteration.\\n            start += 1\\n            end -= 1\\n        \\n        # Convert the character array back to a string and return the result.\\n        return \"\".join(word)\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        // Convert the input string to a character array.\\n        string word = s;\\n        int start = 0;\\n        int end = s.length() - 1;\\n        string vowels = \"aeiouAEIOU\";\\n        \\n        // Loop until the start pointer is no longer less than the end pointer.\\n        while (start < end) {\\n            // Move the start pointer towards the end until it points to a vowel.\\n            while (start < end && vowels.find(word[start]) == string::npos) {\\n                start++;\\n            }\\n            \\n            // Move the end pointer towards the start until it points to a vowel.\\n            while (start < end && vowels.find(word[end]) == string::npos) {\\n                end--;\\n            }\\n            \\n            // Swap the vowels found at the start and end positions.\\n            swap(word[start], word[end]);\\n            \\n            // Move the pointers towards each other for the next iteration.\\n            start++;\\n            end--;\\n        }\\n        \\n        // Return the modified string.\\n        return word;\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/acf12ce9-4139-4e80-a219-5d02f3d054bf_1688572264.1963482.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] word = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n        \\n        while (start < end) {\\n            // Move start pointer until it points to a vowel\\n            while (start < end && vowels.indexOf(word[start]) == -1) {\\n                start++;\\n            }\\n            \\n            // Move end pointer until it points to a vowel\\n            while (start < end && vowels.indexOf(word[end]) == -1) {\\n                end--;\\n            }\\n            \\n            // Swap the vowels\\n            char temp = word[start];\\n            word[start] = word[end];\\n            word[end] = temp;\\n            \\n            // Move the pointers towards each other\\n            start++;\\n            end--;\\n        }\\n        \\n        String answer = new String(word);\\n        return answer;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        # Convert the input string to a character array.\\n        word = list(s)\\n        start = 0\\n        end = len(s) - 1\\n        vowels = \"aeiouAEIOU\"\\n        \\n        # Loop until the start pointer is no longer less than the end pointer.\\n        while start < end:\\n            # Move the start pointer towards the end until it points to a vowel.\\n            while start < end and vowels.find(word[start]) == -1:\\n                start += 1\\n            \\n            # Move the end pointer towards the start until it points to a vowel.\\n            while start < end and vowels.find(word[end]) == -1:\\n                end -= 1\\n            \\n            # Swap the vowels found at the start and end positions.\\n            word[start], word[end] = word[end], word[start]\\n            \\n            # Move the pointers towards each other for the next iteration.\\n            start += 1\\n            end -= 1\\n        \\n        # Convert the character array back to a string and return the result.\\n        return \"\".join(word)\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        // Convert the input string to a character array.\\n        string word = s;\\n        int start = 0;\\n        int end = s.length() - 1;\\n        string vowels = \"aeiouAEIOU\";\\n        \\n        // Loop until the start pointer is no longer less than the end pointer.\\n        while (start < end) {\\n            // Move the start pointer towards the end until it points to a vowel.\\n            while (start < end && vowels.find(word[start]) == string::npos) {\\n                start++;\\n            }\\n            \\n            // Move the end pointer towards the start until it points to a vowel.\\n            while (start < end && vowels.find(word[end]) == string::npos) {\\n                end--;\\n            }\\n            \\n            // Swap the vowels found at the start and end positions.\\n            swap(word[start], word[end]);\\n            \\n            // Move the pointers towards each other for the next iteration.\\n            start++;\\n            end--;\\n        }\\n        \\n        // Return the modified string.\\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81262,
                "title": "1-2-lines-python-ruby",
                "content": "**Ruby**\\n\\n    def reverse_vowels(s)\\n      vowels = s.scan(/[aeiou]/i)\\n      s.gsub(/[aeiou]/i) { vowels.pop }\\n    end\\n\\n---\\n\\n**Python**\\n\\n    def reverseVowels(self, s):\\n        vowels = re.findall('(?i)[aeiou]', s)\\n        return re.sub('(?i)[aeiou]', lambda m: vowels.pop(), s)\\n\\n---\\n\\nIt's possible in one line, but I don't really like it:\\n\\n    def reverseVowels(self, s):\\n        return re.sub('(?i)[aeiou]', lambda m, v=re.findall('(?i)[aeiou]', s): v.pop(), s)\\n\\n---\\n\\nAnother version, finding replacement vowels on the fly instead of collecting all in advance:\\n\\n    def reverseVowels(self, s):\\n        vowels = (c for c in reversed(s) if c in 'aeiouAEIOU')\\n        return re.sub('(?i)[aeiou]', lambda m: next(vowels), s)",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "**Ruby**\\n\\n    def reverse_vowels(s)\\n      vowels = s.scan(/[aeiou]/i)\\n      s.gsub(/[aeiou]/i) { vowels.pop }\\n    end\\n\\n---\\n\\n**Python**\\n\\n    def reverseVowels(self, s):\\n        vowels = re.findall('(?i)[aeiou]', s)\\n        return re.sub('(?i)[aeiou]', lambda m: vowels.pop(), s)\\n\\n---\\n\\nIt's possible in one line, but I don't really like it:\\n\\n    def reverseVowels(self, s):\\n        return re.sub('(?i)[aeiou]', lambda m, v=re.findall('(?i)[aeiou]', s): v.pop(), s)\\n\\n---\\n\\nAnother version, finding replacement vowels on the fly instead of collecting all in advance:\\n\\n    def reverseVowels(self, s):\\n        vowels = (c for c in reversed(s) if c in 'aeiouAEIOU')\\n        return re.sub('(?i)[aeiou]', lambda m: next(vowels), s)",
                "codeTag": "Python3"
            },
            {
                "id": 81233,
                "title": "python-2-pointers-solution",
                "content": "    class Solution(object):\\n        def reverseVowels(self, s):\\n            vowels = set(list(\"aeiouAEIOU\"))\\n            s = list(s)\\n            ptr_1, ptr_2 = 0, len(s) - 1\\n            while ptr_1 < ptr_2:\\n                if s[ptr_1] in vowels and s[ptr_2] in vowels:\\n                    s[ptr_1], s[ptr_2] = s[ptr_2], s[ptr_1]\\n                    ptr_1 += 1\\n                    ptr_2 -= 1\\n                if s[ptr_1] not in vowels:\\n                    ptr_1 += 1\\n                if s[ptr_2] not in vowels:\\n                    ptr_2 -= 1\\n            return ''.join(s)\\n\\nThe idea is really simple. But I think my code is somewhat ugly in two ways:\\n\\n 1. Convert string to list then convert back \\n 2. Pointer processing is verbose.\\n\\nAny suggestion? Thanks.",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def reverseVowels(self, s):\\n            vowels = set(list(\"aeiouAEIOU\"))\\n            s = list(s)\\n            ptr_1, ptr_2 = 0, len(s) - 1\\n            while ptr_1 < ptr_2:\\n                if s[ptr_1] in vowels and s[ptr_2] in vowels:\\n                    s[ptr_1], s[ptr_2] = s[ptr_2], s[ptr_1]\\n                    ptr_1 += 1\\n                    ptr_2 -= 1\\n                if s[ptr_1] not in vowels:\\n                    ptr_1 += 1\\n                if s[ptr_2] not in vowels:\\n                    ptr_2 -= 1\\n            return ''.join(s)\\n\\nThe idea is really simple. But I think my code is somewhat ugly in two ways:\\n\\n 1. Convert string to list then convert back \\n 2. Pointer processing is verbose.\\n\\nAny suggestion? Thanks.",
                "codeTag": "Java"
            },
            {
                "id": 81326,
                "title": "simple-java-solution-one-line-hashset-init",
                "content": "```\\npublic class Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> set = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = arr.length - 1;\\n        while (left < right) {\\n            if (!set.contains(arr[left])) {\\n                left++;\\n            } else if (!set.contains(arr[right])) {\\n                right--;\\n            } else {\\n                char tmp = arr[left];\\n                arr[left] = arr[right];\\n                arr[right] = tmp;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> set = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = arr.length - 1;\\n        while (left < right) {\\n            if (!set.contains(arr[left])) {\\n                left++;\\n            } else if (!set.contains(arr[right])) {\\n                right--;\\n            } else {\\n                char tmp = arr[left];\\n                arr[left] = arr[right];\\n                arr[right] = tmp;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775357,
                "title": "python3-two-pointers-reverse-and-replace-2-approaches-o-n",
                "content": "**Algorithm 1 - Two Pointers:**\\nLet\\'s use a left pointer and a right pointer starting from the two ends of the string and moving toward each other. When both ```s[left]``` and ```s[right]``` are vowels, sweep them, and move both pointers forward by 1 position. If any pointer is not on a vowel position, move it forward by 1 position. Note that we need to convert the input string to a list for fast O(1) sweep.\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n\\n        ### Convert s to list for fast sweep\\n        s = list(s)\\n\\n        ### initialize two pointers at the two ends\\n        left = 0\\n        right = len(s)-1\\n\\n        ### left and right are moving toward each other\\n        ### but they should\\'t cross each other\\n        while left<right:\\n\\n        \\t### if both pointers are on vowels, sweep them.\\n            if s[left] in vowels and s[right] in vowels:\\n                s[left],s[right] = s[right],s[left]\\n                right -= 1\\n                left += 1\\n\\n            ### if any pointer is not on a vowel, move it by 1.\\n            elif s[left] not in vowels:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n        ### join the modified list as a string and return it\\n        return \\'\\'.join(s)\\n```\\nWe can also use two while loop to move left and right to the next vowel positions.\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n        left = 0\\n        right = len(s)-1\\n\\n        while left<right:\\n            \\n            ### move left and right to the next vowel positions.\\n            while left < right and s[left] not in vowels:\\n                left += 1\\n            while left < right and s[right] not in vowels:\\n                right -= 1\\n        \\t\\n            ### sweep and move the pointers one more time.\\n            s[left],s[right] = s[right],s[left]\\n            right -= 1\\n            left += 1\\n\\n        return \\'\\'.join(s)\\n```\\n**Algorithm 2 - Reverse and Replace:**\\nThe idea is to first extract all vowels from s and then reverse it. Next, replace the vowels in the original s with the extracted and reversed vowels.\\n\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n\\n        ### extract all vowels from s\\n        vowelInS = [c for c in s if c in vowels]\\n        ### reverse the extracted vowels\\n        reversedVowel = vowelInS[::-1]\\n\\n        ### replace the vowels in s with the reversed ones\\n        for i in range(len(s)):\\n            if s[i] in vowels:\\n                s[i] = reversedVowel.pop(0)\\n\\n        return \\'\\'.join(s)\\n```\\n\\nWe can also skip the reverse step and simply pop from the end of the ```vowelInS```\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n\\n        ### extract all vowels from s\\n        vowelInS = [c for c in s if c in vowels]\\n\\n        ### replace the vowels in s with the reversed ones\\n        for i in range(len(s)):\\n            if s[i] in vowels:\\n                s[i] = vowelInS.pop(-1)\\n\\n        return \\'\\'.join(s)\\n```\\n\\nAlso check out the iterator version from [@alvin-777](https://leetcode.com/alvin-777/) [HERE](https://leetcode.com/problems/reverse-vowels-of-a-string/discuss/2775366/python-iterator-simple-2-lines)\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```s[left]```\n```s[right]```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n\\n        ### Convert s to list for fast sweep\\n        s = list(s)\\n\\n        ### initialize two pointers at the two ends\\n        left = 0\\n        right = len(s)-1\\n\\n        ### left and right are moving toward each other\\n        ### but they should\\'t cross each other\\n        while left<right:\\n\\n        \\t### if both pointers are on vowels, sweep them.\\n            if s[left] in vowels and s[right] in vowels:\\n                s[left],s[right] = s[right],s[left]\\n                right -= 1\\n                left += 1\\n\\n            ### if any pointer is not on a vowel, move it by 1.\\n            elif s[left] not in vowels:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n        ### join the modified list as a string and return it\\n        return \\'\\'.join(s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n        left = 0\\n        right = len(s)-1\\n\\n        while left<right:\\n            \\n            ### move left and right to the next vowel positions.\\n            while left < right and s[left] not in vowels:\\n                left += 1\\n            while left < right and s[right] not in vowels:\\n                right -= 1\\n        \\t\\n            ### sweep and move the pointers one more time.\\n            s[left],s[right] = s[right],s[left]\\n            right -= 1\\n            left += 1\\n\\n        return \\'\\'.join(s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n\\n        ### extract all vowels from s\\n        vowelInS = [c for c in s if c in vowels]\\n        ### reverse the extracted vowels\\n        reversedVowel = vowelInS[::-1]\\n\\n        ### replace the vowels in s with the reversed ones\\n        for i in range(len(s)):\\n            if s[i] in vowels:\\n                s[i] = reversedVowel.pop(0)\\n\\n        return \\'\\'.join(s)\\n```\n```vowelInS```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n\\n        ### extract all vowels from s\\n        vowelInS = [c for c in s if c in vowels]\\n\\n        ### replace the vowels in s with the reversed ones\\n        for i in range(len(s)):\\n            if s[i] in vowels:\\n                s[i] = vowelInS.pop(-1)\\n\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164745,
                "title": "python-solution-99-58-faster-86-96-less-memory",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        left = 0\\n        right = len(s) - 1\\n        m = \\'aeiouAEIOU\\'\\n        while left < right:\\n            if s[left] in m and s[right] in m:\\n                \\n                s[left], s[right] = s[right], s[left]\\n                \\n                left += 1; right -= 1\\n            \\n            elif s[left] not in m:\\n                left += 1\\n            \\n            elif s[right] not in m:\\n                right -= 1\\n            \\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        left = 0\\n        right = len(s) - 1\\n        m = \\'aeiouAEIOU\\'\\n        while left < right:\\n            if s[left] in m and s[right] in m:\\n                \\n                s[left], s[right] = s[right], s[left]\\n                \\n                left += 1; right -= 1\\n            \\n            elif s[left] not in m:\\n                left += 1\\n            \\n            elif s[right] not in m:\\n                right -= 1\\n            \\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81261,
                "title": "c-easy-understanding-solution",
                "content": "    class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            int dict[256] = {0};\\n            dict['a'] = 1, dict['A'] = 1;\\n            dict['e'] = 1, dict['E'] = 1;\\n            dict['i'] = 1, dict['I'] = 1;\\n            dict['o'] = 1, dict['O'] = 1;\\n            dict['u'] = 1, dict['U'] = 1;\\n            int start = 0, end = (int)s.size() - 1;\\n            while(start < end){\\n                while(start < end && dict[s[start]] == 0) start++;\\n                while(start < end && dict[s[end]] == 0) end--;\\n                swap(s[start],s[end]);\\n                start++;end--;\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            int dict[256] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2775693,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/oSFnTxi9/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go",
                    "Two Pointers"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/oSFnTxi9/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 81221,
                "title": "one-pass-java-solution-13ms",
                "content": "    public class Solution {\\n        public String reverseVowels(String s) {\\n            char[] list=s.toCharArray();\\n            Set<Character> set=new HashSet<>();\\n            set.add('a');\\n            set.add('e');\\n            set.add('i');\\n            set.add('o');\\n            set.add('u');\\n            set.add('A');\\n            set.add('E');\\n            set.add('I');\\n            set.add('O');\\n            set.add('U');\\n            for (int i=0, j=list.length-1; i<j; ) {\\n                if (!set.contains(list[i])) {\\n                    i++;\\n                    continue;\\n                }\\n                if (!set.contains(list[j])) {\\n                    j--;\\n                    continue;\\n                }\\n                char temp=list[i];\\n                list[i]=list[j];\\n                list[j]=temp;\\n                i++;\\n                j--;\\n            }\\n            return String.valueOf(list);\\n        }\\n    }\\nWe could also initilize the set like this:\\n```\\nSet<Character> vowels = new HashSet<>(Arrays.asList(new Character[]{'a','e','i','o','u','A','E','I','O','U'}));\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nSet<Character> vowels = new HashSet<>(Arrays.asList(new Character[]{'a','e','i','o','u','A','E','I','O','U'}));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81355,
                "title": "beat-99-7-using-python-two-pointers",
                "content": "    class Solution(object):\\n        def reverseVowels(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\\n            L = list(s)\\n            i = 0\\n            j = len(L) - 1\\n            while i < j:\\n                while i < j and L[i] not in vowels:\\n                    i += 1\\n                while j > i and L[j] not in vowels:\\n                    j -= 1\\n                L[i], L[j] = L[j], L[i] \\n                i += 1\\n                j -= 1\\n            return ''.join(L)",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def reverseVowels(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
                "codeTag": "Java"
            },
            {
                "id": 1371985,
                "title": "very-simple-lc-says-your-runtime-beats-97-12-of-cpp-submissions",
                "content": "**Approch:** \\nIdea is to use two pointers. Let say one point at the start index (0) of the string and a second at the last (s.size()-1)  of the string.\\n\\nNow if both the pointers are pointing at vowels simply swap the values. And if not increment or decrement them accordingly (check code for more explanation)\\n\\n```\\nclass Solution \\n{\\n\\t\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        int i = 0;\\n        int j = s.size()-1;\\n        \\n        while(i<j)\\n        {\\n            bool flag1 = false, flag2 = false;   // to check if we are pointing to a vowel or not\\n            \\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i]==\\'A\\' || s[i]==\\'E\\' || s[i]==\\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            flag1 = true;\\n            \\n            if(s[j]==\\'a\\' || s[j]==\\'e\\' || s[j]==\\'i\\' || s[j]==\\'o\\' || s[j]==\\'u\\' || s[j]==\\'A\\' || s[j]==\\'E\\' || s[j]==\\'I\\' || s[j]==\\'O\\' || s[j]==\\'U\\')\\n            flag2 = true;\\n            \\n            if(flag1 && flag2)   // if both are pointing to vowels just swap them\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--; \\n            }\\n            \\n            if(!flag1)    // if i is not pointing to a vowel, move the pointer forward\\n            i++;\\n            if(!flag2)    // if j is not pointing to a vowel, move the pointer backwards\\n            j--;\\n        }\\n        \\n        return s;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\n\\t\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        int i = 0;\\n        int j = s.size()-1;\\n        \\n        while(i<j)\\n        {\\n            bool flag1 = false, flag2 = false;   // to check if we are pointing to a vowel or not\\n            \\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i]==\\'A\\' || s[i]==\\'E\\' || s[i]==\\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            flag1 = true;\\n            \\n            if(s[j]==\\'a\\' || s[j]==\\'e\\' || s[j]==\\'i\\' || s[j]==\\'o\\' || s[j]==\\'u\\' || s[j]==\\'A\\' || s[j]==\\'E\\' || s[j]==\\'I\\' || s[j]==\\'O\\' || s[j]==\\'U\\')\\n            flag2 = true;\\n            \\n            if(flag1 && flag2)   // if both are pointing to vowels just swap them\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--; \\n            }\\n            \\n            if(!flag1)    // if i is not pointing to a vowel, move the pointer forward\\n            i++;\\n            if(!flag2)    // if j is not pointing to a vowel, move the pointer backwards\\n            j--;\\n        }\\n        \\n        return s;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81247,
                "title": "2-line-javascript-o-n-solution-using-stack-and-regex",
                "content": "The standard solution for comparison:\\n```\\nvar reverseVowels = function(s) {\\n    const VOWELS = { 'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1 };\\n    const arr = s.split('');\\n    let i = 0, j = arr.length - 1;\\n    while (i < j) {\\n        if (VOWELS[arr[i]] && VOWELS[arr[j]]) {\\n            [arr[i], arr[j]] = [arr[j], arr[i]];\\n            i++;\\n            j--;\\n        } else if (VOWELS[arr[i]]) {\\n            j--;\\n        } else {\\n            i++;\\n        }\\n    }\\n    return arr.join('');\\n};\\n```\\nAnd here is the fancy solution:\\n```\\nvar reverseVowels = function(s) {\\n    const vowels = s.split('').filter(a => /[aeiou]/i.test(a));\\n    return s.split(/[aeiou]/i).reduce((res, a) => res + a + (vowels.pop() || ''), '');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseVowels = function(s) {\\n    const VOWELS = { 'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1 };\\n    const arr = s.split('');\\n    let i = 0, j = arr.length - 1;\\n    while (i < j) {\\n        if (VOWELS[arr[i]] && VOWELS[arr[j]]) {\\n            [arr[i], arr[j]] = [arr[j], arr[i]];\\n            i++;\\n            j--;\\n        } else if (VOWELS[arr[i]]) {\\n            j--;\\n        } else {\\n            i++;\\n        }\\n    }\\n    return arr.join('');\\n};\\n```\n```\\nvar reverseVowels = function(s) {\\n    const vowels = s.split('').filter(a => /[aeiou]/i.test(a));\\n    return s.split(/[aeiou]/i).reduce((res, a) => res + a + (vowels.pop() || ''), '');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2775770,
                "title": "python-c-java-rust-2-pointers-stack-reverse-consonants-too-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a two-pointer strategy to swap vowels. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** Sorting of just vowels in reverse order is equivalent to swapping first vowel with last vowel, second vowel with the last but one, and so on. Thus, to detect vowels from both ends (and swap them), we employ a strategy with two converging pointers.\\n\\n**For the BONUS to reverse BOTH vowels and consonants simultaneously, please scroll down.**\\n\\n**Python.**\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = set(list(\"aeiouAEIOU\"))) -> str:\\n        \\n        l, r, s = 0, len(s) - 1, list(s)\\n        while l < r:                           \\n            while l < r and s[l] not in vwls: l += 1     # [1] move pointers until\\n            while l < r and s[r] not in vwls: r -= 1     #     two vowels are found \\n            s[l], s[r] = s[r], s[l]                      # [2] swap vowels and move\\n            l, r = l + 1, r - 1                          #     pointers further\\n        return \"\".join(s)\\n```\\nHere is a two-pass solution with stack.\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        stack = [v for v in s if v in vwls]\\n        return \"\".join(c if c not in vwls else stack.pop() for c in s)\\n```\\n\\nThere is an even better approach that was originally proposed [**here**](https://leetcode.com/problems/reverse-vowels-of-a-string/discuss/2775366/python-iterator-simple-2-lines). I modified it a bit...\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        it = (v for v in reversed(s) if v in vwls)\\n        return \"\".join(next(it) if c in vwls else c for c in s)\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/AwxaByBF/shared\" frameBorder=\"0\" width=\"800\" height=\"400\"></iframe>\\n\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\nAs a **BONUS**, I provide an upgrade to this problem, namely, a solution to reverse both vowels and consonant *simutaneously* using deque. Here, deque is a convenient data structure for two independent stacks. *(For this problem, all characters should be english letters with no other symbols. Otherwise, this algorithm should check for vovels, consonants and non-letters, however, still using deque to store vowels and consonants.)*\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        dq = deque()\\n        for c in s:\\n            if c in vwls : dq.append(c)\\n            else         : dq.appendleft(c)\\n        \\n        return \"\".join(dq.pop() if c in vwls else dq.popleft() for c in s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = set(list(\"aeiouAEIOU\"))) -> str:\\n        \\n        l, r, s = 0, len(s) - 1, list(s)\\n        while l < r:                           \\n            while l < r and s[l] not in vwls: l += 1     # [1] move pointers until\\n            while l < r and s[r] not in vwls: r -= 1     #     two vowels are found \\n            s[l], s[r] = s[r], s[l]                      # [2] swap vowels and move\\n            l, r = l + 1, r - 1                          #     pointers further\\n        return \"\".join(s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        stack = [v for v in s if v in vwls]\\n        return \"\".join(c if c not in vwls else stack.pop() for c in s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        it = (v for v in reversed(s) if v in vwls)\\n        return \"\".join(next(it) if c in vwls else c for c in s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        dq = deque()\\n        for c in s:\\n            if c in vwls : dq.append(c)\\n            else         : dq.appendleft(c)\\n        \\n        return \"\".join(dq.pop() if c in vwls else dq.popleft() for c in s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620822,
                "title": "python-two-pointer-approach-set-runtime-o-n",
                "content": "The idea is to have two pointers (one starting from the left and another one starting from the right). \\n\\n**CASE 1**\\nBoth pointers will move one place each. Left pointer will move one place to the right and right pointer will move one place to the left: \\n* IF both letters that the pointers are pointing at **are vowels**\\n\\t* IF this is the case, *swap the letters*\\n* IF both letters that the pointers are pointing at are **not vowels**\\n\\n**CASE 2**\\nIf one pointer is pointing to a vowel but another one is not:\\n* Move the pointer either one place to right (if it is left pointer) or one place to left (if it is right pointer) WHILE keeping the pointer pointing at a vowel at the same position.\\n\\t* Eventually, you will reach CASE 1 or you will never reach CASE 1 (in this case left == right and basically the swap is just one the same letter)\\n\\n``` python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowels = set(\\'aeiouAEIOU\\')\\n        s = list(s)\\n        left = 0\\n        right = len(s)-1\\n        \\n        while left <= right:\\n            if s[left] in vowels and s[right] in vowels:\\n                s[left], s[right] = s[right], s[left]\\n            elif s[right] not in vowels:\\n                right -= 1\\n                continue\\n            elif s[left] not in vowels:\\n                left += 1\\n                continue\\n            left += 1\\n            right -= 1\\n        \\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "``` python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowels = set(\\'aeiouAEIOU\\')\\n        s = list(s)\\n        left = 0\\n        right = len(s)-1\\n        \\n        while left <= right:\\n            if s[left] in vowels and s[right] in vowels:\\n                s[left], s[right] = s[right], s[left]\\n            elif s[right] not in vowels:\\n                right -= 1\\n                continue\\n            elif s[left] not in vowels:\\n                left += 1\\n                continue\\n            left += 1\\n            right -= 1\\n        \\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81435,
                "title": "c-12ms-two-pointers-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            auto p1 = s.begin(), p2 = s.end() - 1;\\n            string vowels = \"aeiouAEIOU\";\\n            while(p1 < p2) {\\n                while((vowels.find(*p1) == string::npos) && (p1 < p2)) p1++;\\n                while((vowels.find(*p2) == string::npos) && (p1 < p2)) p2--;\\n                if(p1 < p2) swap(*p1, *p2);\\n                p1++;\\n                p2--;\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            auto p1 = s.begin(), p2 = s.end() - 1;\\n            string vowels = \"aeiouAEIOU\";\\n            while(p1 < p2) {\\n                while((vowels.find(*p1) == string::npos) && (p1 < p2)) p1++;\\n                while((vowels.find(*p2) == string::npos) && (p1 < p2)) p2--;\\n                if(p1 < p2) swap(*p1, *p2);\\n                p1++;\\n                p2--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 567723,
                "title": "two-pointers-technique-python-o-n-time-and-space",
                "content": "Hello, everyone! \\uD83D\\uDC4B Here is my solution to this problem.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set(\"AaEeIiOoUu\")\\n        data = list(s)\\n        p1, p2 = 0, len(data) - 1\\n        while p1 < p2:\\n            if data[p1] in vowels and data[p2] in vowels:\\n                data[p1], data[p2] = data[p2], data[p1]\\n                p1 += 1\\n                p2 -= 1\\n\\t\\t\\t\\n\\t\\t\\tif data[p1] not in vowels:\\n                p1 += 1\\n\\t\\t\\t\\n\\t\\t\\tif data[p2] not in vowels:\\n                p2 -= 1\\n\\n        return \"\".join(data)\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n).*\\n*Space complexity: O(n).*\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode. \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set(\"AaEeIiOoUu\")\\n        data = list(s)\\n        p1, p2 = 0, len(data) - 1\\n        while p1 < p2:\\n            if data[p1] in vowels and data[p2] in vowels:\\n                data[p1], data[p2] = data[p2], data[p1]\\n                p1 += 1\\n                p2 -= 1\\n\\t\\t\\t\\n\\t\\t\\tif data[p1] not in vowels:\\n                p1 += 1\\n\\t\\t\\t\\n\\t\\t\\tif data[p2] not in vowels:\\n                p2 -= 1\\n\\n        return \"\".join(data)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320125,
                "title": "python-solution",
                "content": "Python strings are immutable so convert s to a list to reduce time complexity from n^2 to n.\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n        i, j = 0, len(s) - 1\\n        \\n        while i < j:\\n            if s[i] not in vowels:\\n                i += 1\\n                continue\\n                \\n            if s[j] not in vowels:\\n                j -= 1\\n                continue\\n                \\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n            \\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n        i, j = 0, len(s) - 1\\n        \\n        while i < j:\\n            if s[i] not in vowels:\\n                i += 1\\n                continue\\n                \\n            if s[j] not in vowels:\\n                j -= 1\\n                continue\\n                \\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n            \\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775649,
                "title": "java-explained-in-detail-simple-fast-solution-two-pointers",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n## Approach\\nUse two pointers to traverse from left and right towards to center.\\n\\nSwap when both position contains vowels \"aeiouAEIOU\".\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n  where $$n$$ is the length of the String.\\n\\n- Space complexity: $$O(n)$$\\n  due to the toCharArray( ) function.\\n\\n---\\n\\n### Java (Clean Code)\\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            while (left < right && !isVowel(chars[left]))\\n                left++;\\n            while (left < right && !isVowel(chars[right]))\\n                right--;\\n\\n            if (left < right) {\\n                char temp = chars[left];\\n                chars[left++] = chars[right];\\n                chars[right--] = temp;\\n            }\\n        }\\n        return new String(chars);\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```\\n\\n### Java (With Explanation)\\n```\\nclass Solution {\\n\\n    // Approach:\\n    // Use two pointers to traverse from left and right towards to center.\\n    // Swap when both position contains vowels \"aeiouAEIOU\".\\n\\n    public String reverseVowels(String s) {\\n\\n        // Convert the string to charArray.\\n        char[] chars = s.toCharArray();\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        // When both pointers meet, we know all the vowels are swapped.\\n        while (left < right) {\\n            // If chars[left] is not vowel, continue to move right.\\n            while (left < right && !isVowel(chars[left])) {\\n                left++;\\n            }\\n            // If chars[right] is not vowel, continue to move left.\\n            while (left < right && !isVowel(chars[right])) {\\n                right--;\\n            }\\n\\n            // Swap the vowels.\\n            if (left < right) {\\n                char temp = chars[left];\\n                chars[left++] = chars[right];\\n                chars[right--] = temp;\\n            }\\n        }\\n        return new String(chars);\\n    }\\n\\n    // Return true if char is a vowel.\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            while (left < right && !isVowel(chars[left]))\\n                left++;\\n            while (left < right && !isVowel(chars[right]))\\n                right--;\\n\\n            if (left < right) {\\n                char temp = chars[left];\\n                chars[left++] = chars[right];\\n                chars[right--] = temp;\\n            }\\n        }\\n        return new String(chars);\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    // Approach:\\n    // Use two pointers to traverse from left and right towards to center.\\n    // Swap when both position contains vowels \"aeiouAEIOU\".\\n\\n    public String reverseVowels(String s) {\\n\\n        // Convert the string to charArray.\\n        char[] chars = s.toCharArray();\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        // When both pointers meet, we know all the vowels are swapped.\\n        while (left < right) {\\n            // If chars[left] is not vowel, continue to move right.\\n            while (left < right && !isVowel(chars[left])) {\\n                left++;\\n            }\\n            // If chars[right] is not vowel, continue to move left.\\n            while (left < right && !isVowel(chars[right])) {\\n                right--;\\n            }\\n\\n            // Swap the vowels.\\n            if (left < right) {\\n                char temp = chars[left];\\n                chars[left++] = chars[right];\\n                chars[right--] = temp;\\n            }\\n        }\\n        return new String(chars);\\n    }\\n\\n    // Return true if char is a vowel.\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218626,
                "title": "c-beats-99-detailed-explaination",
                "content": "Basic Idea is to store the index of the vowels in the array \\n\\nLets take an example \\n\"**leetcode**\" here the vowel has an index --> **[1,2,5,7]** we store this in a vector array and then we can apply swap from start and end in the vector.\\n```\\n string reverseString(string &s){\\n         vector<int> v;\\n        for(int i=0 ; i<s.size();i++){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || \\n               s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n                v.push_back(i);\\n        }\\n        for(int start=0, end = v.size()-1; start < end; start++, end--){\\n            swap(s[v[start]] , s[v[end ]]);\\n        }\\n        return s;\\n    }\\n    string reverseVowels(string s) {\\n       reverseString(s);\\n        return s;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Basic Idea is to store the index of the vowels in the array \\n\\nLets take an example \\n\"**leetcode**\" here the vowel has an index --> **[1,2,5,7]** we store this in a vector array and then we can apply swap from start and end in the vector.\\n```\\n string reverseString(string &s){\\n         vector<int> v;\\n        for(int i=0 ; i<s.size();i++){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || \\n               s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n                v.push_back(i);\\n        }\\n        for(int start=0, end = v.size()-1; start < end; start++, end--){\\n            swap(s[v[start]] , s[v[end ]]);\\n        }\\n        return s;\\n    }\\n    string reverseVowels(string s) {\\n       reverseString(s);\\n        return s;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2775366,
                "title": "python-iterator-simple-2-lines",
                "content": "# Approach\\n- create an iterator that iterates all the vowels backwards\\n- create the string with each vowel replaced by the one from the iterator\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        it = (ch for ch in s[::-1] if ch.lower() in \\'aeiou\\')\\n        return \\'\\'.join(next(it) if ch.lower() in \\'aeiou\\' else ch for ch in s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        it = (ch for ch in s[::-1] if ch.lower() in \\'aeiou\\')\\n        return \\'\\'.join(next(it) if ch.lower() in \\'aeiou\\' else ch for ch in s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776920,
                "title": "c-5-different-approaches-two-passes-stack-two-pointers-and-more",
                "content": "Please let me know if you have a different approach or a suggestion for one of the approaches blow. For all the the approaches we need to decide if a character is a vowel, which I did with the following code:\\n\\n```cpp\\n    static bool isVowel(char ch) {\\n        return\\n            ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n            ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\';\\n    }\\n```\\n\\nOther implementations could use a lookup in the a bit / bool vector and avoid the branching, and do something like\\n\\n```cpp\\n    static constexpr bool is_vowel[256] = {\\n        [\\'a\\'] = true, [\\'e\\'] = true, [\\'i\\'] = true, [\\'o\\'] = true, [\\'u\\'] = true,\\n        [\\'A\\'] = true, [\\'E\\'] = true, [\\'I\\'] = true, [\\'O\\'] = true, [\\'U\\'] = true,        \\n    };\\n\\t\\n\\t// We would likley drop this wrapper\\n\\tstatic constexpr bool isVowel(char ch) {\\n\\t\\treturn is_vowel[ch];\\n\\t}\\n```\\n\\nCompiler are pure magic! It\\'s kinda mind blowing that clang generates branchless code for the first version as well, see https://godbolt.org/z/bhErrjEq1\\n\\n# Approach 1: extract, reverse, update\\n\\nWe extract all the vowels, reverse them, and then update the string.\\n\\n```cpp\\n    static string reverseVowels(string s) {\\n        string vowels;\\n        vowels.reserve(size(s));\\n        copy_if(begin(s), end(s), back_inserter(vowels), isVowel);\\n        reverse(begin(vowels), end(vowels));\\n        for (int i = 0, v = 0; i < size(s); ++i)\\n            if (isVowel(s[i])) s[i] = vowels[v++];\\n        return s;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$\\n  * Space Complexity: $$O(n)$$\\n\\n# Approach 2: extract w/ index, reverse, update\\n\\nSimilar to approach 1, but instead of scanning the full string again, we keep track where we found the vowels and just update these positions. This approach is faster than approach 1 if there are only very few vowels in a long string.\\n\\n```cpp\\n    static string reverseVowels(string s) {\\n        string vowels;\\n        vowels.reserve(size(s));\\n        vector<int> idx;\\n        idx.reserve(size(s));\\n        for (int i = 0; i < size(s); ++i) {\\n            if (isVowel(s[i])) {\\n                vowels.push_back(s[i]);\\n                idx.push_back(i);\\n            }\\n        }\\n        reverse(begin(vowels), end(vowels));\\n        for (int i = 0; i < size(idx); ++i)\\n            s[idx[i]] = vowels[i];\\n        return s;\\n    }\\n```\\n\\nInstead of reversing ```vowels``` we could just read the vowels or the index from the back, i.e. do something like:\\n\\n```cpp\\n        for (int i = 0; i < size(idx); ++i)\\n            s[idx[size(idx) - 1 - i]] = vowels[i];\\n```\\n\\n**Complexity Analysis**\\nLike approach 1, but the constant factors are different.\\n\\n# Approach 3: stack\\nThis is based on [a post](https://leetcode.com/problems/reverse-vowels-of-a-string/discuss/2775879/Very-easy-solution-using-Stack) by @kalashpatil which is kinda neat. Runtime wise this is similar to approach 1. ... and yeah,  ```string``` or a ```vector``` are a perfectly fine stack, but obviously we could use a ```stack<char>``` too.\\n\\n```cpp\\n    static string reverseVowels(string s) {\\n        string st;\\n        st.reserve(size(s));\\n        for (char ch : s)\\n            if (isVowel(ch)) st.push_back(ch);\\n        for (char& ch : s)\\n            if (isVowel(ch)) {\\n                ch = st.back();\\n                st.pop_back();\\n            }\\n        return s;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$\\n  * Space Complexity: $$O(n)$$\\n\\n\\n# Approach 4: two pointers\\n\\nIMO this is the best approach. Btw. doing ```swap(s[l++], s[r--]);``` instead of ```if (l < r) swap(s[l++], s[r--]);``` will swap a character with itself at the end, but that doesn\\'t matter.\\n\\n```cpp\\n    static string reverseVowels(string s) {\\n        for (int l = 0, r = size(s) - 1; l < r; ) {\\n            while (l < r && !isVowel(s[l])) ++l;\\n            while (l < r && !isVowel(s[r])) --r;\\n            swap(s[l++], s[r--]);\\n        }\\n        return s;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$\\n  * Space Complexity: $$O(1)$$ if we don\\'t count the output, but we are just modifying the input.\\n\\n# Approach 5: string::find_first_of, string::find_last_of\\n\\nThis approach which is similar to approach 4 is based on [a solution](Super-clean-C%2B%2B-solution-using-find_first_of-and-find_last_of) by @ChowTaiFok.\\n\\n```cpp\\n    static string reverseVowels(string s) {\\n        for (int l = 0, r = size(s) - 1; l < r; ) {\\n            l = s.find_first_of(\"aeiouAEIOU\", l);\\n            r = s.find_last_of(\"aeiouAEIOU\", r);\\n            if (l < r) swap(s[l++], s[r--]);\\n        }\\n        return s;\\n    }\\n```\\n\\n**Complexity Analysis**\\nThis is basically the same as solution 4.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static bool isVowel(char ch) {\\n        return\\n            ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n            ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\';\\n    }\\n```\n```cpp\\n    static constexpr bool is_vowel[256] = {\\n        [\\'a\\'] = true, [\\'e\\'] = true, [\\'i\\'] = true, [\\'o\\'] = true, [\\'u\\'] = true,\\n        [\\'A\\'] = true, [\\'E\\'] = true, [\\'I\\'] = true, [\\'O\\'] = true, [\\'U\\'] = true,        \\n    };\\n\\t\\n\\t// We would likley drop this wrapper\\n\\tstatic constexpr bool isVowel(char ch) {\\n\\t\\treturn is_vowel[ch];\\n\\t}\\n```\n```cpp\\n    static string reverseVowels(string s) {\\n        string vowels;\\n        vowels.reserve(size(s));\\n        copy_if(begin(s), end(s), back_inserter(vowels), isVowel);\\n        reverse(begin(vowels), end(vowels));\\n        for (int i = 0, v = 0; i < size(s); ++i)\\n            if (isVowel(s[i])) s[i] = vowels[v++];\\n        return s;\\n    }\\n```\n```cpp\\n    static string reverseVowels(string s) {\\n        string vowels;\\n        vowels.reserve(size(s));\\n        vector<int> idx;\\n        idx.reserve(size(s));\\n        for (int i = 0; i < size(s); ++i) {\\n            if (isVowel(s[i])) {\\n                vowels.push_back(s[i]);\\n                idx.push_back(i);\\n            }\\n        }\\n        reverse(begin(vowels), end(vowels));\\n        for (int i = 0; i < size(idx); ++i)\\n            s[idx[i]] = vowels[i];\\n        return s;\\n    }\\n```\n```vowels```\n```cpp\\n        for (int i = 0; i < size(idx); ++i)\\n            s[idx[size(idx) - 1 - i]] = vowels[i];\\n```\n```string```\n```vector```\n```stack<char>```\n```cpp\\n    static string reverseVowels(string s) {\\n        string st;\\n        st.reserve(size(s));\\n        for (char ch : s)\\n            if (isVowel(ch)) st.push_back(ch);\\n        for (char& ch : s)\\n            if (isVowel(ch)) {\\n                ch = st.back();\\n                st.pop_back();\\n            }\\n        return s;\\n    }\\n```\n```swap(s[l++], s[r--]);```\n```if (l < r) swap(s[l++], s[r--]);```\n```cpp\\n    static string reverseVowels(string s) {\\n        for (int l = 0, r = size(s) - 1; l < r; ) {\\n            while (l < r && !isVowel(s[l])) ++l;\\n            while (l < r && !isVowel(s[r])) --r;\\n            swap(s[l++], s[r--]);\\n        }\\n        return s;\\n    }\\n```\n```cpp\\n    static string reverseVowels(string s) {\\n        for (int l = 0, r = size(s) - 1; l < r; ) {\\n            l = s.find_first_of(\"aeiouAEIOU\", l);\\n            r = s.find_last_of(\"aeiouAEIOU\", r);\\n            if (l < r) swap(s[l++], s[r--]);\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057077,
                "title": "java-two-pointer-2ms-beats-99-81",
                "content": "# Intuition\\nMy initial thoughts on solving this problem involve reversing the vowels in a given string while keeping the consonants and other characters in their original positions. To achieve this, I would iterate through the string using two pointers, one starting from the beginning and the other from the end. When both pointers point to vowels, I will swap them to reverse the vowels.\\n\\n# Approach\\nI will start by converting the input string s into a character array to make it easier to manipulate. Then, I\\'ll initialize two pointers, start and end, pointing to the beginning and end of the string, respectively.\\n\\nI\\'ll use a while loop to traverse the string. In each iteration, I\\'ll use inner while loops to advance start and end until they point to vowels (or until start crosses end). When both pointers are on vowels, I\\'ll swap the characters at their positions to reverse the vowels. After the loop completes, I\\'ll return the modified character array as a string.\\n\\nTo determine whether a character is a vowel, I\\'ll define a helper function isVowel that checks if the character is one of the vowel characters (both lowercase and uppercase).\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is O(n), where n is the length of the input string s. This is because we traverse the string once with two pointers, and each character is examined only once.\\n\\nSpace complexity: The space complexity is O(n) as well, primarily due to the character array used to store the modified string.\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n\\n        char[] chars = s.toCharArray();\\n\\n        int start = 0 ;\\n\\n        int end = s.length()-1;\\n\\n        while (start<end){\\n            while (start < end && !isVowel(chars[start])) {\\n                start++;\\n            }\\n\\n            while (start < end && !isVowel(chars[end])) {\\n                end--;\\n            }\\n\\n            if (start < end) {\\n                swap(chars, start, end);\\n                start++;\\n                end--;\\n            }\\n\\n        }\\n\\n        return new String(chars);\\n    }\\n\\n    private void swap(char[] word, int start, int end){\\n        char temp = word[start];\\n        word[start] = word[end];\\n        word[end] = temp;\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```\\n![87bab3dd-fabf-4b71-9ac5-984d9015438e_1678160362.0612018.jpeg](https://assets.leetcode.com/users/images/8e036e7a-8854-4426-bf26-d01253a36b73_1694976337.0712368.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n\\n        char[] chars = s.toCharArray();\\n\\n        int start = 0 ;\\n\\n        int end = s.length()-1;\\n\\n        while (start<end){\\n            while (start < end && !isVowel(chars[start])) {\\n                start++;\\n            }\\n\\n            while (start < end && !isVowel(chars[end])) {\\n                end--;\\n            }\\n\\n            if (start < end) {\\n                swap(chars, start, end);\\n                start++;\\n                end--;\\n            }\\n\\n        }\\n\\n        return new String(chars);\\n    }\\n\\n    private void swap(char[] word, int start, int end){\\n        char temp = word[start];\\n        word[start] = word[end];\\n        word[end] = temp;\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775348,
                "title": "daily-leetcoding-challenge-november-day-4",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-vowels-of-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-vowels-of-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 4011156,
                "title": "easy-python-solution",
                "content": "# Intuition\\nTwo pointer approach\\n\\n# Approach\\nSwapping left and right if they are vowels.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        n=len(s)\\n        left=0\\n        right=n-1\\n        vowels=set(\\'AEIOUaeiou\\')\\n        while left<right:\\n            while left<right and s[left] not in vowels:\\n                left+=1\\n            while left<right and s[right] not in vowels:\\n                right-=1\\n            s[left],s[right]=s[right],s[left]\\n            left+=1\\n            right-=1\\n        s=\\'\\'.join(s)\\n        return s\\n\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        n=len(s)\\n        left=0\\n        right=n-1\\n        vowels=set(\\'AEIOUaeiou\\')\\n        while left<right:\\n            while left<right and s[left] not in vowels:\\n                left+=1\\n            while left<right and s[right] not in vowels:\\n                right-=1\\n            s[left],s[right]=s[right],s[left]\\n            left+=1\\n            right-=1\\n        s=\\'\\'.join(s)\\n        return s\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81409,
                "title": "simple-java-solution-using-stringbuilder",
                "content": "    public class Solution {\\n    public String reverseVowels(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int j = s.length() - 1;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1)\\n            {\\n                while (j >= 0 && \"AEIOUaeiou\".indexOf(s.charAt(j)) == -1)\\n                {\\n                    j--;\\n                }\\n                sb.append(s.charAt(j));\\n                j--;\\n            }\\n            else\\n                sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String reverseVowels(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int j = s.length() - 1;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1)\\n            {\\n                while (j >= 0 && \"AEIOUaeiou\".indexOf(s.charAt(j)) == -1)\\n                {\\n                    j--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2776456,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "[Watch](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n          int strt = 0, end = s.size() - 1;\\n        char vow[256] = {0};\\n        vow[\\'a\\'] = 1, vow[\\'A\\'] = 1, vow[\\'e\\'] = 1, vow[\\'E\\'] = 1, vow[\\'i\\'] = 1, vow[\\'I\\'] = 1, vow[\\'o\\'] = 1, vow[\\'O\\'] = 1, vow[\\'u\\'] = 1, vow[\\'U\\'] = 1;\\n      \\n        while(strt < end){\\n            while(strt < end && vow[s[strt]] == 0) \\n                strt++;\\n            while(strt < end && vow[s[end]] == 0) \\n                end--;\\n            \\n            swap(s[strt],s[end]);\\n            strt++;end--;\\n        }\\n        return s;\\n    }\\n};\\n\\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n          int strt = 0, end = s.size() - 1;\\n        char vow[256] = {0};\\n        vow[\\'a\\'] = 1, vow[\\'A\\'] = 1, vow[\\'e\\'] = 1, vow[\\'E\\'] = 1, vow[\\'i\\'] = 1, vow[\\'I\\'] = 1, vow[\\'o\\'] = 1, vow[\\'O\\'] = 1, vow[\\'u\\'] = 1, vow[\\'U\\'] = 1;\\n      \\n        while(strt < end){\\n            while(strt < end && vow[s[strt]] == 0) \\n                strt++;\\n            while(strt < end && vow[s[end]] == 0) \\n                end--;\\n            \\n            swap(s[strt],s[end]);\\n            strt++;end--;\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775879,
                "title": "very-easy-solution-using-stack",
                "content": "```\\n```\\n\\n```\\n```class Solution\\n{\\npublic:\\n \\xA0   string reverseVowels(string s)\\n    {\\n        stack<int> st;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n                st.push(s[i]);\\n        }\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n            {\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};\\nComment if you have any doubt.Suggestions and feedback are welcomed.Happy Coding !!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2503097,
                "title": "python-easy-solution",
                "content": "Solution 1:\\n```\\ndef reverseVowels(self, s: str) -> str: # s = \"leetcode\"\\n        vowel = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s_vowel = [v for v in s if v in vowel] # [\\'e\\', \\'e\\', \\'o\\', \\'e\\']\\n        j=len(s_vowel)-1\\n        s_list = list(s)\\n        for i in range(len(s_list)):\\n            if s_list[i] in vowel:\\n                s_list[i] = s_vowel[j]\\n                j -=1\\n        return \"\".join(s_list)\\n```\\nSolution 2 (faster than 92%):\\n```\\ndef reverseVowels(self, s: str) -> str: # s = \"leetcode\"\\n        vowel = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s_list = list(s)\\n        start = 0\\n        last = len(s_list) - 1\\n        while start < last:\\n            if s_list[start] in vowel and s_list[last] in vowel:\\n                s_list[start], s_list[last] = s_list[last], s_list[start]\\n                start += 1\\n                last -= 1\\n            else:\\n                if s_list[start] not in vowel:\\n                    start += 1\\n                if s_list[last] not in vowel:\\n                    last -= 1\\n        return \"\".join(s_list)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef reverseVowels(self, s: str) -> str: # s = \"leetcode\"\\n        vowel = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s_vowel = [v for v in s if v in vowel] # [\\'e\\', \\'e\\', \\'o\\', \\'e\\']\\n        j=len(s_vowel)-1\\n        s_list = list(s)\\n        for i in range(len(s_list)):\\n            if s_list[i] in vowel:\\n                s_list[i] = s_vowel[j]\\n                j -=1\\n        return \"\".join(s_list)\\n```\n```\\ndef reverseVowels(self, s: str) -> str: # s = \"leetcode\"\\n        vowel = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s_list = list(s)\\n        start = 0\\n        last = len(s_list) - 1\\n        while start < last:\\n            if s_list[start] in vowel and s_list[last] in vowel:\\n                s_list[start], s_list[last] = s_list[last], s_list[start]\\n                start += 1\\n                last -= 1\\n            else:\\n                if s_list[start] not in vowel:\\n                    start += 1\\n                if s_list[last] not in vowel:\\n                    last -= 1\\n        return \"\".join(s_list)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 130442,
                "title": "python-73ms",
                "content": "class Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowel = {\\'a\\', \\'e\\', \\'i\\' ,\\'o\\',\\'u\\', \\'A\\', \\'E\\', \\'I\\' , \\'O\\', \\'U\\'}\\n        \\n        s = list(s)\\n        \\n        vpos=[]\\n        vword=[]\\n        \\n        for index, char in enumerate(s):\\n            if char in vowel:\\n                vpos.append(index)\\n                vword.append(char)\\n            \\n        for i in vpos:\\n            s[i]=vword.pop()\\n            \\n        return \"\".join(s)\\n            \\n            ",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowel = {\\'a\\', \\'e\\', \\'i\\' ,\\'o\\',\\'u\\', \\'A\\', \\'E\\', \\'I\\' , \\'O\\', \\'U\\'}",
                "codeTag": "Java"
            },
            {
                "id": 81377,
                "title": "my-4ms-solution-in-java-beats-98-20",
                "content": "        public static boolean isVowel(char a){\\n    \\t    switch(a){\\n    \\t         case ('a') : return true;\\n    \\t         case ('e') : return true;\\n    \\t         case ('i') : return true;\\n    \\t         case ('o') : return true;\\n    \\t         case ('u') : return true;\\n    \\t         case ('A') : return true;\\n    \\t         case ('E') : return true;\\n    \\t         case ('I') : return true;\\n    \\t         case ('O') : return true;\\n    \\t         case ('U') : return true;\\n    \\t         default : return false;\\n    \\t    }\\n        }\\n    \\n        public static String reverseVowels(String s) {\\n    \\t     if (s.length()<2) return s;\\n    \\t\\n    \\t     char[] tab = s.toCharArray();\\n    \\t     int j = tab.length - 1;\\n    \\t     int i = 0;\\n    \\t\\n    \\t     while( i < j ) {\\n\\n    \\t\\tif (!isVowel(tab[i]))\\n    \\t\\t\\ti++;\\t\\n    \\t\\telse {\\n    \\t\\t\\twhile (j!=i && !isVowel(tab[j]))\\n    \\t\\t\\t\\tj--;\\n    \\t\\t\\t\\n    \\t\\t\\tchar temp = tab[i];\\n    \\t\\t\\ttab[i] = tab[j];\\n    \\t\\t\\ttab[j] = temp;\\n    \\t\\t\\ti++;\\n    \\t\\t\\tj--;\\n    \\t\\t}\\n    \\t}\\n    \\treturn new String(tab);\\n    }",
                "solutionTags": [],
                "code": "        public static boolean isVowel(char a){\\n    \\t    switch(a){\\n    \\t         case ('a') : return true;\\n    \\t         case ('e') : return true;\\n    \\t         case ('i') : return true;\\n    \\t         case ('o') : return true;\\n    \\t         case ('u') : return true;\\n    \\t         case ('A') : return true;\\n    \\t         case ('E') : return true;\\n    \\t         case ('I') : return true;\\n    \\t         case ('O') : return true;\\n    \\t         case ('U') : return true;\\n    \\t         default : return false;\\n    \\t    }\\n        }\\n    \\n        public static String reverseVowels(String s) {\\n    \\t     if (s.length()<2) return s;\\n    \\t\\n    \\t     char[] tab = s.toCharArray();\\n    \\t     int j = tab.length - 1;\\n    \\t     int i = 0;\\n    \\t\\n    \\t     while( i < j ) {\\n\\n    \\t\\tif (!isVowel(tab[i]))\\n    \\t\\t\\ti++;\\t\\n    \\t\\telse {\\n    \\t\\t\\twhile (j!=i && !isVowel(tab[j]))\\n    \\t\\t\\t\\tj--;\\n    \\t\\t\\t\\n    \\t\\t\\tchar temp = tab[i];\\n    \\t\\t\\ttab[i] = tab[j];\\n    \\t\\t\\ttab[j] = temp;\\n    \\t\\t\\ti++;\\n    \\t\\t\\tj--;\\n    \\t\\t}\\n    \\t}\\n    \\treturn new String(tab);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1249797,
                "title": "simple-java-solution",
                "content": "```\\n public String reverseVowels(String s) {\\n        int x=0;\\n        int y=s.length()-1;\\n        \\n        List<Character> list=Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n       \\n        char[] arr=s.toCharArray();\\n        while(x<y){\\n            if(!list.contains(arr[x])){\\n                x++;\\n            }\\n            if(!list.contains(arr[y])){\\n                y--;\\n            }\\n            if(list.contains(arr[x]) && list.contains(arr[y])){\\n                char temp=arr[x];\\n                arr[x]=arr[y];\\n                arr[y]=temp;\\n                x++;\\n                y--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n public String reverseVowels(String s) {\\n        int x=0;\\n        int y=s.length()-1;\\n        \\n        List<Character> list=Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n       \\n        char[] arr=s.toCharArray();\\n        while(x<y){\\n            if(!list.contains(arr[x])){\\n                x++;\\n            }\\n            if(!list.contains(arr[y])){\\n                y--;\\n            }\\n            if(list.contains(arr[x]) && list.contains(arr[y])){\\n                char temp=arr[x];\\n                arr[x]=arr[y];\\n                arr[y]=temp;\\n                x++;\\n                y--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81388,
                "title": "5ms-java-two-pointer-solution",
                "content": "    public class Solution {\\n        public String reverseVowels(String s) {\\n            if (s == null) {\\n                throw new IllegalArgumentException();\\n            }\\n            if (s.length() <= 1) {\\n                return s;\\n            }\\n            char[] str = s.toCharArray();\\n            for (int i = 0, j = str.length - 1; i < j; i++, j--) {\\n                while (i < j && !isVowel(str[i])) i++;\\n                while (i < j && !isVowel(str[j])) j--;\\n                if (i <= j) swap(str, i, j);\\n            }\\n            return new String(str);\\n        }\\n        private boolean isVowel(char ch) {\\n            char c = Character.toLowerCase(ch);\\n            return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\\n        }\\n        private void swap(char[] str, int i, int j) {\\n            char tmp = str[i];\\n            str[i] = str[j];\\n            str[j] = tmp;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n        public String reverseVowels(String s) {\\n            if (s == null) {\\n                throw new IllegalArgumentException();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3602504,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe given problem is to reverse only the vowels in a given string. The vowels are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\', and they can appear in both lower and upper case.\\n\\n\\n# Approach\\nThe provided solution uses a two-pointer approach to reverse the vowels in the string. It initializes two pointers, start and end, at the beginning and end of the string, respectively. It also creates a list, vowels, that contains all the vowels (both lowercase and uppercase).\\n\\nThe solution converts the input string into a list, s, for easier manipulation. It then enters a while loop that continues until the start pointer surpasses the end pointer. Inside the loop, it checks if the character at s[start] is a vowel. If it is, it enters another nested while loop that moves the end pointer towards the start until it finds a vowel at s[end]. This helps in finding the corresponding vowel from the end of the string to swap with the vowel at the start.\\n\\nOnce a vowel is found at both the start and end pointers, the solution swaps them by using a temporary variable, aux. After the swap, both pointers are adjusted accordingly. The end pointer moves towards the start, and the start pointer moves towards the end.\\n\\nFinally, after the while loop, the solution reconstructs the modified list, s, into a string, res, by iterating over each character in s and appending it to res. This modified string is then returned as the output.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n The solution iterates through the string using two pointers, so the while loop runs until the pointers meet or cross each other. This takes O(n/2) time, where n is the length of the string. The process of swapping the vowels takes constant time. The reconstruction of the modified list into a string also takes O(n) time. Therefore, the overall time complexity of the solution is O(n).\\n\\n\\n- Space complexity:\\nThe solution uses additional space to store the modified list, s, and the final string, res. Both have a maximum size of n, where n is the length of the input string. Therefore, the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, word: str) -> str:\\n        start=0\\n        end=len(word)-1\\n        vowels= [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s=[word[i] for i in range(len(word))]\\n        while start<end:\\n            if s[start] in vowels:\\n                while start<end and s[end] not in vowels:\\n                    end-=1\\n                aux=s[start]\\n                s[start]=s[end]\\n                s[end]=aux\\n                end-=1\\n            start+=1\\n        res=\"\"\\n        for i in s:\\n            res+=i\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, word: str) -> str:\\n        start=0\\n        end=len(word)-1\\n        vowels= [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s=[word[i] for i in range(len(word))]\\n        while start<end:\\n            if s[start] in vowels:\\n                while start<end and s[end] not in vowels:\\n                    end-=1\\n                aux=s[start]\\n                s[start]=s[end]\\n                s[end]=aux\\n                end-=1\\n            start+=1\\n        res=\"\"\\n        for i in s:\\n            res+=i\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010246,
                "title": "javascript-two-pointer-approach",
                "content": "```\\nvar reverseVowels = function(s) {\\n    let left = 0\\n    let right = s.length - 1\\n    let arr = s.split(\"\")\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \"I\", \\'O\\', \\'U\\']\\n    \\n    while(left < right){\\n        if(vowels.indexOf(arr[left]) !== -1 && vowels.indexOf(arr[right]) !== -1)\\n            {\\n                [arr[left], arr[right]] = [arr[right], arr[left]]\\n                ++left;\\n                --right;\\n            }\\n        if(vowels.indexOf(arr[left]) == -1){\\n            ++left\\n        }\\n        if(vowels.indexOf(arr[right]) == -1){\\n            --right\\n        }\\n    }\\n    return arr.join(\"\")\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseVowels = function(s) {\\n    let left = 0\\n    let right = s.length - 1\\n    let arr = s.split(\"\")\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \"I\", \\'O\\', \\'U\\']\\n    \\n    while(left < right){\\n        if(vowels.indexOf(arr[left]) !== -1 && vowels.indexOf(arr[right]) !== -1)\\n            {\\n                [arr[left], arr[right]] = [arr[right], arr[left]]\\n                ++left;\\n                --right;\\n            }\\n        if(vowels.indexOf(arr[left]) == -1){\\n            ++left\\n        }\\n        if(vowels.indexOf(arr[right]) == -1){\\n            --right\\n        }\\n    }\\n    return arr.join(\"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669092,
                "title": "easy-solution-with-stack",
                "content": "\\n# Complexity\\n\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string ReverseVowels(string s) {\\n        var str = new StringBuilder();\\n        var l = new Stack<char>();\\n\\n        foreach(var i in s){\\n            if(\"aeiouAEIOU\".Contains(i))\\n                l.Push(i);\\n        }\\n\\n        foreach(var i in s){\\n            if(\"aeiouAEIOU\".Contains(i))\\n                str.Append(l.Pop());\\n            else\\n                str.Append(i);\\n        }\\n        \\n        return str.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string ReverseVowels(string s) {\\n        var str = new StringBuilder();\\n        var l = new Stack<char>();\\n\\n        foreach(var i in s){\\n            if(\"aeiouAEIOU\".Contains(i))\\n                l.Push(i);\\n        }\\n\\n        foreach(var i in s){\\n            if(\"aeiouAEIOU\".Contains(i))\\n                str.Append(l.Pop());\\n            else\\n                str.Append(i);\\n        }\\n        \\n        return str.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777180,
                "title": "c-two-pointers-clean-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nWe simply used two pointers to swap the vowels from left and right . \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool vowel(char c)\\n   {\\n       return (c==\\'a\\' || c==\\'A\\' || c==\\'E\\' || c==\\'e\\' || c==\\'i\\' || c==\\'I\\' || c==\\'o\\' || c==\\'O\\' ||c==\\'u\\' || c==\\'U\\');\\n   }\\n    string reverseVowels(string s) {\\n        int l=0 , r=s.length()-1;\\n        while(l<r)\\n        {\\n            while(l<r && !vowel(s[l])) l++;\\n            while(l<r && !vowel(s[r])) r--;\\n            if(l<r) swap(s[l++],s[r--]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool vowel(char c)\\n   {\\n       return (c==\\'a\\' || c==\\'A\\' || c==\\'E\\' || c==\\'e\\' || c==\\'i\\' || c==\\'I\\' || c==\\'o\\' || c==\\'O\\' ||c==\\'u\\' || c==\\'U\\');\\n   }\\n    string reverseVowels(string s) {\\n        int l=0 , r=s.length()-1;\\n        while(l<r)\\n        {\\n            while(l<r && !vowel(s[l])) l++;\\n            while(l<r && !vowel(s[r])) r--;\\n            if(l<r) swap(s[l++],s[r--]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776192,
                "title": "intuitive-two-pointer-approach-o-n-o-1",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- We have to reverse the vowels present in the string, so we\\'ll  -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo reverse the vowels of the given string, we\\'ll follow two pointers approach. We\\'ll keep the two pointers `i=0` and `j=s.length()-1`; we\\'ll search for the vowels by incrementing `i` and decrementing `j`; if found, swap. We\\'ll perform this action while `i<j`. \\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we\\'ll go through the whole string once.\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHere we are using only `unordered_set<char> st` to store vowels and perform a better search independent of the size of `string s` so space complexity is of constant order.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        unordered_set<char> st = {\\'a\\',\\'A\\', \\'e\\', \\'E\\', \\'i\\', \\'I\\', \\'o\\', \\'O\\', \\'u\\', \\'U\\'};\\n        int i=0, j=s.length()-1;\\n        while(i<j){\\n            while(!st.count(s[i]) && i<j){\\n                i++;\\n            }\\n            while(!st.count(s[j]) && i<j) j--;\\n            swap(s[i], s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        unordered_set<char> st = {\\'a\\',\\'A\\', \\'e\\', \\'E\\', \\'i\\', \\'I\\', \\'o\\', \\'O\\', \\'u\\', \\'U\\'};\\n        int i=0, j=s.length()-1;\\n        while(i<j){\\n            while(!st.count(s[i]) && i<j){\\n                i++;\\n            }\\n            while(!st.count(s[j]) && i<j) j--;\\n            swap(s[i], s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775402,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        char currCh = tolower(ch); //lower all the characters to reduce checking for upppercase vowels\\n        if (currCh == \\'a\\' || currCh == \\'e\\' || currCh == \\'i\\' || currCh == \\'o\\' || currCh == \\'u\\') return true;\\n        return false;\\n    }\\n    string reverseVowels(string s)\\n    {\\n        int n = s.size();\\n        int low = 0, high = n - 1;\\n        while(low < high)\\n        {\\n            bool isLowVowel = isVowel(s[low]);\\n            bool isHighVowel = isVowel(s[high]);\\n            if (isLowVowel && isHighVowel) //consider swapping only when both s[low] and s[high] are vowels\\n            {\\n                swap(s[low], s[high]);\\n                low++; high--; //move low to right, high to left as we have swapped them\\n            }\\n            else if (!isLowVowel) low++; //if s[low] is not a vowel keep traversing to right in search of a vowel\\n            else if (!isHighVowel) high--; //if s[high] is not a vowel keep traversing to left in search of vowel\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        char currCh = tolower(ch); //lower all the characters to reduce checking for upppercase vowels\\n        if (currCh == \\'a\\' || currCh == \\'e\\' || currCh == \\'i\\' || currCh == \\'o\\' || currCh == \\'u\\') return true;\\n        return false;\\n    }\\n    string reverseVowels(string s)\\n    {\\n        int n = s.size();\\n        int low = 0, high = n - 1;\\n        while(low < high)\\n        {\\n            bool isLowVowel = isVowel(s[low]);\\n            bool isHighVowel = isVowel(s[high]);\\n            if (isLowVowel && isHighVowel) //consider swapping only when both s[low] and s[high] are vowels\\n            {\\n                swap(s[low], s[high]);\\n                low++; high--; //move low to right, high to left as we have swapped them\\n            }\\n            else if (!isLowVowel) low++; //if s[low] is not a vowel keep traversing to right in search of a vowel\\n            else if (!isHighVowel) high--; //if s[high] is not a vowel keep traversing to left in search of vowel\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445341,
                "title": "javascript-solution-with-a-stack",
                "content": "```\\nvar reverseVowels = function(s) {\\n  let vowels = [\"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\"]\\n  let stack = []\\n  for (let i = 0; i < s.length; i++) {\\n    if (vowels.indexOf(s[i]) !== -1) {\\n      stack.push(s[i])\\n    }\\n  }\\n  let ans = []\\n  for (let i = 0; i < s.length; i++) {\\n    if (vowels.indexOf(s[i]) !== -1) {\\n      ans.push(stack.pop())\\n    } else {\\n      ans.push(s[i])\\n    }\\n  }\\n  return ans.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseVowels = function(s) {\\n  let vowels = [\"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\"]\\n  let stack = []\\n  for (let i = 0; i < s.length; i++) {\\n    if (vowels.indexOf(s[i]) !== -1) {\\n      stack.push(s[i])\\n    }\\n  }\\n  let ans = []\\n  for (let i = 0; i < s.length; i++) {\\n    if (vowels.indexOf(s[i]) !== -1) {\\n      ans.push(stack.pop())\\n    } else {\\n      ans.push(s[i])\\n    }\\n  }\\n  return ans.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607705,
                "title": "easy-java-solution-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity : O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        String t = \"\";\\n        String e = \"\";\\n        for(int i=0;i<s.length();i++){\\n         char ch = s.charAt(i);\\n        if(ch ==\\'a\\'||ch == \\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\')\\n              e = ch+e;\\n        }\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n        char ch = s.charAt(i);\\n        if(ch ==\\'a\\'||ch == \\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\'){\\n               t+=e.charAt(j);\\n               j++;\\n            }\\n            else\\n            t+=ch;\\n        }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        String t = \"\";\\n        String e = \"\";\\n        for(int i=0;i<s.length();i++){\\n         char ch = s.charAt(i);\\n        if(ch ==\\'a\\'||ch == \\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\')\\n              e = ch+e;\\n        }\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n        char ch = s.charAt(i);\\n        if(ch ==\\'a\\'||ch == \\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\'){\\n               t+=e.charAt(j);\\n               j++;\\n            }\\n            else\\n            t+=ch;\\n        }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523609,
                "title": "java-solution-for-reverse-vowels-of-a-string-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this solution is to reverse the vowels in the input string s. The intuition is to use two pointers, i and j, to traverse the string from both ends, swapping the vowels as they are encountered.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an ArrayList vowList containing all the vowels (both lowercase and uppercase).\\n2. Convert the input string s to a character array arr.\\n3. Initialize two pointers, i at the beginning of the array and j at the end.\\n4. Traverse the array using the two pointers: a. If the character at i is not a vowel, increment i. b. If the character at j is not a vowel, decrement j. c. If both characters at i and j are vowels, swap them and update i and j.\\n5. Continue the traversal until i and j meet or cross each other.\\n6. Convert the modified character array back to a string and return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input string s. The algorithm iterates through the string once, with each character being visited at most twice (once by i and once by j).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for the character array arr created from the input string s. The space required for the vowList ArrayList is constant, as it only contains a fixed number of vowels\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        ArrayList<Character> vowList = new ArrayList<Character>();\\n        vowList.add(\\'a\\');\\n        vowList.add(\\'e\\');\\n        vowList.add(\\'i\\');\\n        vowList.add(\\'o\\');\\n        vowList.add(\\'u\\');\\n        vowList.add(\\'A\\');\\n        vowList.add(\\'E\\');\\n        vowList.add(\\'I\\');\\n        vowList.add(\\'O\\');\\n        vowList.add(\\'U\\');\\n        char[] arr = s.toCharArray();\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(!vowList.contains(arr[i]))\\n            {\\n                i++;\\n                continue;\\n            }\\n            if(!vowList.contains(arr[j]))\\n            {\\n                j--;\\n                continue;\\n            }\\n        char t = arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        i++;\\n        j--;\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        ArrayList<Character> vowList = new ArrayList<Character>();\\n        vowList.add(\\'a\\');\\n        vowList.add(\\'e\\');\\n        vowList.add(\\'i\\');\\n        vowList.add(\\'o\\');\\n        vowList.add(\\'u\\');\\n        vowList.add(\\'A\\');\\n        vowList.add(\\'E\\');\\n        vowList.add(\\'I\\');\\n        vowList.add(\\'O\\');\\n        vowList.add(\\'U\\');\\n        char[] arr = s.toCharArray();\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(!vowList.contains(arr[i]))\\n            {\\n                i++;\\n                continue;\\n            }\\n            if(!vowList.contains(arr[j]))\\n            {\\n                j--;\\n                continue;\\n            }\\n        char t = arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        i++;\\n        j--;\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777575,
                "title": "simple-two-pointer-solution-easy-to-understand",
                "content": "\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake Two pointers i, j.\\nMove i from start and j from end and kept on moving both the pointers until consonents are there, stop when vowels are found.\\nSwap the vowels and do i++ and j-- . \\nMove until i<j .\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) for creating char array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int i = 0, j = s.length() - 1;\\n        while(i<j){\\n            while(i<j){\\n            if(contains(arr[i])) break;\\n            i++;\\n            }\\n            while(j>i){\\n            if(contains(arr[j])) break;\\n                j--; \\n            }\\n            if(i >= j) return String.valueOf(arr);\\n            swap(arr,i,j);\\n            i++;j--;\\n        }\\n        return String.valueOf(arr);\\n    }\\n    public void swap(char[] arr, int i, int j){\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    public boolean contains(char c){\\n       char[] vowels = new char[]{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'};\\n       for(int i = 0; i<10; i++){\\n           if(c == vowels[i]) return true;\\n       }\\n       return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int i = 0, j = s.length() - 1;\\n        while(i<j){\\n            while(i<j){\\n            if(contains(arr[i])) break;\\n            i++;\\n            }\\n            while(j>i){\\n            if(contains(arr[j])) break;\\n                j--; \\n            }\\n            if(i >= j) return String.valueOf(arr);\\n            swap(arr,i,j);\\n            i++;j--;\\n        }\\n        return String.valueOf(arr);\\n    }\\n    public void swap(char[] arr, int i, int j){\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    public boolean contains(char c){\\n       char[] vowels = new char[]{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'};\\n       for(int i = 0; i<10; i++){\\n           if(c == vowels[i]) return true;\\n       }\\n       return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118355,
                "title": "java-simple-solution",
                "content": "JAVA CODE IS:\\n#   \\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char arr[]=s.toCharArray();\\n        Set<Character>vowel=Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n        int l=0,r=s.length()-1;\\n        while(l<r){\\n          if(vowel.contains(arr[l])&&vowel.contains(arr[r])){\\n              char t=arr[l];\\n              arr[l++]=arr[r];\\n              arr[r--]=t;\\n          }\\n          else if(!vowel.contains(arr[l])&&!vowel.contains(arr[r])){\\n              l++;\\n              r--;\\n          }\\n          else if(!vowel.contains(arr[l])&&vowel.contains(arr[r])) l++;\\n          else r--;\\n        }\\n        return String.valueOf(arr);\\n    }\\n}\\n```\\nTIME : O(n)\\nSPACE : O(1)\\n*****PLEASE,UPVOTE IF THIS IS HELPFUL*****",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char arr[]=s.toCharArray();\\n        Set<Character>vowel=Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n        int l=0,r=s.length()-1;\\n        while(l<r){\\n          if(vowel.contains(arr[l])&&vowel.contains(arr[r])){\\n              char t=arr[l];\\n              arr[l++]=arr[r];\\n              arr[r--]=t;\\n          }\\n          else if(!vowel.contains(arr[l])&&!vowel.contains(arr[r])){\\n              l++;\\n              r--;\\n          }\\n          else if(!vowel.contains(arr[l])&&vowel.contains(arr[r])) l++;\\n          else r--;\\n        }\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296384,
                "title": "one-liner-efficient-python-solution-beats-99-97-explained",
                "content": "\\n\\n# SOLUTION\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = re.findall(\\'[aeiouAEIOU]\\', s)\\n        return re.sub(\\'[aeiouAEIOU]\\', lambda _ : vowels.pop(), s)\\n\\n\\n```\\n# STEP-BY-STEP EXPLANATION \\n1. The \"re.findall()\" method is used to find all the vowels in the input string s using a regular expression pattern. The pattern [aeiouAEIOU] matches any lowercase or uppercase vowel.\\n\\n2. The resulting list of vowels is stored in the variable \"vowels\".\\n\\n3. The \"re.sub()\" method is used to replace all vowels in the input string s with a replacement string that is generated using a lambda function.\\n\\n4. The lambda function takes a match object \"_\" as its argument and returns the next vowel from the vowels list using the \"pop()\" method. The pop() method removes the last element from the list and returns it.\\n\\n5.  \"re.sub()\" method replaces each vowel in s with the corresponding vowel from the vowels list in reverse order, effectively reversing the order of the vowels in the string.\\n\\n6. The modified string is returned by the reverseVowels method.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = re.findall(\\'[aeiouAEIOU]\\', s)\\n        return re.sub(\\'[aeiouAEIOU]\\', lambda _ : vowels.pop(), s)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777208,
                "title": "c-most-easy-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        stack<char> stack;    // stores all the vowels in the order they are present in the string\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                stack.push(s[i]);\\n            }\\n            \\n        }\\n        string ans; // will  store the answer string\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                ans.push_back(stack.top()); // whenever any vowels come in the string , we put the stack\\'s top most element which will the last vowels from opposite side of the string\\n                stack.pop(); // after putting the string --> removing the top most element\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]); // if it\\'s not a vowels then we just push the element into out ans string\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        stack<char> stack;    // stores all the vowels in the order they are present in the string\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                stack.push(s[i]);\\n            }\\n            \\n        }\\n        string ans; // will  store the answer string\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                ans.push_back(stack.top()); // whenever any vowels come in the string , we put the stack\\'s top most element which will the last vowels from opposite side of the string\\n                stack.pop(); // after putting the string --> removing the top most element\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]); // if it\\'s not a vowels then we just push the element into out ans string\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776937,
                "title": "short-and-easy-one-pass-solution",
                "content": "```csharp\\npublic class Solution\\n{\\n    public string ReverseVowels(string s)\\n    {\\n        var vowels = \"aeiouAEIOU\";\\n        var extract = s.Where(c => vowels.Contains(c)).Reverse().ToArray();\\n        var res = s.ToCharArray();\\n\\n        int v = 0;\\n\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (vowels.Contains(s[i]))\\n            {\\n                res[i] = extract[v++];\\n            }\\n        }\\n\\n        return new string(res);\\n    }\\n}\\n```\\n1. Extract the vowels from the input string and put them in the reversed order.\\n2. Iterate over the characters in the input string and replace each vowel with the vowel from Step 1.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public string ReverseVowels(string s)\\n    {\\n        var vowels = \"aeiouAEIOU\";\\n        var extract = s.Where(c => vowels.Contains(c)).Reverse().ToArray();\\n        var res = s.ToCharArray();\\n\\n        int v = 0;\\n\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (vowels.Contains(s[i]))\\n            {\\n                res[i] = extract[v++];\\n            }\\n        }\\n\\n        return new string(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775427,
                "title": "daily-leetcode-solution-one-pass-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        if(n==0||n==1) return s;\\n        if(s==\" \") return s;\\n        while(i<=j&&i!=n&&j!=-1)\\n        {\\n            while(i!=n&&j!=-1&&i<=j&&!isVowel(s[i])) i++;\\n            while(i!=n&&j!=-1&&i<=j&&!isVowel(s[j])) j--;\\n            if(i<=j&&i!=n&&j!=-1)\\n            {\\n                swap(s[i],s[j]);\\n            }\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        if(n==0||n==1) return s;\\n        if(s==\" \") return s;\\n        while(i<=j&&i!=n&&j!=-1)\\n        {\\n            while(i!=n&&j!=-1&&i<=j&&!isVowel(s[i])) i++;\\n            while(i!=n&&j!=-1&&i<=j&&!isVowel(s[j])) j--;\\n            if(i<=j&&i!=n&&j!=-1)\\n            {\\n                swap(s[i],s[j]);\\n            }\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449971,
                "title": "typescript-beats-100-two-pointers",
                "content": "```\\nfunction reverseVowels(s: string): string {\\n  let start = 0;\\n  let end = s.length - 1;\\n  const VOWELS = new Set([\"a\", \"i\", \"u\", \"e\", \"o\",\"A\", \"I\", \"U\", \"E\", \"O\"])\\n  const ans = [...s];\\n  while(start < end){\\n    if(!VOWELS.has(ans[start]))\\n      start++;\\n    if(!VOWELS.has(ans[end]))\\n      end--;\\n    if(VOWELS.has(ans[start]) && VOWELS.has(ans[end])){\\n      const temp = ans[start];\\n      ans[start] = ans[end];\\n      ans[end] = temp;\\n      start++\\n      end--;\\n    }\\n  }\\n  return ans.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```\\nfunction reverseVowels(s: string): string {\\n  let start = 0;\\n  let end = s.length - 1;\\n  const VOWELS = new Set([\"a\", \"i\", \"u\", \"e\", \"o\",\"A\", \"I\", \"U\", \"E\", \"O\"])\\n  const ans = [...s];\\n  while(start < end){\\n    if(!VOWELS.has(ans[start]))\\n      start++;\\n    if(!VOWELS.has(ans[end]))\\n      end--;\\n    if(VOWELS.has(ans[start]) && VOWELS.has(ans[end])){\\n      const temp = ans[start];\\n      ans[start] = ans[end];\\n      ans[end] = temp;\\n      start++\\n      end--;\\n    }\\n  }\\n  return ans.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81356,
                "title": "javascript-solution",
                "content": "```\\nvar reverseVowels = function(s) {\\n    if(s === null || s.length === 0) {\\n        return s;\\n    }\\n    var chars = s.split('');\\n    var low = 0;\\n    var high = s.length - 1;\\n    var vowels = \"aeiouAEIOU\";\\n    var tmp;\\n    while(low < high) {\\n        while(low < high && vowels.indexOf(chars[low]) === -1) {\\n            low++;\\n        }\\n        \\n        while(low < high && vowels.indexOf(chars[high]) === -1) {\\n            high--;\\n        }\\n        \\n        tmp = chars[high];\\n        chars[high] = chars[low];\\n        chars[low] = tmp;\\n        low++;\\n        high--;\\n    }\\n    \\n    return chars.join('');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseVowels = function(s) {\\n    if(s === null || s.length === 0) {\\n        return s;\\n    }\\n    var chars = s.split('');\\n    var low = 0;\\n    var high = s.length - 1;\\n    var vowels = \"aeiouAEIOU\";\\n    var tmp;\\n    while(low < high) {\\n        while(low < high && vowels.indexOf(chars[low]) === -1) {\\n            low++;\\n        }\\n        \\n        while(low < high && vowels.indexOf(chars[high]) === -1) {\\n            high--;\\n        }\\n        \\n        tmp = chars[high];\\n        chars[high] = chars[low];\\n        chars[low] = tmp;\\n        low++;\\n        high--;\\n    }\\n    \\n    return chars.join('');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057153,
                "title": "easy-c-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n## **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n### **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nThe reverseVowels function takes a string s as input and returns a new string where only the vowels in the input string are reversed, while the consonants remain in their original positions.\\n\\nHere\\'s an approach to understand how this code works:\\n\\nisVowel Function:\\n\\n- This function takes a character c as input and checks whether it is a vowel.\\n- It does this by comparing c to a list of lowercase and uppercase vowel characters (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\') using logical OR (||) operators.\\n- If c matches any of these characters, the function returns true, indicating that c is a vowel; otherwise, it returns false.\\nreverseVowels Function:\\n\\n- This function takes a string s as input and aims to reverse the order of vowels within the string.\\n- It initializes two pointers, i and j, to the beginning and end of the string, respectively.\\n- It enters a while loop that continues as long as i is less than j, indicating that there are more characters to process.\\n- Inside the loop:\\n-  It advances the pointer i to the right (towards the end of the string) until it finds a vowel using the isVowel function.\\n- It advances the pointer j to the left (towards the beginning of the string) until it finds a vowel using the isVowel function.\\n- Once both i and j have found vowels or i is no longer less than j, the loop continues.\\n- It then swaps the vowels found at positions i and j in the string s to reverse their order.\\n- After the swap, it increments i and decrements j to move the pointers closer to each other.\\n- The loop continues until i is no longer less than j, at which point all the vowels in the string have been reversed.\\n- Finally, the modified string s is returned as the result.\\nOverall, this code efficiently reverses the order of vowels in a given string while keeping the consonants in their original positions.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n                c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\');\\n    }\\n    string reverseVowels(string s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        while (i < j) {\\n            while (i < j && !isVowel(s[i])) {\\n                i++;\\n            }\\n            while (i < j && !isVowel(s[j])) {\\n                j--;\\n            }\\n            swap(s[i], s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n                c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\');\\n    }\\n    string reverseVowels(string s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        while (i < j) {\\n            while (i < j && !isVowel(s[i])) {\\n                i++;\\n            }\\n            while (i < j && !isVowel(s[j])) {\\n                j--;\\n            }\\n            swap(s[i], s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909601,
                "title": "easiest-two-pointer-approach-to-reverse-vowels-of-a-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution involves using a two-pointer approach to reverse the vowels in the given string. The idea is to find pairs of vowels from both ends of the string and swap them until the pointers meet in the middle. By swapping only the vowel characters, the non-vowel characters will remain in their original positions.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, l and r, pointing to the start and end of the string respectively.\\n2. Create a list of vowel characters, both lowercase and uppercase.\\n3. Convert the input string into a list of characters for ease of swapping.\\n4. Iterate through the string using the two-pointer approach:\\n    - If the character at position l is not a vowel, increment l.\\n    - If the character at position r is not a vowel, decrement r.\\n    - If both characters at positions l and r are vowels, swap them and then increment l and decrement r.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe two-pointer approach iterates through the string once, so the time complexity is O(n), where n is the length of the input string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses additional space to store the list of characters, which takes O(n) space, where n is the length of the input string.\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        l = 0\\n        r = len(s) - 1\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        s = list(s)\\n        while (l < r):\\n            if s[l].lower() not in vowels:\\n                l += 1\\n            elif s[r].lower() not in vowels:\\n                r -= 1\\n            else:\\n                s[l], s[r] = s[r], s[l]\\n                l += 1\\n                r -= 1\\n        return \"\".join(s)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        l = 0\\n        r = len(s) - 1\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        s = list(s)\\n        while (l < r):\\n            if s[l].lower() not in vowels:\\n                l += 1\\n            elif s[r].lower() not in vowels:\\n                r -= 1\\n            else:\\n                s[l], s[r] = s[r], s[l]\\n                l += 1\\n                r -= 1\\n        return \"\".join(s)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646561,
                "title": "the-shortest-solution",
                "content": "# Code\\n```\\nconst reverseVowels = function(s) {\\n    const vow = s.match(/[aeiou]/gi);\\n    return s.replace(/[aeiou]/ig, el=> vow.pop());\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst reverseVowels = function(s) {\\n    const vow = s.match(/[aeiou]/gi);\\n    return s.replace(/[aeiou]/ig, el=> vow.pop());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546210,
                "title": "python-solution-beats-72-38-60ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe traverse the list from left and right till we find a vowel from both the directions \\nthen we swap them and search for the next pair of vowels \\nthis process repeats till left crosses right\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        left,right=0,len(s)-1\\n        v=\\'aeiouAEIOU\\'\\n        s=list(s)\\n        while left<right:\\n            if s[left] not in v:\\n                left+=1\\n            if s[right] not in v:\\n                right-=1    \\n            if s[left] in v  and s[right] in v :\\n                s[left],s[right]=s[right],s[left]\\n\\n                left+=1\\n                right-=1\\n        return \\'\\'.join(s) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        left,right=0,len(s)-1\\n        v=\\'aeiouAEIOU\\'\\n        s=list(s)\\n        while left<right:\\n            if s[left] not in v:\\n                left+=1\\n            if s[right] not in v:\\n                right-=1    \\n            if s[left] in v  and s[right] in v :\\n                s[left],s[right]=s[right],s[left]\\n\\n                left+=1\\n                right-=1\\n        return \\'\\'.join(s) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246282,
                "title": "345-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe reverseVowels function takes a string s as input and returns a new string with all the vowels in s reversed.\\n\\nFirst, a set of all vowels is created, including both lowercase and uppercase vowels. Then, the input string s is converted to a list of characters using the list() function, since strings are immutable in Python.\\n\\nTwo pointers, left and right, are used to iterate through the list from both ends towards the middle. If both characters at the current positions are vowels, they are swapped. If only the character at left is a vowel, right is decremented. If only the character at right is a vowel, left is incremented. If neither character is a vowel, both pointers are moved towards the middle. This process continues until left >= right.\\n\\nFinally, the modified list is converted back into a string using the \"\".join() method and returned as the output of the function.\\n\\n# Complexity\\n- Time complexity:\\n86.71%\\n\\n- Space complexity:\\n80.34%\\n\\n# Code\\n```\\nclass Solution:\\n  def reverseVowels(self, s: str) -> str:\\n    vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n    # Convert string to list since string is immutable in Python\\n    s_list = list(s)\\n    left, right = 0, len(s_list) - 1\\n    while left < right:\\n        if s_list[left] in vowels and s_list[right] in vowels:\\n        # Swap the vowels\\n            s_list[left], s_list[right] = s_list[right], s_list[left]\\n            left += 1\\n            right -= 1\\n        elif s_list[left] in vowels:\\n            right -= 1\\n        elif s_list[right] in vowels:\\n            left += 1\\n        else:\\n            left += 1\\n            right -= 1\\n        # Convert the list back to string and return\\n    return \"\".join(s_list)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  def reverseVowels(self, s: str) -> str:\\n    vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n    # Convert string to list since string is immutable in Python\\n    s_list = list(s)\\n    left, right = 0, len(s_list) - 1\\n    while left < right:\\n        if s_list[left] in vowels and s_list[right] in vowels:\\n        # Swap the vowels\\n            s_list[left], s_list[right] = s_list[right], s_list[left]\\n            left += 1\\n            right -= 1\\n        elif s_list[left] in vowels:\\n            right -= 1\\n        elif s_list[right] in vowels:\\n            left += 1\\n        else:\\n            left += 1\\n            right -= 1\\n        # Convert the list back to string and return\\n    return \"\".join(s_list)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171202,
                "title": "c-4-line-code-easiest-solution-for-this-problem",
                "content": "Please upvote if you found this helpful ;)\\n```\\nstring reverseVowels(string s) {\\n        for(int i=0,j=s.size()-1;i<j;){\\n            while(s[i]!=\\'a\\'&&s[i]!=\\'e\\'&&s[i]!=\\'i\\'&&s[i]!=\\'o\\'&&s[i]!=\\'u\\'&&s[i]!=\\'A\\'&&s[i]!=\\'E\\'&&s[i]!=\\'I\\'&&s[i]!=\\'O\\'&&s[i]!=\\'U\\'&&i<j) i++;\\n            while(s[j]!=\\'a\\'&&s[j]!=\\'e\\'&&s[j]!=\\'i\\'&&s[j]!=\\'o\\'&&s[j]!=\\'u\\'&&s[j]!=\\'A\\'&&s[j]!=\\'E\\'&&s[j]!=\\'I\\'&&s[j]!=\\'O\\'&&s[j]!=\\'U\\'&&j>i) j--;\\n            swap(s[i++],s[j--]);     \\n        }\\n        return s;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Please upvote if you found this helpful ;)\\n```\\nstring reverseVowels(string s) {\\n        for(int i=0,j=s.size()-1;i<j;){\\n            while(s[i]!=\\'a\\'&&s[i]!=\\'e\\'&&s[i]!=\\'i\\'&&s[i]!=\\'o\\'&&s[i]!=\\'u\\'&&s[i]!=\\'A\\'&&s[i]!=\\'E\\'&&s[i]!=\\'I\\'&&s[i]!=\\'O\\'&&s[i]!=\\'U\\'&&i<j) i++;\\n            while(s[j]!=\\'a\\'&&s[j]!=\\'e\\'&&s[j]!=\\'i\\'&&s[j]!=\\'o\\'&&s[j]!=\\'u\\'&&s[j]!=\\'A\\'&&s[j]!=\\'E\\'&&s[j]!=\\'I\\'&&s[j]!=\\'O\\'&&s[j]!=\\'U\\'&&j>i) j--;\\n            swap(s[i++],s[j--]);     \\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2950475,
                "title": "fastest-solution-two-pointers-o-n-java",
                "content": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean isVowel(char c)\\n    {\\n        return (c == \\'a\\' || c == \\'A\\' || c == \\'e\\'\\n                || c == \\'E\\' || c == \\'i\\' || c == \\'I\\'\\n                || c == \\'o\\' || c == \\'O\\' || c == \\'u\\'\\n                || c == \\'U\\');\\n    }\\n    public String reverseVowels(String s) \\n    {\\n        int start=0,end=s.length()-1;\\n        String st = \"aeiouAEIOU\";\\n        char[] str=s.toCharArray();\\n        \\n        while(start<end)\\n        {\\n            if (!isVowel(str[start]))\\n            {\\n                start++;\\n                continue;\\n            }\\n            if (!isVowel(str[end]))\\n            {\\n                end--;\\n                continue;\\n            }\\n            char temp = str[start];\\n            str[start]= str[end];\\n            str[end]= temp;\\n            \\n            start++;\\n            end--;\\n        }\\n        String str2 = String.copyValueOf(str);\\n        return str2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\n```\\nclass Solution \\n{\\n    public boolean isVowel(char c)\\n    {\\n        return (c == \\'a\\' || c == \\'A\\' || c == \\'e\\'\\n                || c == \\'E\\' || c == \\'i\\' || c == \\'I\\'\\n                || c == \\'o\\' || c == \\'O\\' || c == \\'u\\'\\n                || c == \\'U\\');\\n    }\\n    public String reverseVowels(String s) \\n    {\\n        int start=0,end=s.length()-1;\\n        String st = \"aeiouAEIOU\";\\n        char[] str=s.toCharArray();\\n        \\n        while(start<end)\\n        {\\n            if (!isVowel(str[start]))\\n            {\\n                start++;\\n                continue;\\n            }\\n            if (!isVowel(str[end]))\\n            {\\n                end--;\\n                continue;\\n            }\\n            char temp = str[start];\\n            str[start]= str[end];\\n            str[end]= temp;\\n            \\n            start++;\\n            end--;\\n        }\\n        String str2 = String.copyValueOf(str);\\n        return str2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778770,
                "title": "python-2-liner-no-regex",
                "content": "Use `iter` to get a generator for the vowels in reverse order. When you reach a vowel, ask for the next element. Since the number of vowels won\\'t change, `vowels` will always have the character you need.\\n```python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = iter(c for c in s[::-1] if c.lower() in \\'aeiou\\')\\n        return \"\".join(next(vowels) if c.lower() in \\'aeiou\\' else c for c in s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = iter(c for c in s[::-1] if c.lower() in \\'aeiou\\')\\n        return \"\".join(next(vowels) if c.lower() in \\'aeiou\\' else c for c in s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777029,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        if(s.empty()) return s;\\n        set<char>v{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n        string a = \"\";\\n        int x = 0;\\n        for(int i = s.size() - 1; i >= 0; i--){\\n            if(v.count(s[i])) a+=s[i];\\n        }\\n        for(int i = 0; i < s.size(); i++){\\n            if(v.count(s[i])) s[i] = a[x++];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        if(s.empty()) return s;\\n        set<char>v{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n        string a = \"\";\\n        int x = 0;\\n        for(int i = s.size() - 1; i >= 0; i--){\\n            if(v.count(s[i])) a+=s[i];\\n        }\\n        for(int i = 0; i < s.size(); i++){\\n            if(v.count(s[i])) s[i] = a[x++];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776205,
                "title": "one-pass-o-1-space-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust like we use two pointer in reverse a string problem. Start pointers from start and end , if we find vowels on both indices , exchange the characters. I used unordered set to check if a char is vowel in O(1).\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n        int i =0,j= s.size()-1;\\n        unordered_set<char> v({\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'});\\n        \\n        while(i<j){\\n           if(v.find(s[i])!=v.end() && v.find(s[j])!=v.end()){ \\n               char x = s[i];\\n               s[i]=s[j],s[j]=x;\\n               i++,j--;\\n           }\\n           else if(v.find(s[i])==v.end())i++;\\n           else\\n               j--;\\n        }\\n\\n        return s;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n        int i =0,j= s.size()-1;\\n        unordered_set<char> v({\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'});\\n        \\n        while(i<j){\\n           if(v.find(s[i])!=v.end() && v.find(s[j])!=v.end()){ \\n               char x = s[i];\\n               s[i]=s[j],s[j]=x;\\n               i++,j--;\\n           }\\n           else if(v.find(s[i])==v.end())i++;\\n           else\\n               j--;\\n        }\\n\\n        return s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2776072,
                "title": "java-easy-and-clean-soln-using-hashset-and-2-pointers",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        StringBuilder sb=new StringBuilder(s);\\n        HashSet<Character> set=new HashSet<>();\\n        set.add(\\'a\\');\\n        set.add(\\'e\\');\\n        set.add(\\'i\\');\\n        set.add(\\'o\\');\\n        set.add(\\'u\\');\\n        set.add(\\'A\\');\\n        set.add(\\'E\\');\\n        set.add(\\'I\\');\\n        set.add(\\'O\\');\\n        set.add(\\'U\\');\\n        while(i<j){\\n           // System.out.println(sb);\\n            char a=s.charAt(i);\\n            char b=s.charAt(j);\\n            if(set.contains(a) ){\\n                if(set.contains(b)){\\n                    sb.replace(i,i+1,\"\"+b);\\n                    sb.replace(j,j+1,\"\"+a);\\n                    i++;\\n                } \\n                j--;\\n            }\\n            else if(set.contains(b)){\\n                i++;\\n            }\\n            else{\\n                i++;\\n                j--;\\n            }\\n            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        StringBuilder sb=new StringBuilder(s);\\n        HashSet<Character> set=new HashSet<>();\\n        set.add(\\'a\\');\\n        set.add(\\'e\\');\\n        set.add(\\'i\\');\\n        set.add(\\'o\\');\\n        set.add(\\'u\\');\\n        set.add(\\'A\\');\\n        set.add(\\'E\\');\\n        set.add(\\'I\\');\\n        set.add(\\'O\\');\\n        set.add(\\'U\\');\\n        while(i<j){\\n           // System.out.println(sb);\\n            char a=s.charAt(i);\\n            char b=s.charAt(j);\\n            if(set.contains(a) ){\\n                if(set.contains(b)){\\n                    sb.replace(i,i+1,\"\"+b);\\n                    sb.replace(j,j+1,\"\"+a);\\n                    i++;\\n                } \\n                j--;\\n            }\\n            else if(set.contains(b)){\\n                i++;\\n            }\\n            else{\\n                i++;\\n                j--;\\n            }\\n            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775900,
                "title": "java-beats-100-easy-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate isVowel function which will accept char as argument and will tell it is vowel or not.\\nuse Two pointers concept and initialize pointers start=0 and end=length-1. swap first vowel with last, second vowel with second last and so on... till star<end\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n- Space complexity:O(N) as we are using extra char array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String str) {\\n        int n=str.length();\\n        char [] ch=str.toCharArray();\\n\\n        int start=0,end=n-1;\\n        while(start<end){\\n            while(start<end && !isVowel(ch[start])){\\n                start++;\\n            }\\n            while(start<end && !isVowel(ch[end])){\\n                end--;\\n            }\\n                char temp=ch[start];\\n                ch[start]=ch[end];\\n                ch[end]=temp;\\n                start++;\\n                end--;\\n        }\\n\\n        return String.valueOf(ch);\\n    }\\n    public boolean isVowel(char chr){\\n        if(chr==\\'a\\' || chr==\\'e\\' || chr==\\'i\\' || chr==\\'o\\' ||chr==\\'u\\' \\n        || chr==\\'A\\' || chr==\\'E\\' || chr==\\'I\\' || chr==\\'O\\' || chr==\\'U\\'){\\n                return true;\\n            }\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String str) {\\n        int n=str.length();\\n        char [] ch=str.toCharArray();\\n\\n        int start=0,end=n-1;\\n        while(start<end){\\n            while(start<end && !isVowel(ch[start])){\\n                start++;\\n            }\\n            while(start<end && !isVowel(ch[end])){\\n                end--;\\n            }\\n                char temp=ch[start];\\n                ch[start]=ch[end];\\n                ch[end]=temp;\\n                start++;\\n                end--;\\n        }\\n\\n        return String.valueOf(ch);\\n    }\\n    public boolean isVowel(char chr){\\n        if(chr==\\'a\\' || chr==\\'e\\' || chr==\\'i\\' || chr==\\'o\\' ||chr==\\'u\\' \\n        || chr==\\'A\\' || chr==\\'E\\' || chr==\\'I\\' || chr==\\'O\\' || chr==\\'U\\'){\\n                return true;\\n            }\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775583,
                "title": "using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        stack<char>st;\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\'){\\n                char c = st.top();\\n                st.pop();\\n                s[i] = c;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        stack<char>st;\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\'){\\n                char c = st.top();\\n                st.pop();\\n                s[i] = c;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962990,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn reverse_vowels(s: String) -> String {\\n        let is_vowel = |b: u8| matches!(b, b\\'a\\' | b\\'e\\' | b\\'i\\' | b\\'o\\' | b\\'u\\' | b\\'A\\' | b\\'E\\' | b\\'I\\' | b\\'O\\' | b\\'U\\');\\n        let mut vb = s.into_bytes();\\n        let (mut i, mut j) = (0, vb.len() - 1);\\n        while i < j {\\n            while i < j && !is_vowel(vb[i]) {\\n                i += 1;\\n            }\\n            while i < j && !is_vowel(vb[j]) {\\n                j -= 1;\\n            }\\n            if i < j {\\n                vb.swap(i, j);\\n                i += 1;\\n                j -= 1;\\n            }\\n        }\\n        String::from_utf8(vb).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn reverse_vowels(s: String) -> String {\\n        let is_vowel = |b: u8| matches!(b, b\\'a\\' | b\\'e\\' | b\\'i\\' | b\\'o\\' | b\\'u\\' | b\\'A\\' | b\\'E\\' | b\\'I\\' | b\\'O\\' | b\\'U\\');\\n        let mut vb = s.into_bytes();\\n        let (mut i, mut j) = (0, vb.len() - 1);\\n        while i < j {\\n            while i < j && !is_vowel(vb[i]) {\\n                i += 1;\\n            }\\n            while i < j && !is_vowel(vb[j]) {\\n                j -= 1;\\n            }\\n            if i < j {\\n                vb.swap(i, j);\\n                i += 1;\\n                j -= 1;\\n            }\\n        }\\n        String::from_utf8(vb).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903510,
                "title": "c-0ms-faster-than-100-simple-clean-readable",
                "content": "It should be pretty straightforward here. We have to traverse from both ends of the string until we encounter vowels from both sides. Once we do, we can then swap it and proceed to do so for the rest of the string.\\n\\nLet us use 2 pointers named ```beg``` and ```end```  traverse from the left and right ends respectively. There are 3 things that can occur as you traverse from both ends. You may encounter:\\n- A vowel at the left side (at ```s[beg]```) & a consonant at the right (at ```s[end]```)\\n\\t- If so, we keep the ```beg``` pointer as it is, and move the ```end``` pointer a step towards the left.\\n- A consonant at the left side & a vowel at the right\\n\\t- We keep the ```end``` pointer as it is, and move the ```beg``` pointer a step to the right\\n- Vowels at both positions of ```beg``` and ```end```.\\n\\t- We swap the vowels\\n\\nWe carry this out until we\\'re done scanning all the characters. The condition ```beg < end``` is to verify the same, since you know that you\\'ve traversed all the characters when the pointers meet at a position where ```beg == end```.\\n\\n**C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n    \\n    string reverseVowels(string s) {\\n        int beg = 0, end = s.size() - 1;\\n        string s1 = s;\\n        \\n        while (beg < end) {\\n            if (isVowel(s1[beg]) && isVowel(s1[end])) {\\n                swap(s1[beg], s1[end]);\\n                beg++; end--;\\n            } else if (isVowel(s1[beg])) {\\n                end--;\\n            } else if (isVowel(s1[end])) {\\n                beg++;\\n            } else {\\n                beg++;\\n                end--;\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```beg```\n```end```\n```s[beg]```\n```s[end]```\n```beg```\n```end```\n```end```\n```beg```\n```beg```\n```end```\n```beg < end```\n```beg == end```\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n    \\n    string reverseVowels(string s) {\\n        int beg = 0, end = s.size() - 1;\\n        string s1 = s;\\n        \\n        while (beg < end) {\\n            if (isVowel(s1[beg]) && isVowel(s1[end])) {\\n                swap(s1[beg], s1[end]);\\n                beg++; end--;\\n            } else if (isVowel(s1[beg])) {\\n                end--;\\n            } else if (isVowel(s1[end])) {\\n                beg++;\\n            } else {\\n                beg++;\\n                end--;\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135893,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string reverseVowels(string s)\\n    {\\n        vector<int>v;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i]==\\'A\\' || s[i]==\\'E\\' || s[i]==\\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.empty())\\n        {\\n            return s;\\n        }\\n        int i=0,j=v.size()-1;\\n        while(j>i)\\n        {\\n            swap(s[v[i]],s[v[j]]);\\n            j--;\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string reverseVowels(string s)\\n    {\\n        vector<int>v;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i]==\\'A\\' || s[i]==\\'E\\' || s[i]==\\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.empty())\\n        {\\n            return s;\\n        }\\n        int i=0,j=v.size()-1;\\n        while(j>i)\\n        {\\n            swap(s[v[i]],s[v[j]]);\\n            j--;\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088089,
                "title": "probably-the-easiest-one-to-understand-with-comments",
                "content": "```\\nvar reverseVowels = function(s) {\\n   let b = [],\\n    v = [\"a\", \"e\", \"i\", \"o\", \"u\"],\\n    arr = s.split(\"\");\\n    \\n  for (let i = 0; i < s.length; i++) {\\n    if (v.includes(s[i].toLowerCase())) {\\n\\t// pushing all the vowels\\n      b.push(s[i]);\\n    }\\n  }\\n    \\n  for (let i = 0; i < s.length; i++) {\\n    if (v.includes(s[i].toLowerCase())) {\\n\\t// by pop() we are placing the last vowel of the array at the place of first vowel of given string(which means we are reversing the position)\\n      arr[i] = b.pop();\\n    }\\n  }\\n    \\n  return arr.join(\"\");\\n};\\n```\\n```\\nvar reverseVowels = function(s) {\\n    const vowels=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n    const revVowels=[]\\n    for(let ch of s){\\n        if(vowels.includes(ch.toLowerCase())){\\n            revVowels.push(ch)\\n        }\\n    }\\n    s=s.split(\\'\\')\\n    let last=revVowels.length-1\\n    for(let i=0;i<s.length;i++){\\n        if(vowels.includes(s[i].toLowerCase())){\\n            s[i]=revVowels[last--]\\n        }\\n    }\\n    return s.join(\\'\\')\\n};\\n```\\n2 pointer approach(No additional memory to store vowels)\\n```\\nvar reverseVowels = function(s) {\\n  const set=new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'])  \\n    s=s.split(\\'\\')\\n    let i=0;\\n    let j=s.length-1\\n    while(i<j){\\n\\t\\t// move the pointers until they\\'re not pointing at vowels\\n        while(i<j && !set.has(s[i].toLowerCase()))i++\\n        while(i<j && !set.has(s[j].toLowerCase()))j--\\n\\t\\t // when both pointers are pointing at vowel, swap them using array destructuring\\n        [s[i],s[j]] = [s[j],s[i]];\\n        i++\\n        j--\\n    }\\n    return s.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseVowels = function(s) {\\n   let b = [],\\n    v = [\"a\", \"e\", \"i\", \"o\", \"u\"],\\n    arr = s.split(\"\");\\n    \\n  for (let i = 0; i < s.length; i++) {\\n    if (v.includes(s[i].toLowerCase())) {\\n\\t// pushing all the vowels\\n      b.push(s[i]);\\n    }\\n  }\\n    \\n  for (let i = 0; i < s.length; i++) {\\n    if (v.includes(s[i].toLowerCase())) {\\n\\t// by pop() we are placing the last vowel of the array at the place of first vowel of given string(which means we are reversing the position)\\n      arr[i] = b.pop();\\n    }\\n  }\\n    \\n  return arr.join(\"\");\\n};\\n```\n```\\nvar reverseVowels = function(s) {\\n    const vowels=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n    const revVowels=[]\\n    for(let ch of s){\\n        if(vowels.includes(ch.toLowerCase())){\\n            revVowels.push(ch)\\n        }\\n    }\\n    s=s.split(\\'\\')\\n    let last=revVowels.length-1\\n    for(let i=0;i<s.length;i++){\\n        if(vowels.includes(s[i].toLowerCase())){\\n            s[i]=revVowels[last--]\\n        }\\n    }\\n    return s.join(\\'\\')\\n};\\n```\n```\\nvar reverseVowels = function(s) {\\n  const set=new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'])  \\n    s=s.split(\\'\\')\\n    let i=0;\\n    let j=s.length-1\\n    while(i<j){\\n\\t\\t// move the pointers until they\\'re not pointing at vowels\\n        while(i<j && !set.has(s[i].toLowerCase()))i++\\n        while(i<j && !set.has(s[j].toLowerCase()))j--\\n\\t\\t // when both pointers are pointing at vowel, swap them using array destructuring\\n        [s[i],s[j]] = [s[j],s[i]];\\n        i++\\n        j--\\n    }\\n    return s.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806132,
                "title": "99-faster-simplest-solution",
                "content": "\\tdef reverseVowels(self, s: str) -> str:\\n\\t\\t\\tvowels = set({\"a\", \"e\", \"i\", \"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"})\\n\\t\\t\\ts = list(s)\\n\\t\\t\\ti,j = 0, len(s) - 1\\n\\t\\t\\twhile i<j:\\n\\t\\t\\t\\tif s[i] not in vowels and s[j] not in vowels:\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telif s[i] in vowels and s[j] in vowels:\\n\\t\\t\\t\\t\\ts[i], s[j] = s[j], s[i]\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telif s[i] in vowels and s[j] not in vowels:\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\treturn \\'\\'.join(s)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "\\tdef reverseVowels(self, s: str) -> str:\\n\\t\\t\\tvowels = set({\"a\", \"e\", \"i\", \"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"})\\n\\t\\t\\ts = list(s)\\n\\t\\t\\ti,j = 0, len(s) - 1\\n\\t\\t\\twhile i<j:\\n\\t\\t\\t\\tif s[i] not in vowels and s[j] not in vowels:\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telif s[i] in vowels and s[j] in vowels:\\n\\t\\t\\t\\t\\ts[i], s[j] = s[j], s[i]\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telif s[i] in vowels and s[j] not in vowels:\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\treturn \\'\\'.join(s)",
                "codeTag": "Python3"
            },
            {
                "id": 400736,
                "title": "go-golang-two-solutions",
                "content": "```go\\nfunc reverseVowels(s string) string {\\n\\n    tmp := []byte(s)\\n    i := 0\\n    j := len(s)-1\\n    \\n    for i < j {\\n        if !isVowel(s[i]) {\\n            i++\\n            continue\\n        }\\n        if !isVowel(s[j]) {\\n            j--\\n            continue\\n        }\\n        tmp[i], tmp[j] = tmp[j], tmp[i]\\n        i++\\n        j--\\n    }\\n    return string(tmp)\\n}\\n\\nfunc isVowel(c byte) bool {\\n    if c < \\'a\\' { c += 32 }\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n}\\n```\\n\\n```go\\nfunc reverseVowels(s string) string {\\n    tmp := []byte(s)\\n    vowels := map[byte]bool{\\n        \\'a\\':true,\\n        \\'e\\':true,\\n        \\'i\\':true,\\n        \\'o\\':true,\\n        \\'u\\':true,\\n        \\'A\\':true,\\n        \\'E\\':true,\\n        \\'I\\':true,\\n        \\'O\\':true,\\n        \\'U\\':true,\\n    }\\n    for l, r := 0, len(s) - 1; l < r; {\\n        if vowels[tmp[l]] && vowels[tmp[r]] {\\n            tmp[l], tmp[r] = tmp[r], tmp[l]\\n            l++\\n            r--\\n        }\\n        if !vowels[tmp[l]] { l++ }\\n        if !vowels[tmp[r]] { r-- }\\n    }\\n    return string(tmp)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc reverseVowels(s string) string {\\n\\n    tmp := []byte(s)\\n    i := 0\\n    j := len(s)-1\\n    \\n    for i < j {\\n        if !isVowel(s[i]) {\\n            i++\\n            continue\\n        }\\n        if !isVowel(s[j]) {\\n            j--\\n            continue\\n        }\\n        tmp[i], tmp[j] = tmp[j], tmp[i]\\n        i++\\n        j--\\n    }\\n    return string(tmp)\\n}\\n\\nfunc isVowel(c byte) bool {\\n    if c < \\'a\\' { c += 32 }\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n}\\n```\n```go\\nfunc reverseVowels(s string) string {\\n    tmp := []byte(s)\\n    vowels := map[byte]bool{\\n        \\'a\\':true,\\n        \\'e\\':true,\\n        \\'i\\':true,\\n        \\'o\\':true,\\n        \\'u\\':true,\\n        \\'A\\':true,\\n        \\'E\\':true,\\n        \\'I\\':true,\\n        \\'O\\':true,\\n        \\'U\\':true,\\n    }\\n    for l, r := 0, len(s) - 1; l < r; {\\n        if vowels[tmp[l]] && vowels[tmp[r]] {\\n            tmp[l], tmp[r] = tmp[r], tmp[l]\\n            l++\\n            r--\\n        }\\n        if !vowels[tmp[l]] { l++ }\\n        if !vowels[tmp[r]] { r-- }\\n    }\\n    return string(tmp)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389902,
                "title": "python-3-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef reverseVowels(self, s: str) -> str:        \\n\\t\\t\\tvowels = []\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif i in \"aeiouAEIOU\":                \\n\\t\\t\\t\\t\\tvowels.append(i)\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif i in \"aeiouAEIOU\":\\n\\t\\t\\t\\t\\tres += vowels.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres += i\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef reverseVowels(self, s: str) -> str:        \\n\\t\\t\\tvowels = []\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif i in \"aeiouAEIOU\":                \\n\\t\\t\\t\\t\\tvowels.append(i)\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif i in \"aeiouAEIOU\":\\n\\t\\t\\t\\t\\tres += vowels.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres += i\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 81423,
                "title": "12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n    string reverseVowels(string s) {\\n        string s1=s;\\n        int n= s1.length();\\n        int i=0,j=n-1;\\n        while(i<j){\\n            while((!isVovel(s1[i]))&&i<j)i++;\\n            while((!isVovel(s1[j]))&&i<j)j--;\\n            swap(s1[i],s1[j]);\\n            i++;j--;\\n        }\\n        return s1;\\n    }\\n    private:\\n    bool isVovel(char &ch)\\n    {\\n        bool flag=false;\\n        if((ch=='a')||(ch=='e')||(ch=='i')||(ch=='o')||(ch=='u')\\n        ||(ch=='A')||(ch=='E')||(ch=='I')||(ch=='O')||(ch=='U'))\\n            flag = true;\\n        return flag;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    string reverseVowels(string s) {\\n        string s1=s;\\n        int n= s1.length();\\n        int i=0,j=n-1;\\n        while(i<j){\\n            while((!isVovel(s1[i]))&&i<j)i++;\\n            while((!isVovel(s1[j]))&&i<j)j--;\\n            swap(s1[i],s1[j]);\\n            i++;j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3768204,
                "title": "simplest-solution-beats-98",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int n= s.length();\\n        char[] ch = s.toCharArray();\\n        int start = 0;\\n        int end = n-1;\\n        while(start < end) {\\n            if(!isVowel(ch[start])) {\\n                start++;\\n            }\\n            else if(!isVowel(ch[end])) {\\n                end--;\\n            }else {\\n                char t = ch[start];\\n                ch[start] = ch[end];\\n                ch[end] = t;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return new String(ch);\\n    }\\n    public boolean isVowel(char temp) {\\n        if(temp == \\'a\\'|| temp == \\'e\\' || temp == \\'i\\' || temp == \\'o\\' || temp == \\'u\\' || temp == \\'A\\'|| temp == \\'E\\' || temp == \\'I\\' || temp == \\'O\\' || temp == \\'U\\') return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int n= s.length();\\n        char[] ch = s.toCharArray();\\n        int start = 0;\\n        int end = n-1;\\n        while(start < end) {\\n            if(!isVowel(ch[start])) {\\n                start++;\\n            }\\n            else if(!isVowel(ch[end])) {\\n                end--;\\n            }else {\\n                char t = ch[start];\\n                ch[start] = ch[end];\\n                ch[end] = t;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return new String(ch);\\n    }\\n    public boolean isVowel(char temp) {\\n        if(temp == \\'a\\'|| temp == \\'e\\' || temp == \\'i\\' || temp == \\'o\\' || temp == \\'u\\' || temp == \\'A\\'|| temp == \\'E\\' || temp == \\'I\\' || temp == \\'O\\' || temp == \\'U\\') return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565745,
                "title": "simplest-2-pointer",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        v = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s)-1\\n        while l < r:\\n            if s[l] not in v and s[r] not in v:\\n                l+=1\\n                r-=1\\n            elif s[l] not in v:\\n                l+=1\\n            elif s[r] not in v:\\n                r-=1\\n            else:\\n                s[l], s[r] = s[r], s[l]\\n                l+=1\\n                r-=1\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        v = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s)-1\\n        while l < r:\\n            if s[l] not in v and s[r] not in v:\\n                l+=1\\n                r-=1\\n            elif s[l] not in v:\\n                l+=1\\n            elif s[r] not in v:\\n                r-=1\\n            else:\\n                s[l], s[r] = s[r], s[l]\\n                l+=1\\n                r-=1\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123597,
                "title": "beginner-friendly-90-fast-o-n-time-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int> v;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\' || s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')\\n            v.push_back(i);\\n        }\\n        for(int i=0;i<v.size()/2;i++){\\n            swap(s[v[i]],s[v[v.size()-1-i]]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int> v;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\' || s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')\\n            v.push_back(i);\\n        }\\n        for(int i=0;i<v.size()/2;i++){\\n            swap(s[v[i]],s[v[v.size()-1-i]]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778018,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int dict[256] = {0};\\n        dict[\\'a\\'] = 1, dict[\\'A\\'] = 1;\\n        dict[\\'e\\'] = 1, dict[\\'E\\'] = 1;\\n        dict[\\'i\\'] = 1, dict[\\'I\\'] = 1;\\n        dict[\\'o\\'] = 1, dict[\\'O\\'] = 1;\\n        dict[\\'u\\'] = 1, dict[\\'U\\'] = 1;\\n        int start = 0, end = (int)s.size() - 1;\\n        while(start < end){\\n            while(start < end && dict[s[start]] == 0) start++;\\n            while(start < end && dict[s[end]] == 0) end--;\\n            swap(s[start],s[end]);\\n            start++;end--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int dict[256] = {0};\\n        dict[\\'a\\'] = 1, dict[\\'A\\'] = 1;\\n        dict[\\'e\\'] = 1, dict[\\'E\\'] = 1;\\n        dict[\\'i\\'] = 1, dict[\\'I\\'] = 1;\\n        dict[\\'o\\'] = 1, dict[\\'O\\'] = 1;\\n        dict[\\'u\\'] = 1, dict[\\'U\\'] = 1;\\n        int start = 0, end = (int)s.size() - 1;\\n        while(start < end){\\n            while(start < end && dict[s[start]] == 0) start++;\\n            while(start < end && dict[s[end]] == 0) end--;\\n            swap(s[start],s[end]);\\n            start++;end--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777068,
                "title": "java-solution-without-2-pointer",
                "content": "\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        ArrayList<Character> vowels = new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'a\\'||s.charAt(i)==\\'e\\'||s.charAt(i)==\\'i\\'||s.charAt(i)==\\'o\\'||s.charAt(i)==\\'u\\' || s.charAt(i)==\\'A\\' || s.charAt(i)==\\'E\\' || s.charAt(i)==\\'I\\' || s.charAt(i)==\\'O\\' || s.charAt(i)==\\'U\\'){\\n                vowels.add(s.charAt(i));\\n            }\\n        } \\n        // System.out.println(vowels);   \\n        for(int i=0,j=vowels.size()-1;i<s.length();i++){\\n                if(s.charAt(i)==\\'a\\'||s.charAt(i)==\\'e\\'||s.charAt(i)==\\'i\\'||s.charAt(i)==\\'o\\'||s.charAt(i)==\\'u\\' || s.charAt(i)==\\'A\\' || s.charAt(i)==\\'E\\' || s.charAt(i)==\\'I\\' || s.charAt(i)==\\'O\\' || s.charAt(i)==\\'U\\'){\\n                    s=s.substring(0,i)+vowels.get(j)+s.substring(i+1);\\n                    //  System.out.println(s);   \\n                    j--;\\n                 }\\n        }\\n       return s; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        ArrayList<Character> vowels = new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'a\\'||s.charAt(i)==\\'e\\'||s.charAt(i)==\\'i\\'||s.charAt(i)==\\'o\\'||s.charAt(i)==\\'u\\' || s.charAt(i)==\\'A\\' || s.charAt(i)==\\'E\\' || s.charAt(i)==\\'I\\' || s.charAt(i)==\\'O\\' || s.charAt(i)==\\'U\\'){\\n                vowels.add(s.charAt(i));\\n            }\\n        } \\n        // System.out.println(vowels);   \\n        for(int i=0,j=vowels.size()-1;i<s.length();i++){\\n                if(s.charAt(i)==\\'a\\'||s.charAt(i)==\\'e\\'||s.charAt(i)==\\'i\\'||s.charAt(i)==\\'o\\'||s.charAt(i)==\\'u\\' || s.charAt(i)==\\'A\\' || s.charAt(i)==\\'E\\' || s.charAt(i)==\\'I\\' || s.charAt(i)==\\'O\\' || s.charAt(i)==\\'U\\'){\\n                    s=s.substring(0,i)+vowels.get(j)+s.substring(i+1);\\n                    //  System.out.println(s);   \\n                    j--;\\n                 }\\n        }\\n       return s; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776495,
                "title": "c-solution-two-pointer-set",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string str) {\\n        unordered_set<char> s;\\n        s.insert(\\'a\\');\\n        s.insert(\\'e\\');\\n        s.insert(\\'i\\');\\n        s.insert(\\'o\\');\\n        s.insert(\\'u\\');\\n        s.insert(\\'A\\');\\n        s.insert(\\'E\\');\\n        s.insert(\\'I\\');\\n        s.insert(\\'O\\');\\n        s.insert(\\'U\\');\\n\\n        int i=0, j=str.size()-1;\\n\\n        while(i < j) {\\n            if(s.find(str[i]) != s.end() && s.find(str[j]) != s.end()) {\\n                swap(str[i], str[j]);\\n                i++;\\n                j--;\\n            }\\n            else if(s.find(str[i]) != s.end()) {\\n                j--;                \\n            }\\n            else if(s.find(str[j]) != s.end()) {\\n                i++;\\n            }\\n            else {\\n                i++;\\n                j--;\\n            }\\n        }\\n\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string str) {\\n        unordered_set<char> s;\\n        s.insert(\\'a\\');\\n        s.insert(\\'e\\');\\n        s.insert(\\'i\\');\\n        s.insert(\\'o\\');\\n        s.insert(\\'u\\');\\n        s.insert(\\'A\\');\\n        s.insert(\\'E\\');\\n        s.insert(\\'I\\');\\n        s.insert(\\'O\\');\\n        s.insert(\\'U\\');\\n\\n        int i=0, j=str.size()-1;\\n\\n        while(i < j) {\\n            if(s.find(str[i]) != s.end() && s.find(str[j]) != s.end()) {\\n                swap(str[i], str[j]);\\n                i++;\\n                j--;\\n            }\\n            else if(s.find(str[i]) != s.end()) {\\n                j--;                \\n            }\\n            else if(s.find(str[j]) != s.end()) {\\n                i++;\\n            }\\n            else {\\n                i++;\\n                j--;\\n            }\\n        }\\n\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776380,
                "title": "java-o-n-solution-with-explanation-two-pointers",
                "content": "**JAVA SOLUTION USING TWO-POINTERS**\\n\\n*If-else if statements cover up all possible senarios that we may encounter during iteration. We use Two-Pointers i & j to figure out whether its vowel or not and accordingly do the necessary operations. In some cases the ith character may not be included in the character array hence a check for whether the char[i]==\\'\\\\u000\\' is required at the end.*\\n\\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int n=s.length();\\n        char []a =new char[n];\\n        int i=0;int j=n-1;\\n       \\n        if(n==1){return s;}  // if only 1 character present in String\\n      \\n        while(i<j){\\n            int l=Character.getNumericValue(s.charAt(i)); \\n            int r=Character.getNumericValue(s.charAt(j));\\n            \\n            if((l!=10&&l!=14&&l!=18&&l!=24&&l!=30) && (r!=10&&r!=14&&r!=18&&r!=24&&r!=30)){\\n                a[i]=(char)s.charAt(i);\\n                ++i;\\n                 a[j]=(char)s.charAt(j);\\n                --j;\\n                \\n            }\\n              else  if((l==10||l==14||l==18||l==24||l==30) && (r==10||r==14||r==18||r==24||r==30)) {\\n                  a[i]=s.charAt(j);\\n                  a[j]=s.charAt(i);\\n                  ++i;--j;\\n              }\\n           \\n          else  if((l==10||l==14||l==18||l==24||l==30) && (r!=10&&r!=14&&r!=18&&r!=24&&r!=30)){\\n                a[j]=(char)s.charAt(j);\\n                --j;\\n            }\\n          else  if((l!=10&&l!=14&&l!=18&&l!=24&&l!=30) && (r==10||r==14||r==18||r==24||r==30)){\\n                a[i]=(char)s.charAt(i);\\n                ++i;\\n            }\\n        }\\n     \\n         if(a[i]==\\'\\\\u0000\\') //checking if the i-th character is not null(i.e left out)Example i/p:\"axyz\" here i will never increment in above loop hence this check is required!\\n             a[i]=s.charAt(i);       \\n        \\n        return new String(a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int n=s.length();\\n        char []a =new char[n];\\n        int i=0;int j=n-1;\\n       \\n        if(n==1){return s;}  // if only 1 character present in String\\n      \\n        while(i<j){\\n            int l=Character.getNumericValue(s.charAt(i)); \\n            int r=Character.getNumericValue(s.charAt(j));\\n            \\n            if((l!=10&&l!=14&&l!=18&&l!=24&&l!=30) && (r!=10&&r!=14&&r!=18&&r!=24&&r!=30)){\\n                a[i]=(char)s.charAt(i);\\n                ++i;\\n                 a[j]=(char)s.charAt(j);\\n                --j;\\n                \\n            }\\n              else  if((l==10||l==14||l==18||l==24||l==30) && (r==10||r==14||r==18||r==24||r==30)) {\\n                  a[i]=s.charAt(j);\\n                  a[j]=s.charAt(i);\\n                  ++i;--j;\\n              }\\n           \\n          else  if((l==10||l==14||l==18||l==24||l==30) && (r!=10&&r!=14&&r!=18&&r!=24&&r!=30)){\\n                a[j]=(char)s.charAt(j);\\n                --j;\\n            }\\n          else  if((l!=10&&l!=14&&l!=18&&l!=24&&l!=30) && (r==10||r==14||r==18||r==24||r==30)){\\n                a[i]=(char)s.charAt(i);\\n                ++i;\\n            }\\n        }\\n     \\n         if(a[i]==\\'\\\\u0000\\') //checking if the i-th character is not null(i.e left out)Example i/p:\"axyz\" here i will never increment in above loop hence this check is required!\\n             a[i]=s.charAt(i);       \\n        \\n        return new String(a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776118,
                "title": "c-solution-with-explanation",
                "content": "Here is the code with explanations:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n\\n        // we\\'re going to store the positions of the vowels here\\n        vector<int> positions;\\n\\n        // We\\'re using stack as it follows FILO, whoch means the vowels we put in first\\n        // are going to come out of the stack at last, ie. in opposite order\\n        stack<char> vowels;\\n\\n        // vowels list\\n        vector<char> v{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n\\n        for (int i{0}; i<s.length(); ++i) {\\n            for (char x:v) {\\n\\n                // we check if the character is equal to the lowercase vowels or not\\n                // we also check with x-32 as in ascii, subtracting 32 will get you the upper case\\n                // for eg, ascii code for \\'a\\' is 97. 97-32=65 which is ascii code for \\'A\\' and so on\\n                // You might think characters & numbers are supposed to be treated separately, right?\\n                // But we can actually subtract numbers from characters as if we\\'re dealing with their ascii code!\\n                if (x==s[i] || x-32==s[i]) {\\n                    // inserting the positions of vowels in positions list\\n                    positions.push_back(i);\\n                    // vowels being pushed into stack\\n                    vowels.push(s[i]);\\n                }\\n            }\\n        }\\n\\n        for (int x:positions) {\\n            // for the first position in the vector, the last inserted vowel from stack is inserted\\n            // that\\'s because the last thing inserted in stack comes out first! [FILO - First In Last Out]\\n            s[x] = vowels.top();\\n            // Let\\'s remove the topmost element from the stack as it is used up\\n            vowels.pop();\\n        }\\n\\n        return s;        \\n    }\\n};\\n```\\n\\n*If the explanation helped you, please upvote this solution*\\n*Happy coding* :)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n\\n        // we\\'re going to store the positions of the vowels here\\n        vector<int> positions;\\n\\n        // We\\'re using stack as it follows FILO, whoch means the vowels we put in first\\n        // are going to come out of the stack at last, ie. in opposite order\\n        stack<char> vowels;\\n\\n        // vowels list\\n        vector<char> v{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n\\n        for (int i{0}; i<s.length(); ++i) {\\n            for (char x:v) {\\n\\n                // we check if the character is equal to the lowercase vowels or not\\n                // we also check with x-32 as in ascii, subtracting 32 will get you the upper case\\n                // for eg, ascii code for \\'a\\' is 97. 97-32=65 which is ascii code for \\'A\\' and so on\\n                // You might think characters & numbers are supposed to be treated separately, right?\\n                // But we can actually subtract numbers from characters as if we\\'re dealing with their ascii code!\\n                if (x==s[i] || x-32==s[i]) {\\n                    // inserting the positions of vowels in positions list\\n                    positions.push_back(i);\\n                    // vowels being pushed into stack\\n                    vowels.push(s[i]);\\n                }\\n            }\\n        }\\n\\n        for (int x:positions) {\\n            // for the first position in the vector, the last inserted vowel from stack is inserted\\n            // that\\'s because the last thing inserted in stack comes out first! [FILO - First In Last Out]\\n            s[x] = vowels.top();\\n            // Let\\'s remove the topmost element from the stack as it is used up\\n            vowels.pop();\\n        }\\n\\n        return s;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775963,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Two Pointer Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isvowel(char x)\\n    {\\n        if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n            return true;\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n        int start = 0;\\n        int end = s.length()-1;\\n        \\n        while(start<end)\\n        {\\n            if(isvowel(s[start]) and isvowel(s[end]))\\n            {\\n                swap(s[start],s[end]);\\n                start++;\\n                end--;\\n            }\\n            else if(isvowel(s[start]))\\n            {\\n                end--;\\n            }\\n            else\\n                start++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isvowel(char x)\\n    {\\n        if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n            return true;\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n        int start = 0;\\n        int end = s.length()-1;\\n        \\n        while(start<end)\\n        {\\n            if(isvowel(s[start]) and isvowel(s[end]))\\n            {\\n                swap(s[start],s[end]);\\n                start++;\\n                end--;\\n            }\\n            else if(isvowel(s[start]))\\n            {\\n                end--;\\n            }\\n            else\\n                start++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775859,
                "title": "c-two-pointer-easy-and-short",
                "content": "```\\nIf you learned/found something new please upvote \\uD83D\\uDC4D\\n```\\n\\n# Intuition\\nAsking to reverse the vowels in the string. So we will be swapping 1st vowel with last vowel. So will need to keep a look at both front and back side of array. Therefore need two pointers.\\n\\n# Approach\\nCreate two pointers and iterate one pointer from front and one from end. Check if current char is a vowel or not. If a vowel then wait for another pointer to also get a vowel. Else if not a vowel then move to next char.\\n\\nIf both pointers get vowels swap both the chars and move the pointers to respective next position. Here running criteria will be till when end pointer is greater than start pointer.\\n\\n# Complexity\\n- Time complexity:  O(n)\\n\\n- Space complexity:  O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        int str = 0, end = n-1;\\n\\n        map<char,int> vow;\\n        vow[\\'a\\'] = 1, vow[\\'e\\'] = 1, vow[\\'o\\'] = 1, vow[\\'i\\'] = 1, vow[\\'u\\'] = 1;\\n\\n        while(str < end){\\n            if(vow[tolower(s[end])] == 1 && vow[tolower(s[str])] == 1){\\n                swap(s[str], s[end]);\\n                str++;\\n                end--;\\n                continue;\\n            }\\n\\n            if(vow[tolower(s[str])] == 0)\\n                str++;\\n            if(vow[tolower(s[end])] == 0)\\n                end--;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n```\\nIf you learned/found something new please upvote \\uD83D\\uDC4D\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nIf you learned/found something new please upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        int str = 0, end = n-1;\\n\\n        map<char,int> vow;\\n        vow[\\'a\\'] = 1, vow[\\'e\\'] = 1, vow[\\'o\\'] = 1, vow[\\'i\\'] = 1, vow[\\'u\\'] = 1;\\n\\n        while(str < end){\\n            if(vow[tolower(s[end])] == 1 && vow[tolower(s[str])] == 1){\\n                swap(s[str], s[end]);\\n                str++;\\n                end--;\\n                continue;\\n            }\\n\\n            if(vow[tolower(s[str])] == 0)\\n                str++;\\n            if(vow[tolower(s[end])] == 0)\\n                end--;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\n```\\nIf you learned/found something new please upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775520,
                "title": "javascript-linear-loop-fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRun through both the ends of the string, keep finding vowels from both front and back. Stop when you find vowels from both the ends. Pause, swap them and move ahead!!!\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- o(n):\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- o(1):\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst VOWELS = \\'aeiouAEIOU\\';\\nvar reverseVowels = function(s) {\\n    const arr = [...s];\\n\\n    for(let i = 0, j = arr.length - 1; i < j; i++, j--) {\\n        while (!VOWELS.includes(arr[i]) && i < j) {\\n            i++;\\n        }\\n\\n        while (!VOWELS.includes(arr[j]) && i < j) {\\n            j--;\\n        }\\n\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n    }\\n\\n    return arr.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst VOWELS = \\'aeiouAEIOU\\';\\nvar reverseVowels = function(s) {\\n    const arr = [...s];\\n\\n    for(let i = 0, j = arr.length - 1; i < j; i++, j--) {\\n        while (!VOWELS.includes(arr[i]) && i < j) {\\n            i++;\\n        }\\n\\n        while (!VOWELS.includes(arr[j]) && i < j) {\\n            j--;\\n        }\\n\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n    }\\n\\n    return arr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2775428,
                "title": "python-3-8-lines-two-pointer-w-explanation-t-m-96-60",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)                                     # string --> list\\n\\n        l,r, vowels = 0, len(s) - 1, \\'aeiouAEIOU\\'\\n        \\n        while l < r:\\n            while l < r and s[l] not in vowels: l += 1  # Increment each pointer l and r until\\n            while l < r and s[r] not in vowels: r -= 1  # each is pointing at a vowel or l >= r.\\n\\n            s[l], s[r] = s[r], s[l]                     # Swap the pointed vowels and increment\\n            l += 1   ;   r -= 1                         # each pointer.\\n\\n        return \\'\\'.join(s)                               # list --> string\\n```\\n[https://leetcode.com/submissions/detail/613726669/](http://)\\n\\nI think it\\'s *O*(*n*) / *O*(1), but I could be wrong... maybe *O*(*n*) / *O*(*n*).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)                                     # string --> list\\n\\n        l,r, vowels = 0, len(s) - 1, \\'aeiouAEIOU\\'\\n        \\n        while l < r:\\n            while l < r and s[l] not in vowels: l += 1  # Increment each pointer l and r until\\n            while l < r and s[r] not in vowels: r -= 1  # each is pointing at a vowel or l >= r.\\n\\n            s[l], s[r] = s[r], s[l]                     # Swap the pointed vowels and increment\\n            l += 1   ;   r -= 1                         # each pointer.\\n\\n        return \\'\\'.join(s)                               # list --> string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773516,
                "title": "java-solution-two-pointers",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        \\n        List<Character> list=Arrays.asList(\\'a\\', \\'e\\', \\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n\\n        char[] ch=s.toCharArray();\\n\\n        System.out.println(Arrays.toString(ch));\\n        int i=0;\\n        int j=ch.length-1;\\n\\n        while(i<j){\\n\\n            if(list.contains(ch[i]) && list.contains(ch[j])){\\n                char temp=ch[i];\\n                ch[i]=ch[j];\\n                ch[j]=temp;\\n                i++;\\n                j--;\\n            }else if(list.contains(ch[i]) && !list.contains(ch[j])){\\n                j--;\\n            }else if(!list.contains(ch[i]) && list.contains(ch[j])){\\n                i++;\\n            }else if(!list.contains(ch[i]) && !list.contains(ch[j])){\\n                i++;\\n                j--;\\n            }\\n\\n        }\\n\\n        String res=String.valueOf(ch);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        \\n        List<Character> list=Arrays.asList(\\'a\\', \\'e\\', \\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n\\n        char[] ch=s.toCharArray();\\n\\n        System.out.println(Arrays.toString(ch));\\n        int i=0;\\n        int j=ch.length-1;\\n\\n        while(i<j){\\n\\n            if(list.contains(ch[i]) && list.contains(ch[j])){\\n                char temp=ch[i];\\n                ch[i]=ch[j];\\n                ch[j]=temp;\\n                i++;\\n                j--;\\n            }else if(list.contains(ch[i]) && !list.contains(ch[j])){\\n                j--;\\n            }else if(!list.contains(ch[i]) && list.contains(ch[j])){\\n                i++;\\n            }else if(!list.contains(ch[i]) && !list.contains(ch[j])){\\n                i++;\\n                j--;\\n            }\\n\\n        }\\n\\n        String res=String.valueOf(ch);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672130,
                "title": "reverse-vowels-of-string-python-easy-solution",
                "content": "# Easy and Simple Approach:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        def swap(a,b):\\n            s[a],s[b]=s[b],s[a]\\n        vowels=\"aeiouAEIOU\"\\n        l=0\\n        r=len(s)-1\\n        while l<r:\\n            if s[l] in vowels and s[r] in vowels:\\n                swap(l,r)\\n                l+=1\\n                r-=1\\n            elif s[l] in vowels:\\n                r-=1\\n            elif s[r] in vowels:\\n                l+=1\\n            else:\\n                l+=1\\n                r-=1\\n        return \"\".join(s)",
                "solutionTags": [
                    "Python"
                ],
                "code": "# Easy and Simple Approach:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        def swap(a,b):\\n            s[a],s[b]=s[b],s[a]\\n        vowels=\"aeiouAEIOU\"\\n        l=0\\n        r=len(s)-1\\n        while l<r:\\n            if s[l] in vowels and s[r] in vowels:\\n                swap(l,r)\\n                l+=1\\n                r-=1\\n            elif s[l] in vowels:\\n                r-=1\\n            elif s[r] in vowels:\\n                l+=1\\n            else:\\n                l+=1\\n                r-=1\\n        return \"\".join(s)",
                "codeTag": "Python3"
            },
            {
                "id": 2608640,
                "title": "java-2-approaches-easy",
                "content": "### **Please Upvote !!! (\\u25E0\\u203F\\u25E0)**\\n##### 1. Two-pointer approach:\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> set = Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n\\t\\t\\n        int i = 0, j = s.length() - 1;\\n        char[] chars = s.toCharArray();\\n\\n        while (i < j) {\\n            while (i < j && !set.contains(chars[i])) i++;\\n            while (i < j && !set.contains(chars[j])) j--;\\n\\n            // swap\\n            char temp = chars[i];\\n            chars[i++] = chars[j];\\n            chars[j--] = temp;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n##### 2. Using Queue:\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Queue<Character> q = new LinkedList<>();\\n        Set<Character> set = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\');\\n        \\n        for (int i = s.length() - 1; i >= 0; i--){\\n            char c =  Character.toLowerCase(s.charAt(i));\\n            \\n            if (set.contains(c)) {\\n                q.add(s.charAt(i));\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(s);\\n                \\n        for (int i = 0; i < sb.length(); i++){\\n            char c = Character.toLowerCase(sb.charAt(i));\\n            \\n            if (set.contains(c)) {\\n                sb.setCharAt(i, q.poll());\\n            }\\n        }\\n                \\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> set = Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n\\t\\t\\n        int i = 0, j = s.length() - 1;\\n        char[] chars = s.toCharArray();\\n\\n        while (i < j) {\\n            while (i < j && !set.contains(chars[i])) i++;\\n            while (i < j && !set.contains(chars[j])) j--;\\n\\n            // swap\\n            char temp = chars[i];\\n            chars[i++] = chars[j];\\n            chars[j--] = temp;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Queue<Character> q = new LinkedList<>();\\n        Set<Character> set = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\');\\n        \\n        for (int i = s.length() - 1; i >= 0; i--){\\n            char c =  Character.toLowerCase(s.charAt(i));\\n            \\n            if (set.contains(c)) {\\n                q.add(s.charAt(i));\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(s);\\n                \\n        for (int i = 0; i < sb.length(); i++){\\n            char c = Character.toLowerCase(sb.charAt(i));\\n            \\n            if (set.contains(c)) {\\n                sb.setCharAt(i, q.poll());\\n            }\\n        }\\n                \\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447060,
                "title": "javascipt-too-easy-with-two-pointers-100",
                "content": "```\\nconst vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n\\nvar reverseVowels = function(s) {\\n    let output = s.split(\\'\\');\\n    let cursor1 = 0;\\n    let cursor2 = s.length - 1;\\n\\n    while (cursor1 < cursor2) {\\n        if (vowels.includes(s[cursor1].toLowerCase()) && vowels.includes(s[cursor2].toLowerCase())) {\\n            [output[cursor1], output[cursor2]] = [output[cursor2], output[cursor1]];\\n            cursor1++;\\n            cursor2--;\\n        }\\n        if (!vowels.includes(s[cursor1].toLowerCase())) {\\n            cursor1++;\\n        }\\n        if (!vowels.includes(s[cursor2].toLowerCase())) {\\n            cursor2--;\\n        }\\n    }\\n    \\n    return output.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nconst vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n\\nvar reverseVowels = function(s) {\\n    let output = s.split(\\'\\');\\n    let cursor1 = 0;\\n    let cursor2 = s.length - 1;\\n\\n    while (cursor1 < cursor2) {\\n        if (vowels.includes(s[cursor1].toLowerCase()) && vowels.includes(s[cursor2].toLowerCase())) {\\n            [output[cursor1], output[cursor2]] = [output[cursor2], output[cursor1]];\\n            cursor1++;\\n            cursor2--;\\n        }\\n        if (!vowels.includes(s[cursor1].toLowerCase())) {\\n            cursor1++;\\n        }\\n        if (!vowels.includes(s[cursor2].toLowerCase())) {\\n            cursor2--;\\n        }\\n    }\\n    \\n    return output.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1396242,
                "title": "python-two-pointer-solution-with-98-27-speed",
                "content": "```python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set(list(\"aeiouAEIOU\"))\\n        s = list(s)\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            if s[j] not in vowels:\\n                j -=1\\n            elif s[i] not in vowels:\\n                i +=1\\n            else:\\n                s[i], s[j] = s[j], s[i]\\n                i += 1\\n                j -= 1\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set(list(\"aeiouAEIOU\"))\\n        s = list(s)\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            if s[j] not in vowels:\\n                j -=1\\n            elif s[i] not in vowels:\\n                i +=1\\n            else:\\n                s[i], s[j] = s[j], s[i]\\n                i += 1\\n                j -= 1\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229329,
                "title": "java-easy-to-understand-3ms-two-pointers",
                "content": "This approach uses two pointer and inspired by quick sort.\\nPlease upvote if you found helpful.\\n```\\npublic String reverseVowels(String s) \\n{\\n\\tint i = 0 , j = s.length() - 1 ;\\n\\tchar temp ;\\n\\tHashSet<Character> vowels=new HashSet<>();\\n\\tvowels.add(\\'a\\'); vowels.add(\\'A\\');\\n\\tvowels.add(\\'e\\'); vowels.add(\\'E\\');\\n\\tvowels.add(\\'i\\'); vowels.add(\\'I\\');\\n\\tvowels.add(\\'o\\'); vowels.add(\\'O\\');\\n\\tvowels.add(\\'u\\'); vowels.add(\\'U\\');\\n\\tchar[] c = s.toCharArray() ;\\n\\twhile( i < j )\\n\\t{        \\n\\t\\twhile( i < j && !vowels.contains(c[i]))\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\twhile( i < j && !vowels.contains(c[j]))\\n\\t\\t{\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\ttemp = c[i];\\n\\t\\tc[i++] = c[j];\\n\\t\\tc[j--] = temp;\\n\\t}        \\n\\treturn new String(c) ;        \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic String reverseVowels(String s) \\n{\\n\\tint i = 0 , j = s.length() - 1 ;\\n\\tchar temp ;\\n\\tHashSet<Character> vowels=new HashSet<>();\\n\\tvowels.add(\\'a\\'); vowels.add(\\'A\\');\\n\\tvowels.add(\\'e\\'); vowels.add(\\'E\\');\\n\\tvowels.add(\\'i\\'); vowels.add(\\'I\\');\\n\\tvowels.add(\\'o\\'); vowels.add(\\'O\\');\\n\\tvowels.add(\\'u\\'); vowels.add(\\'U\\');\\n\\tchar[] c = s.toCharArray() ;\\n\\twhile( i < j )\\n\\t{        \\n\\t\\twhile( i < j && !vowels.contains(c[i]))\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\twhile( i < j && !vowels.contains(c[j]))\\n\\t\\t{\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\ttemp = c[i];\\n\\t\\tc[i++] = c[j];\\n\\t\\tc[j--] = temp;\\n\\t}        \\n\\treturn new String(c) ;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144933,
                "title": "python-2-pointer-easy-solution-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']\\n        s = list(s)\\n        l, h = 0, len(s) - 1\\n        while l < h:\\n            if s[l] not in vowels: l += 1\\n            elif s[h] not in vowels: h -= 1\\n            else:\\n                s[l], s[h] = s[h], s[l]\\n                l += 1\\n                h -= 1\\n        return \"\".join(s)\\n```\\nFor more such problems: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']\\n        s = list(s)\\n        l, h = 0, len(s) - 1\\n        while l < h:\\n            if s[l] not in vowels: l += 1\\n            elif s[h] not in vowels: h -= 1\\n            else:\\n                s[l], s[h] = s[h], s[l]\\n                l += 1\\n                h -= 1\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112683,
                "title": "java-simple-easy-solution",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char ch[] = s.toCharArray();\\n        String vowels = \"aeiouAEIOU\";\\n        int i=0, j=ch.length-1;\\n        char temp;\\n        \\n        while(i<j){\\n            if(!vowels.contains(ch[i]+\"\")) i++;\\n            else if(!vowels.contains(ch[j]+\"\")) j--;\\n            else{\\n                temp = ch[i];\\n                ch[i] = ch[j];\\n                ch[j] = temp;\\n                \\n                i++; j--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char ch[] = s.toCharArray();\\n        String vowels = \"aeiouAEIOU\";\\n        int i=0, j=ch.length-1;\\n        char temp;\\n        \\n        while(i<j){\\n            if(!vowels.contains(ch[i]+\"\")) i++;\\n            else if(!vowels.contains(ch[j]+\"\")) j--;\\n            else{\\n                temp = ch[i];\\n                ch[i] = ch[j];\\n                ch[j] = temp;\\n                \\n                i++; j--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077031,
                "title": "swift-solution",
                "content": "We\\'ll use two pointers here. One pointing to the first unchanged vowel, the second one to the last one. Everytime both of them are pointing to a vowel we\\'ll swap them. \\n\\n```\\nfunc reverseVowels(_ s: String) -> String {\\n            \\n\\tvar p1 = 0\\n\\tvar p2 = s.count-1\\n\\n\\tlet vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\\n\\n\\tvar chars = Array(s)\\n\\n\\twhile p1 < p2 {\\n\\t\\tif !vowels.contains(chars[p1].lowercased()) { p1+=1;continue }\\n\\t\\tif !vowels.contains(chars[p2].lowercased()) { p2-=1;continue }\\n\\n\\t\\tchars.swapAt(p1, p2)\\n\\t\\tp1+=1;p2-=1\\n\\t}\\n\\treturn String(chars)\\n            \\n }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc reverseVowels(_ s: String) -> String {\\n            \\n\\tvar p1 = 0\\n\\tvar p2 = s.count-1\\n\\n\\tlet vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\\n\\n\\tvar chars = Array(s)\\n\\n\\twhile p1 < p2 {\\n\\t\\tif !vowels.contains(chars[p1].lowercased()) { p1+=1;continue }\\n\\t\\tif !vowels.contains(chars[p2].lowercased()) { p2-=1;continue }\\n\\n\\t\\tchars.swapAt(p1, p2)\\n\\t\\tp1+=1;p2-=1\\n\\t}\\n\\treturn String(chars)\\n            \\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009087,
                "title": "java-easy-to-understand",
                "content": "# Please upvote if helpful\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = arr.length-1;\\n        \\n        while(left <= right) {\\n            if(isVowel(arr[left]) && isVowel(arr[right])) {\\n                swap(arr, left, right);\\n                left++; \\n                right--;\\n            } else if(!isVowel(arr[left])) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n                      \\n        return String.valueOf(arr);\\n    }\\n                      \\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n            c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n\\n    \\n    private void swap(char[] arr, int i, int j) {\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = arr.length-1;\\n        \\n        while(left <= right) {\\n            if(isVowel(arr[left]) && isVowel(arr[right])) {\\n                swap(arr, left, right);\\n                left++; \\n                right--;\\n            } else if(!isVowel(arr[left])) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n                      \\n        return String.valueOf(arr);\\n    }\\n                      \\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n            c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n\\n    \\n    private void swap(char[] arr, int i, int j) {\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997121,
                "title": "python-solution-using-stack",
                "content": "1. In stack store all the vowels\\n2. Append the consonants in result list directly and vowels from stack while iterating over string. \\n \\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        stack = [i for i in s if i in \"aeiouAEIOU\"]\\n        res = []\\n        for i in s:\\n            if(i in \"aeiouAEIOU\"):\\n                res.append(stack.pop())\\n            else:\\n                res.append(i)\\n        return(\"\".join(res))\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        stack = [i for i in s if i in \"aeiouAEIOU\"]\\n        res = []\\n        for i in s:\\n            if(i in \"aeiouAEIOU\"):\\n                res.append(stack.pop())\\n            else:\\n                res.append(i)\\n        return(\"\".join(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972401,
                "title": "python3-standard-two-pointer-with-a-set-data-structure",
                "content": "```\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s = list(s)\\n        left, right = 0, len(s)-1\\n        \\n        while left < right:\\n            if s[left] not in vowels:\\n                left +=1\\n                continue\\n                \\n            elif s[right] not in vowels:\\n                right -=1\\n                continue\\n            else:\\n                s[left],s[right] = s[right],s[left]\\n                left +=1\\n                right -=1\\n        return \"\".join(s)",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "```\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s = list(s)\\n        left, right = 0, len(s)-1\\n        \\n        while left < right:\\n            if s[left] not in vowels:\\n                left +=1\\n                continue\\n                \\n            elif s[right] not in vowels:\\n                right -=1\\n                continue\\n            else:\\n                s[left],s[right] = s[right],s[left]\\n                left +=1\\n                right -=1\\n        return \"\".join(s)",
                "codeTag": "Python3"
            },
            {
                "id": 635819,
                "title": "java-two-pointer",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        \\n        char[] ltrs = s.toCharArray();\\n        \\n        // two pointers\\n        int left = 0, right = s.length() - 1;\\n        while (left < right) {\\n            \\n            boolean leftV = isVowel(s.charAt(left)), rightV = isVowel(s.charAt(right));\\n            \\n            if (leftV && rightV)\\n                swap(ltrs, left, right);\\n            else if (leftV)\\n                left--;\\n            else if (rightV)\\n                right++;\\n            \\n            left++;\\n            right--;\\n        }\\n        \\n        return new String(ltrs);\\n    }\\n    \\n    public void swap(char[] ltrs, int left, int right) {\\n        char tmp = ltrs[left];\\n        ltrs[left] = ltrs[right];\\n        ltrs[right] = tmp;\\n    } \\n    \\n    public boolean isVowel(char c) {\\n        char[] vowels = new char[]{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n        \\n        for (char vow : vowels)\\n            if (c == vow)\\n                return true;\\n        \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        char[] ltrs = s.toCharArray();\\n        \\n        // two pointers\\n        int left = 0, right = s.length() - 1;\\n        while (left < right) {\\n            \\n            boolean leftV = isVowel(s.charAt(left)), rightV = isVowel(s.charAt(right));\\n            \\n            if (leftV && rightV)\\n                swap(ltrs, left, right);\\n            else if (leftV)\\n                left--;\\n            else if (rightV)\\n                right++;\\n            \\n            left++;\\n            right--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 574697,
                "title": "java-o-n-simple-with-explaination-faster-85-lighter-80",
                "content": "If the string is smaller than size 2, no need to swap in any case.\\nAdd constant number of characters to a set to avoid checking ten times in an OR condition string.\\nConvert string to char array for easier faster access.\\nLoop with two pointers, and when both of them have found vowels, and they haven\\'t crossed each other, swap.\\nExit the loop when the pointers meet because any swap after that is just reversing our work so far.\\nconvert char array to string and return.\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        if(s == null || s.length() < 2) return s;\\n        char[] ch = s.toCharArray();\\n        int left = 0;\\n        int right = ch.length-1;\\n        Set<Character> vowels = new HashSet<>();\\n        vowels.add(\\'a\\');\\n        vowels.add(\\'e\\');\\n        vowels.add(\\'i\\');\\n        vowels.add(\\'o\\');\\n        vowels.add(\\'u\\');\\n        vowels.add(\\'A\\');\\n        vowels.add(\\'E\\');\\n        vowels.add(\\'I\\');\\n        vowels.add(\\'O\\');\\n        vowels.add(\\'U\\');\\n        \\n        while(left < right){\\n            if(!vowels.contains(ch[left])) left++;\\n            else if(!vowels.contains(ch[right])) right--;\\n            else{ //(left < right){\\n                char temp = ch[left];\\n                ch[left] = ch[right];\\n                ch[right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        if(s == null || s.length() < 2) return s;\\n        char[] ch = s.toCharArray();\\n        int left = 0;\\n        int right = ch.length-1;\\n        Set<Character> vowels = new HashSet<>();\\n        vowels.add(\\'a\\');\\n        vowels.add(\\'e\\');\\n        vowels.add(\\'i\\');\\n        vowels.add(\\'o\\');\\n        vowels.add(\\'u\\');\\n        vowels.add(\\'A\\');\\n        vowels.add(\\'E\\');\\n        vowels.add(\\'I\\');\\n        vowels.add(\\'O\\');\\n        vowels.add(\\'U\\');\\n        \\n        while(left < right){\\n            if(!vowels.contains(ch[left])) left++;\\n            else if(!vowels.contains(ch[right])) right--;\\n            else{ //(left < right){\\n                char temp = ch[left];\\n                ch[left] = ch[right];\\n                ch[right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551222,
                "title": "python-3-simple-re-solution-beats-92-77",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = re.findall(\\'(?i)[aeiou]\\', s)\\n        return re.sub(\\'(?i)[aeiou]\\', lambda x:vowels.pop(), s)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = re.findall(\\'(?i)[aeiou]\\', s)\\n        return re.sub(\\'(?i)[aeiou]\\', lambda x:vowels.pop(), s)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516532,
                "title": "several-python-sol-sharing-80-with-hint-and-explanation",
                "content": "---\\n\\nMethod_#1\\nBy *two-pointers*\\n\\nMethod_#2\\nBy self-made *generator*\\n\\nMethod_#3\\nBy *stack* and two-pass *linear scan*\\n\\n---\\n\\n**Hint**:\\n\\nFor Method_#1, by two-potiners.\\n\\nThink of **two-pointers** algorithm framework.\\n\\nRemember that [**python string** is **immutable**](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str)( swap character is not allowed), but [**python list** is **mutable**](https://docs.python.org/3/library/stdtypes.html#list) (support  swap element). \\nThus, we need a python list for swap operation\\n\\nLet *i*, *j* denote two pointers we use,\\n*i* traverse from head to tail (i.e., left to right), while *j* traverse from tail to head (i.e., right to left).\\n\\n**Swap list_str[i]** and **list_str[j]** if **vowel is met**\\n\\nFinally convert list_str back to python string by [\"\".join( list_str )](https://docs.python.org/3/library/stdtypes.html?highlight=join%20str#str.join).\\n\\n---\\n**Implementation**:\\nMethod_#1, by two-potiners.\\n\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        \\n\\t\\tnew_s = list(s)                 # use python list as buffer for element swap\\n        last_index = len(s)-1\\n        left, right = 0, last_index     # initialization for two pointers\\n        \\n        while left <= right:\\n            \\n            while left <= right and s[left] not in vowel: left +=1\\n            while left <= right and s[right] not in vowel: right -=1\\n            \\n            if left > right:\\n                break\\n            \\n\\t\\t\\t# swap vowel\\n            new_s[ left ], new_s[ right ] = new_s[ right ], new_s[ left ]\\n            \\n            left, right = left+1, right-1\\n            \\n        return \\'\\'.join(new_s)\\n```\\n\\n---\\n\\n**Hint**:\\nFor Method_#2, by self-made *generator*.\\n\\nThink of [yield statement and generator](https://docs.python.org/3/reference/expressions.html?highlight=yield#yield-expressions).\\n\\nIamgine the generator as a machine scan from the tail to head, and output a vowel once it is met.\\n\\n---\\n**Implementation**:\\nMethod_#2, by self-made generator.\\n\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        new_s = \\'\\'\\n        \\n        def rev_vowel( s:str):\\n\\t\\t\\n            # Support function to collect vowel in reverse direction\\n\\t\\t\\t\\n            for char in reversed(s):\\n                if char in vowel:\\n                    yield char\\n        \\n        vowel_gen = rev_vowel(s)\\n        # Generate string with reversed vowels\\n        for char in s:\\n            \\n            if char in vowel:\\n                new_s += next( vowel_gen )\\n            else:\\n                new_s += char\\n                \\n        return new_s\\n```\\n\\n---\\n\\n**Hint**:\\nFor Method_#3, by *stack* and two-pass *linear scan*.\\n\\nThink of [**stack** and **Last-in First out** (aka LIFO)](https://docs.python.org/3/tutorial/datastructures.html?highlight=stack#using-lists-as-stacks) property\\n\\nUse first-pass linear scan to **store vowels in stack**.\\n\\nThen, in secon-pass, once we met a vowel in original string, pop a character from stack, which yields the vowel with reversed order, based on last-in first out property of stack.\\n\\n---\\n\\n**Implementation**:\\nMethod_#3, by stack and two-pass linear scan.\\n\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        new_s = \\'\\'\\n        v_stack = []\\n        \\n        size = len(s)-1\\n        \\n        # Step_#1:\\n        # Collect vowels in stack\\n        for char in s:\\n            \\n            if char in vowel:\\n                v_stack.append( char )\\n                \\n        # Step_#2:\\n        # Generate string with reversed vowels\\n        for char in s:\\n            \\n            if char in vowel:\\n                new_s += v_stack.pop()\\n            else:\\n                new_s += char\\n                \\n        return new_s\\n```\\n\\n---",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        \\n\\t\\tnew_s = list(s)                 # use python list as buffer for element swap\\n        last_index = len(s)-1\\n        left, right = 0, last_index     # initialization for two pointers\\n        \\n        while left <= right:\\n            \\n            while left <= right and s[left] not in vowel: left +=1\\n            while left <= right and s[right] not in vowel: right -=1\\n            \\n            if left > right:\\n                break\\n            \\n\\t\\t\\t# swap vowel\\n            new_s[ left ], new_s[ right ] = new_s[ right ], new_s[ left ]\\n            \\n            left, right = left+1, right-1\\n            \\n        return \\'\\'.join(new_s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        new_s = \\'\\'\\n        \\n        def rev_vowel( s:str):\\n\\t\\t\\n            # Support function to collect vowel in reverse direction\\n\\t\\t\\t\\n            for char in reversed(s):\\n                if char in vowel:\\n                    yield char\\n        \\n        vowel_gen = rev_vowel(s)\\n        # Generate string with reversed vowels\\n        for char in s:\\n            \\n            if char in vowel:\\n                new_s += next( vowel_gen )\\n            else:\\n                new_s += char\\n                \\n        return new_s\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        new_s = \\'\\'\\n        v_stack = []\\n        \\n        size = len(s)-1\\n        \\n        # Step_#1:\\n        # Collect vowels in stack\\n        for char in s:\\n            \\n            if char in vowel:\\n                v_stack.append( char )\\n                \\n        # Step_#2:\\n        # Generate string with reversed vowels\\n        for char in s:\\n            \\n            if char in vowel:\\n                new_s += v_stack.pop()\\n            else:\\n                new_s += char\\n                \\n        return new_s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81382,
                "title": "python-solution",
                "content": "    class Solution(object):\\n        def reverseVowels(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            vowels='aeiouAEIOU'\\n            vpos=[i for i,j in enumerate(s) if j in vowels]\\n            svrev=list(s)\\n            i,j=0,len(vpos)-1\\n            while i<j:\\n                svrev[vpos[i]],svrev[vpos[j]]=svrev[vpos[j]],svrev[vpos[i]]\\n                i+=1\\n                j-=1\\n            return ''.join(svrev)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def reverseVowels(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            vowels='aeiouAEIOU'\\n            vpos=[i for i,j in enumerate(s) if j in vowels]\\n            svrev=list(s)\\n            i,j=0,len(vpos)-1\\n            while i<j:\\n                svrev[vpos[i]],svrev[vpos[j]]=svrev[vpos[j]],svrev[vpos[i]]\\n                i+=1\\n                j-=1\\n            return ''.join(svrev)",
                "codeTag": "Java"
            },
            {
                "id": 81405,
                "title": "my-12ms-c-simple-solution",
                "content": "    class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            if (s.length() < 2) return s;\\n\\t    string vowels=\"aeiouAEIOU\";\\n            int i = 0, j = s.length()-1;\\n\\n            while (i < j)\\n            {\\n                while (vowels.find(s[i])==string::npos && i<j) i++;\\n                while (vowels.find(s[j])==string::npos && i<j) j--;\\n                swap(s[i++],s[j--]);\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            if (s.length() < 2) return s;\\n\\t    string vowels=\"aeiouAEIOU\";\\n            int i = 0, j = s.length()-1;\\n\\n            while (i < j)\\n            {\\n                while (vowels.find(s[i])==string::npos && i<j) i++;\\n                while (vowels.find(s[j])==string::npos && i<j) j--;\\n                swap(s[i++],s[j--]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 81413,
                "title": "my-clear-cpp-solution",
                "content": "    class Solution {\\n    public:\\n        bool isVowel(char c)\\n        {\\n            return c=='a' || c=='e' || c=='i' || c=='o' || c=='u'\\n                || c=='A' || c=='E' || c=='I' || c=='O' || c=='U';\\n        }\\n    \\n        string reverseVowels(string s) \\n        {\\n            int i=0, j=s.size()-1;\\n            while(1)\\n            {\\n                while(i < j && !isVowel(s[i]))\\n                    i++;\\n                while(i < j && !isVowel(s[j]))\\n                    j--;\\n                \\n                if(i >= j) break;\\n                \\n                std::swap(s[i++], s[j--]);\\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isVowel(char c)\\n        {\\n            return c=='a' || c=='e' || c=='i' || c=='o' || c=='u'\\n                || c=='A' || c=='E' || c=='I' || c=='O' || c=='U';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 81450,
                "title": "clean-c-solution",
                "content": "    class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\\n            int i = 0, j = s.length() - 1;\\n            while (i < j) {\\n                if (!vowels.count(s[i]))\\n                    ++i;\\n                else if (!vowels.count(s[j]))\\n                    --j;\\n                else\\n                    swap(s[i++], s[j--]);\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
                "codeTag": "Java"
            },
            {
                "id": 81470,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    \\tbool isVowel (char c) {\\n    \\t\\treturn (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \\n    \\t\\t        c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\\n    \\t}\\n    \\n    \\tstring reverseVowels (string s) {\\n    \\t\\tif (s.size() <= 1) return s;\\n    \\t\\tint i = 0, j = s.size() - 1;\\n    \\t\\twhile (i < j) {\\n    \\t\\t\\tif (isVowel(s[i]) && isVowel(s[j]))\\n    \\t\\t\\t\\tswap(s[i++], s[j--]);\\n    \\t\\t\\telse {\\n    \\t\\t\\t\\tif (!isVowel(s[i])) ++i;\\n    \\t\\t\\t\\tif (!isVowel(s[j])) --j;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn s;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tbool isVowel (char c) {\\n    \\t\\treturn (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \\n    \\t\\t        c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 4048699,
                "title": "easy-c-solution-with-two-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We should just care about the pairs from left of the string and the right of the string which are vowel characters. As an example for the second input:\\nleetcode =>  \\n1. left vowel is \\'e\\' right vowel is \\'e\\' swap them. result --> leetcode\\n2. left vowel is \\'e\\' right vowel is \\'o\\' swap them. result --> leotcede\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Approach is simply using two pointers for left index and write index while the left index is smaller than the right index. When a vowel encountered ,say, at left index, we should not increment the left index until we find a pair for that character at right index. Finally, if we find a pair of vowels, we swap them and continue the process.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), n is the length of the string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), we just store the vowels and constant variables.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int size = s.length();\\n        int left = 0;\\n        int right = size - 1;\\n        set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n        bool left_found, right_found;\\n        left_found = false;\\n        right_found = false;\\n\\n        while(left < right){\\n            if(vowels.find(s[left]) != vowels.end()){\\n                left_found = true;\\n            }\\n            if(vowels.find(s[right]) != vowels.end()){\\n                right_found = true;\\n            }\\n            if(left_found && right_found){\\n                char temp = s[right];\\n                s[right] = s[left];\\n                s[left] = temp;\\n                left_found = false;\\n                right_found = false;\\n            }\\n            if(!left_found){\\n                left++;\\n            }\\n            if(!right_found){\\n                right--;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int size = s.length();\\n        int left = 0;\\n        int right = size - 1;\\n        set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n        bool left_found, right_found;\\n        left_found = false;\\n        right_found = false;\\n\\n        while(left < right){\\n            if(vowels.find(s[left]) != vowels.end()){\\n                left_found = true;\\n            }\\n            if(vowels.find(s[right]) != vowels.end()){\\n                right_found = true;\\n            }\\n            if(left_found && right_found){\\n                char temp = s[right];\\n                s[right] = s[left];\\n                s[left] = temp;\\n                left_found = false;\\n                right_found = false;\\n            }\\n            if(!left_found){\\n                left++;\\n            }\\n            if(!right_found){\\n                right--;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048447,
                "title": "day-28-reverse-vowels-of-a-string-java-solution",
                "content": "# Approach\\n1. Firstly I created an HashSet containing all the lower and upper case vowels.\\n2. As I used two pointer technique and Strings are immutable in Java so here I converted the String s to an array.\\n3. Initialized left and right pointers with `left = 0;` and `right = s.length() - 1;`\\n4. Simply traverse through the char array and while left and right both pointers are pointing at a vowel swap them and increment left and decrement right.\\n5. Coming to the last step, as in the question it is clearly mentioned that we have to return String s, `return s=String.valueOf(characters);` this line converts the array to string, and returns it.\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\n    O(n) \\uD83D\\uDD50\\n\\n- Space complexity:\\n    O(n) \\uD83D\\uDD24\\n\\n---\\n# Request\\n>     If you find this post helpful, please up-vote.\\uD83D\\uDE4F\\uD83C\\uDFFC\\uD83D\\uDE4F\\uD83C\\uDFFC\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> vowels = new HashSet<>();\\n\\t\\tvowels.add(\\'A\\');\\n\\t\\tvowels.add(\\'a\\');\\n\\t\\tvowels.add(\\'E\\');\\n\\t\\tvowels.add(\\'e\\');\\n\\t\\tvowels.add(\\'I\\');\\n\\t\\tvowels.add(\\'i\\');\\n\\t\\tvowels.add(\\'O\\');\\n\\t\\tvowels.add(\\'o\\');\\n\\t\\tvowels.add(\\'U\\');\\n\\t\\tvowels.add(\\'u\\');\\n\\t\\t\\n\\t\\tchar[] characters = s.toCharArray();\\n\\t\\t\\n\\t\\tint left=0, right=s.length()-1;\\n\\t\\t\\n\\t\\twhile(left<right){\\n\\t\\t\\tif(vowels.contains(characters[left]))\\n\\t\\t\\t\\tif(vowels.contains(characters[right])){\\n\\t\\t\\t\\t\\tcharacters[left] = (char)(characters[left] + characters[right] - (characters[right] = characters[left]));\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft++;\\n\\t\\t}\\n\\t\\treturn s=String.valueOf(characters);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> vowels = new HashSet<>();\\n\\t\\tvowels.add(\\'A\\');\\n\\t\\tvowels.add(\\'a\\');\\n\\t\\tvowels.add(\\'E\\');\\n\\t\\tvowels.add(\\'e\\');\\n\\t\\tvowels.add(\\'I\\');\\n\\t\\tvowels.add(\\'i\\');\\n\\t\\tvowels.add(\\'O\\');\\n\\t\\tvowels.add(\\'o\\');\\n\\t\\tvowels.add(\\'U\\');\\n\\t\\tvowels.add(\\'u\\');\\n\\t\\t\\n\\t\\tchar[] characters = s.toCharArray();\\n\\t\\t\\n\\t\\tint left=0, right=s.length()-1;\\n\\t\\t\\n\\t\\twhile(left<right){\\n\\t\\t\\tif(vowels.contains(characters[left]))\\n\\t\\t\\t\\tif(vowels.contains(characters[right])){\\n\\t\\t\\t\\t\\tcharacters[left] = (char)(characters[left] + characters[right] - (characters[right] = characters[left]));\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft++;\\n\\t\\t}\\n\\t\\treturn s=String.valueOf(characters);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030591,
                "title": "reverse-vowels-of-string-java-solution-video-available",
                "content": "# if any doubt in solution and you neeed a detailed explaination and soution Watch this video :-\\nhttps://youtu.be/491jQJcmTrY?si=fZeZRMENqPpTD_f3\\n\\n# Problem :-\\nGiven a string s, reverse only all the vowels in the string and return it.\\nThe vowels are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\', and they can appear in both lower and upper cases, more than once.\\n\\nExample :\\nInput: s = \"hello\"\\nOutput: \"holle\"\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Two pointer aproach is used.\\n- keep one pointer on first index and one on last index .\\n- until both of them points on vowels keep moving them towards each other. \\n- if both points on vowel , swap them .\\n- keep moving pointers towards each other till firt index is smaller than last index .\\n\\n\\n# Time complexity :-\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int lengthOfString = s.length();\\n        char ch[] = s.toCharArray();\\n        int start = 0;\\n        int end = lengthOfString - 1;\\n        while(start < end) {\\n            if(!isVowel(ch[start])) {\\n                start++;\\n            }\\n            else if(!isVowel(ch[end])) {\\n                end--;\\n            }\\n            else {\\n                char temp = ch[start];\\n                ch[start] = ch[end];\\n                ch[end] = temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n        \\n    }\\n     public static boolean isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' || ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\') {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int lengthOfString = s.length();\\n        char ch[] = s.toCharArray();\\n        int start = 0;\\n        int end = lengthOfString - 1;\\n        while(start < end) {\\n            if(!isVowel(ch[start])) {\\n                start++;\\n            }\\n            else if(!isVowel(ch[end])) {\\n                end--;\\n            }\\n            else {\\n                char temp = ch[start];\\n                ch[start] = ch[end];\\n                ch[end] = temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n        \\n    }\\n     public static boolean isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' || ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\') {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960373,
                "title": "python3-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo swap the positions, need to save the position and reverse the position list\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nval stores the value at the index and pos stores the position, next only one of the two lists is reversed. Next reconstruct the string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAssume len(s) = n and len(val) = m\\nthen time complexity:\\n$$O(n+m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIDK\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        v = [\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        val = []\\n        pos = []\\n        for i in range(len(s)):\\n            if s[i].lower() in v:\\n                val.append(s[i])\\n                pos.append(i)\\n        val = val[::-1]\\n        for i in range(len(pos)):\\n            s[pos[i]] = val[i] \\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        v = [\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        val = []\\n        pos = []\\n        for i in range(len(s)):\\n            if s[i].lower() in v:\\n                val.append(s[i])\\n                pos.append(i)\\n        val = val[::-1]\\n        for i in range(len(pos)):\\n            s[pos[i]] = val[i] \\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958594,
                "title": "o-n-beginner-friendly-100-beats-fully-explained",
                "content": "# Approach\\n\\n**Problem Statement:**\\nGiven a string `s`, you need to reverse the order of only the vowels in the string and return the modified string.\\n\\n**Approach:**\\nTo solve this problem, we can use a two-pointer approach. We\\'ll maintain two pointers, one starting from the beginning of the string (`left`) and the other starting from the end of the string (`right`). We\\'ll move these pointers towards each other, swapping the vowels they point to until they meet in the middle.\\n\\n**Logic:**\\n1. Convert the input string `s` into a character array to make it mutable (`char[] arr = s.toCharArray();`).\\n\\n2. Initialize two pointers: `left = 0` (starting from the beginning of the array) and `right = arr.length - 1` (starting from the end of the array).\\n\\n3. Iterate while `left` is less than `right`:\\n   - Check if the character at index `left` is a vowel using the `isVowel` function.\\n     - If it\\'s a vowel, move the `right` pointer towards the left until a vowel is found using the inner `while` loop.\\n     - Swap the vowels at index `left` and index `right` using the `swap` function.\\n     - Move the `right` pointer one step to the left (`right--`).\\n   - Move the `left` pointer one step to the right (`left++`).\\n\\n4. After the loop completes, the character array `arr` will have the vowels reversed in the string.\\n\\n5. Convert the character array `arr` back to a string using `new String(arr)` and return the modified string.\\n\\n**Vowel Check (isVowel function):**\\nThe `isVowel` function checks whether a given character is a vowel (either lowercase or uppercase) using a simple condition that compares the character against a list of vowel characters.\\n\\n**Swap Function:**\\nThe `swap` function swaps two characters in the character array `arr` using a temporary variable to hold one of the characters while swapping.\\n\\n**Time Complexity:**\\nThe time complexity of this approach is O(n), where n is the length of the input string. The two pointers traverse the string once, and for each character, we either move the `right` pointer leftward or swap two characters, both of which are constant time operations.\\n\\n**Space Complexity:**\\nThe space complexity is O(n) due to the character array `arr` and the constant space used by the `left` and `right` pointers.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int left = 0;\\n        int right = arr.length - 1;\\n\\n        while(left < right) {\\n            if(isVowel(arr[left])) {\\n                while(left < right && !isVowel(arr[right])) {\\n                    right--;\\n                }\\n                if(isVowel(arr[right])) {\\n                    swap(arr, left, right);\\n                    right--;\\n                }\\n            }\\n            left++;\\n        }\\n\\n        return new String(arr);\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n            c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n\\n    private void swap(char[] arr, int left, int right) {\\n        char temp = arr[left];\\n        arr[left] = arr[right];\\n        arr[right] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int left = 0;\\n        int right = arr.length - 1;\\n\\n        while(left < right) {\\n            if(isVowel(arr[left])) {\\n                while(left < right && !isVowel(arr[right])) {\\n                    right--;\\n                }\\n                if(isVowel(arr[right])) {\\n                    swap(arr, left, right);\\n                    right--;\\n                }\\n            }\\n            left++;\\n        }\\n\\n        return new String(arr);\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n            c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n\\n    private void swap(char[] arr, int left, int right) {\\n        char temp = arr[left];\\n        arr[left] = arr[right];\\n        arr[right] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948582,
                "title": "just-2-checks-simplified-one",
                "content": "# Approach\\n*Step-1 -> Convert given string to char array and intialize start = 0 and end = array.length-1 (last element of char array)\\nStep-2 -> Need a helper method to check whether char is vowel or not.\\nStep-3 -> Loop until start less than end\\n    - check if char at start is not vowel if so start++ , \\n    - check if char at end is not vowel if so end-- , \\n    - if both are vowels time to swap them and move start++ and end--\\nStep-4 -> Just return char array in string form using valueOf()*\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int start = 0;\\n        int end = arr.length-1;\\n        while(start < end){\\n            if(!isVowel(arr[start])){\\n                start++;\\n            }else if(!isVowel(arr[end])){\\n                end--;\\n            }else{\\n                char temp = arr[start];\\n                arr[start] = arr[end];\\n                arr[end] = temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(arr);\\n    }\\n    boolean isVowel(char ch){\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n        ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int start = 0;\\n        int end = arr.length-1;\\n        while(start < end){\\n            if(!isVowel(arr[start])){\\n                start++;\\n            }else if(!isVowel(arr[end])){\\n                end--;\\n            }else{\\n                char temp = arr[start];\\n                arr[start] = arr[end];\\n                arr[end] = temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(arr);\\n    }\\n    boolean isVowel(char ch){\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n        ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948578,
                "title": "2-pointer-easy-approach-with-easy-explanation",
                "content": "# Approach\\n1) First we have to convert the string in to char array(toCharArray)\\n2) With the help of two pointer approach we declare start and end variables and we do this problem.\\n3) If the first character is not the vowel means move the start pointer to forward i.e., start++\\n4) Similarly if the end character is not vowel means move the end pointer to backward i.e., end--\\n5) Finally if we found the vowel means swap the characters and make start++ and end--\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] ch=s.toCharArray();\\n        int start=0;\\n        int end=ch.length-1;\\n        while(start<end){\\n            if(!isVowels(ch[start])){\\n                start++;\\n            }\\n            else if(!isVowels(ch[end])){\\n                end--;\\n            }\\n            else{\\n                char temp=ch[start];\\n                ch[start]=ch[end];\\n                ch[end]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n    public boolean isVowels(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\' ||ch==\\'A\\' ||     ch==\\'E\\' ||  ch==\\'I\\' ||ch==\\'O\\' ||ch==\\'U\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] ch=s.toCharArray();\\n        int start=0;\\n        int end=ch.length-1;\\n        while(start<end){\\n            if(!isVowels(ch[start])){\\n                start++;\\n            }\\n            else if(!isVowels(ch[end])){\\n                end--;\\n            }\\n            else{\\n                char temp=ch[start];\\n                ch[start]=ch[end];\\n                ch[end]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n    public boolean isVowels(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\' ||ch==\\'A\\' ||     ch==\\'E\\' ||  ch==\\'I\\' ||ch==\\'O\\' ||ch==\\'U\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762681,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointers easy\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvowel(char ch){\\n        ch=tolower(ch);\\n        return ch==\\'a\\' || ch==\\'e\\' || ch==\\'o\\' || ch==\\'i\\' || ch==\\'u\\';\\n    }\\n    string reverseVowels(string s) {\\n        int n=s.length();\\n        int i=0;\\n        int j=n-1;\\n        while(i<j){\\n            if(!isvowel(s[i])) i++;\\n            else if(!isvowel(s[j])) j--;\\n            else if(i<j){\\n                swap(s[i],s[j]);\\n                i++;\\n                j--;\\n            }\\n             \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvowel(char ch){\\n        ch=tolower(ch);\\n        return ch==\\'a\\' || ch==\\'e\\' || ch==\\'o\\' || ch==\\'i\\' || ch==\\'u\\';\\n    }\\n    string reverseVowels(string s) {\\n        int n=s.length();\\n        int i=0;\\n        int j=n-1;\\n        while(i<j){\\n            if(!isvowel(s[i])) i++;\\n            else if(!isvowel(s[j])) j--;\\n            else if(i<j){\\n                swap(s[i],s[j]);\\n                i++;\\n                j--;\\n            }\\n             \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762507,
                "title": "two-approach-beat-100-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) brute force\\n2) Two Pointer \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointer:\\n1) Take two variable p1 and p2;\\n2) On each iteration p1 will increament and p2 will decreament\\n3) check weather the they vowel or not if yes swap that value\\n4) return the same string \\n\\nmy Bruteforce code you also help you  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code Two pointer Approach\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char a){\\n        if(a==\\'a\\' || a == \\'A\\' || a == \\'E\\' || a == \\'e\\' ||a==\\'i\\' || a == \\'I\\' || a == \\'o\\' || a == \\'O\\' ||a==\\'U\\' || a == \\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        int p1 = 0;\\n        int p2 = n-1;\\n\\n        while(p1<=p2){\\n            if(isVowel(s[p1]) && isVowel(s[p2])){\\n                swap(s[p1], s[p2]);\\n                p1++;\\n                p2--;\\n            }\\n            else if(isVowel(s[p1])){\\n                p2--;\\n\\n            }\\n            else if(isVowel(s[p2])){\\n                p1++;\\n            }\\n            else{\\n                p2--;\\n                p1++;\\n            }\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```\\n# BruteForce Approach\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        vector<char>v;\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i] == \\'a\\' || s[i] ==\\'A\\' || s[i] == \\'E\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i] == \\'I\\' || s[i] == \\'o\\' || s[i] == \\'O\\' || s[i] == \\'u\\' || s[i] == \\'U\\'){\\n                v.push_back(s[i]);\\n            }\\n        }\\n        int m = v.size();\\n        reverse(v.begin(), v.end());\\n        int k = 0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'a\\' || s[i] ==\\'A\\' || s[i] == \\'E\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i] == \\'I\\' || s[i] == \\'o\\' || s[i] == \\'O\\' || s[i] == \\'u\\' || s[i] == \\'U\\'){\\n                s[i] = v[k];\\n                k++;\\n            }\\n\\n        }\\n\\n        return s;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char a){\\n        if(a==\\'a\\' || a == \\'A\\' || a == \\'E\\' || a == \\'e\\' ||a==\\'i\\' || a == \\'I\\' || a == \\'o\\' || a == \\'O\\' ||a==\\'U\\' || a == \\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        int p1 = 0;\\n        int p2 = n-1;\\n\\n        while(p1<=p2){\\n            if(isVowel(s[p1]) && isVowel(s[p2])){\\n                swap(s[p1], s[p2]);\\n                p1++;\\n                p2--;\\n            }\\n            else if(isVowel(s[p1])){\\n                p2--;\\n\\n            }\\n            else if(isVowel(s[p2])){\\n                p1++;\\n            }\\n            else{\\n                p2--;\\n                p1++;\\n            }\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        vector<char>v;\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i] == \\'a\\' || s[i] ==\\'A\\' || s[i] == \\'E\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i] == \\'I\\' || s[i] == \\'o\\' || s[i] == \\'O\\' || s[i] == \\'u\\' || s[i] == \\'U\\'){\\n                v.push_back(s[i]);\\n            }\\n        }\\n        int m = v.size();\\n        reverse(v.begin(), v.end());\\n        int k = 0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'a\\' || s[i] ==\\'A\\' || s[i] == \\'E\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i] == \\'I\\' || s[i] == \\'o\\' || s[i] == \\'O\\' || s[i] == \\'u\\' || s[i] == \\'U\\'){\\n                s[i] = v[k];\\n                k++;\\n            }\\n\\n        }\\n\\n        return s;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665019,
                "title": "dart-replace-reversed-vowels-list",
                "content": "# Approach\\nReverse the vowels in the sentence and later replace them in the base sentance.\\n\\n\\n# Code\\n```\\nclass Solution {\\n  String reverseVowels(String s) {\\n    String vowels = \\'aeiouAEIOU\\';\\n    List<String> sVowels =\\n        s.split(\\'\\').reversed.where((char) => vowels.contains(char)).toList();\\n\\n    List<String> newS =\\n        s.split(\\'\\').map((char) => vowels.contains(char) ? \\'_\\' : char).toList();\\n\\n    for (int i = 0, j = 0; i < newS.length; i++) {\\n      if (newS[i] == \\'_\\') {\\n        newS[i] = sVowels[j];\\n        j++;\\n      }\\n    }\\n\\n    return newS.join();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String reverseVowels(String s) {\\n    String vowels = \\'aeiouAEIOU\\';\\n    List<String> sVowels =\\n        s.split(\\'\\').reversed.where((char) => vowels.contains(char)).toList();\\n\\n    List<String> newS =\\n        s.split(\\'\\').map((char) => vowels.contains(char) ? \\'_\\' : char).toList();\\n\\n    for (int i = 0, j = 0; i < newS.length; i++) {\\n      if (newS[i] == \\'_\\') {\\n        newS[i] = sVowels[j];\\n        j++;\\n      }\\n    }\\n\\n    return newS.join();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357200,
                "title": "c-stack-linq-2-lines",
                "content": "```\\npublic class Solution {\\n    public string ReverseVowels(string s) {\\n        Stack<char> stack = new(s.Where(\"aeiouAEIOU\".Contains));\\n        return string.Concat(s.Select(c => \"aeiouAEIOU\".Contains(c) ? stack.Pop() : c));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string ReverseVowels(string s) {\\n        Stack<char> stack = new(s.Where(\"aeiouAEIOU\".Contains));\\n        return string.Concat(s.Select(c => \"aeiouAEIOU\".Contains(c) ? stack.Pop() : c));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210279,
                "title": "reverse-only-vowels-in-a-string-two-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use two pointers approach. We can use one pointer to traverse the string from the beginning and another pointer to traverse the string from the end. Whenever we encounter a vowel at the first pointer and another vowel at the second pointer, we swap them. We continue doing this until the two pointers meet in the middle.\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n        s = list(s)\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            if s[i] in vowels and s[j] in vowels:\\n                s[i], s[j] = s[j], s[i]\\n                i += 1\\n                j -= 1\\n            elif s[i] in vowels:\\n                j -= 1\\n            else:\\n                i += 1\\n        return \"\".join(s)\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this code, we first create a set of vowels to check whether a character is a vowel or not. We then convert the string to a list so that we can modify its characters.\\n\\nWe initialize two pointers i and j to point to the first and last characters of the string, respectively. We then move the two pointers towards each other until they meet in the middle.\\n\\nFor each pair of characters, if both are vowels, we swap them. If the character at i is a vowel but the character at j is not, we move j towards the beginning of the string. Similarly, if the character at j is a vowel but the character at i is not, we move i towards the end of the string.\\n\\nFinally, we convert the modified list back to a string and return it.\\n# Complexity\\n- Time complexity: The time complexity of this code is $$ O(n)$$, where $$n$$ is the length of the string. This is because we only traverse the string once from both ends and perform constant time operations on each character.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of this code is also $$O(n)$$, since we create a list to store the modified string. However, we can modify the string in place, which would reduce the space complexity to $$O(1)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nOverall, your code is well-written and easy to understand. It should work correctly for any valid input string.",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n        s = list(s)\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            if s[i] in vowels and s[j] in vowels:\\n                s[i], s[j] = s[j], s[i]\\n                i += 1\\n                j -= 1\\n            elif s[i] in vowels:\\n                j -= 1\\n            else:\\n                i += 1\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848343,
                "title": "beginner-friendly-o-n-time-complexity-code",
                "content": "# Intuition\\nCreate a seperate string to store all the vowels in order.\\n\\n# Approach\\nThe string holding all the vowels of the string(say, temp) will be iterated in reverse manner(j = temp.size() - 1) and whenever we will find a vowel in origginal stirng we will replace it with temp[j] and decrement j. This way we will replace all the vowels in reverse order. The code is attached for reference.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        string ans = \"\", temp = \"\";\\n        int n = s.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n               || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n            {\\n                temp += s[i];\\n            }\\n        }\\n        int j = temp.size() - 1;\\n        for(int i= 0; i < n; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' \\n               || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n            {\\n                ans += temp[j];\\n                j--;\\n            }\\n            else\\n            {\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        string ans = \"\", temp = \"\";\\n        int n = s.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n               || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n            {\\n                temp += s[i];\\n            }\\n        }\\n        int j = temp.size() - 1;\\n        for(int i= 0; i < n; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' \\n               || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n            {\\n                ans += temp[j];\\n                j--;\\n            }\\n            else\\n            {\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782043,
                "title": "java-most-possible-solution",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        HashSet<Character> vowels = new HashSet<Character>();\\n        Collections.addAll(vowels, \\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n        int left = 0, right = s.length() - 1;\\n        char[] result = s.toCharArray();\\n        while (left < right) {\\n            if (!vowels.contains(result[left])) {\\n                left ++;\\n                continue;\\n            }\\n            if (!vowels.contains(result[right])) {\\n                right --;\\n                continue;\\n            }\\n            char temp = result[left];\\n            result[left] = result[right];\\n            result[right] = temp;\\n            left ++;\\n            right --;\\n        }\\n        return new String(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        HashSet<Character> vowels = new HashSet<Character>();\\n        Collections.addAll(vowels, \\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n        int left = 0, right = s.length() - 1;\\n        char[] result = s.toCharArray();\\n        while (left < right) {\\n            if (!vowels.contains(result[left])) {\\n                left ++;\\n                continue;\\n            }\\n            if (!vowels.contains(result[right])) {\\n                right --;\\n                continue;\\n            }\\n            char temp = result[left];\\n            result[left] = result[right];\\n            result[right] = temp;\\n            left ++;\\n            right --;\\n        }\\n        return new String(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779022,
                "title": "python-simple-python-solution-97-ms",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        l=\"aeiouAEIOU\"\\n        s=list(s)\\n        i,j=0,len(s)-1\\n        while(i<j):\\n            if s[i] in l and s[j] in l:\\n                s[i],s[j]=s[j],s[i]\\n                i+=1\\n                j-=1\\n            elif s[i] not in l:\\n                i+=1\\n            elif s[j] not in l:\\n                j-=1\\n        return \\'\\'.join(s)\\n                \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        l=\"aeiouAEIOU\"\\n        s=list(s)\\n        i,j=0,len(s)-1\\n        while(i<j):\\n            if s[i] in l and s[j] in l:\\n                s[i],s[j]=s[j],s[i]\\n                i+=1\\n                j-=1\\n            elif s[i] not in l:\\n                i+=1\\n            elif s[j] not in l:\\n                j-=1\\n        return \\'\\'.join(s)\\n                \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778713,
                "title": "kotlin-two-pointers",
                "content": "Solution [kotlin]\\n```\\n    fun reverseVowels(s: String): String {\\n        val vowels = setOf(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\')\\n        var chrs = s.toCharArray()\\n        var l = 0\\n        var r = chrs.lastIndex\\n        while(l < r) {\\n            while(l<r && chrs[l] !in vowels) l++\\n            while(l<r && chrs[r] !in vowels) r--\\n            if (l < r) chrs[l] = chrs[r].also { chrs[r] = chrs[l] }\\n            r--\\n            l++\\n        }\\n        return String(chrs)\\n    }\\n```\\nExplanation:\\nStraightforward solution : use two pointers method and scan from the both sides.\\n\\nSpeed: O(N), Memory O(N)\\n\\nBtw, I post my daily leetcode here https://dmitrysamoylenko.com/2022/10/31/leetcode_daily.html and in the telegram channel https://t.me/leetcode_daily_unstoppable",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\n    fun reverseVowels(s: String): String {\\n        val vowels = setOf(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\')\\n        var chrs = s.toCharArray()\\n        var l = 0\\n        var r = chrs.lastIndex\\n        while(l < r) {\\n            while(l<r && chrs[l] !in vowels) l++\\n            while(l<r && chrs[r] !in vowels) r--\\n            if (l < r) chrs[l] = chrs[r].also { chrs[r] = chrs[l] }\\n            r--\\n            l++\\n        }\\n        return String(chrs)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778519,
                "title": "c-just-checking-the-new-ui",
                "content": "# Intuition\\n- check for each character from front and end using 2 variables left and right \\n- if both characters are vowel swap left and right values\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        c = tolower(c);\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n    string reverseVowels(string s) {\\n        int l=0, r=s.size()-1;\\n        while(l<r){\\n            while (l < r && !isVowel(s[l])) l++;\\n            while (r > l && !isVowel(s[r])) r--;\\n            swap(s[l], s[r]);\\n            l++, r--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        c = tolower(c);\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n    string reverseVowels(string s) {\\n        int l=0, r=s.size()-1;\\n        while(l<r){\\n            while (l < r && !isVowel(s[l])) l++;\\n            while (r > l && !isVowel(s[r])) r--;\\n            swap(s[l], s[r]);\\n            l++, r--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777623,
                "title": "c-simple-using-only-loop",
                "content": "bool isvowel(char c)\\n        {\\n            if(c>=97)\\n                c-=32;\\n            if(c==\\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' ||c==\\'U\\')\\n                return true;\\n            return false;\\n        }\\n    \\n    string reverseVowels(string s) {\\n            for(int i=0,j=s.size()-1;i<j;i++,j--)\\n            {\\n                while(i<j && isvowel(s[i])==0)\\n                    i++;\\n                while(i<j && isvowel(s[j])==0)\\n                    j--;\\n                if(i<j)\\n                    swap(s[i],s[j]);\\n            }\\n                return s;\\n    }",
                "solutionTags": [],
                "code": "bool isvowel(char c)\\n        {\\n            if(c>=97)\\n                c-=32;\\n            if(c==\\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' ||c==\\'U\\')\\n                return true;\\n            return false;\\n        }\\n    \\n    string reverseVowels(string s) {\\n            for(int i=0,j=s.size()-1;i<j;i++,j--)\\n            {\\n                while(i<j && isvowel(s[i])==0)\\n                    i++;\\n                while(i<j && isvowel(s[j])==0)\\n                    j--;\\n                if(i<j)\\n                    swap(s[i],s[j]);\\n            }\\n                return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2777164,
                "title": "easy-method-without-using-reverse-function-10-lines-code-c",
                "content": "class Solution {\\npublic:\\n#    string reverseVowels(string s)\\n    {\\n        vector<char>ch;\\n       for(int i=0;i<s.size();i++){\\n           if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n               ch.push_back(s[i]);  }}\\n        int t=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n               s[i]=ch[t];\\n                t++;}}\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n#    string reverseVowels(string s)\\n    {\\n        vector<char>ch;\\n       for(int i=0;i<s.size();i++){\\n           if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n               ch.push_back(s[i]);  }",
                "codeTag": "Java"
            },
            {
                "id": 2777140,
                "title": "stack-usage-c-beats-80-super-easy-for-beginners-starting-dsa",
                "content": "# Intuition\\nIntuition tells us to store into a vector and then to reverse it, however this is perfect question for stack implementation\\n# Approach\\nUsing stack to reverse\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        stack<char> ss;\\n        for(auto x:s)if(x==\\'a\\'|| x==\\'e\\'||x==\\'i\\'||x==\\'o\\'|| x==\\'u\\'||x==\\'A\\'||x==\\'E\\'|| x==\\'I\\'||x==\\'O\\'||x==\\'U\\')ss.push(x);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            auto x=s[i];\\n            if(x==\\'a\\'|| x==\\'e\\'||x==\\'i\\'||x==\\'o\\'|| x==\\'u\\'||x==\\'A\\'||x==\\'E\\'|| x==\\'I\\'||x==\\'O\\'||x==\\'U\\')\\n                {\\n                    s[i]=ss.top();\\n                    ss.pop();\\n                }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        stack<char> ss;\\n        for(auto x:s)if(x==\\'a\\'|| x==\\'e\\'||x==\\'i\\'||x==\\'o\\'|| x==\\'u\\'||x==\\'A\\'||x==\\'E\\'|| x==\\'I\\'||x==\\'O\\'||x==\\'U\\')ss.push(x);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            auto x=s[i];\\n            if(x==\\'a\\'|| x==\\'e\\'||x==\\'i\\'||x==\\'o\\'|| x==\\'u\\'||x==\\'A\\'||x==\\'E\\'|| x==\\'I\\'||x==\\'O\\'||x==\\'U\\')\\n                {\\n                    s[i]=ss.top();\\n                    ss.pop();\\n                }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776981,
                "title": "python-two-pointer-approach-o-n",
                "content": "# Two Pointer:\\nFirst we\\'ll convert the string into list. Applying the two pointer approach here, first we take the ```start``` pointer and the ```end``` pointer. When both have same values we swap their values and move both by 1. ```start += 1``` and ```end -=1```. If any value is not vowels move the pointer forward by 1.\\n\\n# Time Complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s_list = list(s)\\n        vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\\n        start = 0\\n        end = len(s_list) - 1\\n\\n        while start < end:\\n            if (s_list[start] not in vowels):\\n                start +=1\\n            if (s_list[end] not in vowels):\\n                end -= 1\\n            \\n            if s_list[start] in vowels and s_list[end] in vowels:\\n                s_list[start], s_list[end] = s_list[end], s_list[start]\\n                start +=1\\n                end -= 1\\n\\n        return \"\".join(s_list)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```start```\n```end```\n```start += 1```\n```end -=1```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s_list = list(s)\\n        vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\\n        start = 0\\n        end = len(s_list) - 1\\n\\n        while start < end:\\n            if (s_list[start] not in vowels):\\n                start +=1\\n            if (s_list[end] not in vowels):\\n                end -= 1\\n            \\n            if s_list[start] in vowels and s_list[end] in vowels:\\n                s_list[start], s_list[end] = s_list[end], s_list[start]\\n                start +=1\\n                end -= 1\\n\\n        return \"\".join(s_list)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776686,
                "title": "o-n-c-easy-understanding-two-pointer-approach-top-99-2-time-96-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nswapping elements when we se a vovel \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake 2 pointers one at start other at end index if both are vovel swap then and increment si and decrement ed,if si is vovel the reduce ed samilarly for ed if both are not vovel incease si end decrease ed.\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int si=0;\\n        int ed=s.size()-1;\\n\\n        while(si<ed){\\n            if((s[si]==\\'a\\'||s[si]==\\'e\\'||s[si]==\\'i\\'||s[si]==\\'o\\'||s[si]==\\'u\\'||s[si]==\\'A\\'||s[si]==\\'E\\'||s[si]==\\'I\\'||s[si]==\\'O\\'||s[si]==\\'U\\')&&(s[ed]==\\'a\\'||s[ed]==\\'e\\'||s[ed]==\\'i\\'||s[ed]==\\'o\\'||s[ed]==\\'u\\'||s[ed]==\\'A\\'||s[ed]==\\'E\\'||s[ed]==\\'I\\'||s[ed]==\\'O\\'||s[ed]==\\'U\\')){\\n                char temp=s[si];\\n                s[si]=s[ed];\\n                s[ed]=temp;\\n                si++;\\n                ed--;\\n            }else if(s[si]==\\'a\\'||s[si]==\\'e\\'||s[si]==\\'i\\'||s[si]==\\'o\\'||s[si]==\\'u\\'||s[si]==\\'A\\'||s[si]==\\'E\\'||s[si]==\\'I\\'||s[si]==\\'O\\'||s[si]==\\'U\\'){\\n                ed--;\\n            }else if (s[ed]==\\'a\\'||s[ed]==\\'e\\'||s[ed]==\\'i\\'||s[ed]==\\'o\\'||s[ed]==\\'u\\'||s[ed]==\\'A\\'||s[ed]==\\'E\\'||s[ed]==\\'I\\'||s[ed]==\\'O\\'||s[ed]==\\'U\\'){\\n                si++;\\n            }else{\\n                si++;\\n                ed--;\\n            }\\n\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int si=0;\\n        int ed=s.size()-1;\\n\\n        while(si<ed){\\n            if((s[si]==\\'a\\'||s[si]==\\'e\\'||s[si]==\\'i\\'||s[si]==\\'o\\'||s[si]==\\'u\\'||s[si]==\\'A\\'||s[si]==\\'E\\'||s[si]==\\'I\\'||s[si]==\\'O\\'||s[si]==\\'U\\')&&(s[ed]==\\'a\\'||s[ed]==\\'e\\'||s[ed]==\\'i\\'||s[ed]==\\'o\\'||s[ed]==\\'u\\'||s[ed]==\\'A\\'||s[ed]==\\'E\\'||s[ed]==\\'I\\'||s[ed]==\\'O\\'||s[ed]==\\'U\\')){\\n                char temp=s[si];\\n                s[si]=s[ed];\\n                s[ed]=temp;\\n                si++;\\n                ed--;\\n            }else if(s[si]==\\'a\\'||s[si]==\\'e\\'||s[si]==\\'i\\'||s[si]==\\'o\\'||s[si]==\\'u\\'||s[si]==\\'A\\'||s[si]==\\'E\\'||s[si]==\\'I\\'||s[si]==\\'O\\'||s[si]==\\'U\\'){\\n                ed--;\\n            }else if (s[ed]==\\'a\\'||s[ed]==\\'e\\'||s[ed]==\\'i\\'||s[ed]==\\'o\\'||s[ed]==\\'u\\'||s[ed]==\\'A\\'||s[ed]==\\'E\\'||s[ed]==\\'I\\'||s[ed]==\\'O\\'||s[ed]==\\'U\\'){\\n                si++;\\n            }else{\\n                si++;\\n                ed--;\\n            }\\n\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776568,
                "title": "c-easy-solution-easy-understanding-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.length();\\n        int i=0,j=n-1;\\n        while(i<j)\\n        {\\n            while(s[i]!=\\'a\\' && s[i]!=\\'i\\' && s[i]!=\\'e\\' && s[i]!=\\'o\\' && s[i]!=\\'u\\' && s[i]!=\\'A\\' && s[i]!=\\'I\\' && s[i]!=\\'E\\' && s[i]!=\\'O\\' && s[i]!=\\'U\\'&& i<j)\\n            {\\n                i++;\\n            }\\n            while(s[j]!=\\'a\\' && s[j]!=\\'i\\' && s[j]!=\\'e\\' && s[j]!=\\'o\\' && s[j]!=\\'u\\' && s[j]!=\\'A\\' && s[j]!=\\'I\\' && s[j]!=\\'E\\' && s[j]!=\\'O\\' && s[j]!=\\'U\\' && i<j)\\n            {\\n                 j--;\\n            }\\n            \\n            if(i<j)swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.length();\\n        int i=0,j=n-1;\\n        while(i<j)\\n        {\\n            while(s[i]!=\\'a\\' && s[i]!=\\'i\\' && s[i]!=\\'e\\' && s[i]!=\\'o\\' && s[i]!=\\'u\\' && s[i]!=\\'A\\' && s[i]!=\\'I\\' && s[i]!=\\'E\\' && s[i]!=\\'O\\' && s[i]!=\\'U\\'&& i<j)\\n            {\\n                i++;\\n            }\\n            while(s[j]!=\\'a\\' && s[j]!=\\'i\\' && s[j]!=\\'e\\' && s[j]!=\\'o\\' && s[j]!=\\'u\\' && s[j]!=\\'A\\' && s[j]!=\\'I\\' && s[j]!=\\'E\\' && s[j]!=\\'O\\' && s[j]!=\\'U\\' && i<j)\\n            {\\n                 j--;\\n            }\\n            \\n            if(i<j)swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776516,
                "title": "faster-than-100-0ms-c-submission",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool IsVowel(char x) // check if character is vowel or not.\\n    { \\n        if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\' || x==\\'o\\' || x==\\'u\\' || x==\\'A\\' || x==\\'E\\'|| x==\\'I\\'|| x==\\'O\\'|| x==\\'U\\') return true;\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n       int low=0,high=s.size()-1; \\n       while(low<high)  \\n       {\\n          if(IsVowel(s[low]) && !IsVowel(s[high])) high--; // s[low] is vowel and s[high] is not then high--.\\n\\n          else if(!IsVowel(s[low]) && IsVowel(s[high])) low++; // else low++.\\n\\n          else if(IsVowel(s[low]) && IsVowel(s[high]))swap(s[low++],s[high--]); // if both are vowel than swap them and low++,high-- as well.\\n\\n          else high--,++low; // if both are not vowel simply ignore and low++,high--.\\n       }\\n       return s; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool IsVowel(char x) // check if character is vowel or not.\\n    { \\n        if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\' || x==\\'o\\' || x==\\'u\\' || x==\\'A\\' || x==\\'E\\'|| x==\\'I\\'|| x==\\'O\\'|| x==\\'U\\') return true;\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n       int low=0,high=s.size()-1; \\n       while(low<high)  \\n       {\\n          if(IsVowel(s[low]) && !IsVowel(s[high])) high--; // s[low] is vowel and s[high] is not then high--.\\n\\n          else if(!IsVowel(s[low]) && IsVowel(s[high])) low++; // else low++.\\n\\n          else if(IsVowel(s[low]) && IsVowel(s[high]))swap(s[low++],s[high--]); // if both are vowel than swap them and low++,high-- as well.\\n\\n          else high--,++low; // if both are not vowel simply ignore and low++,high--.\\n       }\\n       return s; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775934,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    bool isvowel(char x)\\n    {\\n        if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n            return true;\\n        return false;\\n    }\\n    \\n    string reverseVowels(string s) {\\n        \\n        int start = 0;\\n        int end = s.length()-1;\\n        \\n        while(start<end)\\n        {\\n            if(isvowel(s[start]) and isvowel(s[end]))\\n            {\\n                swap(s[start],s[end]);\\n                start++;\\n                end--;\\n            }\\n            else if(isvowel(s[start]))\\n            {\\n                end--;\\n            }\\n            else\\n                start++;\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool isvowel(char x)\\n    {\\n        if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2775895,
                "title": "o-n-c-solution-using-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to swap the positons of the vowels in order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will use two pointers; start & end, then if we find vowels at start & end positions then swap; other wise increment and/or decrement pointers.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)-we only need to iterate over the string only once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)- constant space for swaping purpose.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isVowel(char c){\\n        if(c==\\'a\\'|| c==\\'e\\'|| c==\\'i\\' || c==\\'o\\' || c==\\'u\\'|| \\n           c==\\'A\\'|| c==\\'E\\'|| c==\\'I\\' || c==\\'O\\'|| c==\\'U\\')\\n           return true;\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n   \\n    int start,end;\\n    start=0;\\n    end=s.size()-1;\\n    while(start<=end){\\n\\n        if(isVowel(s[start]) && isVowel(s[end])){\\n            char ch=s[start];\\n            s[start]=s[end];\\n            s[end]=ch;\\n            start++;\\n            end--;\\n        }\\n        else if(isVowel(s[start])) end--;\\n\\n        else if(isVowel(s[end])) start++;\\n\\n        else {\\n            start++;\\n            end--;\\n        }\\n    }\\n    return s;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isVowel(char c){\\n        if(c==\\'a\\'|| c==\\'e\\'|| c==\\'i\\' || c==\\'o\\' || c==\\'u\\'|| \\n           c==\\'A\\'|| c==\\'E\\'|| c==\\'I\\' || c==\\'O\\'|| c==\\'U\\')\\n           return true;\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n   \\n    int start,end;\\n    start=0;\\n    end=s.size()-1;\\n    while(start<=end){\\n\\n        if(isVowel(s[start]) && isVowel(s[end])){\\n            char ch=s[start];\\n            s[start]=s[end];\\n            s[end]=ch;\\n            start++;\\n            end--;\\n        }\\n        else if(isVowel(s[start])) end--;\\n\\n        else if(isVowel(s[end])) start++;\\n\\n        else {\\n            start++;\\n            end--;\\n        }\\n    }\\n    return s;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775761,
                "title": "java-reverse-vowels-of-a-string",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        String str=\"aeiouAEIOU\";\\n        String dummy=\"\";\\n        for(char c:s.toCharArray())\\n        {\\n            if(str.contains(\"\"+c))dummy+=c;\\n        }\\n        char c[]=s.toCharArray();\\n        int j=dummy.length()-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(str.contains(\"\"+s.charAt(i))){c[i]=dummy.charAt(j);j--;}\\n        }\\n\\t\\t\\n        return String.valueOf(c);\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String reverseVowels(String s) {\\n        String str=\"aeiouAEIOU\";\\n        String dummy=\"\";\\n        for(char c:s.toCharArray())\\n        {\\n            if(str.contains(\"\"+c))dummy+=c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2775438,
                "title": "java-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\n    boolean isVowel(char ch)\\n    {\\n        ch = Character.toLowerCase(ch); //lower all the characters to reduce checking for upppercase vowels\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') return true;\\n        return false;\\n    }\\n    void swap(StringBuilder s, int i, int j)\\n    {\\n        char ch1 = s.charAt(i), ch2 = s.charAt(j);\\n        s.setCharAt(i, ch2);\\n        s.setCharAt(j, ch1);\\n    }\\n    public String reverseVowels(String s) \\n    {\\n        StringBuilder str = new StringBuilder(s);\\n        int i = 0, j = str.length() - 1;\\n        while(i <= j)\\n        {\\n            char ch1 = str.charAt(i), ch2 = str.charAt(j);\\n            if (isVowel(ch1) && isVowel(ch2)) //consider swapping only when both s[i] and s[j] are vowels\\n            {\\n                swap(str, i, j);\\n                i++; j--; //move i to right, j to left as we have swapped  \\n                continue;\\n            }\\n            \\n            if (!isVowel(ch1)) i++; //if s[i] is not a vowel keep traversing to right in search of a vowel\\n            if (!isVowel(ch2)) j--; //if s[j] is not a vowel keep traversing to left in search of vowel\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    boolean isVowel(char ch)\\n    {\\n        ch = Character.toLowerCase(ch); //lower all the characters to reduce checking for upppercase vowels\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') return true;\\n        return false;\\n    }\\n    void swap(StringBuilder s, int i, int j)\\n    {\\n        char ch1 = s.charAt(i), ch2 = s.charAt(j);\\n        s.setCharAt(i, ch2);\\n        s.setCharAt(j, ch1);\\n    }\\n    public String reverseVowels(String s) \\n    {\\n        StringBuilder str = new StringBuilder(s);\\n        int i = 0, j = str.length() - 1;\\n        while(i <= j)\\n        {\\n            char ch1 = str.charAt(i), ch2 = str.charAt(j);\\n            if (isVowel(ch1) && isVowel(ch2)) //consider swapping only when both s[i] and s[j] are vowels\\n            {\\n                swap(str, i, j);\\n                i++; j--; //move i to right, j to left as we have swapped  \\n                continue;\\n            }\\n            \\n            if (!isVowel(ch1)) i++; //if s[i] is not a vowel keep traversing to right in search of a vowel\\n            if (!isVowel(ch2)) j--; //if s[j] is not a vowel keep traversing to left in search of vowel\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775411,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int j = 0;\\n        char[] str = s.toCharArray();\\n        String vowel = \"\";\\n        for (int i = 0; i < str.length; i++) {\\n            if (str[i] == \\'a\\' || str[i] == \\'A\\' || str[i] == \\'e\\'\\n                    || str[i] == \\'E\\' || str[i] == \\'i\\' || str[i] == \\'I\\'\\n                    || str[i] == \\'o\\' || str[i] == \\'O\\' || str[i] == \\'u\\'\\n                    || str[i] == \\'U\\') {\\n                j++;\\n                vowel += str[i];\\n            }\\n        }\\n        for (int k = 0; k < str.length; k++) {\\n            if (str[k] == \\'a\\' || str[k] == \\'A\\' || str[k] == \\'e\\'\\n                    || str[k] == \\'E\\' || str[k] == \\'i\\' || str[k] == \\'I\\'\\n                    || str[k] == \\'o\\' || str[k] == \\'O\\' || str[k] == \\'u\\'\\n                    || str[k] == \\'U\\') {\\n                str[k] = vowel.charAt(--j);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public String reverseVowels(String s) {\\n        int j = 0;\\n        char[] str = s.toCharArray();\\n        String vowel = \"\";\\n        for (int i = 0; i < str.length; i++) {\\n            if (str[i] == \\'a\\' || str[i] == \\'A\\' || str[i] == \\'e\\'\\n                    || str[i] == \\'E\\' || str[i] == \\'i\\' || str[i] == \\'I\\'\\n                    || str[i] == \\'o\\' || str[i] == \\'O\\' || str[i] == \\'u\\'\\n                    || str[i] == \\'U\\') {\\n                j++;\\n                vowel += str[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2748292,
                "title": "cpp-simple-o-n-solution-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch){      //function to check if given charachter is charcter is vowel\\n        ch=tolower(ch);\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n        int i=0,k=s.size()-1;\\n        while(i<k){                              //stop after swapping left side vowels with right side\\n            if(isVowel(s[i])){ \\n                while(k>=0 && !isVowel(s[k]))    //till we find a vowel from right side of string and k is not less than 0\\n                    k--;\\n                int temp=s[i];                   //swap vowel from lest side of string to right side\\n                s[i]=s[k];\\n                s[k--]=temp;\\n            }\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch){      //function to check if given charachter is charcter is vowel\\n        ch=tolower(ch);\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n        int i=0,k=s.size()-1;\\n        while(i<k){                              //stop after swapping left side vowels with right side\\n            if(isVowel(s[i])){ \\n                while(k>=0 && !isVowel(s[k]))    //till we find a vowel from right side of string and k is not less than 0\\n                    k--;\\n                int temp=s[i];                   //swap vowel from lest side of string to right side\\n                s[i]=s[k];\\n                s[k--]=temp;\\n            }\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641586,
                "title": "python-solution-99-fast",
                "content": "class Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        vowellist = set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'])\\n        \\n        s = list(s)\\n        l = 0\\n        r = len(s) - 1\\n        \\n        while l < r:\\n            while l < r and s[l] not in vowellist:\\n                l += 1\\n            while r > l and s[r] not in vowellist:\\n                r -= 1\\n            \\n            s[l],s[r] = s[r],s[l]\\n            l += 1\\n            r -= 1\\n        \\n        return \"\".join(s)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "class Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        vowellist = set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'])\\n        \\n        s = list(s)\\n        l = 0\\n        r = len(s) - 1\\n        \\n        while l < r:\\n            while l < r and s[l] not in vowellist:\\n                l += 1\\n            while r > l and s[r] not in vowellist:\\n                r -= 1\\n            \\n            s[l],s[r] = s[r],s[l]\\n            l += 1\\n            r -= 1\\n        \\n        return \"\".join(s)",
                "codeTag": "Java"
            },
            {
                "id": 2478678,
                "title": "simple-java-solution-with-explanation-2-pointers",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        char[] arr = s.toCharArray();\\n        while (i < j) {\\n            if (isVowel(arr[i]) && isVowel(arr[j])) { // if both forward and backward pointer are at vowel\\'s then swap\\n                char temp = arr[i];\\n                arr[i++] = arr[j];\\n                arr[j--] = temp;\\n            } else if (!isVowel(arr[i])) { // if non-vowel then increment forward pointer\\n                i++;\\n            } else if (!isVowel(arr[j])) { // if non-vowel then decrement backward pointer\\n                j--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n    \\n    boolean isVowel(char c) { // check if character is vowel\\n        return ((c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') ||\\n                (c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\'));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        char[] arr = s.toCharArray();\\n        while (i < j) {\\n            if (isVowel(arr[i]) && isVowel(arr[j])) { // if both forward and backward pointer are at vowel\\'s then swap\\n                char temp = arr[i];\\n                arr[i++] = arr[j];\\n                arr[j--] = temp;\\n            } else if (!isVowel(arr[i])) { // if non-vowel then increment forward pointer\\n                i++;\\n            } else if (!isVowel(arr[j])) { // if non-vowel then decrement backward pointer\\n                j--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n    \\n    boolean isVowel(char c) { // check if character is vowel\\n        return ((c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') ||\\n                (c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\'));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455759,
                "title": "easy-fast-solution-two-pointer",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n```\\n    public String reverseVowels(String s) {\\n        int i = 0, j = s.length() - 1;\\n        char[] carr = s.toCharArray();\\n        while (i < j){\\n            if (!isVowel(carr[i])) i++;\\n            if (!isVowel(carr[j])) j--;\\n\\n            if (isVowel(carr[i]) && isVowel(carr[j])){\\n                char temp = carr[i];\\n                carr[i++] = carr[j];\\n                carr[j--] = temp;\\n            }\\n        }\\n        return new String(carr);\\n    }\\n\\n    private boolean isVowel(char c){\\n        switch (c){\\n            case \\'A\\':\\n            case \\'a\\':\\n            case \\'E\\':\\n            case \\'e\\':\\n            case \\'I\\':\\n            case \\'i\\':\\n            case \\'O\\':\\n            case \\'o\\':\\n            case \\'U\\': \\n            case \\'u\\': return true;\\n            default: return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474263,
                "title": "simple-javascript-solution",
                "content": "```\\n// function to swap two chars\\nfunction swap(arr, idx1, idx2) {\\n    return [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\\n}\\n\\n// reverse vowel function\\nvar reverseVowels = function(s) {\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'];\\n    s = s.split(\\'\\');\\n    let start = 0;\\n    let end = s.length-1;\\n    while(start < end) {\\n        if(vowels.includes(s[start]) && vowels.includes(s[end])) {\\n            swap(s, start, end);\\n            start++;\\n            end--;\\n        }else if(!vowels.includes(s[start])){\\n            start++;\\n        } else if(!vowels.includes(s[end])) {\\n            end--;\\n        }\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// function to swap two chars\\nfunction swap(arr, idx1, idx2) {\\n    return [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\\n}\\n\\n// reverse vowel function\\nvar reverseVowels = function(s) {\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'];\\n    s = s.split(\\'\\');\\n    let start = 0;\\n    let end = s.length-1;\\n    while(start < end) {\\n        if(vowels.includes(s[start]) && vowels.includes(s[end])) {\\n            swap(s, start, end);\\n            start++;\\n            end--;\\n        }else if(!vowels.includes(s[start])){\\n            start++;\\n        } else if(!vowels.includes(s[end])) {\\n            end--;\\n        }\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1322317,
                "title": "easy-c-solution-using-two-pointer-o-n",
                "content": "Two Pointer Approach\\n\\n\\n**Time complexity - O(N)** \\n**Space complexity - O(N)** \\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isvowel( char ch){\\n        return ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\' || \\n               ch==\\'A\\' || ch==\\'E\\' || ch==\\'I\\' || ch==\\'O\\' || ch==\\'U\\';  \\n    }\\n        \\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        int left =0;\\n        int right = n-1;\\n        while(left < right){\\n            \\n            while(left< right && !isvowel(s[left]))left++;\\n            while(left < right && !isvowel(s[right])) right--;\\n            swap(s[left], s[right]);\\n            left++;\\n            right--;\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool isvowel( char ch){\\n        return ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\' || \\n               ch==\\'A\\' || ch==\\'E\\' || ch==\\'I\\' || ch==\\'O\\' || ch==\\'U\\';  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1247882,
                "title": "python-not-fast-but-easy-solution",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        k=list(s)\\n        v=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        vs=[] #Vowels list from the strig\\n        for i in k:\\n            if i in v:\\n                vs.append(i)\\n        for i in range(len(k)):\\n            if k[i] in v:\\n                k[i]=vs[len(vs)-1] #Taking vowels from back and replacing\\n                vs.pop()\\n        t=\"\".join(k)\\n        return(t)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        k=list(s)\\n        v=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        vs=[] #Vowels list from the strig\\n        for i in k:\\n            if i in v:\\n                vs.append(i)\\n        for i in range(len(k)):\\n            if k[i] in v:\\n                k[i]=vs[len(vs)-1] #Taking vowels from back and replacing\\n                vs.pop()\\n        t=\"\".join(k)\\n        return(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147660,
                "title": "python-3-using-list-pop",
                "content": "Intuition\\n(1) Keep vowels in stack with reverse order\\n(2) loop the string and only replace the vowels.\\n\\n```\\n\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = \"aeiouAEIOU\"\\n        stack = [x for x in s if x in vowels]\\n        ans = [stack.pop() if v in vowels else v for v in s]\\n\\n        return \"\".join(ans)\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = \"aeiouAEIOU\"\\n        stack = [x for x in s if x in vowels]\\n        ans = [stack.pop() if v in vowels else v for v in s]\\n\\n        return \"\".join(ans)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1121020,
                "title": "java-two-pointers-time-o-n",
                "content": "**Two-Pointers Approch:**\\n4 Possible Cases are there that left and right Pointers are Pointing to:\\n**1.vowel and vowel** `[swap and l++ and r--]`\\n**2.vowel and non-vowel** `[find other vowel on right side . Decrease right pointer (r--) only]`\\n**3.non-vowel and vowe**l `[find other vowel on left side . Increase left pointer (l++) only]`\\n**4.non-vowel and non-vowel** `[no swap and l++ and r--](because want to swap vowels only)`\\n```\\n    public String reverseVowels(String s) {\\n        int l=0;\\n        int r=s.length()-1;\\n        char[] words=s.toCharArray();\\n        HashSet<Character> vowels=new HashSet<>();\\n        vowels.add(\\'a\\'); vowels.add(\\'A\\');\\n        vowels.add(\\'e\\'); vowels.add(\\'E\\');\\n        vowels.add(\\'i\\'); vowels.add(\\'I\\');\\n        vowels.add(\\'o\\'); vowels.add(\\'O\\');\\n        vowels.add(\\'u\\'); vowels.add(\\'U\\');\\n        \\n        while(l<r){\\n            char ch1=words[l];\\n            char ch2=words[r];\\n            if(vowels.contains(ch1) && vowels.contains(ch2)){\\n               swap(words,l,r);\\n                l++;\\n                r--;\\n            }else if(vowels.contains(ch1)){\\n                r--;\\n            }else if(vowels.contains(ch2)){\\n                l++;\\n            }else{\\n                l++;\\n                r--;\\n            }\\n        }\\n        String ans=new String(words);\\n        return ans;\\n    }\\n    \\n    private void swap(char[] arr,int i,int j){\\n         char temp=arr[i];\\n          arr[i]=arr[j];\\n          arr[j]=temp;\\n    }\\n```\\t\\nTime:O(N) \\nSpace: constant( we are adding vowels to hashmap which is fix So in Big O notation it is constant)\\n\\nPlease **UPVOTE** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n    public String reverseVowels(String s) {\\n        int l=0;\\n        int r=s.length()-1;\\n        char[] words=s.toCharArray();\\n        HashSet<Character> vowels=new HashSet<>();\\n        vowels.add(\\'a\\'); vowels.add(\\'A\\');\\n        vowels.add(\\'e\\'); vowels.add(\\'E\\');\\n        vowels.add(\\'i\\'); vowels.add(\\'I\\');\\n        vowels.add(\\'o\\'); vowels.add(\\'O\\');\\n        vowels.add(\\'u\\'); vowels.add(\\'U\\');\\n        \\n        while(l<r){\\n            char ch1=words[l];\\n            char ch2=words[r];\\n            if(vowels.contains(ch1) && vowels.contains(ch2)){\\n               swap(words,l,r);\\n                l++;\\n                r--;\\n            }else if(vowels.contains(ch1)){\\n                r--;\\n            }else if(vowels.contains(ch2)){\\n                l++;\\n            }else{\\n                l++;\\n                r--;\\n            }\\n        }\\n        String ans=new String(words);\\n        return ans;\\n    }\\n    \\n    private void swap(char[] arr,int i,int j){\\n         char temp=arr[i];\\n          arr[i]=arr[j];\\n          arr[j]=temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 995617,
                "title": "python-not-much-but-it-is-honest-work",
                "content": "slow but low space\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels  = \"eoauiEOAUI\"\\n        order = []\\n        k = 0\\n        for i in s:\\n            if i in vowels:\\n                order.append(i)\\n                s = s.replace(i,\\'$\\')\\n        for j in s:\\n            if j == \\'$\\':\\n                k-=1\\n                s = s.replace(j,order[k],1)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels  = \"eoauiEOAUI\"\\n        order = []\\n        k = 0\\n        for i in s:\\n            if i in vowels:\\n                order.append(i)\\n                s = s.replace(i,\\'$\\')\\n        for j in s:\\n            if j == \\'$\\':\\n                k-=1\\n                s = s.replace(j,order[k],1)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987871,
                "title": "swift-simple-solution-by-joshua-puente",
                "content": "```\\nclass Solution {\\n    func reverseVowels(_ s: String) -> String {\\n        let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\\n        \\n        var sArray = Array(s)\\n        var left = 0\\n        var right = sArray.count - 1\\n        while left < right {\\n            if vowels.contains(sArray[left]) && vowels.contains(sArray[right]) {\\n                sArray.swapAt(left, right)\\n                left += 1\\n                right -= 1\\n            } else if vowels.contains(sArray[left]) {\\n                right -= 1\\n            } else {\\n                left += 1\\n            }\\n        }\\n        return String(sArray)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseVowels(_ s: String) -> String {\\n        let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\\n        \\n        var sArray = Array(s)\\n        var left = 0\\n        var right = sArray.count - 1\\n        while left < right {\\n            if vowels.contains(sArray[left]) && vowels.contains(sArray[right]) {\\n                sArray.swapAt(left, right)\\n                left += 1\\n                right -= 1\\n            } else if vowels.contains(sArray[left]) {\\n                right -= 1\\n            } else {\\n                left += 1\\n            }\\n        }\\n        return String(sArray)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911137,
                "title": "c-o-n-with-double-pointers",
                "content": "```\\nclass Solution\\n{\\nprivate:\\n  inline bool m_isVowel(char ch)\\n  {\\n    return (\\n        ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n        ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\');\\n  }\\n\\npublic:\\n  string reverseVowels(string s)\\n  {\\n    int len = s.length();\\n    int front = 0, back = len - 1;\\n    char tmp;\\n\\n    while (front < back)\\n    {\\n      if (!m_isVowel(s[front]))\\n      {\\n        front++;\\n      }\\n      else if (!m_isVowel(s[back]))\\n      {\\n        back--;\\n      }\\n      else\\n      {\\n        tmp = s[front];\\n        s[front++] = s[back];\\n        s[back--] = tmp;\\n      }\\n    }\\n    return s;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n  inline bool m_isVowel(char ch)\\n  {\\n    return (\\n        ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n        ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\');\\n  }\\n\\npublic:\\n  string reverseVowels(string s)\\n  {\\n    int len = s.length();\\n    int front = 0, back = len - 1;\\n    char tmp;\\n\\n    while (front < back)\\n    {\\n      if (!m_isVowel(s[front]))\\n      {\\n        front++;\\n      }\\n      else if (!m_isVowel(s[back]))\\n      {\\n        back--;\\n      }\\n      else\\n      {\\n        tmp = s[front];\\n        s[front++] = s[back];\\n        s[back--] = tmp;\\n      }\\n    }\\n    return s;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755897,
                "title": "straightforward-javascript-solution-2-pointers",
                "content": "```\\nconst reverseVowels = (s) => {\\n    const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']);\\n    s = s.split(\\'\\');\\n    \\n    let l = 0, r = s.length - 1;\\n    \\n    while(l < r){\\n        if(vowels.has(s[l]) && vowels.has(s[r])){\\n            swap(s, l, r);\\n            l++, r--;\\n        }else if(!vowels.has(s[l])){\\n            l++;\\n        }else if(!vowels.has(s[r])){\\n            r--;\\n        }\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n\\nconst swap = (arr, l, r) => {\\n    const temp = arr[l];\\n    arr[l] = arr[r];\\n    arr[r] = temp;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst reverseVowels = (s) => {\\n    const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']);\\n    s = s.split(\\'\\');\\n    \\n    let l = 0, r = s.length - 1;\\n    \\n    while(l < r){\\n        if(vowels.has(s[l]) && vowels.has(s[r])){\\n            swap(s, l, r);\\n            l++, r--;\\n        }else if(!vowels.has(s[l])){\\n            l++;\\n        }else if(!vowels.has(s[r])){\\n            r--;\\n        }\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n\\nconst swap = (arr, l, r) => {\\n    const temp = arr[l];\\n    arr[l] = arr[r];\\n    arr[r] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 671824,
                "title": "c-o-n-short-and-clear-solution-with-2-pointers-80-speed-100-space",
                "content": "I know the function to test vowels might probably be optimised, as in sacrificing some space to build a simple hashmap or the like but I found that trivial and boring.\\n\\nThe solution basically moves `i` and `j` until a vowel is found (if it is found) and until they are so that `i < j`; built-in `swap` just does the rest of the magic for us:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        c = tolower(c);\\n        return (c == \\'a\\') || (c == \\'e\\') ||(c == \\'i\\') ||(c == \\'o\\') ||(c == \\'u\\');\\n    }\\n    \\n    string reverseVowels(string s) {\\n        int i = 0, j = s.size() - 1;\\n        while (i < j) {\\n            while (i < s.size() && !isVowel(s[i])) i++;\\n            while (j && !isVowel(s[j])) j--;\\n            if (i < j) swap(s[i++], s[j--]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        c = tolower(c);\\n        return (c == \\'a\\') || (c == \\'e\\') ||(c == \\'i\\') ||(c == \\'o\\') ||(c == \\'u\\');\\n    }\\n    \\n    string reverseVowels(string s) {\\n        int i = 0, j = s.size() - 1;\\n        while (i < j) {\\n            while (i < s.size() && !isVowel(s[i])) i++;\\n            while (j && !isVowel(s[j])) j--;\\n            if (i < j) swap(s[i++], s[j--]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621693,
                "title": "extremely-simple-javascript-solution-video-tutorial",
                "content": "I made a JavaScript video tutorial for anyone who\\'s having difficulty understanding :) Enjoy!\\n\\nhttps://www.youtube.com/watch?v=5d2pRr8TmoE",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "I made a JavaScript video tutorial for anyone who\\'s having difficulty understanding :) Enjoy!\\n\\nhttps://www.youtube.com/watch?v=5d2pRr8TmoE",
                "codeTag": "Unknown"
            },
            {
                "id": 600947,
                "title": "python-easy-solution-2-lines",
                "content": "filter function and list comprehension\\n\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = list(filter(lambda x : x in \\'aeiouAEIOU\\', s))\\n        return \\'\\'.join(x if x not in \\'aeiouAEIOU\\' else vowels.pop() for x in s)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = list(filter(lambda x : x in \\'aeiouAEIOU\\', s))\\n        return \\'\\'.join(x if x not in \\'aeiouAEIOU\\' else vowels.pop() for x in s)\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1670059,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670419,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670208,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1566085,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670072,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1909009,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1863195,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670584,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670352,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1571618,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670059,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670419,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670208,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1566085,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670072,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1909009,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1863195,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670584,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670352,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1571618,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [] as in KIT), and \"lovely\" (which has the happY vowel, either [] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong  a vowel's job  in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1671112,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 1670924,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 1670768,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 1670733,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 1575979,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2065633,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2063660,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2059257,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2054923,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2049493,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2049349,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 2022678,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 2020375,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 2008649,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1994450,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1990346,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1961857,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1961780,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1951518,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1947106,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1946982,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1941866,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1938873,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1938605,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1912256,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1908778,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1905646,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1900812,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1895506,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1891310,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1879175,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1877900,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1877862,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1814018,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1768326,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1695618,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1676407,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1672442,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1671302,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1671183,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1671138,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1671084,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1671070,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1671029,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670983,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670977,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670891,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670884,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670881,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670858,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670857,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670856,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670855,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670713,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670686,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670535,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670490,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670461,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670290,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670268,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    }
]