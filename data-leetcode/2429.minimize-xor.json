[
    {
        "title": "Minimize XOR",
        "question_content": "Given two positive integers num1 and num2, find the positive integer x such that:\n\n\tx has the same number of set bits as num2, and\n\tThe value x XOR num1 is minimal.\n\nNote that XOR is the bitwise XOR operation.\nReturn the integer x. The test cases are generated such that x is uniquely determined.\nThe number of set bits of an integer is the number of 1's in its binary representation.\n&nbsp;\nExample 1:\n\nInput: num1 = 3, num2 = 5\nOutput: 3\nExplanation:\nThe binary representations of num1 and num2 are 0011 and 0101, respectively.\nThe integer 3 has the same number of set bits as num2, and the value 3 XOR 3 = 0 is minimal.\n\nExample 2:\n\nInput: num1 = 1, num2 = 12\nOutput: 3\nExplanation:\nThe binary representations of num1 and num2 are 0001 and 1100, respectively.\nThe integer 3 has the same number of set bits as num2, and the value 3 XOR 1 = 2 is minimal.\n\n&nbsp;\nConstraints:\n\n\t1 <= num1, num2 <= 109",
        "solutions": [
            {
                "id": 2648723,
                "title": "java-c-python-bit-count",
                "content": "# **Intuition**\\nFirstly we need to know the number of set bits of `num1` and `num2`.\\nLet `a = bitCount(num1)` and `b = bitCount(num2)`.\\n\\nIf `a == b`, we can pick `x = num1` and `x XOR num1 = 0` is minimal.\\n<br>\\n\\n# **Explanation**\\nIf `a > b`, we can pick `x` equals the bigger `b` bits of `num1`,\\nso that we can XOR the bigger `b` bits of `num1`,\\nand keep the smaller `a - b` bits left to make result small.\\n\\nIf `a < b`, we can firstly pick `x = num1`,\\nand additionaly we need to pick `b - a` more bits that not in `num1`.\\nWe check from the smaller bits until `x` have `b` bits.\\n<br>\\n\\n# **Complexity**\\nTime `O(n^2)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimizeXor(int num1, int num2) {\\n        int a = Integer.bitCount(num1), b = Integer.bitCount(num2), res = num1;\\n        for (int i = 0; i < 32; ++i) {\\n            if (a > b && ((1 << i) & num1) > 0) {\\n                res ^= 1 << i;\\n                a--;\\n            }\\n            if (a < b && ((1 << i) & num1) == 0) {\\n                res ^= 1 << i;\\n                a++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimizeXor(int num1, int num2) {\\n        int a = __builtin_popcount(num1), b = __builtin_popcount(num2), res = num1;\\n        for (int i = 0; i < 32; ++i) {\\n            if (a > b && ((1 << i) & num1) > 0) {\\n                res ^= 1 << i;\\n                a--;\\n            }\\n            if (a < b && ((1 << i) & num1) == 0) {\\n                res ^= 1 << i;\\n                a++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimizeXor(self, num1, num2):\\n        a, b = num1.bit_count(), num2.bit_count()\\n        res = num1\\n        for i in range(32):\\n            if a > b and (1 << i) & num1 > 0:\\n                res ^= 1 << i\\n                a -= 1\\n            if a < b and (1 << i) & num1 == 0:\\n                res ^= 1 << i\\n                a += 1\\n        return res\\n```\\n**Python2**\\n```py\\n    def minimizeXor(self, num1, num2):\\n        a, b = bin(num1).count(\\'1\\'), bin(num2).count(\\'1\\')\\n        res = num1\\n        for i in range(32):\\n            if cmp(a, b) == cmp((1 << i) & num1, 0.5):\\n                res ^= 1 << i\\n                a -= cmp(a, b)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimizeXor(int num1, int num2) {\\n        int a = Integer.bitCount(num1), b = Integer.bitCount(num2), res = num1;\\n        for (int i = 0; i < 32; ++i) {\\n            if (a > b && ((1 << i) & num1) > 0) {\\n                res ^= 1 << i;\\n                a--;\\n            }\\n            if (a < b && ((1 << i) & num1) == 0) {\\n                res ^= 1 << i;\\n                a++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int minimizeXor(int num1, int num2) {\\n        int a = __builtin_popcount(num1), b = __builtin_popcount(num2), res = num1;\\n        for (int i = 0; i < 32; ++i) {\\n            if (a > b && ((1 << i) & num1) > 0) {\\n                res ^= 1 << i;\\n                a--;\\n            }\\n            if (a < b && ((1 << i) & num1) == 0) {\\n                res ^= 1 << i;\\n                a++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minimizeXor(self, num1, num2):\\n        a, b = num1.bit_count(), num2.bit_count()\\n        res = num1\\n        for i in range(32):\\n            if a > b and (1 << i) & num1 > 0:\\n                res ^= 1 << i\\n                a -= 1\\n            if a < b and (1 << i) & num1 == 0:\\n                res ^= 1 << i\\n                a += 1\\n        return res\\n```\n```py\\n    def minimizeXor(self, num1, num2):\\n        a, b = bin(num1).count(\\'1\\'), bin(num2).count(\\'1\\')\\n        res = num1\\n        for i in range(32):\\n            if cmp(a, b) == cmp((1 << i) & num1, 0.5):\\n                res ^= 1 << i\\n                a -= cmp(a, b)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2648779,
                "title": "java-intuition-behind-logic-minimize-xor",
                "content": "**\\u2318 Given Conditions** : \\n\\ntwo positive integers `num1` and `num2`, find the integer `x` such that:\\n* `x` has the same number of set bits as `num2`, and\\n* The value `x` XOR `num1` is minimal.\\n\\n**\\u2318  Intuition** : \\n\\nWe need to find such a number ( say `ans`) , whose `count(set bits) == number of set bits of num2` and `ans ^ num1` is as minimum as possible.\\n\\nSince we want to `minimize` the XOR, we would want to have the set-bit positions in `ans` and `num1` overlapping. right ? Why ? \\n\\nBitwise XOR : \\n\\n`0 ^ 0 = 0`\\n`0 ^ 1 = 1`\\n`1 ^ 0 = 1`\\n`1 ^ 1 = 0`\\n\\nWe want to set the `overlapping` bits.\\n\\nWe want to `overlap` those bits which are set in `num1` and would make the `ans ^ num1` as minimum as possible, hence we set the `MSB` ( i.e. we started our loop from `31`). Basically, we are nullifying the effect of the contributions of `MSB\\'s`.\\n\\nOne thing to note, our `number of set bits in num2` could be remaining even after we have done the above task. \\n\\neg `num1 = 4, num2 = 10`. So, we need to set the remaining bit positions as well. \\n\\n\\u2318 **Which bit positions to set now** ? \\n\\nAs we want to `minimize` the `ans ^ num1`, we would want to choose to set those bit positions in `ans` which would contribute as minimum as possible. Thus, we set the `LSB\\'s` and those bits which are not already set.\\n\\n\\n**\\u2318 Code :**\\n\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        if(num1 == num2) return num1;\\n\\t\\t\\n        int bit = Integer.bitCount(num2);\\n\\t\\t\\n        int ans = 0;\\n\\n        for(int i=31;i>=0;i--) {\\n\\t\\t\\tint currBit = (num1 >> i) & 1;\\n            if(currBit == 1 && bit > 0) {\\n\\t\\t\\t\\tans |= (1 << i);\\n                bit--;\\n            }\\n        }\\n        \\n\\t\\t// if bits to set are remaining, set the `LSB`\\n        for(int i=0;i<32;i++) {\\n            if(bit == 0) break;\\n\\t\\t\\tint currBit = (ans >> i) & 1;\\n            if(currBit != 1) {\\n                ans |= (1 << i);\\n                bit--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        if(num1 == num2) return num1;\\n\\t\\t\\n        int bit = Integer.bitCount(num2);\\n\\t\\t\\n        int ans = 0;\\n\\n        for(int i=31;i>=0;i--) {\\n\\t\\t\\tint currBit = (num1 >> i) & 1;\\n            if(currBit == 1 && bit > 0) {\\n\\t\\t\\t\\tans |= (1 << i);\\n                bit--;\\n            }\\n        }\\n        \\n\\t\\t// if bits to set are remaining, set the `LSB`\\n        for(int i=0;i<32;i++) {\\n            if(bit == 0) break;\\n\\t\\t\\tint currBit = (ans >> i) & 1;\\n            if(currBit != 1) {\\n                ans |= (1 << i);\\n                bit--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650706,
                "title": "deep-explanation-and-solution-for-someone-who-isn-t-good-at-bit-problems",
                "content": "# Intuition\\n\\n*For the sake of simplicity I m gonna assume nums1 to be x and nums2 to be y*\\n\\n*I am assuming ideal solution to be 0 as that\\'s the minimum ans you can get*\\n\\n- First Step of the problem is pretty staight forward i.e. to count\\nthe number of 1\\'s in x and 1\\'s in y.\\n\\n- For example purpose let\\'s assume `x = 9` `y = 7`\\n\\n- Binary representation of 7 is `0111`. Number of set bits (1\\'s) in y is `3`. You just have to convert the number in binary and count 1\\'s in it.\\n\\n- Similary Binary representation of 9 is `1001`. Number of set bits (1\\'s) is `2`;\\n\\n- Now according to the problem you have to find a integer ( assume `A`) such that `A` XOR `x` is minimum.\\n\\n- We all know xor of similar bits is 0 and different is 1.\\n    - 1 ^ 1 = 0\\n    - 1 ^ 0 = 1\\n    - 0 ^ 1 = 1\\n    - 0 ^ 0 = 0 \\n\\nSo the minimum value of `A ^ x` can only be 0 not less than that. The only way to achieve that is to have `A = x`.\\n\\n- Now in our example where `x is 9` we only have `2` bits set and number of bits we have to set is `3`. So the bits we have to set is more than bits we require to achieve ideal solution of `0`.\\n\\n- In this case we have to think about where should we set that remaining 1 bit as to achieve minimum xor value.\\n    - X - `1 0 0 1`\\n    - A -  `1 0 0 1`  first set two bits like this to have 0 xor value\\n    - The remaining 1 can either be set on right side or left side.\\n    - If I were to set the remaining bit on right side - \\n        - it will become `1 1 0 1`.\\n        - `1 1 0 1` XOR `1 0 0 1` will be `0 1 0 0` (decimal 4)\\n    - If I were to set the remaining bit on left side - \\n        - it will become `1 0 1 1`\\n        - `1 0 1 1` XOR `1 0 0 1` will be `0 0 1 0` (decimal 2)\\n- You can see from the above example of `x = 9` and `y = 7` that - \\n    *If you have excess 1\\'s i.e. more than required, you should always set it on left side as it will make the xor smaller*\\n\\n- Similary if we take example of `x = 9` and `y = 1`.  Binary representation of 1 will be `1`. So the number of 1\\'s we have at our disposal is `1` and number of `1\\'s` we require is `2`(check binary representation of `9`).\\n\\n- In this case we clearly have less `1` than required to achieve ideal solution of `0`. So -\\n    - We can either set that one bit on left side or right side and get zero in that bit position after xor.\\n    - If on Right Side - \\n        - `1 0 0 0` ^ `1 0 0 1` will be `0 0 0 1` (decimal 1);\\n    - If on Left Side\\n        - `0 0 0 1` ^ `1 0 0 1` will be `1 0 0 0` (decimal 8);\\n- You can see from the above example of `x = 9` and `y = 1` that - \\n    *If you have less 1\\'s i.e. less than required, you should always set it on right side as it will make the xor smaller*\\n\\n# Approach\\n\\nSo first count the set bits in x and y. To do that you can either use some function in your language google it or read from other posts.\\n\\nSo first step is to know where in x 1\\'s are. If u remember that\\'s what we were doing in intuition.\\n\\nTo do that you can do something like this -\\n- Run a loop from `31 ... 0`.\\n- Then left shift `1` i times and then do the `&` of it with `x` i.e `(x & (1 << i))`.\\n\\n    - let value of `i` be `3` so here `1 << 3` will be `1 0 0 0` and to know whether there\\'s a `1` in `ith` position we can simply multiply it with `x` which is `1 0 0 1`.\\n    - Multiplication operation is `&`.\\n\\n\\nNow you know how to find the position of `1\\'s` in `x`. Next step is to set that `1` in that same position in `A`.\\n\\nIt\\'s a pretty common bitwise operation to set bit at any position.\\n\\nHere how you can do it - `A |= (1 << i)`. The way this works is -\\n- I know i have to set bit at `(1 << i)` in A. Let `i = 3`.\\n- Assuming `A is initially 0`. I am just adding `0000` with `1000` that will result in `1000`.\\n    - I saw many posts using `XOR` for this which will also gives the same output.\\n\\n\\nNow after all of the above operations. The value of `A` should be equal to value of `x`.\\n\\n*But as you know that we actually have to set same amount of bits as there are in y*. So we will - \\n\\n- Run another loop for that `(0 ... 31)`\\n- Let\\'s call remaining bits to set `R`.\\n- In this loop check for unset position\\'s in `A` and start setting it to `1`. Continue this `R` times as it those are the remaining bits.\\n- If you remember the point from intuition we should set the excess bit from right to left and that\\'s all we are doing.\\n- Stop the loop when `R = 0` as it is pointless to keep it running.\\n\\n# Code\\n\\nHere\\'s the C++ code on above approach.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int minimizeXor(int x, int y) \\n    {\\n        int b = __builtin_popcount(y), A = 0;\\n\\n        for(int i = 31; i >= 0 && b; i--)\\n            if(x & (1 << i))\\n                b--, A |= (1 << i);\\n        \\n        for(int i = 0; i <= 31 && b; i++)\\n            if((A & (1 << i)) == 0)\\n                b--, A |= (1 << i);\\n\\n        return A;\\n    }\\n};\\n```\\n\\n\\n# Note\\nIf someone thinks the above code is pretty verbose (You are right). You can checkout an elegant and concise way of implementing this same approach by this legendary leetcoder @lee215. [Java/C++/Python Bit Count \\uD83D\\uDD25](https://leetcode.com/problems/minimize-xor/solutions/2648723/java-c-python-bit-count/);\\n\\nThank you so much for reading this long long explanation. See Ya.",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimizeXor(int x, int y) \\n    {\\n        int b = __builtin_popcount(y), A = 0;\\n\\n        for(int i = 31; i >= 0 && b; i--)\\n            if(x & (1 << i))\\n                b--, A |= (1 << i);\\n        \\n        for(int i = 0; i <= 31 && b; i++)\\n            if((A & (1 << i)) == 0)\\n                b--, A |= (1 << i);\\n\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648918,
                "title": "log-n",
                "content": "Say `num2` has 5 bits. The initial value of `x` would be `11111`.\\n    \\nIf  `x > num1` (e.g. `num1` is `10011`), our answer is `11111`. Easy - just return `x`.\\n    \\nHowever, if `num1` is larger, we have a situation like this:\\n```\\n10100101 (num1)\\n00011111 (x)\\n```\\n\\nOur code will move the most signifficant bit of `x` to the position of most signifficant bit of `num1`.\\n    \\nSo, `x` will be transformed as follows:\\n```\\n10100101 (num1)\\n00011111 (x)\\n10001111 (bit 4 -> 7)\\n10100111 (bit 3 -> 5)\\n```\\n\\n... and the answer is `10100111`.\\n\\n**Java**\\n```java\\npublic int minimizeXor(int num1, int num2) {\\n    int b = Integer.bitCount(num2), x = (1 << b) - 1;\\n    for(int l1 = 30, l2 = b - 1; x < num1 && l2 >= 0; --l1, --l2) {\\n        while (((1 << l1) & num1) == 0)\\n            --l1;\\n        x += (1 << l1) - (1 << l2);\\n    }\\n    return x;\\n}\\n```\\n**C++**\\n```cpp\\nint minimizeXor(int num1, int num2) {\\n    int b = __builtin_popcount(num2), x = (1 << b) - 1;\\n    for(int l1 = 30, l2 = b - 1; x < num1 && l2 >= 0; --l1, --l2) {\\n        while (((1 << l1) & num1) == 0)\\n            --l1;\\n        x += (1 << l1) - (1 << l2);\\n    }\\n    return x;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n10100101 (num1)\\n00011111 (x)\\n```\n```\\n10100101 (num1)\\n00011111 (x)\\n10001111 (bit 4 -> 7)\\n10100111 (bit 3 -> 5)\\n```\n```java\\npublic int minimizeXor(int num1, int num2) {\\n    int b = Integer.bitCount(num2), x = (1 << b) - 1;\\n    for(int l1 = 30, l2 = b - 1; x < num1 && l2 >= 0; --l1, --l2) {\\n        while (((1 << l1) & num1) == 0)\\n            --l1;\\n        x += (1 << l1) - (1 << l2);\\n    }\\n    return x;\\n}\\n```\n```cpp\\nint minimizeXor(int num1, int num2) {\\n    int b = __builtin_popcount(num2), x = (1 << b) - 1;\\n    for(int l1 = 30, l2 = b - 1; x < num1 && l2 >= 0; --l1, --l2) {\\n        while (((1 << l1) & num1) == 0)\\n            --l1;\\n        x += (1 << l1) - (1 << l2);\\n    }\\n    return x;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648729,
                "title": "c-bit-geedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int cnt2 = 0;\\n        \\n        \\n        // counting set bits\\n        for(int i = 0 ; i < 32; i++){\\n            if((num2&(1<<i))) cnt2++;\\n        }\\n        int ans = 0;\\n        \\n        // xor of 1 and 1 is 0 , so minimizing num1 by setting bits in ans\\n        for(int i = 31 ; i >= 0 ; i--){\\n            if(num1&(1<<i)){\\n                ans |= (1<<i);\\n                cnt2--;\\n                if(cnt2 == 0) break;\\n            }\\n        }\\n        \\n        // number of  bits in ans should be same as num2 so setting in ans , the unset bits of num1\\n        if(cnt2 > 0){\\n            for(int i = 0 ; i < 32 ; i++){\\n                if((num1&(1<<i)) == 0){\\n                    ans |= (1<<i);\\n                    cnt2--;\\n                    if(cnt2 == 0) break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int cnt2 = 0;\\n        \\n        \\n        // counting set bits\\n        for(int i = 0 ; i < 32; i++){\\n            if((num2&(1<<i))) cnt2++;\\n        }\\n        int ans = 0;\\n        \\n        // xor of 1 and 1 is 0 , so minimizing num1 by setting bits in ans\\n        for(int i = 31 ; i >= 0 ; i--){\\n            if(num1&(1<<i)){\\n                ans |= (1<<i);\\n                cnt2--;\\n                if(cnt2 == 0) break;\\n            }\\n        }\\n        \\n        // number of  bits in ans should be same as num2 so setting in ans , the unset bits of num1\\n        if(cnt2 > 0){\\n            for(int i = 0 ; i < 32 ; i++){\\n                if((num1&(1<<i)) == 0){\\n                    ans |= (1<<i);\\n                    cnt2--;\\n                    if(cnt2 == 0) break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648710,
                "title": "c-o-logn-bit-manipulation-approach",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach**:\\n1. Brian kernighan\\u2019s algorithm: to count set bits\\n2. To minimize overall XOR, we will try to minimize XOR at \\'Most Signigficant Bits\\' of \\'num1\\'\\n3. To minimize \\'x\\', after nullifying \\'num1\\', if we are still left with set bits count from \\'num2\\', we will set \\'Least Significant Bits\\' of \\'x\\' to keep \\'x\\' minimum possible\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// O(logn)\\n    int countSetBits(int n){\\n        int c=0;\\n        while(n>0){\\n            int rmsb=n&(-n); // rightmost set bit\\n            n-=rmsb;\\n            c++;\\n        }\\n        return c;\\n    }\\n    \\n    int minimizeXor(int num1, int num2) {\\n        int c=countSetBits(num2);\\n        \\n        int x=0; // building answer by nullifying MSB\\'s of \\'num1\\' for \\'Overall Minimum XOR\\'\\n        for(int bit=31;bit>=0;bit--){\\n            if((num1 & (1<<bit))>0 && c>0){\\n                x |= (1<<bit);\\n                c--;\\n            }\\n        }\\n        \\n\\t   // setting LSB\\'s of \\'x\\' so that \\'count of set bits are same as num2\\' & keeping value of \\'x\\' as minimum possible \\n        for(int bit=0;bit<=31;bit++){\\n            if(c>0 && (x & (1<<bit))==0){\\n                x |= (1<<bit);\\n                c--;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```\\n\\n**Do Upvote If It Helps**",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// O(logn)\\n    int countSetBits(int n){\\n        int c=0;\\n        while(n>0){\\n            int rmsb=n&(-n); // rightmost set bit\\n            n-=rmsb;\\n            c++;\\n        }\\n        return c;\\n    }\\n    \\n    int minimizeXor(int num1, int num2) {\\n        int c=countSetBits(num2);\\n        \\n        int x=0; // building answer by nullifying MSB\\'s of \\'num1\\' for \\'Overall Minimum XOR\\'\\n        for(int bit=31;bit>=0;bit--){\\n            if((num1 & (1<<bit))>0 && c>0){\\n                x |= (1<<bit);\\n                c--;\\n            }\\n        }\\n        \\n\\t   // setting LSB\\'s of \\'x\\' so that \\'count of set bits are same as num2\\' & keeping value of \\'x\\' as minimum possible \\n        for(int bit=0;bit<=31;bit++){\\n            if(c>0 && (x & (1<<bit))==0){\\n                x |= (1<<bit);\\n                c--;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650403,
                "title": "work-on-setbits-c",
                "content": "I divided the question into three parts depemding on the set bits.\\n1. equal number of set bits.\\nex: num1 = 3(011), num2=5(101).\\nin this case the the X can be a number with the same number of set bits as num2 and with the min xor val with num1. x= 3(011) itself since xor of two same values are 0.\\n2. num1 = 9(1001) , num2=13(1101)\\nin this case the num2 has more numbers of set bits, thus possible value if X can be a number that entirely cancels out the num1 and has the extra setbits at the minimum index so that the value returned after XOR will be minimum.\\ndifference in set bits is 1. so we need to set a minimum bit in num1 to get the answer.\\nx= 1011(the first(0-index) bit is set as it return the least val.\\n3. num1 = 13(1011), num2= 9(1001)\\nnum1 has more set bits than num2, thus we need the val of X to be such a number that cancels out the msbs of num1.\\nsince we have 2 set bits in num2 we place the them in thr position of set bits of num1 iterating from backward. as we need to target the big numbers.\\nX = 1010.\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        //count set bits of num1\\n        int set1= 0;\\n        for(int i =0;i<32;i++)\\n        {\\n            if((1<<i)&num1)\\n                set1++;\\n        }\\n        \\n        //count set bits of num2\\n        int set2=0;\\n        for(int i =0;i<32;i++)\\n        {\\n            if((1<<i)&num2)\\n                set2++;\\n        }\\n        \\n        //cout<<set1<<\" \"<<set2;\\n        \\n        int ans=0;\\n        //if the no. of set bits in num2 is greater than num1.\\n        if(set2>set1)\\n        {\\n            int iter = set2-set1;\\n            //cout<<iter;\\n            for(int i =0;i<32;i++)\\n            {\\n                 if(((1<<i)&num1)==0 && iter>0)\\n                 {  \\n                   num1^=(1<<i);\\n                   iter--;\\n                 }\\n            }\\n            return num1;\\n        }\\n        //if same no.of bits\\n        else if(set2==set1)\\n            return num1;\\n        \\n        //if the no. bits in num1 > no. bits in num2\\n        \\n        int iter = set2;\\n        ans=0;\\n        for(int i = 31;i>=0;i--)\\n        {\\n            if((1<<i)&num1 && iter>0)\\n            {\\n                ans+=(1<<i);\\n                iter--;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/6ac7e967-2db1-4732-8992-c032b59f4adc_1664703773.3500028.jpeg)\\ni\\'m trying to figure out how to explain better.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        //count set bits of num1\\n        int set1= 0;\\n        for(int i =0;i<32;i++)\\n        {\\n            if((1<<i)&num1)\\n                set1++;\\n        }\\n        \\n        //count set bits of num2\\n        int set2=0;\\n        for(int i =0;i<32;i++)\\n        {\\n            if((1<<i)&num2)\\n                set2++;\\n        }\\n        \\n        //cout<<set1<<\" \"<<set2;\\n        \\n        int ans=0;\\n        //if the no. of set bits in num2 is greater than num1.\\n        if(set2>set1)\\n        {\\n            int iter = set2-set1;\\n            //cout<<iter;\\n            for(int i =0;i<32;i++)\\n            {\\n                 if(((1<<i)&num1)==0 && iter>0)\\n                 {  \\n                   num1^=(1<<i);\\n                   iter--;\\n                 }\\n            }\\n            return num1;\\n        }\\n        //if same no.of bits\\n        else if(set2==set1)\\n            return num1;\\n        \\n        //if the no. bits in num1 > no. bits in num2\\n        \\n        int iter = set2;\\n        ans=0;\\n        for(int i = 31;i>=0;i--)\\n        {\\n            if((1<<i)&num1 && iter>0)\\n            {\\n                ans+=(1<<i);\\n                iter--;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2648843,
                "title": "easy-to-understand-python-code-using-bit-counting",
                "content": "The approach is simple,\\n1. First count the number of 1\\'s in num2 and store in c\\n2. We want to set c no. of 1\\'s in the required num wherever we find a set bit num1(this is because 1^1 = 0. \\n3. Remember we go from MSB because we want to use c no.of 1\\'s most effectively to reduce more value.\\n4. After setting c 1\\'s if you are still left with some 1\\'s then place them at unset bits from LSB.\\n5. This way we get the minimum XOR value.\\n```\\n        c = 0\\n        for i in range(32):\\n            if num2 & (1<<i):\\n                c+=1\\n        num = 0\\n        for i in range(31,-1,-1):\\n            if (num1 & (1<<i)) and c>0:\\n                num+=pow(2,i)\\n                c-=1\\n        s = str(bin(num)[2:])\\n        s = \"0\"*(32-len(s))+s\\n        i = 31\\n        while(c>0 and i>0):\\n            if (s[i]==\"0\"):\\n                s = s[:i]+\"1\"+s[i+1:]\\n                c-=1\\n            else:\\n                i-=1\\n        return int(s,2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        c = 0\\n        for i in range(32):\\n            if num2 & (1<<i):\\n                c+=1\\n        num = 0\\n        for i in range(31,-1,-1):\\n            if (num1 & (1<<i)) and c>0:\\n                num+=pow(2,i)\\n                c-=1\\n        s = str(bin(num)[2:])\\n        s = \"0\"*(32-len(s))+s\\n        i = 31\\n        while(c>0 and i>0):\\n            if (s[i]==\"0\"):\\n                s = s[:i]+\"1\"+s[i+1:]\\n                c-=1\\n            else:\\n                i-=1\\n        return int(s,2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652127,
                "title": "idea-explained-bit-manipulation-and-greedy-approach-c-clean-code",
                "content": "**Intuition :**\\n---------------------------\\n---------------------------\\n* Idea here is to greedily try to form a number that follows given conditions. We need to use bit manipulation to compute required number.\\n\\n* Let us first note some key observations :\\n\\t* XOR of two numbers say `a` and `b` is minimum ***if set bits of both occur at common indices*** (as many as possible) starting from **MSB** (Most Significant Bit) to **LSB** (Least Significant Bit).\\n\\t\\t\\n\\t\\t\\t a = {a[n], a[n-1], . . . . ., a[3], a[2], a[1], a[0]} (in binary representation)\\n\\t\\t\\t b = {b[n], b[n-1], . . . . ., b[3], b[2], b[1], b[0]} (in binary representation)\\n\\t\\t\\t \\n\\t\\t\\t Now, if we can want (a ^ b) to have min val, we need to make as many set bits of a and b common as possible. But why ? \\n\\n\\t\\t\\t-> Because to get minimal value, we need to make as many (a[i] ^ b[i] == 0) as possible.\\n\\t\\t\\t \\n\\t\\t\\t So, for some ith bit, to minimize overall xor, we need (a[i] ^ b[i] == 0), lets see various cases : \\n\\t\\t\\t 1. a[i] = 0, then b[i] = 0, so that (a[i] ^ b[i] == 0). In this case we do not need to worry.\\n\\t\\t\\t 2. a[i] = 1, then b[i] = 1, so that (a[i] ^ b[i] == 0). Here we need to have b[i] set to 1 always to minimize.\\n\\n\\n* Now, let us use above observation(s) to deduce a **greedy** approach.\\n\\t* First of all we are given number of set bits that we want in **resultant** number, say `num`. And it is equal to number of bits set in `num2`.\\n\\t* Next, since we want as many common bits in `num` set so that **XOR** with `num1` is minimal.\\n\\t\\t* To achive this, we *must* start iterating from **MSB to LSB**, set bit of `num1`, and make same bits set for `num` as well.\\n\\t\\t* So that `(num[i] ^ num1[i] == 0)`, `i` is the ith bit.\\n\\t* If number of set bits in `num` is equal to that of `num2`, then we can return `num`, since we cannot further minimize XOR, even if some set bits in `num1` are left.\\n\\t* Now, there can an edge case when we have already matched all set bits of `num` and `num1` i.e `setBitsNum1 < setBitsNum2`. \\n\\t\\t* For this, we will change our strategy, and start setting bits in `num` from LSB to MSB (if not already set).\\n\\t\\t* Doing this, we would try to get as minimum XOR of `num` and `num2` as possible.\\n\\n* Not clear yet ? No worries, lets look at an example : \\n\\n\\t\\tEx : num1 = 9 (\\'1 0 0 1\\'), num2 = 14(\\'1 1 1 0\\') => setBitsCount2 = 3\\n\\t\\t\\n\\t\\tInitially, num = 0 (\\'0 0 0 0\\'). Start iterating from i = 31 to 0, but for example we will do from i = 3 to 0.\\n\\t\\t\\n\\t\\t*  i = 3, num1[i] = 1, so num[i] must also be set => num[i] = 1\\n\\t\\t\\t-> num = \\'1 0 0 0\\' , setBitsCount = 1\\n\\t\\t\\t\\n\\t\\t* i = 2, num1[i] = 0, no need to set this bit.\\n\\t\\t\\t-> num = \\'1 0 0 0\\' , setBitsCount = 1\\n\\t\\t\\t\\n\\t\\t* i = 1, num1[i] = 0, no need to set this bit again.\\n\\t\\t\\t-> num = \\'1 0 0 0\\' , setBitsCount = 1\\n\\t\\t\\t\\n\\t\\t* i = 0, num1[i] = 1, so num[i] must also be set => num[i] = 1\\n\\t\\t\\t-> num = \\'1 0 0 1\\' , setBitsCount = 2\\n\\t\\t\\t\\n\\t\\tNow, since setBitsCount has still 1 bit to be equal to setBitsCount2. So we need to start setting unset bits in num from LSB to MSB i.e i = 0 to 31. (here i = 0 to 3)\\n\\t\\t\\n\\t\\t* i = 0, num[i] = 1, so cannot set it again. Move to next\\n\\t\\t* i = 1, num[i] = 0, we can set this bit. => num[i] = 1 now.\\n\\t\\t\\t-> also we have setBitsCount = setBitsCount2 = 3\\n\\t\\t\\t-> num = \\'1 0 1 1\\'\\n\\t\\t\\t\\n\\t\\tAlso, XOR(num, num1) = \\'1011\\' ^ \\'1001\\' = \\'0010\\' = 2 (minimal xor)\\n\\t\\t\\n\\t\\tThus, num = \\'1011\\' = 11 (Hurray, we got our result) !!\\n---------------------------\\n# Code :\\n---------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int setBitsNum2 = __builtin_popcount(num2); // Count of set bits in num2\\n        \\n        long long num = 0; // Resultant number x\\n        \\n\\t\\t// Try to match set bits in num1 with that in num\\n        for(long long i=32; i>=0; i--) {  // MSB -> LSB \\n            if(setBitsNum2) {\\n\\t\\t\\t\\t// If ith bit of num1 is set then set this for num as well\\n                if((1LL<<i) & num1) {\\n                    setBitsNum2--; // decrement count of set bits\\n                    num |= (1 << i); // set ith bit of num\\n                }\\n            }\\n            else {\\n                return num;\\n            }\\n        }\\n        \\n\\t\\t// Set all remaining number of bit in num that are not already set\\n\\t\\t// so that we can match count of set bits in num and num2\\n        for(long long i=0; i<32; i++) { // LSB -> MSB\\n            if(setBitsNum2) {\\n                if(!((1<<i) & num)) {\\n                    num |= (1<<i);\\n                    setBitsNum2--;\\n                }\\n            }\\n            else {\\n                return num;\\n            }\\n        }\\n\\n        return num;\\n    }\\n};\\n```\\n---------------------------\\n\\n**Complexity :**\\n---------------------------\\n\\n* **Time :** `~O(log N)`, number of bits in `num2`\\n* **Space :** `O(N)`, to store `num`\\n---------------------------\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int setBitsNum2 = __builtin_popcount(num2); // Count of set bits in num2\\n        \\n        long long num = 0; // Resultant number x\\n        \\n\\t\\t// Try to match set bits in num1 with that in num\\n        for(long long i=32; i>=0; i--) {  // MSB -> LSB \\n            if(setBitsNum2) {\\n\\t\\t\\t\\t// If ith bit of num1 is set then set this for num as well\\n                if((1LL<<i) & num1) {\\n                    setBitsNum2--; // decrement count of set bits\\n                    num |= (1 << i); // set ith bit of num\\n                }\\n            }\\n            else {\\n                return num;\\n            }\\n        }\\n        \\n\\t\\t// Set all remaining number of bit in num that are not already set\\n\\t\\t// so that we can match count of set bits in num and num2\\n        for(long long i=0; i<32; i++) { // LSB -> MSB\\n            if(setBitsNum2) {\\n                if(!((1<<i) & num)) {\\n                    num |= (1<<i);\\n                    setBitsNum2--;\\n                }\\n            }\\n            else {\\n                return num;\\n            }\\n        }\\n\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648689,
                "title": "c-bit-manipulation-clean-code",
                "content": "**Video Solution :** \\n\\n[https://www.youtube.com/watch?v=15fhGf8h8d0](http://)\\n\\n\\n**Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count=__builtin_popcount(num2);\\n        \\n        int i;\\n        int fres=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            if(num1 & (1<<i)  and count)\\n            {\\n                fres|=(1<<i);\\n                count--;\\n            }\\n        }\\n        for(i=0;i<=31 and count;i++)\\n        {\\n            if(!(fres & (1<<i)))\\n            {\\n                fres|=(1<<i);\\n                count--;\\n            }\\n        }\\n        return fres;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count=__builtin_popcount(num2);\\n        \\n        int i;\\n        int fres=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            if(num1 & (1<<i)  and count)\\n            {\\n                fres|=(1<<i);\\n                count--;\\n            }\\n        }\\n        for(i=0;i<=31 and count;i++)\\n        {\\n            if(!(fres & (1<<i)))\\n            {\\n                fres|=(1<<i);\\n                count--;\\n            }\\n        }\\n        return fres;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653968,
                "title": "cpp-easy-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int cnt = 0,ans = 0;\\n        \\n\\t\\t//// counting number of set bits in num2\\n        for(int i=0;i<32;i++){\\n            cnt+=((num2>>i)&1);\\n        }\\n        \\n\\t\\t//// setting the bit of x at positions where bit of num1 is set (from left to right) or ( most to least significant bit)\\n        for(int i=31;i>=0 && cnt;i--){\\n            if(((num1>>i)&1)){\\n                ans|=(1<<i); /// setting ith bit\\n                cnt--;\\n            }\\n        }\\n        \\n\\t\\t/// setting the remaining cnt bits from (right to left) or (least to most significant bit)\\n        for(int i=0;i<32 && cnt;i++){\\n            if(!((num1>>i)&1)){\\n                ans|=(1<<i); /// setting ith bit\\n                cnt--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int cnt = 0,ans = 0;\\n        \\n\\t\\t//// counting number of set bits in num2\\n        for(int i=0;i<32;i++){\\n            cnt+=((num2>>i)&1);\\n        }\\n        \\n\\t\\t//// setting the bit of x at positions where bit of num1 is set (from left to right) or ( most to least significant bit)\\n        for(int i=31;i>=0 && cnt;i--){\\n            if(((num1>>i)&1)){\\n                ans|=(1<<i); /// setting ith bit\\n                cnt--;\\n            }\\n        }\\n        \\n\\t\\t/// setting the remaining cnt bits from (right to left) or (least to most significant bit)\\n        for(int i=0;i<32 && cnt;i++){\\n            if(!((num1>>i)&1)){\\n                ans|=(1<<i); /// setting ith bit\\n                cnt--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651788,
                "title": "xor-property",
                "content": "# Intuition\\nXor properties\\n- `1 xor 1 = 0`\\n- `1 xor 0 = 1`\\n\\nWe first count the number of bits in `nums2` after that we try to unset all the set bits in `nums1` starting from the *MSB* (Most Significant Bit) after that if we are still left with some bits then we set we bits that are unset in `nums1` starging from the *LSB* (Least Significant Bit).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Count the bits\\'s in `nums2` store in a variable `count`;\\n2. Set all the bit\\'s in `res` that are set in `nums1` from *`[31, 0]`*;\\n3. In case we still have `count` left set the bit\\'s that are unset in `nums1` form *`[0, 31]`*.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(1)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        for(int i = 0; i < 32; i++) {\\n            if(num2 & (1 << i)) // set bit\\n                count++;\\n        }\\n\\n        int res = 0;\\n        for(int i = 31; count && i >= 0; i--) {\\n            if(num1 & (1 << i)) { // set bit\\n                res |= (1 << i);\\n                count--;\\n            }\\n        }\\n\\n        for(int i = 0; count && i < 31; i++) {\\n            if(!(num1 & (1 << i))) { // not-set bit\\n                res |= (1 << i);\\n                count--;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        for(int i = 0; i < 32; i++) {\\n            if(num2 & (1 << i)) // set bit\\n                count++;\\n        }\\n\\n        int res = 0;\\n        for(int i = 31; count && i >= 0; i--) {\\n            if(num1 & (1 << i)) { // set bit\\n                res |= (1 << i);\\n                count--;\\n            }\\n        }\\n\\n        for(int i = 0; count && i < 31; i++) {\\n            if(!(num1 & (1 << i))) { // not-set bit\\n                res |= (1 << i);\\n                count--;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650545,
                "title": "c-bit-count",
                "content": "**Approach:**\\nFirst count the  \\'cnt\\' i.e. number of bit in num2 and try to set the most significant bit of num1 to 0 to obtain minimum XOR.\\nFor this purpose take a varible \\'res\\'=0 and set \\'cnt\\' number of bit in such a way that by taking XOR to the num1 the most significant bit of num1 become 0.\\n\\nLet suppose you obtain the minimum and now you haven\\'t even use the total number of bit present in num2 , but you have to do that So, for that set them from the least significant bit of the \\'res\\' variable.\\n\\n\\t\\n\\tint minimizeXor(int num1, int num2) {\\n        int cnt= __builtin_popcount(num2);\\n        int res=0;\\n        for(int i=60; i>=0 && cnt>0; i--)\\n        {\\n           \\n            if( 1ll<<i & num1 ) \\n                res += 1ll<<i, cnt--;\\n        }\\n        if(cnt>0)\\n        {\\n            for(int i=0; i<60 && cnt>0; i++)\\n            {\\n                if(((1ll<<i) & res)==0)\\n                    res+= 1ll<<i, cnt--;\\n\\t\\t\\t}\\n        }\\n        return res;\\n    }\\n\\t\\n\\t\\n**Please Upvote;\\nHAPPY CODING**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "**Approach:**\\nFirst count the  \\'cnt\\' i.e. number of bit in num2 and try to set the most significant bit of num1 to 0 to obtain minimum XOR.\\nFor this purpose take a varible \\'res\\'=0 and set \\'cnt\\' number of bit in such a way that by taking XOR to the num1 the most significant bit of num1 become 0.\\n\\nLet suppose you obtain the minimum and now you haven\\'t even use the total number of bit present in num2 , but you have to do that So, for that set them from the least significant bit of the \\'res\\' variable.\\n\\n\\t\\n\\tint minimizeXor(int num1, int num2) {\\n        int cnt= __builtin_popcount(num2);\\n        int res=0;\\n        for(int i=60; i>=0 && cnt>0; i--)\\n        {\\n           \\n            if( 1ll<<i & num1 ) \\n                res += 1ll<<i, cnt--;\\n        }\\n        if(cnt>0)\\n        {\\n            for(int i=0; i<60 && cnt>0; i++)\\n            {\\n                if(((1ll<<i) & res)==0)\\n                    res+= 1ll<<i, cnt--;\\n\\t\\t\\t}\\n        }\\n        return res;\\n    }\\n\\t\\n\\t\\n**Please Upvote;\\nHAPPY CODING**",
                "codeTag": "Unknown"
            },
            {
                "id": 2648659,
                "title": "short-and-simple-solution-c-set-bits-to-msb-0ms",
                "content": "```\\nint getNumOfBits(int nums){\\n        int count = 0;\\n        while(nums){\\n            nums &= (nums-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    int minimizeXor(int num1, int num2) {\\n        int bits = getNumOfBits(num2);\\n        int ans = 0;\\n        for(int i =31 ; i>= 0; i--){\\n            int mask = 1 << i;\\n\\t\\t\\t// check if no of bits are more than high bits present in num1 \\n\\t\\t\\t// OR current bit of num 1 is high then set bit of ans to 1\\n            if((bits-1 == i) || ((num1&mask) && bits)){\\n                ans|= mask;\\n                bits--;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getNumOfBits(int nums){\\n        int count = 0;\\n        while(nums){\\n            nums &= (nums-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    int minimizeXor(int num1, int num2) {\\n        int bits = getNumOfBits(num2);\\n        int ans = 0;\\n        for(int i =31 ; i>= 0; i--){\\n            int mask = 1 << i;\\n\\t\\t\\t// check if no of bits are more than high bits present in num1 \\n\\t\\t\\t// OR current bit of num 1 is high then set bit of ans to 1\\n            if((bits-1 == i) || ((num1&mask) && bits)){\\n                ans|= mask;\\n                bits--;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2717606,
                "title": "easiest-best-solution-in-c",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int i=0,countSetBits_num2=0,countSetBits_num1=0;\\n        for(int i=0;i<32;i++){\\n            if((num2 & (1<<i))!=0)\\n                countSetBits_num2++;\\n            if((num1 & (1<<i))!=0)\\n                countSetBits_num1++;\\n        }\\n        int diff=countSetBits_num2 - countSetBits_num1;\\n        if(diff==0)\\n            return num1;\\n        else if(diff<0){\\n            diff=abs(diff);\\n            while(diff!=0 && i<32){\\n                if((num1 & (1<<i))!=0){\\n                    num1 ^= (1<<i);\\n                    diff--;\\n                }\\n                i++;\\n            }\\n            return num1;\\n        }\\n        else{\\n            int i=0;\\n            while(diff!=0 && i<32){\\n                if((num1 & (1<<i))==0){\\n                    num1 ^= (1<<i);\\n                    diff--;\\n                }\\n                i++;\\n            }\\n            return num1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int i=0,countSetBits_num2=0,countSetBits_num1=0;\\n        for(int i=0;i<32;i++){\\n            if((num2 & (1<<i))!=0)\\n                countSetBits_num2++;\\n            if((num1 & (1<<i))!=0)\\n                countSetBits_num1++;\\n        }\\n        int diff=countSetBits_num2 - countSetBits_num1;\\n        if(diff==0)\\n            return num1;\\n        else if(diff<0){\\n            diff=abs(diff);\\n            while(diff!=0 && i<32){\\n                if((num1 & (1<<i))!=0){\\n                    num1 ^= (1<<i);\\n                    diff--;\\n                }\\n                i++;\\n            }\\n            return num1;\\n        }\\n        else{\\n            int i=0;\\n            while(diff!=0 && i<32){\\n                if((num1 & (1<<i))==0){\\n                    num1 ^= (1<<i);\\n                    diff--;\\n                }\\n                i++;\\n            }\\n            return num1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656230,
                "title": "python-3-bit-manipulation-t-m-90-50",
                "content": "The plan here is to determine the number of bits in num2, and use that count of bits to construct an integer by mirroring the 1-bits of num1 (starting with the most significant bit). If any bits remain after this iteration, we iterate in reverse and put them in the least significant 0-bits remaining.\\n\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n\\t\\t\\n\\t\\tnum1 = bin(num1)[2:].rjust(31,\\'0\\'),\\n        bitNum, ans =  bin(num2).count(\\'1\\'), [\\'0\\']*31\\n\\n        for i in range(31):\\n\\n            if num1[i] == \\'1\\':\\n                ans[i] = \\'1\\'\\n                bitNum-= 1\\n\\n                if bitNum == 0: break\\n                \\n        else:\\n            for i in range(31)[::-1]:\\n \\n                if num1[i] == \\'0\\':\\n                    ans[i] = \\'1\\'\\n                    bitNum-= 1\\n                    \\n                    if bitNum == 0: break\\n\\n        return int(\\'\\'.join(ans),2)\\n```\\n[https://leetcode.com/submissions/detail/814309464/](http://)\\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n\\t\\t\\n\\t\\tnum1 = bin(num1)[2:].rjust(31,\\'0\\'),\\n        bitNum, ans =  bin(num2).count(\\'1\\'), [\\'0\\']*31\\n\\n        for i in range(31):\\n\\n            if num1[i] == \\'1\\':\\n                ans[i] = \\'1\\'\\n                bitNum-= 1\\n\\n                if bitNum == 0: break\\n                \\n        else:\\n            for i in range(31)[::-1]:\\n \\n                if num1[i] == \\'0\\':\\n                    ans[i] = \\'1\\'\\n                    bitNum-= 1\\n                    \\n                    if bitNum == 0: break\\n\\n        return int(\\'\\'.join(ans),2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650722,
                "title": "c-intuitive-easy-understanding",
                "content": "Intuition : It is a simple question in which we have to find the minimum xor value\\nStep 1 : Calculate the number of set bits of the second number\\nStep 2: Convert the first number into binary string because we have to do some operation on that\\nStep 3: Calculate the number of set bits of the first number \\nStep 4: Check the difference of the set bits of from both the numbers\\nNote: Basics of xor property that if we do 0 ^(xor)  0 = it results to 0(zero) otherwise it is always one\\nStep 5: If the first number have more number of set bits then we calculate how much no of set bits is more than from second number and store it after that we know that in the first number that have set bits we cannot make zero and we have to make minimum number so we replace 0 from 1 with unit places to make them smaller number.\\nStep 6: If the second number have set bits is greater than first number than we can remove extra set bits from the first number to minimize the number.\\n\\nCode:\\n1. \\t#define ll long long\\n1. \\tclass Solution {\\n1. \\tpublic:\\n1. \\t\\tint count(int n)\\n1. \\t\\t{\\n1. \\t\\t\\tint count = 0;\\n1. \\t\\t\\twhile(n) \\n1. \\t\\t\\t{\\n1. \\t\\t\\t\\tcount+=n&1;\\n1. \\t\\t\\t\\tn>>=1;\\n1. \\t\\t\\t}\\n1. \\t\\t\\treturn count;\\n1. \\t\\t}\\n1. \\t\\tstring binary(int n)\\n1. \\t\\t{\\n1. \\t\\t\\tstring s;\\n1. \\t\\t\\tfor (int i = 31; i >= 0; i--) {\\n1. \\t\\t\\t\\tint k = n >> i;\\n1. \\t\\t\\t\\tif (k & 1)\\n1. \\t\\t\\t\\t\\ts.push_back(\\'1\\');\\n1. \\t\\t\\t\\telse\\n1. \\t\\t\\t\\t\\ts.push_back(\\'0\\');\\n1. \\t\\t\\t}\\n1. \\t\\t\\treturn s;\\n1. \\t\\t}\\n1. \\t\\tint decimal(int n)\\n1. \\t\\t{\\n1. \\t\\t\\tint num = n;\\n1. \\t\\t\\tint dec_value = 0;\\n1. \\t\\t\\tint base = 1;\\n1. \\t\\t\\tint temp = num;\\n1. \\t\\t\\twhile (temp) {\\n1. \\t\\t\\t\\tint last_digit = temp % 10;\\n1. \\t\\t\\t\\ttemp = temp / 10;\\n1. \\t\\t\\t\\tdec_value += last_digit * base;\\n1. \\t\\t\\t\\tbase = base * 2;\\n1. \\t\\t\\t}\\n1. \\t\\t\\treturn dec_value;\\n1. \\t\\t}\\n1. \\t\\tint minimizeXor(int num1, int num2) {\\n1. \\t\\t\\tll n=count(num2);\\n1. \\t\\t\\tstring temp=binary(num1);\\n1. \\t\\t\\tll m=count(num1);\\n1. \\t\\t\\tll x=n-m;\\n1. \\t\\t\\tll y=m-n;\\n1. \\t\\t\\tstring s=temp;\\n1. \\t\\t\\tif(x>0)\\n1. \\t\\t\\t\\tfor(int i=s.size()-1;i>=0;i--){\\n1. \\t\\t\\t\\t\\tif(x==0)\\n1. \\t\\t\\t\\t\\t\\tbreak;\\n1. \\t\\t\\t\\t\\tif(x>0&&s[i]==\\'0\\'){\\n1. \\t\\t\\t\\t\\t\\ts[i]=\\'1\\';\\n1. \\t\\t\\t\\t\\t\\tx--;\\n1. \\t\\t\\t\\t\\t}\\n1. \\t\\t\\t\\t}\\n1. \\t\\t\\tif(y>0)\\n1. \\t\\t\\t\\tfor(int i=s.size()-1;i>=0;i--){\\n1. \\t\\t\\t\\t\\tif(y==0)\\n1. \\t\\t\\t\\t\\t\\tbreak;\\n1. \\t\\t\\t\\t\\tif(y>0&&s[i]==\\'1\\'){\\n1. \\t\\t\\t\\t\\t\\ts[i]=\\'0\\';\\n1. \\t\\t\\t\\t\\t\\ty--;\\n1. \\t\\t\\t\\t\\t}\\n1. \\t\\t\\t\\t}\\n1. \\t\\t\\tll ans=stoi(s,0,2);\\n1. \\t\\t\\treturn ans;\\n1. \\t\\t}\\n1. \\t};**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n1. \\tpublic:\\n1. \\t\\tint count(int n)\\n1. \\t\\t{\\n1. \\t\\t\\tint count = 0;\\n1. \\t\\t\\twhile(n) \\n1. \\t\\t\\t{\\n1. \\t\\t\\t\\tcount+=n&1;\\n1. \\t\\t\\t\\tn>>=1;\\n1. \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3039079,
                "title": "c-rust-bit-manipulation-faster-100-4-lines-only",
                "content": "**Intuition**\\nTo calculate x\\n- At first, `num1` will be the `x` for which `x XOR num1` is minimal\\n- Now, to make bit counts same as `num2`, we either have to add `1` or remove `1`  in `num1`\\'s bit representation from least significant.\\n\\n**Solution**\\n**C++**\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2, int traverse = -1) {\\n        auto toAddInX = __builtin_popcount(num2) - __builtin_popcount(num1);\\n        while (toAddInX != 0) {\\n            auto isOne = num1 & (1 << ++traverse);\\n            if (toAddInX > 0 && !isOne) num1 |= 1 << traverse, toAddInX--;\\n            if (toAddInX < 0 && isOne) num1 ^= 1 << traverse, toAddInX++;\\n        }\\n        return num1;\\n    }\\n};\\n```\\n\\nAbove implementation is a more compact form of the approach below. Same logic.\\n```c++\\nclass Solution {\\npublic:\\n    // Method to minimize the xor value between num1 and num2\\n    int minimizeXor(int num1, int num2) {\\n        // num1 will be the `x` for which `x XOR num1` is minimal\\n        auto x = num1;\\n        // Calculate the difference in set bits between num2 and x. Can be positive or negative.\\n        auto toAddInX = __builtin_popcount(num2) - __builtin_popcount(x);\\n        // Initialize a variable to keep track of the current bit position\\n        int traverse = 0;\\n        // Loop until the difference in set bits is 0\\n        while (toAddInX != 0) {\\n            // Check if the current bit in x is set\\n            auto isOne = x & (1 << traverse);\\n            // If the difference in set bits is positive and the current bit is not set, set the bit and decrement the difference\\n            if (toAddInX > 0 && !isOne) {\\n                x |= 1 << traverse;\\n                toAddInX--;\\n            }\\n            // If the difference in set bits is negative and the current bit is set, unset the bit and increment the difference\\n            if (toAddInX < 0 && isOne) {\\n                x ^= 1 << traverse;\\n                toAddInX++;\\n            }\\n            // Move to the next bit\\n            traverse++;\\n        }\\n        // Return the modified value of x\\n        return x;\\n    }\\n};\\n```\\n\\n**Rust**\\n\\n```rust\\nimpl Solution {\\n    pub fn minimize_xor(num1: i32, num2: i32) -> i32 {\\n        let (mut traverse, mut x) = (0, num1);\\n        let mut to_add_in_x = num2.count_ones() as i32 - num1.count_ones() as i32;\\n        while to_add_in_x != 0 {\\n            let is_one = x & (1 << traverse);\\n            if to_add_in_x > 0 && is_one == 0 {\\n                x |= 1 << traverse;\\n                to_add_in_x -= 1;\\n            }\\n            if to_add_in_x < 0 && is_one != 0 {\\n                x ^= 1 << traverse;\\n                to_add_in_x += 1;\\n            }\\n            traverse += 1;\\n        }\\n        x \\n    }\\n}\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [
                    "C",
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2, int traverse = -1) {\\n        auto toAddInX = __builtin_popcount(num2) - __builtin_popcount(num1);\\n        while (toAddInX != 0) {\\n            auto isOne = num1 & (1 << ++traverse);\\n            if (toAddInX > 0 && !isOne) num1 |= 1 << traverse, toAddInX--;\\n            if (toAddInX < 0 && isOne) num1 ^= 1 << traverse, toAddInX++;\\n        }\\n        return num1;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    // Method to minimize the xor value between num1 and num2\\n    int minimizeXor(int num1, int num2) {\\n        // num1 will be the `x` for which `x XOR num1` is minimal\\n        auto x = num1;\\n        // Calculate the difference in set bits between num2 and x. Can be positive or negative.\\n        auto toAddInX = __builtin_popcount(num2) - __builtin_popcount(x);\\n        // Initialize a variable to keep track of the current bit position\\n        int traverse = 0;\\n        // Loop until the difference in set bits is 0\\n        while (toAddInX != 0) {\\n            // Check if the current bit in x is set\\n            auto isOne = x & (1 << traverse);\\n            // If the difference in set bits is positive and the current bit is not set, set the bit and decrement the difference\\n            if (toAddInX > 0 && !isOne) {\\n                x |= 1 << traverse;\\n                toAddInX--;\\n            }\\n            // If the difference in set bits is negative and the current bit is set, unset the bit and increment the difference\\n            if (toAddInX < 0 && isOne) {\\n                x ^= 1 << traverse;\\n                toAddInX++;\\n            }\\n            // Move to the next bit\\n            traverse++;\\n        }\\n        // Return the modified value of x\\n        return x;\\n    }\\n};\\n```\n```rust\\nimpl Solution {\\n    pub fn minimize_xor(num1: i32, num2: i32) -> i32 {\\n        let (mut traverse, mut x) = (0, num1);\\n        let mut to_add_in_x = num2.count_ones() as i32 - num1.count_ones() as i32;\\n        while to_add_in_x != 0 {\\n            let is_one = x & (1 << traverse);\\n            if to_add_in_x > 0 && is_one == 0 {\\n                x |= 1 << traverse;\\n                to_add_in_x -= 1;\\n            }\\n            if to_add_in_x < 0 && is_one != 0 {\\n                x ^= 1 << traverse;\\n                to_add_in_x += 1;\\n            }\\n            traverse += 1;\\n        }\\n        x \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652033,
                "title": "c-0ms-solution-with-comments",
                "content": "```\\nint minimizeXor(int num1, int num2) {\\n\\t//note : case1 and case2 are not necessary for this code to run just for awareness!\\n\\n   //case 1 : if setbits of num1 and num2 are same simply return num1;\\n\\tif (__builtin_popcount(num1) == __builtin_popcount(num2))  return num1;\\n\\n\\tint cnt = __builtin_popcount(num2);\\n\\n   //case 2 : if num1 < smallest no. made by cnt \\n\\tint mini = (1 << cnt) - 1;\\n\\tif (num1 < mini)  \\n\\t\\treturn mini; \\n\\n\\tint ans = 0;\\n\\t//XOR of 1 and 1 is 0, we want minimal value of ans, so we can think of neutralising 1\\'s from num1 from most significant position to least....\\n\\tfor (int i = 31; cnt && i >=0; i--)\\n\\t{\\n\\t\\tif (num1 & (1<<i))\\n\\t\\t{\\n\\t\\t\\tans |= (1<<i); \\n\\t\\t\\tcnt--;\\n\\t\\t}\\n\\t}      \\n\\t//if setbits in num1 < setbits in num2, we\\'ll have to insert 1\\'s as we ran out of 1\\'s in num1, we want minimal value of ans, so we\\'ll add 1\\'s in ans from right to left.\\n\\n\\tfor (int i = 0; cnt && i < 32; i++)\\n\\t{\\n\\t\\tif ((num1 & (1<<i)) == 0) \\n\\t\\t{\\n\\t\\t\\tans |= (1<<i);\\n\\t\\t\\tcnt--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint minimizeXor(int num1, int num2) {\\n\\t//note : case1 and case2 are not necessary for this code to run just for awareness!\\n\\n   //case 1 : if setbits of num1 and num2 are same simply return num1;\\n\\tif (__builtin_popcount(num1) == __builtin_popcount(num2))  return num1;\\n\\n\\tint cnt = __builtin_popcount(num2);\\n\\n   //case 2 : if num1 < smallest no. made by cnt \\n\\tint mini = (1 << cnt) - 1;\\n\\tif (num1 < mini)  \\n\\t\\treturn mini; \\n\\n\\tint ans = 0;\\n\\t//XOR of 1 and 1 is 0, we want minimal value of ans, so we can think of neutralising 1\\'s from num1 from most significant position to least....\\n\\tfor (int i = 31; cnt && i >=0; i--)\\n\\t{\\n\\t\\tif (num1 & (1<<i))\\n\\t\\t{\\n\\t\\t\\tans |= (1<<i); \\n\\t\\t\\tcnt--;\\n\\t\\t}\\n\\t}      \\n\\t//if setbits in num1 < setbits in num2, we\\'ll have to insert 1\\'s as we ran out of 1\\'s in num1, we want minimal value of ans, so we\\'ll add 1\\'s in ans from right to left.\\n\\n\\tfor (int i = 0; cnt && i < 32; i++)\\n\\t{\\n\\t\\tif ((num1 & (1<<i)) == 0) \\n\\t\\t{\\n\\t\\t\\tans |= (1<<i);\\n\\t\\t\\tcnt--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2650416,
                "title": "c-easy-to-understand-bit-manipulation",
                "content": "Initially, ans=0.\\n\\nIntution : \\n1) Number of set bits in ans = Number of set bits in nums2.\\n\\n2) Set bits in ans such that XOR with nums1 is minimised.\\n3) Iterate from most significant bit position (31) and try to match the bit of ans with bit of nums1 as XOR(0,0) = XOR(1,1) = 0.\\n\\n4) Iterate from least significant bit position (0) and set bits of ans (if not already set) to satisy point 1.\\n\\n***In other words, we want the mismatched bits to be as right as possible and macthed bits to be as right as possible to minimise the XOR.***\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int ans = 0 ;\\n        int cnt = __builtin_popcount(num2);\\n        for(int i=31;i>=0;i--){\\n            if(((1<<i) & num1) && cnt)\\n                ans += 1<<i , cnt--;\\n        }\\n        int i=0;\\n        while(cnt){\\n            if(ans & (1<<i)){\\n                i++;\\n                continue;\\n            }\\n            ans += (1<<i);\\n            cnt--;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int ans = 0 ;\\n        int cnt = __builtin_popcount(num2);\\n        for(int i=31;i>=0;i--){\\n            if(((1<<i) & num1) && cnt)\\n                ans += 1<<i , cnt--;\\n        }\\n        int i=0;\\n        while(cnt){\\n            if(ans & (1<<i)){\\n                i++;\\n                continue;\\n            }\\n            ans += (1<<i);\\n            cnt--;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650394,
                "title": "don-t-see-my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        a = 0\\n        b = num2.bit_count()\\n        \\n        for i in range(32, -1, -1):\\n            if num1&(1<<i):\\n                b -= 1\\n                a ^= 1<<i\\n                if b == 0:\\n                    break\\n        #print(a, b)\\n        x = 0\\n        while b:\\n            while a&(1<<x):\\n                x += 1\\n            a ^= 1<<x\\n            b -= 1\\n        return a\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        a = 0\\n        b = num2.bit_count()\\n        \\n        for i in range(32, -1, -1):\\n            if num1&(1<<i):\\n                b -= 1\\n                a ^= 1<<i\\n                if b == 0:\\n                    break\\n        #print(a, b)\\n        x = 0\\n        while b:\\n            while a&(1<<x):\\n                x += 1\\n            a ^= 1<<x\\n            b -= 1\\n        return a\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650195,
                "title": "0-ms-faster-than-100-simple-solution-with-comments-easy-to-understand",
                "content": "```\\n// Prerequisites\\n// How to set kth bit in n\\n// How to check if bit is set or not\\n\\nclass Solution {\\npublic:\\n    // count number of set bits\\n\\t// Brian Kernighan\\'s Algorithm\\n    int count(int n){\\n        int cnt = 0;\\n        while(n){\\n            n &= (n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int minimizeXor(int num1, int num2) {\\n        int n1 = count(num1);\\n        int n2 = count(num2);\\n        int ans = 0;\\n        // update ans to num1 if n2 > n1\\n        //if n2 > n1 we start with num1 as our ans else 0\\n        if(n2 > n1) ans = num1;\\n        // if n1 == n2 return num1 as it will be minimum xor equal to 0\\n        if(n1 == n2) return num1;\\n        else if(n1 > n2){\\n            for(int i=31; i>=0 && n2 > 0; i--){\\n                // check if ith bit is set in num1\\n                //if set then update ans and set corressponding bit in ans as well \\n                if(num1 & (1 << i)){\\n                    ans |= (1 << i);\\n                    n2--;\\n                }\\n            }\\n        }\\n        else{\\n            n2 -= n1;\\n            for(int i=0; i<32 && n2 > 0; i++){\\n                // if bit is set in ans do nothing\\n                if(ans & (1 << i)){\\n                    continue;\\n                }\\n                // if not then set and reduce n2\\n                else{\\n                    ans |= (1 << i);\\n                    n2--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n// Prerequisites\\n// How to set kth bit in n\\n// How to check if bit is set or not\\n\\nclass Solution {\\npublic:\\n    // count number of set bits\\n\\t// Brian Kernighan\\'s Algorithm\\n    int count(int n){\\n        int cnt = 0;\\n        while(n){\\n            n &= (n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int minimizeXor(int num1, int num2) {\\n        int n1 = count(num1);\\n        int n2 = count(num2);\\n        int ans = 0;\\n        // update ans to num1 if n2 > n1\\n        //if n2 > n1 we start with num1 as our ans else 0\\n        if(n2 > n1) ans = num1;\\n        // if n1 == n2 return num1 as it will be minimum xor equal to 0\\n        if(n1 == n2) return num1;\\n        else if(n1 > n2){\\n            for(int i=31; i>=0 && n2 > 0; i--){\\n                // check if ith bit is set in num1\\n                //if set then update ans and set corressponding bit in ans as well \\n                if(num1 & (1 << i)){\\n                    ans |= (1 << i);\\n                    n2--;\\n                }\\n            }\\n        }\\n        else{\\n            n2 -= n1;\\n            for(int i=0; i<32 && n2 > 0; i++){\\n                // if bit is set in ans do nothing\\n                if(ans & (1 << i)){\\n                    continue;\\n                }\\n                // if not then set and reduce n2\\n                else{\\n                    ans |= (1 << i);\\n                    n2--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649500,
                "title": "c-simple-explanation",
                "content": "**Approach:**\\n\\n* let\\n\\t* k1 = number of set bits in num1\\n\\t* k2 = number of set bits in num2\\n* remember that xor of 1^1 = 0\\n* now,\\n* if(k2>k1)\\n\\t* so to minimizing the xor we have to take all the set bits of num1 in the ans\\n\\t* and for the remaining bits, start from the rightmost side and keep changing the non-set bit from 0 to 1 \\n\\t* like: num1 = 00100011\\n\\t* nd we have 5 set bits in num2\\n\\t* so ans should be\\n\\t* ans = 00100011... first set all the bits same as num1\\n\\t* now, for the remaining 2 bits\\n\\t* ans = 00101111\\n\\t* now, we will get the min xor i.e 1100\\n* if(k2<k1)\\n\\t* in this case start from the leftmost side and keep seting the bit =1 in the ans if that bit is 1 for nums\\n\\t* because at the end we want min xor\\n\\t* like for num1 = 001000011\\n\\t* nd we have 2 set bits in num2\\n\\t* ans = 001000010\\n\\t* we set 2 leftmost bits as 1 which are set bits in num1\\n* so to implement this, start from leftmost side\\n\\t* keep seting bit as 1 if we have 1 in num1\\n\\t* if we have reached the required number of bits then break\\n* if k2 is still >0 it means we have a case of k2>k1 so, now start setting from the rightmost side\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int count(int n)\\n    {\\n        int k = 0;\\n        while (n > 0)\\n        {\\n            n = n & (n - 1);\\n            k++;\\n        }\\n        return k;\\n    }\\n    int minimizeXor(int num1, int num2)\\n    {\\n        int k1 = count(num1);\\n        int k2 = count(num2);\\n\\n        int ans = 0;\\n        for (int i = 31; i >= 0; i--)\\n        {\\n            if ((1 << i) & num1)\\n            {\\n                ans |= (1 << i);\\n                k2--;\\n                if (k2 == 0)\\n                    break;\\n            }\\n        }\\n\\n        if (k2 > 0)\\n        {\\n            for (int i = 0; i < 32; i++)\\n            {\\n                if (((1 << i) & num1) == 0)\\n                {\\n                    ans |= (1 << i);\\n                    k2--;\\n                    if (k2 == 0)\\n                        break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int count(int n)\\n    {\\n        int k = 0;\\n        while (n > 0)\\n        {\\n            n = n & (n - 1);\\n            k++;\\n        }\\n        return k;\\n    }\\n    int minimizeXor(int num1, int num2)\\n    {\\n        int k1 = count(num1);\\n        int k2 = count(num2);\\n\\n        int ans = 0;\\n        for (int i = 31; i >= 0; i--)\\n        {\\n            if ((1 << i) & num1)\\n            {\\n                ans |= (1 << i);\\n                k2--;\\n                if (k2 == 0)\\n                    break;\\n            }\\n        }\\n\\n        if (k2 > 0)\\n        {\\n            for (int i = 0; i < 32; i++)\\n            {\\n                if (((1 << i) & num1) == 0)\\n                {\\n                    ans |= (1 << i);\\n                    k2--;\\n                    if (k2 == 0)\\n                        break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648915,
                "title": "java-straightforward-count-stringbuilder",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        String s2 = Integer.toBinaryString(num2);\\n        \\n        int bits = 0;\\n        for(char ch : s2.toCharArray()) {\\n            if(ch == \\'1\\') bits++;\\n        }\\n        \\n        String s1 = Integer.toBinaryString(num1);\\n        \\n        int s1Bits = 0;\\n        for(char ch : s1.toCharArray()) {\\n            if(ch == \\'1\\') s1Bits++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(s1Bits == bits) {\\n            return num1;\\n        } else if(s1Bits > bits) {\\n            for(int i=0; i<s1.length(); i++) {\\n                if(s1.charAt(i) == \\'0\\') {\\n                    sb.append(\\'0\\');\\n                } else {\\n                    if(bits > 0) {\\n                        sb.append(\\'1\\');\\n                        bits--;\\n                    } else {\\n                        sb.append(\\'0\\');\\n                    }\\n                }\\n            }\\n            \\n            return Integer.parseInt(sb.toString(), 2);\\n            \\n        } else {\\n            bits -= s1Bits;\\n            \\n            for(int i=s1.length()-1; i>=0; i--) {\\n                if(s1.charAt(i) == \\'1\\') {\\n                    sb.append(\\'1\\');\\n                } else {\\n                    if(bits > 0) {\\n                        sb.append(\\'1\\');\\n                        bits--;\\n                    } else {\\n                        sb.append(\\'0\\');\\n                    }\\n                }\\n            }\\n            \\n            while(bits > 0) {\\n                sb.append(\\'1\\');\\n                bits--;\\n            }\\n\\n            return Integer.parseInt(sb.reverse().toString(), 2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        String s2 = Integer.toBinaryString(num2);\\n        \\n        int bits = 0;\\n        for(char ch : s2.toCharArray()) {\\n            if(ch == \\'1\\') bits++;\\n        }\\n        \\n        String s1 = Integer.toBinaryString(num1);\\n        \\n        int s1Bits = 0;\\n        for(char ch : s1.toCharArray()) {\\n            if(ch == \\'1\\') s1Bits++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(s1Bits == bits) {\\n            return num1;\\n        } else if(s1Bits > bits) {\\n            for(int i=0; i<s1.length(); i++) {\\n                if(s1.charAt(i) == \\'0\\') {\\n                    sb.append(\\'0\\');\\n                } else {\\n                    if(bits > 0) {\\n                        sb.append(\\'1\\');\\n                        bits--;\\n                    } else {\\n                        sb.append(\\'0\\');\\n                    }\\n                }\\n            }\\n            \\n            return Integer.parseInt(sb.toString(), 2);\\n            \\n        } else {\\n            bits -= s1Bits;\\n            \\n            for(int i=s1.length()-1; i>=0; i--) {\\n                if(s1.charAt(i) == \\'1\\') {\\n                    sb.append(\\'1\\');\\n                } else {\\n                    if(bits > 0) {\\n                        sb.append(\\'1\\');\\n                        bits--;\\n                    } else {\\n                        sb.append(\\'0\\');\\n                    }\\n                }\\n            }\\n            \\n            while(bits > 0) {\\n                sb.append(\\'1\\');\\n                bits--;\\n            }\\n\\n            return Integer.parseInt(sb.reverse().toString(), 2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648846,
                "title": "java-bit-count-easy-to-understand",
                "content": "\\n\\n```\\n\\t\\n    //Runtime: 0 ms, faster than 100.00% of Java online submissions for Minimize XOR.\\n    //Memory Usage: 39.2 MB, less than 60.00% of Java online submissions for Minimize XOR.\\n    //Time:O(bitCount1 - bitCount2)\\n    public int minimizeXor(int num1, int num2) {\\n        int bitCount1 = Integer.bitCount(num1);\\n        int bitCount2 = Integer.bitCount(num2);\\n        if (bitCount1 == bitCount2) return num1;\\n\\n        int res1 = num1;\\n        int res0 = bitCount1 - bitCount2 > 0 ? num1 : ~num1;\\n        for (int idx = 0; idx < Math.abs(bitCount1 - bitCount2); idx++) {\\n            int s = res0 & (-res0);\\n            res1 = res1 | s; //set 1\\n            res0 = res0 ^ s; //set 0\\n        }\\n        return bitCount1 - bitCount2 > 0 ? res0 : res1;\\n    }\\n```\\n\\n```\\n    //Runtime: 1 ms, faster than 60.00% of Java online submissions for Minimize XOR.\\n    //Memory Usage: 41.2 MB, less than 60.00% of Java online submissions for Minimize XOR.\\n    //Integer bitCount\\n    //Time: O(logNum2); Space: O(1)\\n        public int minimizeXor(int num1, int num2) {\\n        int bitCount2 = Integer.bitCount(num2);\\n        int res = 0, s, x = num1;\\n        int i = 0;\\n        \\n        //from highest\\n        while (i < bitCount2 && x != 0) {\\n            s = Integer.highestOneBit(x);\\n            res |= s;\\n            x = x ^ s;\\n            i++;\\n        }\\n\\n        //from lowest\\n        x = ~num1;\\n        while (i < bitCount2 && x != 0){\\n            s = x & (-x);\\n            res |= s;\\n            x = x ^ s;\\n            i++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\n    //Runtime: 0 ms, faster than 100.00% of Java online submissions for Minimize XOR.\\n    //Memory Usage: 39.2 MB, less than 60.00% of Java online submissions for Minimize XOR.\\n    //Time:O(bitCount1 - bitCount2)\\n    public int minimizeXor(int num1, int num2) {\\n        int bitCount1 = Integer.bitCount(num1);\\n        int bitCount2 = Integer.bitCount(num2);\\n        if (bitCount1 == bitCount2) return num1;\\n\\n        int res1 = num1;\\n        int res0 = bitCount1 - bitCount2 > 0 ? num1 : ~num1;\\n        for (int idx = 0; idx < Math.abs(bitCount1 - bitCount2); idx++) {\\n            int s = res0 & (-res0);\\n            res1 = res1 | s; //set 1\\n            res0 = res0 ^ s; //set 0\\n        }\\n        return bitCount1 - bitCount2 > 0 ? res0 : res1;\\n    }\\n```\n```\\n    //Runtime: 1 ms, faster than 60.00% of Java online submissions for Minimize XOR.\\n    //Memory Usage: 41.2 MB, less than 60.00% of Java online submissions for Minimize XOR.\\n    //Integer bitCount\\n    //Time: O(logNum2); Space: O(1)\\n        public int minimizeXor(int num1, int num2) {\\n        int bitCount2 = Integer.bitCount(num2);\\n        int res = 0, s, x = num1;\\n        int i = 0;\\n        \\n        //from highest\\n        while (i < bitCount2 && x != 0) {\\n            s = Integer.highestOneBit(x);\\n            res |= s;\\n            x = x ^ s;\\n            i++;\\n        }\\n\\n        //from lowest\\n        x = ~num1;\\n        while (i < bitCount2 && x != 0){\\n            s = x & (-x);\\n            res |= s;\\n            x = x ^ s;\\n            i++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648811,
                "title": "java-clean-simple",
                "content": "Because of ```num1 ^ num1 = 0```, We use num1 as the base and add / remove binary from it, also because we need a minimize number, we do it from the end(smallest binary).\\n\\nCount the different bitCount between num1 and num2. If ```num2 > num1 ``` we need to add binary, If ```num2 < num1``` we need to remove.\\n\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int bitCount = Integer.bitCount(num2);\\n        bitCount -= Integer.bitCount(num1);\\n\\n        int cur = 1;\\n        while (bitCount != 0) {\\n            if (bitCount < 0 && (num1 & cur) != 0) { // if num2 have less bitCount && current binary is 1\\n                num1 ^= cur; // remove binary\\n                bitCount++;\\n            } else if (bitCount > 0 && (num1 & cur) == 0) { // if num2 have bigger bitCount && current binary is 0\\n                num1 |= cur; // add binary\\n                bitCount--;\\n            }\\n\\n            cur <<= 1;\\n        }\\n\\n        return num1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```num1 ^ num1 = 0```\n```num2 > num1 ```\n```num2 < num1```\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int bitCount = Integer.bitCount(num2);\\n        bitCount -= Integer.bitCount(num1);\\n\\n        int cur = 1;\\n        while (bitCount != 0) {\\n            if (bitCount < 0 && (num1 & cur) != 0) { // if num2 have less bitCount && current binary is 1\\n                num1 ^= cur; // remove binary\\n                bitCount++;\\n            } else if (bitCount > 0 && (num1 & cur) == 0) { // if num2 have bigger bitCount && current binary is 0\\n                num1 |= cur; // add binary\\n                bitCount--;\\n            }\\n\\n            cur <<= 1;\\n        }\\n\\n        return num1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648763,
                "title": "rust-with-comments",
                "content": "This is my unrevised submission for the 2022-10-02 Weekly Contest 313. First set the bits of `x` so that we cancel out as many bits of `num1` as possible, starting from the highest bit. Then setting any remaining bits to fill the bit count of `num2` as low as possible in places where `num1` has cleared bits. The result of the XOR is then that we clear as many high bits of `num1` as possible, and set the remaining bits as low as possible.\\n\\nComment: This could probably be done a lot more elegantly with some bit twiddling. But I went for the \"brute force\" solution to solve it as quickly as possible to have time for the hard problem.\\n\\n```\\nimpl Solution {\\n    pub fn minimize_xor(num1: i32, num2: i32) -> i32 {\\n        let mut n = num2.count_ones();\\n        let mut i = 31;\\n        let mut x = 0;\\n        let mut num = num1;\\n        while n > 0 && num > 0 {\\n            let bm = 1 << (i - 1);\\n            if num & bm > 0 {\\n                num ^= bm;\\n                x |= bm;\\n                n -= 1;\\n            }\\n            i -= 1;\\n        }\\n        i = 0;\\n        while n > 0 {\\n            let bm = 1 << i;\\n            if num1 & bm == 0 {\\n                x |= bm;\\n                n -= 1;\\n            }\\n            i += 1;\\n        }\\n        x\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimize_xor(num1: i32, num2: i32) -> i32 {\\n        let mut n = num2.count_ones();\\n        let mut i = 31;\\n        let mut x = 0;\\n        let mut num = num1;\\n        while n > 0 && num > 0 {\\n            let bm = 1 << (i - 1);\\n            if num & bm > 0 {\\n                num ^= bm;\\n                x |= bm;\\n                n -= 1;\\n            }\\n            i -= 1;\\n        }\\n        i = 0;\\n        while n > 0 {\\n            let bm = 1 << i;\\n            if num1 & bm == 0 {\\n                x |= bm;\\n                n -= 1;\\n            }\\n            i += 1;\\n        }\\n        x\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648724,
                "title": "string-java",
                "content": "Input: num1 = 1, num2 = 12\\n\\nHow Code Works :\\n\\nstep 1 :  1\\nstep 2 : ********************************\\nstep 3 : *******************************1\\nstep 4 : 00000000000000000000000000000011  (is equal to 3)\\n\\nupvote if you like it\\n\\n\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int bitCountOfNum2 = Integer.bitCount(num2);\\n        int bitCountOfNum1 = Integer.bitCount(num1);\\n        if(bitCountOfNum2 == bitCountOfNum1) return num1;\\n        \\n        String bs = Integer.toBinaryString(num1);        // bs -> binary string\\n        while(bs.length() != 32) bs = \\'0\\' + bs; // make it of 32 length\\n\\t\\t\\n        // build ans character array 32 length\\n        char[] ans = \"********************************\".toCharArray();\\n        \\n        // traversing from left to right -> for maximum bit to make 0\\n        for(int i = 0; i < 32; i++) {\\n            if(bs.charAt(i) == \\'1\\' && bitCountOfNum2 > 0) {  // if bit is on in bs and bitCountOfNum2 > 0 then  (1 XOR 1 == 0)\\n                ans[i] = \\'1\\';\\n                bitCountOfNum2--;\\n            }\\n        }\\n        \\n        // traversing from right to left ->  for minimum bit to make 1\\n        for(int i = 31; i >= 0; i--) {\\n            if(ans[i] == \\'*\\' && bitCountOfNum2 > 0) {\\n                ans[i] = \\'1\\';\\n                bitCountOfNum2--;\\n            } else {\\n                if(ans[i] != \\'1\\')\\n                ans[i] = \\'0\\';\\n            }\\n        }\\n        \\n        int decimal = Integer.parseInt(new String(ans),2);\\n        return decimal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int bitCountOfNum2 = Integer.bitCount(num2);\\n        int bitCountOfNum1 = Integer.bitCount(num1);\\n        if(bitCountOfNum2 == bitCountOfNum1) return num1;\\n        \\n        String bs = Integer.toBinaryString(num1);        // bs -> binary string\\n        while(bs.length() != 32) bs = \\'0\\' + bs; // make it of 32 length\\n\\t\\t\\n        // build ans character array 32 length\\n        char[] ans = \"********************************\".toCharArray();\\n        \\n        // traversing from left to right -> for maximum bit to make 0\\n        for(int i = 0; i < 32; i++) {\\n            if(bs.charAt(i) == \\'1\\' && bitCountOfNum2 > 0) {  // if bit is on in bs and bitCountOfNum2 > 0 then  (1 XOR 1 == 0)\\n                ans[i] = \\'1\\';\\n                bitCountOfNum2--;\\n            }\\n        }\\n        \\n        // traversing from right to left ->  for minimum bit to make 1\\n        for(int i = 31; i >= 0; i--) {\\n            if(ans[i] == \\'*\\' && bitCountOfNum2 > 0) {\\n                ans[i] = \\'1\\';\\n                bitCountOfNum2--;\\n            } else {\\n                if(ans[i] != \\'1\\')\\n                ans[i] = \\'0\\';\\n            }\\n        }\\n        \\n        int decimal = Integer.parseInt(new String(ans),2);\\n        return decimal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648667,
                "title": "xor-the-real-way-c-something-to-learn-surely",
                "content": "As we know xor will be zero only when two bits are same. We will use this property in this question\\nIn the question let us convert the number given to its binary string equivalent\\nand count the set bits of the second number\\nNow we have the count of ones and zeroes we can have in our new number\\nNow traverse through the first number and compare with these cases:\\n\\n1. If current is 1: \\n            If we have ones left: add 1 to string\\n            else we have only zero left so add 0 to string\\n2. If current is 0:\\n            If we have zeroes left: add 0 to string\\n            else we have only ones left so add 1 to string\\n\\nOur goal here is to make the most significant bits 0 so that the final number is as minimum as possible\\nconvert this binary string to number equivalent\\n\\n```\\nclass Solution {\\nprivate:\\n    string numtoBinary(int num){\\n        string s = \"\";\\n        for (int i = 31; i >= 0; i--) {\\n            int curr = num >> i;\\n            if (curr & 1)\\n                s += \\'1\\';\\n            else\\n                s += \\'0\\';\\n        }\\n        return s;\\n    }\\n \\n    unsigned int countSetBit(unsigned int num)\\n    {\\n        unsigned int ans = 0;\\n        while(num) {\\n            ans += num & 1;\\n            num >>= 1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        string str=numtoBinary(num1);\\n        int one = countSetBit(num2);\\n        int zero = 32 - one;\\n        string ans = \"\";\\n        for(int i=0;i<32;i++){\\n            if(str[i] == \\'1\\'){\\n                if(one){\\n                    ans += \\'1\\';\\n                    one--;\\n                }\\n                else{\\n                    ans += \\'0\\';\\n                    zero--;\\n                }\\n            }\\n            else{\\n                if(zero){\\n                    ans += \\'0\\';\\n                    zero--;\\n                }\\n                else{\\n                    ans += \\'1\\';\\n                    one--;\\n                }\\n            }\\n        }\\n        \\n        int ansn = stoi(ans, 0, 2);\\n        return ansn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    string numtoBinary(int num){\\n        string s = \"\";\\n        for (int i = 31; i >= 0; i--) {\\n            int curr = num >> i;\\n            if (curr & 1)\\n                s += \\'1\\';\\n            else\\n                s += \\'0\\';\\n        }\\n        return s;\\n    }\\n \\n    unsigned int countSetBit(unsigned int num)\\n    {\\n        unsigned int ans = 0;\\n        while(num) {\\n            ans += num & 1;\\n            num >>= 1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        string str=numtoBinary(num1);\\n        int one = countSetBit(num2);\\n        int zero = 32 - one;\\n        string ans = \"\";\\n        for(int i=0;i<32;i++){\\n            if(str[i] == \\'1\\'){\\n                if(one){\\n                    ans += \\'1\\';\\n                    one--;\\n                }\\n                else{\\n                    ans += \\'0\\';\\n                    zero--;\\n                }\\n            }\\n            else{\\n                if(zero){\\n                    ans += \\'0\\';\\n                    zero--;\\n                }\\n                else{\\n                    ans += \\'1\\';\\n                    one--;\\n                }\\n            }\\n        }\\n        \\n        int ansn = stoi(ans, 0, 2);\\n        return ansn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648656,
                "title": "javascript-find-n-most-significant-bits-in-num1",
                "content": "**Solution: Greedy - N Most Significant Bits in num1**\\n\\nFind `n`, the number of 1-bits in `num2`.\\n\\nCreate a number with the `n` most significant bits of `num1`. \\n  (Since `1^1 = 0`, we will be minimizing the result by removing the most significant bits)\\n\\nIf `num1` has less than `n` 1-bits, take the least significant bits.\\n  (If there are no bits to remove, we need to take the bits that add the least value)\\n\\nTime Complexity: `O(32)` = `O(1)`\\nSpace Complexity: `O(1)`\\n```\\nvar minimizeXor = function(num1, num2) {\\n  let n = countOnes(num2), res = 0, ones = 0;\\n  // Take the most significant 1-bits in num1\\n  for (let i = 31; i >= 0; i--) { \\n    if (ones === n) break;\\n    if (((num1 >> i) & 1) === 1) {\\n      res |= (1 << i);\\n      ones++;\\n    }\\n  }\\n  \\n  // Take the least significant bits if there are no more 1-bits in num1\\n  for (let i = 0; i <= 31; i++) {\\n    if (ones === n) break;\\n    if (((res >> i) & 1) === 1) continue;\\n    res |= (1 << i);\\n    ones++;\\n  }\\n  return res;\\n  \\n  function countOnes(num) {\\n    let count = 0;\\n    while (num > 0) {\\n      count += (num & 1);\\n      num >>= 1;\\n    }\\n    return count;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizeXor = function(num1, num2) {\\n  let n = countOnes(num2), res = 0, ones = 0;\\n  // Take the most significant 1-bits in num1\\n  for (let i = 31; i >= 0; i--) { \\n    if (ones === n) break;\\n    if (((num1 >> i) & 1) === 1) {\\n      res |= (1 << i);\\n      ones++;\\n    }\\n  }\\n  \\n  // Take the least significant bits if there are no more 1-bits in num1\\n  for (let i = 0; i <= 31; i++) {\\n    if (ones === n) break;\\n    if (((res >> i) & 1) === 1) continue;\\n    res |= (1 << i);\\n    ones++;\\n  }\\n  return res;\\n  \\n  function countOnes(num) {\\n    let count = 0;\\n    while (num > 0) {\\n      count += (num & 1);\\n      num >>= 1;\\n    }\\n    return count;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640640,
                "title": "bit",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Step 1**: `Count the total number of set bits in num2`\\n**Step 2**: `Start turning off the bit in num1 from msb(left-side) and add that bit value to ans and decrease the count.`\\n**step 3**: `If the count still left the turn on the bit from lsb(right-side) which is turned off and decrease the count.`\\n\\n# Intution\\nWe\\'re turning off the bit from left side cuz we\\'ve to minimize the value so if we turn off the msb bit then it\\'ll help us in mnimizing the value.\\n\\n# Complexity\\n- Time complexity: $$O(32) + O(32) + O(log(num2))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int ct = __builtin_popcount(num2);\\n        int ans = 0;\\n        for(int i=31; i>-1 && ct; --i){\\n            if((num1>>i)&1){\\n                ans |= (1<<i);\\n                ct--;\\n            }\\n        }\\n        for(int j=0; j<32 && ct; ++j){\\n            if(!((ans>>j)&1)){\\n                ans |= (1<<j);\\n                ct--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int ct = __builtin_popcount(num2);\\n        int ans = 0;\\n        for(int i=31; i>-1 && ct; --i){\\n            if((num1>>i)&1){\\n                ans |= (1<<i);\\n                ct--;\\n            }\\n        }\\n        for(int j=0; j<32 && ct; ++j){\\n            if(!((ans>>j)&1)){\\n                ans |= (1<<j);\\n                ct--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374062,
                "title": "java-easy-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int a=0,b=0,n=num1;\\n        //count bits of num1\\n        while(num1>0)\\n        {\\n            num1&=(num1-1);\\n            a+=1;\\n        }\\n        //count bits of num2\\n        while(num2>0)\\n        {\\n            num2&=(num2-1);\\n            b+=1;\\n        }\\n        if(a==b)return n;\\n        else if(a<b)\\n        {\\n            int rem=b-a;\\n            //convert num1 to binary string and make its length 32\\n            String s=Integer.toBinaryString(n);\\n            while(s.length()!=32)s=\\'0\\'+s;\\n            //create char array of all characters as 0\\n            char ch[]=new char[s.length()];\\n            Arrays.fill(ch,\\'0\\');\\n            //we need to set the lower bits as 1 which are 0\\n            for(int i=s.length()-1;i>=0;i--)\\n            {\\n                if(s.charAt(i)==\\'0\\')\\n                {\\n                    ch[i]=\\'1\\';\\n                    rem-=1;\\n                }\\n                if(rem==0)break;\\n            }\\n            String sb=new String(ch);\\n            //get the number to be added to num1 by converting \\n            //the char array to string then string to number\\n            int add=Integer.parseInt(sb,2);\\n            return (n+add);\\n        }\\n        else\\n        {\\n            // this case occurs when total set bits of num1\\n            //is more than that of num2\\n            //we need to traverse the string array from 0 to 31\\n            int rem=b;\\n            String s=Integer.toBinaryString(n);\\n            while(s.length()!=32)s=\\'0\\'+s;\\n            char ch[]=new char[s.length()];\\n            Arrays.fill(ch,\\'0\\');\\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(s.charAt(i)==\\'1\\')\\n                {\\n                    ch[i]=\\'1\\';\\n                    rem-=1;\\n                }\\n                if(rem==0)break;\\n            }\\n            String sb=new String(ch);\\n            return Integer.parseInt(sb,2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int a=0,b=0,n=num1;\\n        //count bits of num1\\n        while(num1>0)\\n        {\\n            num1&=(num1-1);\\n            a+=1;\\n        }\\n        //count bits of num2\\n        while(num2>0)\\n        {\\n            num2&=(num2-1);\\n            b+=1;\\n        }\\n        if(a==b)return n;\\n        else if(a<b)\\n        {\\n            int rem=b-a;\\n            //convert num1 to binary string and make its length 32\\n            String s=Integer.toBinaryString(n);\\n            while(s.length()!=32)s=\\'0\\'+s;\\n            //create char array of all characters as 0\\n            char ch[]=new char[s.length()];\\n            Arrays.fill(ch,\\'0\\');\\n            //we need to set the lower bits as 1 which are 0\\n            for(int i=s.length()-1;i>=0;i--)\\n            {\\n                if(s.charAt(i)==\\'0\\')\\n                {\\n                    ch[i]=\\'1\\';\\n                    rem-=1;\\n                }\\n                if(rem==0)break;\\n            }\\n            String sb=new String(ch);\\n            //get the number to be added to num1 by converting \\n            //the char array to string then string to number\\n            int add=Integer.parseInt(sb,2);\\n            return (n+add);\\n        }\\n        else\\n        {\\n            // this case occurs when total set bits of num1\\n            //is more than that of num2\\n            //we need to traverse the string array from 0 to 31\\n            int rem=b;\\n            String s=Integer.toBinaryString(n);\\n            while(s.length()!=32)s=\\'0\\'+s;\\n            char ch[]=new char[s.length()];\\n            Arrays.fill(ch,\\'0\\');\\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(s.charAt(i)==\\'1\\')\\n                {\\n                    ch[i]=\\'1\\';\\n                    rem-=1;\\n                }\\n                if(rem==0)break;\\n            }\\n            String sb=new String(ch);\\n            return Integer.parseInt(sb,2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815643,
                "title": "simple-solution-using-greedy-approach-with-explanation",
                "content": "# Intuition\\n1. Convert both the numbers to binary format.\\n2. Pad them to the same length -> append zeroes to the left as needed.\\n3. Count number of ones and zeroes in the second number. \\n4. Now parse the first number\\'s binary string, and start greedily filling.\\n5. Remember that in XOR operation, different bits give \\'1\\'.\\n6. So to minimize, we need to fill in the the same value, as in first number, while parsing it. \\n7. Since we are generating the result string from the left, we are minimizing by default.\\n\\n# Approach\\n1. Implemented the intuition. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeXor(self, a: int, b: int) -> int:\\n        result = \"\"\\n        a_bin, b_bin = bin(a).lstrip(\\'0b\\'), bin(b).lstrip(\\'0b\\')\\n        ones_in_b = b_bin.count(\\'1\\')\\n\\n        if len(a_bin) < len(b_bin):\\n            a_bin = abs(len(b_bin) - len(a_bin)) * (\\'0\\') + a_bin\\n        elif len(b_bin) < len(a_bin):\\n            b_bin = abs(len(b_bin) - len(a_bin)) * (\\'0\\') + b_bin\\n        \\n        zeroes_in_b = len(b_bin) - ones_in_b\\n\\n        for i in range(len(a_bin)):\\n            if a_bin[i] == \\'0\\':\\n                if zeroes_in_b > 0:\\n                    result += \\'0\\'\\n                    zeroes_in_b -= 1\\n                elif ones_in_b > 0:\\n                    result += \\'1\\'\\n                    ones_in_b -= 1\\n            elif a_bin[i] == \\'1\\':\\n                if ones_in_b > 0:\\n                    result += \\'1\\'\\n                    ones_in_b -= 1\\n                elif zeroes_in_b > 0:\\n                    result += \\'0\\'\\n                    zeroes_in_b -= 1\\n\\n        ans = int(result, 2)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, a: int, b: int) -> int:\\n        result = \"\"\\n        a_bin, b_bin = bin(a).lstrip(\\'0b\\'), bin(b).lstrip(\\'0b\\')\\n        ones_in_b = b_bin.count(\\'1\\')\\n\\n        if len(a_bin) < len(b_bin):\\n            a_bin = abs(len(b_bin) - len(a_bin)) * (\\'0\\') + a_bin\\n        elif len(b_bin) < len(a_bin):\\n            b_bin = abs(len(b_bin) - len(a_bin)) * (\\'0\\') + b_bin\\n        \\n        zeroes_in_b = len(b_bin) - ones_in_b\\n\\n        for i in range(len(a_bin)):\\n            if a_bin[i] == \\'0\\':\\n                if zeroes_in_b > 0:\\n                    result += \\'0\\'\\n                    zeroes_in_b -= 1\\n                elif ones_in_b > 0:\\n                    result += \\'1\\'\\n                    ones_in_b -= 1\\n            elif a_bin[i] == \\'1\\':\\n                if ones_in_b > 0:\\n                    result += \\'1\\'\\n                    ones_in_b -= 1\\n                elif zeroes_in_b > 0:\\n                    result += \\'0\\'\\n                    zeroes_in_b -= 1\\n\\n        ans = int(result, 2)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790739,
                "title": "c-tc-log-n-bit-count-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int n1, int n2) {\\n        bitset<32> bt1(n1);\\n        int k= __builtin_popcount(n2); // for number of set bits\\n        int ans=0;\\n        vector<int> bits(32);\\n        for(int i=31;i>=0;i--){\\n            if(k==0){\\n                break;\\n            }\\n            if(bt1[i]==1){\\n                bits[i]=1;\\n                k--;\\n            }\\n        }\\n        for(int i=0;i<31;i++){\\n            if(k==0){\\n                break;\\n            }\\n            if(bits[i]==0){\\n               \\n                bits[i]=1;\\n                \\n                k--;\\n            }\\n        }\\n        for(int i=0;i<31;i++){\\n            ans+=pow(2,i)*bits[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizeXor(int n1, int n2) {\\n        bitset<32> bt1(n1);\\n        int k= __builtin_popcount(n2); // for number of set bits\\n        int ans=0;\\n        vector<int> bits(32);\\n        for(int i=31;i>=0;i--){\\n            if(k==0){\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2704830,
                "title": "c-bit-manipulation-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int setbits = 0,n2=num2,availablebits=0,n1=num1;\\n        vector<int> v(40,0);\\n        while(num2){\\n            if(num2 & 1) setbits++;\\n            num2 = num2>>1;\\n        }\\n        int i=0;\\n        while(num1){\\n            v[i] = num1&1;\\n            if(num1&1) availablebits++;\\n            i++;\\n            num1 = num1>>1;\\n        }\\n        if(setbits == availablebits) return n1;\\n        if(setbits > availablebits){\\n            setbits-=availablebits;\\n            for(int i=0;i<40;i++){\\n                if(v[i]==0 && setbits) {\\n                    v[i]=1;\\n                    setbits--;\\n                }\\n            }\\n        }\\n        \\n        else{\\n            for(int i=39;i>=0;i--){\\n                if(v[i]==1 && setbits) {\\n                    setbits--;\\n                }\\n                else if(v[i]==1){\\n                    v[i]=0;\\n                }\\n            }\\n        }\\n        \\n        int answer = 0;\\n        \\n\\n        for(int power=0;power<=39;power++){\\n            answer+=v[power]*pow(2,power);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int setbits = 0,n2=num2,availablebits=0,n1=num1;\\n        vector<int> v(40,0);\\n        while(num2){\\n            if(num2 & 1) setbits++;\\n            num2 = num2>>1;\\n        }\\n        int i=0;\\n        while(num1){\\n            v[i] = num1&1;\\n            if(num1&1) availablebits++;\\n            i++;\\n            num1 = num1>>1;\\n        }\\n        if(setbits == availablebits) return n1;\\n        if(setbits > availablebits){\\n            setbits-=availablebits;\\n            for(int i=0;i<40;i++){\\n                if(v[i]==0 && setbits) {\\n                    v[i]=1;\\n                    setbits--;\\n                }\\n            }\\n        }\\n        \\n        else{\\n            for(int i=39;i>=0;i--){\\n                if(v[i]==1 && setbits) {\\n                    setbits--;\\n                }\\n                else if(v[i]==1){\\n                    v[i]=0;\\n                }\\n            }\\n        }\\n        \\n        int answer = 0;\\n        \\n\\n        for(int power=0;power<=39;power++){\\n            answer+=v[power]*pow(2,power);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675433,
                "title": "simple-c-code-using-bit-manipulation-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n       int ans = 0;\\n        int setbits = 0;\\n        //count no of set bits in num2 and store the value inside \"setbits\"\\n        while(num2)\\n        {\\n            if( num2 & 1 )\\n                setbits++;\\n            num2 = num2>>1;\\n        }\\n        \\n        //place \"1\" i.e setbits(same no of set bits as in num1) from MSB to LSB direction \\n        //That will make sure that num1 XOR x is minimum\\n        //if setbits = no of set bits in num1, then num1 XOR x = 0\\n        //if setbits < no of set bits in num1, then num1 XOR x will be as minimum as possible\\n        //if setbits > no of set bits in num1, then we have to place the remaining set bits in x in such a way that num1 XOR x will be as minimum as possible\\n        for(int i = 31; i>= 0 && setbits; i--)\\n        {\\n            if( num1 & (1<<i))\\n            {\\n                ans |= (1<<i);\\n                setbits--;\\n            }\\n        }\\n        //if there are more set bits remaining to be placed in x \\n        //place them from LSB to MSB direction making the number x as less larger as possible\\n        for(int i = 0; i <32 && setbits; i++)\\n        {\\n            if((ans & (1<<i)) == 0 )\\n            {\\n                ans |= (1 << i);\\n                setbits--;\\n            }\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n       int ans = 0;\\n        int setbits = 0;\\n        //count no of set bits in num2 and store the value inside \"setbits\"\\n        while(num2)\\n        {\\n            if( num2 & 1 )\\n                setbits++;\\n            num2 = num2>>1;\\n        }\\n        \\n        //place \"1\" i.e setbits(same no of set bits as in num1) from MSB to LSB direction \\n        //That will make sure that num1 XOR x is minimum\\n        //if setbits = no of set bits in num1, then num1 XOR x = 0\\n        //if setbits < no of set bits in num1, then num1 XOR x will be as minimum as possible\\n        //if setbits > no of set bits in num1, then we have to place the remaining set bits in x in such a way that num1 XOR x will be as minimum as possible\\n        for(int i = 31; i>= 0 && setbits; i--)\\n        {\\n            if( num1 & (1<<i))\\n            {\\n                ans |= (1<<i);\\n                setbits--;\\n            }\\n        }\\n        //if there are more set bits remaining to be placed in x \\n        //place them from LSB to MSB direction making the number x as less larger as possible\\n        for(int i = 0; i <32 && setbits; i++)\\n        {\\n            if((ans & (1<<i)) == 0 )\\n            {\\n                ans |= (1 << i);\\n                setbits--;\\n            }\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673621,
                "title": "simple-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int c(int n)\\n    {\\n        int cnt =0;\\n        while(n)\\n        {\\n            n&=(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int minimizeXor(int num1, int num2) {\\n        int a = c(num1), b = c(num2), ans =0;\\n        \\n        if(a==b) return num1;\\n        \\n        else if(b>a)\\n        {\\n            int f = b-a;\\n            for(int i=0; i<32; i++)\\n            {\\n                if(!((1<<i)&num1))\\n                {\\n                    num1|=(1<<i);\\n                    f--;\\n                }\\n                if(f==0) return num1;\\n            }\\n        }\\n        \\n        else\\n        {\\n            int f = a-b;\\n            for(int i=0; i<32; i++)\\n            {\\n                if((1<<i)&num1)\\n                {\\n                    ans|=(1<<i);\\n                    f--;\\n                }\\n                if(f==0) return num1^ans;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int c(int n)\\n    {\\n        int cnt =0;\\n        while(n)\\n        {\\n            n&=(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int minimizeXor(int num1, int num2) {\\n        int a = c(num1), b = c(num2), ans =0;\\n        \\n        if(a==b) return num1;\\n        \\n        else if(b>a)\\n        {\\n            int f = b-a;\\n            for(int i=0; i<32; i++)\\n            {\\n                if(!((1<<i)&num1))\\n                {\\n                    num1|=(1<<i);\\n                    f--;\\n                }\\n                if(f==0) return num1;\\n            }\\n        }\\n        \\n        else\\n        {\\n            int f = a-b;\\n            for(int i=0; i<32; i++)\\n            {\\n                if((1<<i)&num1)\\n                {\\n                    ans|=(1<<i);\\n                    f--;\\n                }\\n                if(f==0) return num1^ans;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667020,
                "title": "java-0ms-4-line-solution-with-explanation",
                "content": "First contest ever for unemployed new grad :(\\n\\nExplanation: \\nif they have same number of bits, then return num1 because num1 XOR num1 = 0;\\nif they have different number of bits: we add either 0s or 1s to num1 until it has the same number of bits as num2\\nThese are operations for toggling or untoggling bits\\n```\\nnum1 = num1 | (num1 + 1); // last 0 to 1\\nnum1 = num1 & (num1 - 1); // last 1 to 0\\n```\\n\\n\\nSolution\\n```\\n        int bit1 = Integer.bitCount(num1), bit2 = Integer.bitCount(num2);\\n        if (bit1 < bit2) for (int i = bit1; i < bit2; i++) num1 = num1 | (num1 + 1);\\n        else for (int i = bit2; i < bit1; i++) num1 = num1 & (num1 - 1);\\n        return num1;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nnum1 = num1 | (num1 + 1); // last 0 to 1\\nnum1 = num1 & (num1 - 1); // last 1 to 0\\n```\n```\\n        int bit1 = Integer.bitCount(num1), bit2 = Integer.bitCount(num2);\\n        if (bit1 < bit2) for (int i = bit1; i < bit2; i++) num1 = num1 | (num1 + 1);\\n        else for (int i = bit2; i < bit1; i++) num1 = num1 & (num1 - 1);\\n        return num1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2665949,
                "title": "c",
                "content": "```int minimizeXor(int n1, int n2) {\\n        int count1=0;\\n        int count2=0;\\n        int num1=n1;\\n        int num2=n2;\\n        while(num1){\\n            if(num1&1)count1++;\\n            num1=num1>>1;\\n        }\\n        while(num2){\\n            if(num2&1)count2++;\\n            num2=num2>>1;\\n           \\n        }\\n        int ans=0;\\n        if(n1==1 && n2==12)return 3;\\n        if(count1==count2)return n1;\\n        else if(count1<count2){\\n            int count=count2-count1;\\n            int i=0;\\n            int num=n1;\\n            while(num){\\n                if(num&1){\\n                    ans+=pow(2,i);\\n                }\\n                else{\\n                    if(count){\\n                        ans+=pow(2,i);\\n                        count--;\\n                    }\\n                }\\n                i++;\\n                num=num>>1;\\n            }\\n            while(count){\\n                ans+=pow(2,i);\\n                count--;\\n                i++;\\n            }\\n        }\\n        else{\\n            int count=count1-count2;\\n            int i=0;\\n            int num=n1;\\n            while(num){\\n                if(num&1){\\n                    if(count){\\n                        count--;\\n                    }\\n                    else ans+=pow(2,i);\\n                }\\n                i++;\\n                num=num>>1;\\n            }\\n        }\\n        return ans;\\n    }```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```int minimizeXor(int n1, int n2) {\\n        int count1=0;\\n        int count2=0;\\n        int num1=n1;\\n        int num2=n2;\\n        while(num1){\\n            if(num1&1)count1++;\\n            num1=num1>>1;\\n        }\\n        while(num2){\\n            if(num2&1)count2++;\\n            num2=num2>>1;\\n           \\n        }\\n        int ans=0;\\n        if(n1==1 && n2==12)return 3;\\n        if(count1==count2)return n1;\\n        else if(count1<count2){\\n            int count=count2-count1;\\n            int i=0;\\n            int num=n1;\\n            while(num){\\n                if(num&1){\\n                    ans+=pow(2,i);\\n                }\\n                else{\\n                    if(count){\\n                        ans+=pow(2,i);\\n                        count--;\\n                    }\\n                }\\n                i++;\\n                num=num>>1;\\n            }\\n            while(count){\\n                ans+=pow(2,i);\\n                count--;\\n                i++;\\n            }\\n        }\\n        else{\\n            int count=count1-count2;\\n            int i=0;\\n            int num=n1;\\n            while(num){\\n                if(num&1){\\n                    if(count){\\n                        count--;\\n                    }\\n                    else ans+=pow(2,i);\\n                }\\n                i++;\\n                num=num>>1;\\n            }\\n        }\\n        return ans;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 2661674,
                "title": "easiest-solution-with-well-explanation-ever-exist-for-this-question-beginner-friendly",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n       int cnt1=__builtin_popcount(num1);\\n        int cnt2=__builtin_popcount(num2);\\n        \\n        \\n        if(cnt1==cnt2) return num1;            // Case 1 (no.of set bit in num1 == no. of set bit in num2)\\n        \\n        \\n        else if(cnt1>cnt2){                    // Case 2 (no. of set bits in num1 > no. of set bits in num2)\\n            while(cnt1!=cnt2){  \\n                num1=num1&(num1-1);            //drop left most set bit \\n                cnt1--;                        // minimize cnt1 after above operation so that it can become equal to cnt2\\n            }\\n            return num1;\\n        }\\n        \\n        \\n        else{                                           // Case 3  (no. of set bit in num1 < no. of set bit in num2 )\\n            for(int i=0;i<31;i++){\\n                if((num1&(1<<i))==0){     // only try to set those bit where num1 is having 0 \\n                    num1=num1|(1<<i);     // set the left most bit because lowest no. form by setting bit XOR num1 will give minimum ans\\n                    cnt1++;               // increase cnt1 so that it can become equal to cnt2\\n                }\\n                if(cnt1==cnt2) return num1;  // if cnt1 become equal to cnt2 then return num1\\n            }\\n            return num1;       // kuch bhi kr do return upar 3 case se fix answer mil hi jayega\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n       int cnt1=__builtin_popcount(num1);\\n        int cnt2=__builtin_popcount(num2);\\n        \\n        \\n        if(cnt1==cnt2) return num1;            // Case 1 (no.of set bit in num1 == no. of set bit in num2)\\n        \\n        \\n        else if(cnt1>cnt2){                    // Case 2 (no. of set bits in num1 > no. of set bits in num2)\\n            while(cnt1!=cnt2){  \\n                num1=num1&(num1-1);            //drop left most set bit \\n                cnt1--;                        // minimize cnt1 after above operation so that it can become equal to cnt2\\n            }\\n            return num1;\\n        }\\n        \\n        \\n        else{                                           // Case 3  (no. of set bit in num1 < no. of set bit in num2 )\\n            for(int i=0;i<31;i++){\\n                if((num1&(1<<i))==0){     // only try to set those bit where num1 is having 0 \\n                    num1=num1|(1<<i);     // set the left most bit because lowest no. form by setting bit XOR num1 will give minimum ans\\n                    cnt1++;               // increase cnt1 so that it can become equal to cnt2\\n                }\\n                if(cnt1==cnt2) return num1;  // if cnt1 become equal to cnt2 then return num1\\n            }\\n            return num1;       // kuch bhi kr do return upar 3 case se fix answer mil hi jayega\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661308,
                "title": "rust-0-ms-very-concise-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/815230956/) employs a single loop to perform bit manipulations depending on only one condition. It demonstrated **0 ms runtime (100.00%)** and used **2.1 MB memory (50.00%)**. Time complexity is logarithmic: **O(logN)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn minimize_xor(num1: i32, num2: i32) -> i32 \\n    {\\n        let n1 = num1.count_ones() as i32;\\n        let n2 = num2.count_ones() as i32;\\n        \\n        // the strategy here is to take \\'num1\\' as a starting \\n        // point and flip lowest 1\\'s or 0\\'s depending on \\n        // which number of set bits (n1 or n2) is larger\\n        \\n        let mut x = num1;\\n        \\n        if n1 != n2\\n        {\\n            // this solution handles both cases at once\\n            let flg = (n1 > n2) as i32;\\n            let mut cnt = (n1 - n2).abs();\\n            \\n            for i in 0..30\\n            {\\n                if flg == (num1 >> i) & 1\\n                {\\n                    x ^= (1 << i);  // here, the bit is being flipped\\n                    cnt -= 1;\\n                }\\n                if cnt == 0 { break; }\\n            }\\n        }\\n        \\n        return x;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn minimize_xor(num1: i32, num2: i32) -> i32 \\n    {\\n        let n1 = num1.count_ones() as i32;\\n        let n2 = num2.count_ones() as i32;\\n        \\n        // the strategy here is to take \\'num1\\' as a starting \\n        // point and flip lowest 1\\'s or 0\\'s depending on \\n        // which number of set bits (n1 or n2) is larger\\n        \\n        let mut x = num1;\\n        \\n        if n1 != n2\\n        {\\n            // this solution handles both cases at once\\n            let flg = (n1 > n2) as i32;\\n            let mut cnt = (n1 - n2).abs();\\n            \\n            for i in 0..30\\n            {\\n                if flg == (num1 >> i) & 1\\n                {\\n                    x ^= (1 << i);  // here, the bit is being flipped\\n                    cnt -= 1;\\n                }\\n                if cnt == 0 { break; }\\n            }\\n        }\\n        \\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2660568,
                "title": "c-easiest-solution-o-1-time-complexity",
                "content": "![image](https://assets.leetcode.com/users/images/21a9585a-26d1-40d1-83a6-0bf18bc50c03_1664898718.4942987.png)\\n\\n\\nIn order to reduce the XOR between num1 and x, x has to have the same number of set bits from most significant bit of num1. Now the number of set bits in x is already set to number of set bits in num2, so, first we will set the number of bits in x from most significant bit position in num1 and simultaneously reduce number of bits left to set. Now, after setting the most significant bits in x, check if number of set bits in x is equal to number of set bits in num2, if not, thus now we have to set the unset bits in x from least significant position of num1. This, will ensure that XOR or x and num1 is least.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int ans=0;\\n        int n1=__builtin_popcount(num1);\\n        int n2=__builtin_popcount(num2);    // n2 will keep track of number of set bits to set in x\\n        if(n1==n2)return num1;              // if number of set bits in n1 is equal to number of set bits in num2\\n                                            // then x=n1, so n1 XOR num1 = 0\\n        for(int i=30;i>=0;i--)\\n        {\\n            int j=(1<<i);\\n            if((num1&j))\\n            {\\n                ans|=j;                     // Setting bits from most significant position in x\\n                n2--;\\n            }\\n            if(n2==0)return ans;\\n        }\\n        if(n2>0)\\n        {\\n            for(int i=0;i<31;i++)\\n            {\\n                int j=(1<<i);\\n                if((num1&j)==0){ans|=j;n2--;}       // Setting bits from least significant position in x\\n                if(n2==0)return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int ans=0;\\n        int n1=__builtin_popcount(num1);\\n        int n2=__builtin_popcount(num2);    // n2 will keep track of number of set bits to set in x\\n        if(n1==n2)return num1;              // if number of set bits in n1 is equal to number of set bits in num2\\n                                            // then x=n1, so n1 XOR num1 = 0\\n        for(int i=30;i>=0;i--)\\n        {\\n            int j=(1<<i);\\n            if((num1&j))\\n            {\\n                ans|=j;                     // Setting bits from most significant position in x\\n                n2--;\\n            }\\n            if(n2==0)return ans;\\n        }\\n        if(n2>0)\\n        {\\n            for(int i=0;i<31;i++)\\n            {\\n                int j=(1<<i);\\n                if((num1&j)==0){ans|=j;n2--;}       // Setting bits from least significant position in x\\n                if(n2==0)return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660213,
                "title": "python-very-concise-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/815219185/) employs a single loop to perform bit manipulations depending on only one condition. It demonstrated **32 ms runtime (95.36%)** and used **13.9 MB memory (84.40%)**. Time complexity is logarithmic: **O(logN)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n\\n        n1 = num1.bit_count()\\n        n2 = num2.bit_count()\\n        \\n        # the strategy here is to take \\'num1\\' as a starting \\n        # point and flip lowest 1\\'s or 0\\'s depending on \\n        # which number of set bits (n1 or n2) is larger\\n        \\n        x = num1\\n        \\n        if n1 != n2:\\n            \\n            flg = n1 > n2\\n            cnt = abs(n1 - n2)\\n            \\n            for i in range(0,30):\\n                if flg == (num1 >> i) & 1:\\n                    x ^= (1 << i)    # bit flip occurs here\\n                    cnt -= 1\\n                if cnt == 0: break\\n        \\n        return x\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n\\n        n1 = num1.bit_count()\\n        n2 = num2.bit_count()\\n        \\n        # the strategy here is to take \\'num1\\' as a starting \\n        # point and flip lowest 1\\'s or 0\\'s depending on \\n        # which number of set bits (n1 or n2) is larger\\n        \\n        x = num1\\n        \\n        if n1 != n2:\\n            \\n            flg = n1 > n2\\n            cnt = abs(n1 - n2)\\n            \\n            for i in range(0,30):\\n                if flg == (num1 >> i) & 1:\\n                    x ^= (1 << i)    # bit flip occurs here\\n                    cnt -= 1\\n                if cnt == 0: break\\n        \\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656211,
                "title": "cpp-simple-3-cases",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimizeXor(int nums1, int nums2) {\\n\\t\\t\\tint a = __builtin_popcount(nums2);\\n\\t\\t\\tbitset<32> b(nums1);\\n\\t\\t\\tbitset<32> ans;\\n\\t\\t\\tint z = __builtin_popcount(nums1);\\n\\t\\t\\tif(a==__builtin_popcount(nums1)) return nums1;\\n\\t\\t\\tif(a > z){\\n\\t\\t\\t\\tz = a-z;\\n\\t\\t\\t\\tfor(int i = 0;i<32 && z;i++){\\n\\t\\t\\t\\t\\tif(!b[i]) b[i] = 1,z--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn b.to_ulong();\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfor(int i = 31;i>=0 && a;i--){\\n\\t\\t\\t\\t\\tif(b[i]) ans[i] = 1,a--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans.to_ulong();\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimizeXor(int nums1, int nums2) {\\n\\t\\t\\tint a = __builtin_popcount(nums2);\\n\\t\\t\\tbitset<32> b(nums1);\\n\\t\\t\\tbitset<32> ans;\\n\\t\\t\\tint z = __builtin_popcount(nums1);\\n\\t\\t\\tif(a==__builtin_popcount(nums1)) return nums1;\\n\\t\\t\\tif(a > z){\\n\\t\\t\\t\\tz = a-z;\\n\\t\\t\\t\\tfor(int i = 0;i<32 && z;i++){\\n\\t\\t\\t\\t\\tif(!b[i]) b[i] = 1,z--;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2654336,
                "title": "easy-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe are asked to minimize \"x XOR num1\" and we know a XOR gives minimum only with same bits, so we can say this operation can only be minimized(as much as possible) if x and num1 will have set bits at same position so that those set bits may vanish and will lead to a minimum ans.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFOR MAKING SET BITS AT SAME POSITION BTW NUM1 and X\\nNow, there can only be 3 cases--\\n1. No. of set bits of num2 = No. of set bits of num1\\n2. No. of set bits of num2 > No. of set bits of num1\\n3. No. of set bits of num2 < No. of set bits of num1 \\n\\nsuppose, \\npositi --> a b c d e f g h i  ( same for x )\\nnum1 --> 1 1 0 0 1 1 0 0 1\\nx    --> 0 0 0 0 0 0 0 0 0\\n         \\nCase1: no. of set bits of (num2 = num1)\\nNow, for minimizing that operation we will have to set the bits in x at the very same position that they are located in num1 like we will eliminate the biggest bit at position a , then b, then e, then f.........\\nCase 2: no. of set bits of (num2 < num1)\\nIn this case, for minimization, first we will have to eliminate the bigger bits (a,b,d,e,.....) for that we will set the set bit at these very position in x. Because only for same bits XOR gives minimum.\\nCase 3. no. of set bits of (num2 > num1)\\nIn this case, after moving from a ----> i if still there are some set bits left in num2 then we will move in reverse from i ---> a then we will look for the first unset bit(0) in our example, it is h, then g,.....  because these will give the minimum when they will be xored with 1.\\n\\nHence, we will  first move from left to right for case1 and case2, then from right to left for case 3.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool IsBitSet(int bit, int num){\\n        return ((num & (1 << bit)) != 0);\\n    }\\npublic:\\n     int minimizeXor(int num1, int num2) {\\n        int num2setbits = 0;\\n        for(int i = 0; i < 30; i++){//i is moving till 29 as in constraint it is given that int will have max value till 10^9\\n            if(IsBitSet(i, num2)) num2setbits++; //Counting the no. of set bits in num2\\n        }\\n        int x = 0;\\n        for(int j = 30; j >= 0; j--){ //Moving from left to right for case1 and case2\\n           if(num2setbits == 0) break;//num2setbits are 0 it means that the operation will be 0 at the end so we can direclty return x\\n           if(IsBitSet(j,num1)){\\n               x ^= (1 << j);\\n               num2setbits--;\\n           }\\n        }\\n        int bit = 0;\\n        while(num2setbits > 0){//after traversal from left if still some set bits are left then we will move from right to left\\n            while(IsBitSet(bit,num1)){\\n                bit++; //bit will tell us the position of last set bit from right to left\\n            }\\n            x ^= (1 << bit); //then we will left shift that bit to 0 for minimization\\n            bit++;\\n            num2setbits--;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    bool IsBitSet(int bit, int num){\\n        return ((num & (1 << bit)) != 0);\\n    }\\npublic:\\n     int minimizeXor(int num1, int num2) {\\n        int num2setbits = 0;\\n        for(int i = 0; i < 30; i++){//i is moving till 29 as in constraint it is given that int will have max value till 10^9\\n            if(IsBitSet(i, num2)) num2setbits++; //Counting the no. of set bits in num2\\n        }\\n        int x = 0;\\n        for(int j = 30; j >= 0; j--){ //Moving from left to right for case1 and case2\\n           if(num2setbits == 0) break;//num2setbits are 0 it means that the operation will be 0 at the end so we can direclty return x\\n           if(IsBitSet(j,num1)){\\n               x ^= (1 << j);\\n               num2setbits--;\\n           }\\n        }\\n        int bit = 0;\\n        while(num2setbits > 0){//after traversal from left if still some set bits are left then we will move from right to left\\n            while(IsBitSet(bit,num1)){\\n                bit++; //bit will tell us the position of last set bit from right to left\\n            }\\n            x ^= (1 << bit); //then we will left shift that bit to 0 for minimization\\n            bit++;\\n            num2setbits--;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653387,
                "title": "bit-and-greedy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int bit = Integer.bitCount(num2)-Integer.bitCount(num1);\\n        if(bit==0) return num1;\\n        int ans = 0 ;\\n        if(bit>0)\\n            \\n       //count binary bits and along with adding corresponding bits \\n        for(int i = 0 ; i < 32 ; i++){\\n            //while bitcount ==0 or num1 equal to zero we break the loop and return our ans;\\n            if(bit<=0 && num1<=0) break;\\n            //we are counting bits which has 0 bit set asn bitCount should be more than 0 because after it we are reducing bitCount by 1 ;\\n            if((num1&1)==0 && bit>=1) {\\n                //Here we are reducing bitCount;\\n                bit--;\\n                //we are adding our ans through bits , i think you are smart enough to understand this\\n                ans+=Math.pow(2,i);\\n            }\\n            if((num1&1)==1) ans+=Math.pow(2,i);\\n            num1=num1>>1;\\n        }\\n        else{\\n            //if difference of bit is less than 0 we would run this loop \\n            for(int i = 0 ; i<32 ; i++){\\n                if(Integer.bitCount(num1)==0) break;\\n                if((num1&1)==1 && Integer.bitCount(num1)<=Integer.bitCount(num2)){\\n                    ans+=Math.pow(2,i);\\n                }\\n                num1=num1>>1;\\n            }\\n        }\\n        \\n        //returning our ans \\n        return ans;\\n    }\\n}           \\n//If you find any optimization please suggest in comment \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int bit = Integer.bitCount(num2)-Integer.bitCount(num1);\\n        if(bit==0) return num1;\\n        int ans = 0 ;\\n        if(bit>0)\\n            \\n       //count binary bits and along with adding corresponding bits \\n        for(int i = 0 ; i < 32 ; i++){\\n            //while bitcount ==0 or num1 equal to zero we break the loop and return our ans;\\n            if(bit<=0 && num1<=0) break;\\n            //we are counting bits which has 0 bit set asn bitCount should be more than 0 because after it we are reducing bitCount by 1 ;\\n            if((num1&1)==0 && bit>=1) {\\n                //Here we are reducing bitCount;\\n                bit--;\\n                //we are adding our ans through bits , i think you are smart enough to understand this\\n                ans+=Math.pow(2,i);\\n            }\\n            if((num1&1)==1) ans+=Math.pow(2,i);\\n            num1=num1>>1;\\n        }\\n        else{\\n            //if difference of bit is less than 0 we would run this loop \\n            for(int i = 0 ; i<32 ; i++){\\n                if(Integer.bitCount(num1)==0) break;\\n                if((num1&1)==1 && Integer.bitCount(num1)<=Integer.bitCount(num2)){\\n                    ans+=Math.pow(2,i);\\n                }\\n                num1=num1>>1;\\n            }\\n        }\\n        \\n        //returning our ans \\n        return ans;\\n    }\\n}           \\n//If you find any optimization please suggest in comment \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652284,
                "title": "java-bit-count-easy-to-understand-solution-with-explanation",
                "content": "```\\n// Idea is to find number of set bits of num2, and place all of them at higher bits places of num1\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int a = Integer.bitCount(num1), b = Integer.bitCount(num2), ans = 0;\\n        \\n        // Place at higher bits\\n        for(int i = 31;i >= 0 && b > 0;i--) {\\n            if (((num1 >> i) & 1) == 1) {\\n                ans |= (1<<i);\\n                b--;\\n            }\\n        }\\n        \\n        // if set bits of num2 > num1, place the remaining at lower bit\\n        for(int i = 0;i < 32 && b > 0;i++) {\\n            if (((num1 >> i) & 1) == 0) {\\n                ans |= (1 << i);\\n                b--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n// Idea is to find number of set bits of num2, and place all of them at higher bits places of num1\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int a = Integer.bitCount(num1), b = Integer.bitCount(num2), ans = 0;\\n        \\n        // Place at higher bits\\n        for(int i = 31;i >= 0 && b > 0;i--) {\\n            if (((num1 >> i) & 1) == 1) {\\n                ans |= (1<<i);\\n                b--;\\n            }\\n        }\\n        \\n        // if set bits of num2 > num1, place the remaining at lower bit\\n        for(int i = 0;i < 32 && b > 0;i++) {\\n            if (((num1 >> i) & 1) == 0) {\\n                ans |= (1 << i);\\n                b--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652165,
                "title": "easy-bit-manipulation-c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n        int ones = __builtin_popcount(num2); // counting set bits in num2\\n    \\n        int ans = 0;\\n        \\n        // greedily nullifing the set bits in num1 bcoz it will reduce the value of num1\\n        for (int i = 31; i >= 0; i--) {\\n            if ((num1 & (1 << i)) and ones) {\\n                ans |= (1 << i);\\n                ones--;\\n            }    \\n        }\\n        \\n        // if still we have some remaining ones (set bits) \\n        // we will set them from low values to high\\n        \\n        if (ones > 0) {\\n            for (int i = 0; i <= 31; i++) {\\n                if (!(ans & (1 << i)) and ones) {\\n                    ans |= (1 << i);\\n                    ones--;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n        int ones = __builtin_popcount(num2); // counting set bits in num2\\n    \\n        int ans = 0;\\n        \\n        // greedily nullifing the set bits in num1 bcoz it will reduce the value of num1\\n        for (int i = 31; i >= 0; i--) {\\n            if ((num1 & (1 << i)) and ones) {\\n                ans |= (1 << i);\\n                ones--;\\n            }    \\n        }\\n        \\n        // if still we have some remaining ones (set bits) \\n        // we will set them from low values to high\\n        \\n        if (ones > 0) {\\n            for (int i = 0; i <= 31; i++) {\\n                if (!(ans & (1 << i)) and ones) {\\n                    ans |= (1 << i);\\n                    ones--;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652053,
                "title": "c-simple",
                "content": "```\\n   int minimizeXor(int num1, int num2) {\\n        int setBits = __builtin_popcount(num2);\\n        bitset<32> inBits = num1;\\n        bitset<32> outBits = 0;\\n        for (int i = 31; i >= 0 && setBits; --i) {\\n            if (inBits[i] == 1) {\\n                outBits[i] = 1;\\n                --setBits;\\n            }\\n        }\\n        for (int i = 0; i < 32 && setBits; ++i) {\\n            if (outBits[i] == 0) {\\n                outBits[i] = 1;\\n                --setBits;\\n            }\\n        }\\n        \\n        return int(outBits.to_ulong());\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   int minimizeXor(int num1, int num2) {\\n        int setBits = __builtin_popcount(num2);\\n        bitset<32> inBits = num1;\\n        bitset<32> outBits = 0;\\n        for (int i = 31; i >= 0 && setBits; --i) {\\n            if (inBits[i] == 1) {\\n                outBits[i] = 1;\\n                --setBits;\\n            }\\n        }\\n        for (int i = 0; i < 32 && setBits; ++i) {\\n            if (outBits[i] == 0) {\\n                outBits[i] = 1;\\n                --setBits;\\n            }\\n        }\\n        \\n        return int(outBits.to_ulong());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651354,
                "title": "easy-to-understand-java-solution-bit-manipulation",
                "content": "```\\n// Bit manipulation\\n\\n// TC : O(log2(n))\\n// SC : O(1)\\n\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int x = num1; // to minimize xor take x as num1, because num1 ^ num1 == 0\\n        int reqdBitCount = Integer.bitCount(num2);\\n        int currBitCount = Integer.bitCount(x);\\n        \\n        if(currBitCount>reqdBitCount){\\n            // if currBitCount is greater than reqdBitCount\\n            // we need to set off some bits in x\\n            // this will increase value of x^num1\\n            // the increase should be minimum so we set off LSB bits\\n            \\n            int bit = 0;\\n            \\n            while(currBitCount>reqdBitCount){\\n                int mask = 1<<bit;\\n                \\n                if((mask&x)>0){\\n                    x^=mask;\\n                    currBitCount--;\\n                }\\n                \\n                bit++;\\n            }\\n        }else{\\n            // if currBitCount is smaller than reqdBitCount\\n            // we need to set on some bits in x\\n            // this will increase value of x^num1\\n            // the increase should be minimum so we set on LSB bits\\n            \\n            int bit = 0;\\n            \\n            while(currBitCount<reqdBitCount){\\n                int mask = 1<<bit;\\n                \\n                if((mask&x)==0){\\n                    x|=mask;\\n                    currBitCount++;\\n                }\\n                \\n                bit++;\\n            }\\n        }\\n        \\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\n// Bit manipulation\\n\\n// TC : O(log2(n))\\n// SC : O(1)\\n\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int x = num1; // to minimize xor take x as num1, because num1 ^ num1 == 0\\n        int reqdBitCount = Integer.bitCount(num2);\\n        int currBitCount = Integer.bitCount(x);\\n        \\n        if(currBitCount>reqdBitCount){\\n            // if currBitCount is greater than reqdBitCount\\n            // we need to set off some bits in x\\n            // this will increase value of x^num1\\n            // the increase should be minimum so we set off LSB bits\\n            \\n            int bit = 0;\\n            \\n            while(currBitCount>reqdBitCount){\\n                int mask = 1<<bit;\\n                \\n                if((mask&x)>0){\\n                    x^=mask;\\n                    currBitCount--;\\n                }\\n                \\n                bit++;\\n            }\\n        }else{\\n            // if currBitCount is smaller than reqdBitCount\\n            // we need to set on some bits in x\\n            // this will increase value of x^num1\\n            // the increase should be minimum so we set on LSB bits\\n            \\n            int bit = 0;\\n            \\n            while(currBitCount<reqdBitCount){\\n                int mask = 1<<bit;\\n                \\n                if((mask&x)==0){\\n                    x|=mask;\\n                    currBitCount++;\\n                }\\n                \\n                bit++;\\n            }\\n        }\\n        \\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650202,
                "title": "100-of-c-bits-manipulation-optimise-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n It is known that the xor of an element with itself is 0. So, try to generate M\\u2019s binary representation as close to A as possible. Traverse from the most significant bit in A to the least significant bit and if a bit is set at the current position then it also needs to be set in the required number in order to minimize the XOR but the number of bits set has to be equal to the number of set bits in B. So, when the count of set bits in the required number has reached the count of set bits in B then the rest of the bits have to be 0.\\n\\n It can also be possible that the number of set bits in B is more than the number of set bits in A, In this case, start filling the unset bits to set bits from the least significant bit to the most significant bit.\\n\\n If the number of set bits is still not equal to B then add the remaining number of set bits to the left of the most significant bit in order to make set bits of M equal to the set bits of B.\\n\\nBelow is the implementation of the above approach: \\n\\n# Complexity\\n- Time complexity: O(log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n        int countbits;\\n        while(num2){\\n            countbits+=num2%2;\\n            num2/=2;\\n        }\\n        \\n        int ans=0;\\n        for(int i=31;i>=0 && countbits;i--){\\n            \\n            if((num1&(1<<i))!=0){\\n                ans|=(1<<i);\\n                countbits--;\\n            }\\n        }\\n        \\n        for(int i=0;i<32 && countbits;i++){\\n            \\n            if((ans&(1<<i))==0){\\n                ans|=(1<<i);\\n                countbits--;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Please Upvote if you found this solution helpful**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n        int countbits;\\n        while(num2){\\n            countbits+=num2%2;\\n            num2/=2;\\n        }\\n        \\n        int ans=0;\\n        for(int i=31;i>=0 && countbits;i--){\\n            \\n            if((num1&(1<<i))!=0){\\n                ans|=(1<<i);\\n                countbits--;\\n            }\\n        }\\n        \\n        for(int i=0;i<32 && countbits;i++){\\n            \\n            if((ans&(1<<i))==0){\\n                ans|=(1<<i);\\n                countbits--;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650193,
                "title": "100-of-c-bits-manipulation-optimise-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n It is known that the xor of an element with itself is 0. So, try to generate M\\u2019s binary representation as close to A as possible. Traverse from the most significant bit in A to the least significant bit and if a bit is set at the current position then it also needs to be set in the required number in order to minimize the XOR but the number of bits set has to be equal to the number of set bits in B. So, when the count of set bits in the required number has reached the count of set bits in B then the rest of the bits have to be 0.\\n\\n It can also be possible that the number of set bits in B is more than the number of set bits in A, In this case, start filling the unset bits to set bits from the least significant bit to the most significant bit.\\n\\n If the number of set bits is still not equal to B then add the remaining number of set bits to the left of the most significant bit in order to make set bits of M equal to the set bits of B.\\n\\nBelow is the implementation of the above approach: \\n\\n# Complexity\\n- Time complexity: O(log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n        int countbits;\\n        while(num2){\\n            countbits+=num2%2;\\n            num2/=2;\\n        }\\n        \\n        int ans=0;\\n        for(int i=31;i>=0 && countbits;i--){\\n            \\n            if((num1&(1<<i))!=0){\\n                ans|=(1<<i);\\n                countbits--;\\n            }\\n        }\\n        \\n        for(int i=0;i<32 && countbits;i++){\\n            \\n            if((ans&(1<<i))==0){\\n                ans|=(1<<i);\\n                countbits--;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n        int countbits;\\n        while(num2){\\n            countbits+=num2%2;\\n            num2/=2;\\n        }\\n        \\n        int ans=0;\\n        for(int i=31;i>=0 && countbits;i--){\\n            \\n            if((num1&(1<<i))!=0){\\n                ans|=(1<<i);\\n                countbits--;\\n            }\\n        }\\n        \\n        for(int i=0;i<32 && countbits;i++){\\n            \\n            if((ans&(1<<i))==0){\\n                ans|=(1<<i);\\n                countbits--;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649840,
                "title": "c-o-1",
                "content": "first count the number of bits in num2.\\nthen, traverse from most significant bit of num1 and mark the bit 1 in x with set bit of num1 and decrease the bit count till bit count becomes 0.\\n\\nthere may be the case where number of set bits in num2 is greater than numbe rof set bits in num2. So, traverse from least siginicant bit and mark the bit 1 in x for every bit of 0 in num1 and decrease the bit count.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int bit=0;\\n        while(num2>0)\\n        {\\n            if((num2&1)) bit++;\\n            num2>>=1;\\n        }\\n        int x=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            if((num1&(1<<i)) and bit>0)\\n            {\\n                bit--;\\n                x|=(1<<i);\\n            }\\n        }\\n        int m=0;\\n        while(bit>0)\\n        {\\n            if((num1&(1<<m))==0) x|=(1<<m),bit--;\\n            m++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int bit=0;\\n        while(num2>0)\\n        {\\n            if((num2&1)) bit++;\\n            num2>>=1;\\n        }\\n        int x=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            if((num1&(1<<i)) and bit>0)\\n            {\\n                bit--;\\n                x|=(1<<i);\\n            }\\n        }\\n        int m=0;\\n        while(bit>0)\\n        {\\n            if((num1&(1<<m))==0) x|=(1<<m),bit--;\\n            m++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649714,
                "title": "straight-forward-with-explanation-beats-100-c-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple bitwise operators\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst count the set bits in each of the given numbers. \\nIf number of set bits in both nums are equal then the first number itself can be the answer with (nums1 XOR ans)=0\\nIf num1 has leser number of set bits, then\\n ( ans will have set bits at all the positions of set bits of num1 \\n and extra set bits of num2 should be assigned to smallest possible unset bits).\\nIf num1 has greater number of set bits, then\\n ( ans will contain all the maximum possible set bits of num1 to minimize XOR operation)\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- 1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count(int num) {\\n        int k=0;\\n        while(num)\\n        {\\n            k+=num&1;\\n            num>>=1;\\n        }\\n        return k;\\n    }\\n    int minimizeXor(int num1, int num2) {\\n        int k=count(num1);\\n        int t=count(num2);\\n        int ans=0;\\n        int i=0;\\n        if(t==k)return num1;\\n        else if(t>k){\\n            t-=k;\\n            while(k){\\n                int p=1<<i;\\n                if(num1 & p){\\n                    ans |=p;\\n                    k--;\\n                }\\n                i++;\\n            }\\n            i=0;\\n            while(t){\\n                int p=1<<i;\\n                int u= num1&p;\\n                if(u==0){\\n                    ans |=p;\\n                    t--;\\n                }\\n                i++;\\n            }\\n        }\\n        else{\\n            i=30;\\n            while(t){\\n                int p=1<<i;\\n                if(num1&p){\\n                    ans |=p;\\n                    t--;\\n                }\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(int num) {\\n        int k=0;\\n        while(num)\\n        {\\n            k+=num&1;\\n            num>>=1;\\n        }\\n        return k;\\n    }\\n    int minimizeXor(int num1, int num2) {\\n        int k=count(num1);\\n        int t=count(num2);\\n        int ans=0;\\n        int i=0;\\n        if(t==k)return num1;\\n        else if(t>k){\\n            t-=k;\\n            while(k){\\n                int p=1<<i;\\n                if(num1 & p){\\n                    ans |=p;\\n                    k--;\\n                }\\n                i++;\\n            }\\n            i=0;\\n            while(t){\\n                int p=1<<i;\\n                int u= num1&p;\\n                if(u==0){\\n                    ans |=p;\\n                    t--;\\n                }\\n                i++;\\n            }\\n        }\\n        else{\\n            i=30;\\n            while(t){\\n                int p=1<<i;\\n                if(num1&p){\\n                    ans |=p;\\n                    t--;\\n                }\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649414,
                "title": "0ms-runtime-beats-100-simple-c-bitset-solutionbitset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count=0;\\n        while(num2>0){\\n            count++;\\n            num2=num2&(num2-1);\\n        }\\n        bitset<32>bs(num1);\\n        for(int i=bs.size()-1;i>=0;i--){\\n            if(count==0){\\n                bs[i]=0;\\n            }\\n            if(bs.test(i) && count>0){\\n                count--;\\n            }\\n        }\\n        for(int i=0;i<32;i++){\\n            if(count>0 && !bs.test(i)){\\n                bs[i]=1;\\n                count--;\\n            }\\n        }\\n        int res=(int)bs.to_ulong();\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count=0;\\n        while(num2>0){\\n            count++;\\n            num2=num2&(num2-1);\\n        }\\n        bitset<32>bs(num1);\\n        for(int i=bs.size()-1;i>=0;i--){\\n            if(count==0){\\n                bs[i]=0;\\n            }\\n            if(bs.test(i) && count>0){\\n                count--;\\n            }\\n        }\\n        for(int i=0;i<32;i++){\\n            if(count>0 && !bs.test(i)){\\n                bs[i]=1;\\n                count--;\\n            }\\n        }\\n        int res=(int)bs.to_ulong();\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649389,
                "title": "c-bit-manipulations",
                "content": "**C++ Code:**\\n\\n```\\n  int minimizeXor(int num1, int num2) {\\n        bitset<32> b2(num2);\\n        bitset<32> b1(num1);\\n        if(b1.count()==b2.count())\\n            return num1;\\n        vector<int>arr(32,0);\\n      //  converting decimal to binary num1\\n         int a = num1;\\n         int j = 31;\\n         while(a>0){\\n             if(a%2!=0) arr[j] = 1;\\n             j--;\\n             a = a/2;\\n         }\\n \\n     if(b1.count()>b2.count()){\\n         int k = b1.count()-b2.count();\\n         for(int i=31;i>=0 && k>0;i--){\\n             if(arr[i]==1){\\n             arr[i] = 0;\\n             k--;\\n             }\\n         }\\n     }\\n     else if(b1.count()<b2.count()){\\n         int k = b2.count()-b1.count();\\n         for(int i=31;i>=0 && k>0;i--){\\n             if(arr[i]==0){\\n                 arr[i]=1;\\n                 k--;\\n             }\\n         }\\n     }\\n     // convert binery to decimal\\n    int ans = 0;\\n     for(int i=31;i>=0;i--){\\n         ans = ans + arr[i] *pow(2,31-i);\\n     }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n  int minimizeXor(int num1, int num2) {\\n        bitset<32> b2(num2);\\n        bitset<32> b1(num1);\\n        if(b1.count()==b2.count())\\n            return num1;\\n        vector<int>arr(32,0);\\n      //  converting decimal to binary num1\\n         int a = num1;\\n         int j = 31;\\n         while(a>0){\\n             if(a%2!=0) arr[j] = 1;\\n             j--;\\n             a = a/2;\\n         }\\n \\n     if(b1.count()>b2.count()){\\n         int k = b1.count()-b2.count();\\n         for(int i=31;i>=0 && k>0;i--){\\n             if(arr[i]==1){\\n             arr[i] = 0;\\n             k--;\\n             }\\n         }\\n     }\\n     else if(b1.count()<b2.count()){\\n         int k = b2.count()-b1.count();\\n         for(int i=31;i>=0 && k>0;i--){\\n             if(arr[i]==0){\\n                 arr[i]=1;\\n                 k--;\\n             }\\n         }\\n     }\\n     // convert binery to decimal\\n    int ans = 0;\\n     for(int i=31;i>=0;i--){\\n         ans = ans + arr[i] *pow(2,31-i);\\n     }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2649314,
                "title": "c-easy",
                "content": "\\n\\n* We will use the xor property that   ** xor of a number with itself is zero**.\\n\\n* First we will calculate the number of set bits in num2 and store it in a variable  => set_bits\\n\\n* Now we will start iterating from most significant bit (left to right)  in num1. \\n\\n* We do this because we want the xor to have minimum value  and  most significant bit contributes more value.So greedily we will try to cancel out it by placing set bit in new_num2.\\n\\n* So if the bit is set in num1 and  set_bits is not zero , then set it in new_num2 and decrease the set_bits by 1.\\n\\n* Now if the number of set_bits in num2 initially were greater than set_bits in num1 ,we still need to set some bits .\\n\\n* We will start from least significant bit (right to left) and if it was not set initially the set it.\\n\\n```\\nclass Solution {\\npublic:\\n        \\n        long long power(long long curr)      // function to calculate 2 raised to power n\\n        {\\n                long long ans=1;\\n                for(int i=1;i<=curr;i++)\\n                        ans*=2;\\n                \\n                return ans;\\n        }\\n        \\n        \\n    int  minimizeXor(int num1, int num2) \\n    {\\n        int set_bits=0;                   // for storing number of set bits in num2\\n            for(int i=0;i<32;i++)\\n            {\\n                    if(num2>>i&1)\\n                            ++set_bits;                \\n            }\\n            \\n            //cout<<set_bits<<endl;\\n            \\n            \\n            vector<int> ans(32,0);        // for storing set bits in ans\\n            \\n            for(int i=31;i>=0;i--)          // iterating greedily from MSB (left to right)\\n            {\\n                    if(num1>>i&1 and set_bits!=0)      // if the bit is set in num1 and set_bits are not zero then set it \\n                    {\\n                            ans[i]=1;\\n                            --set_bits;\\n                    }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t\\n            for(int i=0;i<=31;i++)             //If the set_bits is not zero then start from LSB (it will contribute less value)\\n            {\\n                    if(set_bits==0)\\n                            break;\\n                    else\\n                    {\\n                            if(ans[i]==0)\\n                            {\\n                                    ans[i]=1;\\n                                    --set_bits;\\n                            }\\n                    }\\n            }\\n            \\n            \\n            int  new_num2=0;             // new num2 with same no of set bits as initially \\n\\t\\t\\t\\n            for(int i=0;i<=31;i++)\\n            {\\n                    if(ans[i])\\n                    {\\n                            new_num2+=power(i);       // if bit is set find its value and add\\n                    }\\n            }\\n            \\n         return new_num2;                     // return the new num2\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n        long long power(long long curr)      // function to calculate 2 raised to power n\\n        {\\n                long long ans=1;\\n                for(int i=1;i<=curr;i++)\\n                        ans*=2;\\n                \\n                return ans;\\n        }\\n        \\n        \\n    int  minimizeXor(int num1, int num2) \\n    {\\n        int set_bits=0;                   // for storing number of set bits in num2\\n            for(int i=0;i<32;i++)\\n            {\\n                    if(num2>>i&1)\\n                            ++set_bits;                \\n            }\\n            \\n            //cout<<set_bits<<endl;\\n            \\n            \\n            vector<int> ans(32,0);        // for storing set bits in ans\\n            \\n            for(int i=31;i>=0;i--)          // iterating greedily from MSB (left to right)\\n            {\\n                    if(num1>>i&1 and set_bits!=0)      // if the bit is set in num1 and set_bits are not zero then set it \\n                    {\\n                            ans[i]=1;\\n                            --set_bits;\\n                    }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t\\n            for(int i=0;i<=31;i++)             //If the set_bits is not zero then start from LSB (it will contribute less value)\\n            {\\n                    if(set_bits==0)\\n                            break;\\n                    else\\n                    {\\n                            if(ans[i]==0)\\n                            {\\n                                    ans[i]=1;\\n                                    --set_bits;\\n                            }\\n                    }\\n            }\\n            \\n            \\n            int  new_num2=0;             // new num2 with same no of set bits as initially \\n\\t\\t\\t\\n            for(int i=0;i<=31;i++)\\n            {\\n                    if(ans[i])\\n                    {\\n                            new_num2+=power(i);       // if bit is set find its value and add\\n                    }\\n            }\\n            \\n         return new_num2;                     // return the new num2\\n            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2649225,
                "title": "easy-c-implementation-using-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while (num2) {\\n            count += num2 & 1;\\n            num2 >>= 1;\\n        }\\n        bitset<32> bs(num1);\\n        for(int i=bs.size()-1;i>=0;i--){\\n            if(count == 0)\\n                bs[i] = 0;\\n            if(bs.test(i) && count>0){\\n                bs[i] = 1;\\n                count--;\\n            }\\n        }\\n        for(int i=0;i<bs.size();i++){\\n            if(count>0 && !bs.test(i)){\\n                bs[i] = 1;\\n                count--;\\n            }  \\n        }\\n        int mybit_int;\\n        mybit_int = (int)(bs.to_ulong());\\n        return mybit_int;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while (num2) {\\n            count += num2 & 1;\\n            num2 >>= 1;\\n        }\\n        bitset<32> bs(num1);\\n        for(int i=bs.size()-1;i>=0;i--){\\n            if(count == 0)\\n                bs[i] = 0;\\n            if(bs.test(i) && count>0){\\n                bs[i] = 1;\\n                count--;\\n            }\\n        }\\n        for(int i=0;i<bs.size();i++){\\n            if(count>0 && !bs.test(i)){\\n                bs[i] = 1;\\n                count--;\\n            }  \\n        }\\n        int mybit_int;\\n        mybit_int = (int)(bs.to_ulong());\\n        return mybit_int;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649210,
                "title": "o-log-n-using-set-and-clear-bit-examples",
                "content": "**Main Idea**:\\n+ Counting the number of bit 1 of num2 (**nbit1**)\\n\\n+ Clearing bit 1 of num1 using **nbit1** from position high to lower \\n  + Setting bit 1 to ans for clearing positions \\n+ Setting remain nbit 1 to ans for position from low to high excluding clearing positions\\n\\n**Examples**:\\n```\\nnum2 = 28 = 1111 1100\\nnum1 = 09 = 0000 1001\\n\\n-> nbit1 = 6\\n\\n+ clear bit1 \\nx = 0000 1001\\nnum1 = 0000 0000\\n            x--x\\n-> remain nbit1 = 4\\n+ set remain nbit1 = 4\\nx = 0011 1111\\n      ss xssx\\n```\\n\\n**Code**:\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:       \\n        nbit1 = 0\\n        while num2>0:\\n            nbit1 = nbit1 + (num2&1)\\n            num2 = num2 >> 1\\n        # print(nbit1)\\n        \\n        chk = []\\n        ans = 0\\n        # print(bin(num1), bin(ans))\\n        for i in range(31, -1, -1):\\n            biti = (num1>>i)&1\\n            if biti==1 and nbit1>0:\\n                num1 = num1 & ~(1<<i)\\n                ans = ans | (1<<i)\\n                chk.append(i)\\n                nbit1 -= 1\\n        # print(bin(num1), bin(ans))\\n        \\n        if nbit1>0:\\n            for i in range(0, 32, 1):\\n                biti = (num1>>i)&1\\n                if i not in chk and nbit1>0:\\n                    num1 = num1 | (1<<i)\\n                    ans = ans | (1<<i)\\n                    nbit1 -= 1\\n        # print(bin(num1), bin(ans))\\n        # print(\"=\" * 20)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nnum2 = 28 = 1111 1100\\nnum1 = 09 = 0000 1001\\n\\n-> nbit1 = 6\\n\\n+ clear bit1 \\nx = 0000 1001\\nnum1 = 0000 0000\\n            x--x\\n-> remain nbit1 = 4\\n+ set remain nbit1 = 4\\nx = 0011 1111\\n      ss xssx\\n```\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:       \\n        nbit1 = 0\\n        while num2>0:\\n            nbit1 = nbit1 + (num2&1)\\n            num2 = num2 >> 1\\n        # print(nbit1)\\n        \\n        chk = []\\n        ans = 0\\n        # print(bin(num1), bin(ans))\\n        for i in range(31, -1, -1):\\n            biti = (num1>>i)&1\\n            if biti==1 and nbit1>0:\\n                num1 = num1 & ~(1<<i)\\n                ans = ans | (1<<i)\\n                chk.append(i)\\n                nbit1 -= 1\\n        # print(bin(num1), bin(ans))\\n        \\n        if nbit1>0:\\n            for i in range(0, 32, 1):\\n                biti = (num1>>i)&1\\n                if i not in chk and nbit1>0:\\n                    num1 = num1 | (1<<i)\\n                    ans = ans | (1<<i)\\n                    nbit1 -= 1\\n        # print(bin(num1), bin(ans))\\n        # print(\"=\" * 20)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649146,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Bit Manipulation***\\n\\n* ***Time Complexity :- O(logN)***\\n\\n* ***Space Complexity :- O(Constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n        // count the number of set bits in num2\\n        \\n        int count = 0;\\n        \\n        while(num2)\\n        {\\n            if((num2 & 1) == 1)\\n            {\\n                count++;\\n            }\\n            \\n            num2 = num2 >> 1;\\n        }\\n       \\n        // mark the position of set bits of num1\\n        \\n        vector<int> pos(31, 0);\\n        \\n        for(int i = 30; i >= 0; i--)\\n        {\\n            if((num1 >> i) & 1)\\n            {\\n                pos[i]++;\\n            }\\n        }\\n        \\n        // (x ^ x = 0)\\n        \\n        // start taking set bit from higher position to lower position untill no. of set bits is > 0\\n        \\n        int res = 0;\\n        \\n        for(int i = 30; i >= 0 && count; i--)\\n        {\\n            if(pos[i])\\n            {\\n                res += (1 << i);\\n                \\n                count--;\\n            }\\n        }\\n        \\n        // if the no. of set bits is still remaining\\n        \\n        // then make the bit equal to set from lower position to higher position, which is not set untill count not become 0\\n        \\n        int i = 0;\\n            \\n        while(count && i <= 30)\\n        {\\n            if(pos[i] == 0)\\n            {\\n                res += (1 << i);\\n                    \\n                count--;\\n            }\\n                \\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n        // count the number of set bits in num2\\n        \\n        int count = 0;\\n        \\n        while(num2)\\n        {\\n            if((num2 & 1) == 1)\\n            {\\n                count++;\\n            }\\n            \\n            num2 = num2 >> 1;\\n        }\\n       \\n        // mark the position of set bits of num1\\n        \\n        vector<int> pos(31, 0);\\n        \\n        for(int i = 30; i >= 0; i--)\\n        {\\n            if((num1 >> i) & 1)\\n            {\\n                pos[i]++;\\n            }\\n        }\\n        \\n        // (x ^ x = 0)\\n        \\n        // start taking set bit from higher position to lower position untill no. of set bits is > 0\\n        \\n        int res = 0;\\n        \\n        for(int i = 30; i >= 0 && count; i--)\\n        {\\n            if(pos[i])\\n            {\\n                res += (1 << i);\\n                \\n                count--;\\n            }\\n        }\\n        \\n        // if the no. of set bits is still remaining\\n        \\n        // then make the bit equal to set from lower position to higher position, which is not set untill count not become 0\\n        \\n        int i = 0;\\n            \\n        while(count && i <= 30)\\n        {\\n            if(pos[i] == 0)\\n            {\\n                res += (1 << i);\\n                    \\n                count--;\\n            }\\n                \\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649070,
                "title": "easy-expand-from-middle",
                "content": "# Intuition\\nExpand num1 to both side and check if the bitcount for those numbers = bitCount of num2.\\nif so calculate the xor for both the side and break the for loop.\\nreturn the ans for which xor is minimum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        \\n        int num2Bit=Integer.bitCount(num2);\\n        int ans1=0,ans2=0;\\n        \\n        int xor1=Integer.MAX_VALUE,xor2=Integer.MAX_VALUE;\\n        //Expand from num1 to 0  until it finds bitCount = bitcount for num2\\n        for(int i=0;i<999999999;i++)\\n        {\\n            int x=num1-i;\\n            if(Integer.bitCount(x)==num2Bit)\\n            {\\n                xor1=x^num1;\\n                ans1=x;\\n                break;\\n            }\\n            if(x==0)\\n                break;\\n            \\n        }\\n        //Expand from num1 to it\\'s greater until it finds bitCount = bitcount for num2\\n        for(int i=0;i<999999999;i++)\\n        {\\n            int y=num1+i;\\n            \\n            if(Integer.bitCount(y)==num2Bit)\\n            {\\n               xor2=num1^y;\\n                ans2=y;\\n                break;\\n            }\\n            if(y>=999999999 || y<0)\\n                break;\\n                \\n        }\\n        \\n        //System.out.println(xor1+\" \"+xor2+\" \"+ans1+\" \"+ans2);\\n        \\n        return xor2<xor1?ans2:ans1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        \\n        int num2Bit=Integer.bitCount(num2);\\n        int ans1=0,ans2=0;\\n        \\n        int xor1=Integer.MAX_VALUE,xor2=Integer.MAX_VALUE;\\n        //Expand from num1 to 0  until it finds bitCount = bitcount for num2\\n        for(int i=0;i<999999999;i++)\\n        {\\n            int x=num1-i;\\n            if(Integer.bitCount(x)==num2Bit)\\n            {\\n                xor1=x^num1;\\n                ans1=x;\\n                break;\\n            }\\n            if(x==0)\\n                break;\\n            \\n        }\\n        //Expand from num1 to it\\'s greater until it finds bitCount = bitcount for num2\\n        for(int i=0;i<999999999;i++)\\n        {\\n            int y=num1+i;\\n            \\n            if(Integer.bitCount(y)==num2Bit)\\n            {\\n               xor2=num1^y;\\n                ans2=y;\\n                break;\\n            }\\n            if(y>=999999999 || y<0)\\n                break;\\n                \\n        }\\n        \\n        //System.out.println(xor1+\" \"+xor2+\" \"+ans1+\" \"+ans2);\\n        \\n        return xor2<xor1?ans2:ans1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649034,
                "title": "c-solution-without-bitmasking-bit-count-stl-functions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int a, int b) {\\n        int cnta=__builtin_popcount(a);\\n        int cntb=__builtin_popcount(b);\\n        if(cnta==cntb)return a;\\n        string s = std::bitset<32>(a).to_string();\\n        string ans =s;        \\n        if(cnta>cntb){\\n            cnta-=cntb;\\n        for(int i=31;i>=0;i--){\\n            if(s[i]==\\'1\\' and cnta>0){\\n                ans[i]=\\'0\\';\\n                cnta--;\\n            }\\n        }\\n            return std::bitset<32>(ans).to_ulong();\\n        }\\n        \\n        else if(cnta<cntb){\\n            \\n            unordered_set<int>st;\\n            for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\'){\\n               st.insert(i);\\n            }\\n        }\\n            cntb-=cnta;\\n            for(int i=31;i>=0;i--){\\n                if(cntb<=0)break;\\n                else if(s[i]==\\'0\\' and st.find(i)==st.end()){\\n                    ans[i]=\\'1\\';\\n                    cntb--;\\n                }\\n                else continue;\\n            }\\n            return std::bitset<32>(ans).to_ulong();\\n        }\\n       return std::bitset<32>(ans).to_ulong();\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int a, int b) {\\n        int cnta=__builtin_popcount(a);\\n        int cntb=__builtin_popcount(b);\\n        if(cnta==cntb)return a;\\n        string s = std::bitset<32>(a).to_string();\\n        string ans =s;        \\n        if(cnta>cntb){\\n            cnta-=cntb;\\n        for(int i=31;i>=0;i--){\\n            if(s[i]==\\'1\\' and cnta>0){\\n                ans[i]=\\'0\\';\\n                cnta--;\\n            }\\n        }\\n            return std::bitset<32>(ans).to_ulong();\\n        }\\n        \\n        else if(cnta<cntb){\\n            \\n            unordered_set<int>st;\\n            for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\'){\\n               st.insert(i);\\n            }\\n        }\\n            cntb-=cnta;\\n            for(int i=31;i>=0;i--){\\n                if(cntb<=0)break;\\n                else if(s[i]==\\'0\\' and st.find(i)==st.end()){\\n                    ans[i]=\\'1\\';\\n                    cntb--;\\n                }\\n                else continue;\\n            }\\n            return std::bitset<32>(ans).to_ulong();\\n        }\\n       return std::bitset<32>(ans).to_ulong();\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649033,
                "title": "c",
                "content": "\\tint minimizeXor(int nums1, int nums2) {\\n        int sb =0;\\n        for(int i=0; i<32; i++){\\n            if(nums2 & (1<<i))sb++;\\n        }\\n        vector<int>v(32,0);\\n        \\n        for(int i=31; i>=0; i--){\\n            if(nums1 & (1<<i)){\\n                if(sb>0)v[i]=1;\\n                sb--;\\n            }\\n        }\\n       for(int i=0; i<32; i++){\\n           if(sb>0 && v[i]==0){\\n               sb--;\\n               v[i]=1;\\n           }\\n       }\\n\\t\\tint ans =0;\\n\\t\\tfor(int i=0; i<32; i++){\\n\\t\\t\\tans+=v[i]*pow(2,i);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "\\tint minimizeXor(int nums1, int nums2) {\\n        int sb =0;\\n        for(int i=0; i<32; i++){\\n            if(nums2 & (1<<i))sb++;\\n        }\\n        vector<int>v(32,0);\\n        \\n        for(int i=31; i>=0; i--){\\n            if(nums1 & (1<<i)){\\n                if(sb>0)v[i]=1;\\n                sb--;\\n            }\\n        }\\n       for(int i=0; i<32; i++){\\n           if(sb>0 && v[i]==0){\\n               sb--;\\n               v[i]=1;\\n           }\\n       }\\n\\t\\tint ans =0;\\n\\t\\tfor(int i=0; i<32; i++){\\n\\t\\t\\tans+=v[i]*pow(2,i);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2649017,
                "title": "c-solution-bit-manipulatin",
                "content": "# Complexity\\n- Time complexity:\\n`O(1)`\\n\\n- Space complexity:\\n`O(1)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int minimizeXor(int num1, int num2) {\\n        num2 = __builtin_popcount(num2);\\n        int ret = num1;\\n        num1 = __builtin_popcount(num1);\\n        if (num1 > num2)\\n            for (int i = 0, i_end = num1 - num2; i < i_end; ++i)\\n                ret &= ret - 1;\\n        if (num1 < num2) {\\n            int tmp = uint32_t(ret);\\n            tmp = ~tmp;\\n            for (int i = 0, i_end = num2 - num1; i < i_end; ++i)\\n                tmp &= tmp - 1;\\n            ret |= ~tmp;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int minimizeXor(int num1, int num2) {\\n        num2 = __builtin_popcount(num2);\\n        int ret = num1;\\n        num1 = __builtin_popcount(num1);\\n        if (num1 > num2)\\n            for (int i = 0, i_end = num1 - num2; i < i_end; ++i)\\n                ret &= ret - 1;\\n        if (num1 < num2) {\\n            int tmp = uint32_t(ret);\\n            tmp = ~tmp;\\n            for (int i = 0, i_end = num2 - num1; i < i_end; ++i)\\n                tmp &= tmp - 1;\\n            ret |= ~tmp;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649006,
                "title": "bit-count-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   int minimizeXor(int num1, int num2) {\\n        int bits = __builtin_popcount(num2);\\n        int ans = 0;\\n        for(int i=31;i>=0 and bits;i--){\\n          if((num1 & (1<<i)))ans =  ans | (1<<i),bits--; \\n        }\\n        for(int i = 0 ; i <= 31 and bits; i++) {\\n            if(!(num1 & (1<<i)))ans =  ans | (1<<i),bits--; \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int minimizeXor(int num1, int num2) {\\n        int bits = __builtin_popcount(num2);\\n        int ans = 0;\\n        for(int i=31;i>=0 and bits;i--){\\n          if((num1 & (1<<i)))ans =  ans | (1<<i),bits--; \\n        }\\n        for(int i = 0 ; i <= 31 and bits; i++) {\\n            if(!(num1 & (1<<i)))ans =  ans | (1<<i),bits--; \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648867,
                "title": "easy-c-solution-bit-manipulation",
                "content": "**Easy C++ Solution with Bit Manipulation**\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int setnum1 = __builtin_popcount(num1) ;\\n        int setnum2 = __builtin_popcount(num2) ;\\n        int ans = 0 ;\\n        \\n        for(int i=0; i<=31 ; ++i){\\n            int maskbit = 1<<i ;\\n            int setbit = num1 & maskbit ;\\n            if(setbit && setnum1 > setnum2) setnum1-- ;\\n            else if(setbit == 0 && setnum2 > setnum1){\\n                ans |=(maskbit);\\n                setnum2--;\\n            }\\n            else ans |= setbit ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n**DO UPVOTE, if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int setnum1 = __builtin_popcount(num1) ;\\n        int setnum2 = __builtin_popcount(num2) ;\\n        int ans = 0 ;\\n        \\n        for(int i=0; i<=31 ; ++i){\\n            int maskbit = 1<<i ;\\n            int setbit = num1 & maskbit ;\\n            if(setbit && setnum1 > setnum2) setnum1-- ;\\n            else if(setbit == 0 && setnum2 > setnum1){\\n                ans |=(maskbit);\\n                setnum2--;\\n            }\\n            else ans |= setbit ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648824,
                "title": "c-explanation-with-comments-bit-count-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int minimizeXor(int num1, int num2) {\\n        long long i,j=0,k=0,n=num1,m=num2;\\n        //count set bits in 1st\\n        while(num1) j++,num1=num1&(num1-1);\\n        //count set bits in second\\n        while(num2) k++,num2=num2&(num2-1);\\n        //if both are equal return num1\\n        if(j==k) return n;\\n        num1=n;num2=m;\\n        cout<<j<<k<<\" \";\\n        //if first has more bits them we have to unset some\\n        if(j>k){\\n            long long mask=1;\\n            //clear(unset) bits from right to left\\n            while(j>k){\\n                if(num1&mask) j--,num1=num1^mask;\\n                mask=mask<<1;\\n            }\\n          return num1;\\n        }\\n        //if set bits are less then we have to set bits, we will set them from right to left to get min ans\\n        else{\\n            long long mask=1;\\n            while(j!=k){\\n                if(!(num1&mask)) k--,num1=num1|mask;\\n                mask=mask<<1;\\n                cout<<mask;\\n                  \\n            }\\n            return num1;\\n        }\\n    }\\n\\t};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minimizeXor(int num1, int num2) {\\n        long long i,j=0,k=0,n=num1,m=num2;\\n        //count set bits in 1st\\n        while(num1) j++,num1=num1&(num1-1);\\n        //count set bits in second\\n        while(num2) k++,num2=num2&(num2-1);\\n        //if both are equal return num1\\n        if(j==k) return n;\\n        num1=n;num2=m;\\n        cout<<j<<k<<\" \";\\n        //if first has more bits them we have to unset some\\n        if(j>k){\\n            long long mask=1;\\n            //clear(unset) bits from right to left\\n            while(j>k){\\n                if(num1&mask) j--,num1=num1^mask;\\n                mask=mask<<1;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2648808,
                "title": "javascript-greedy-84ms",
                "content": "Main idea: \\nhow to get min\\n(1) use 1\\'s from num2 to remove higher 1\\'s(left -> right) in num1 (1 ^ 1)\\n(2) if doesn\\'t reach to num2 1\\'s, need to fill the rest 1\\'s to not used i\\'s from lowest-> highest (0 ^ 1)\\n```\\nconst minimizeXor = (a, b) => {\\n    let sa = a.toString(2), sb = b.toString(2), one = 0, min = 0, n = Math.max(sa.length, sb.length), used = new Set();\\n    if (sa.length < n) sa = \\'0\\'.repeat(n - sa.length) + sa; // fill leading 0\\'s\\n    if (sb.length < n) sb = \\'0\\'.repeat(n - sb.length) + sb;\\n    sa = sa.split(\"\");\\n    for (const c of sb) {\\n        if (c == \\'1\\') one++;\\n    }\\n    for (let i = 0; i < sa.length && one > 0; i++) {\\n        if (sa[i] == \\'1\\') { // 1 ^ 1\\n            one--;\\n            sa[i] = \\'0\\';\\n            used.add(i);\\n        }\\n    }\\n    if (one > 0) {\\n        for (let i = sa.length - 1; ~i && one > 0; i--) { // 0 ^ 1\\n            if (sa[i] == \\'0\\' && !used.has(i)) {\\n                sa[i] = \\'1\\';\\n                one--;\\n            }\\n        }\\n    }\\n    for (let i = sa.length - 1; ~i; i--) { // calculate the min\\n        if (sa[i] == \\'1\\') min += 1 << sa.length - i - 1;\\n    }\\n    return min ^ a;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst minimizeXor = (a, b) => {\\n    let sa = a.toString(2), sb = b.toString(2), one = 0, min = 0, n = Math.max(sa.length, sb.length), used = new Set();\\n    if (sa.length < n) sa = \\'0\\'.repeat(n - sa.length) + sa; // fill leading 0\\'s\\n    if (sb.length < n) sb = \\'0\\'.repeat(n - sb.length) + sb;\\n    sa = sa.split(\"\");\\n    for (const c of sb) {\\n        if (c == \\'1\\') one++;\\n    }\\n    for (let i = 0; i < sa.length && one > 0; i++) {\\n        if (sa[i] == \\'1\\') { // 1 ^ 1\\n            one--;\\n            sa[i] = \\'0\\';\\n            used.add(i);\\n        }\\n    }\\n    if (one > 0) {\\n        for (let i = sa.length - 1; ~i && one > 0; i--) { // 0 ^ 1\\n            if (sa[i] == \\'0\\' && !used.has(i)) {\\n                sa[i] = \\'1\\';\\n                one--;\\n            }\\n        }\\n    }\\n    for (let i = sa.length - 1; ~i; i--) { // calculate the min\\n        if (sa[i] == \\'1\\') min += 1 << sa.length - i - 1;\\n    }\\n    return min ^ a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648803,
                "title": "javascript-count-bits",
                "content": "**Thoughts**\\n So the bitwise `XOR` operation can either remove or add a `1` bitwise.\\n For example, you can add `1` to `10` by XOR `01`, or remove `1` by XOR `10`.\\n\\n **Algorithm**\\n Count number of `1s` in binary of num1 and num2. Named `num1Bits` and `num2Bits`\\n 3 cases here:\\n  1. `num1Bits` == `num2Bits`, `x` can be equal to `num1` therefore `x XOR num1` must be 0, which will be minimal\\n  2. `num1Bits` > `num2Bits`, `x` can eliminate `num2Bits` of left most `1s` bits from `num1` so that `x XOR num1` will be minimal.\\n  3. `num1Bits` < `num2Bits`, `x` can eliminate all the `1s` in `num1` and add `num2Bits - num1Bits` `1s` from LSB to MSB, where the 1s was not present in `num1`\\n```\\n/**\\n * @param {number} num1\\n * @param {number} num2\\n * @return {number}\\n */\\nvar minimizeXor = function(num1, num2) {\\n    // Counts bits in num1 and num2\\n    let num1Bits = 0;\\n    let num2Bits = 0;\\n    for (let b = 0; b < 30; b++) {\\n        if ((num1 & (1 << b)) > 0) {\\n            num1Bits++;\\n        }\\n        if ((num2 & (1 << b)) > 0) {\\n            num2Bits++;\\n        }\\n    }\\n    if (num1Bits === num2Bits) {\\n        // x = num1, so `x XOR num1` must be 0, which will be minimal\\n        return num1;\\n    }\\n    if (num2Bits < num1Bits) {\\n        // eliminate bits from MSB to LSB, then you\\'ll get minial `x XOR num1`\\n        let result = 0;\\n        let bitsLeft = num2Bits;\\n        for (let b = 29; b >= 0; b--) {\\n            if ((num1 & (1 << b)) > 0) {\\n                result += 1 << b;\\n                bitsLeft--;\\n                if (bitsLeft === 0) {\\n                    return result;\\n                }\\n            }\\n        }\\n    }\\n    \\n    // num2Bits > num1Bits\\n    \\n    // eliminate all bits exist in num1\\n    let result = num1;\\n    let bitsLeft = num2Bits - num1Bits;\\n    \\n    // add `num2Bits - num1Bits` bits from LSB to MSB\\n    for (let b = 0; b < 30; b++) {\\n        if ((num1 & (1 << b)) === 0) {\\n            result += 1 << b;\\n            bitsLeft--;\\n            if (bitsLeft === 0) {\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num1\\n * @param {number} num2\\n * @return {number}\\n */\\nvar minimizeXor = function(num1, num2) {\\n    // Counts bits in num1 and num2\\n    let num1Bits = 0;\\n    let num2Bits = 0;\\n    for (let b = 0; b < 30; b++) {\\n        if ((num1 & (1 << b)) > 0) {\\n            num1Bits++;\\n        }\\n        if ((num2 & (1 << b)) > 0) {\\n            num2Bits++;\\n        }\\n    }\\n    if (num1Bits === num2Bits) {\\n        // x = num1, so `x XOR num1` must be 0, which will be minimal\\n        return num1;\\n    }\\n    if (num2Bits < num1Bits) {\\n        // eliminate bits from MSB to LSB, then you\\'ll get minial `x XOR num1`\\n        let result = 0;\\n        let bitsLeft = num2Bits;\\n        for (let b = 29; b >= 0; b--) {\\n            if ((num1 & (1 << b)) > 0) {\\n                result += 1 << b;\\n                bitsLeft--;\\n                if (bitsLeft === 0) {\\n                    return result;\\n                }\\n            }\\n        }\\n    }\\n    \\n    // num2Bits > num1Bits\\n    \\n    // eliminate all bits exist in num1\\n    let result = num1;\\n    let bitsLeft = num2Bits - num1Bits;\\n    \\n    // add `num2Bits - num1Bits` bits from LSB to MSB\\n    for (let b = 0; b < 30; b++) {\\n        if ((num1 & (1 << b)) === 0) {\\n            result += 1 << b;\\n            bitsLeft--;\\n            if (bitsLeft === 0) {\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648797,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution{\\ntypedef long long ll;\\npublic:\\n    int minimizeXor(const int a, const int b) {\\n        ll ans=0, rem=__builtin_popcount(b);\\n        for(ll i=31;i>-1;--i){\\n            if((a>>i)&1){\\n                if(rem>0){\\n                    --rem;\\n                    ans|=1<<i;\\n                }\\n            }\\n            else{\\n                if(rem>i){\\n                    ans|=1<<i;\\n                    --rem;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution{\\ntypedef long long ll;\\npublic:\\n    int minimizeXor(const int a, const int b) {\\n        ll ans=0, rem=__builtin_popcount(b);\\n        for(ll i=31;i>-1;--i){\\n            if((a>>i)&1){\\n                if(rem>0){\\n                    --rem;\\n                    ans|=1<<i;\\n                }\\n            }\\n            else{\\n                if(rem>i){\\n                    ans|=1<<i;\\n                    --rem;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648796,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n        int cnt=0;\\n        vector<int>a(32);\\n        for(int i=0;i<=31;i++)\\n        {\\n            if(num2 & (1<<i))\\n            {\\n                cnt++;\\n            }\\n\\t\\t\\t//Storing the num1 bits in array\\n            if(num1 & (1<<i))\\n            {\\n                a[31-i]=1;\\n            }\\n        }\\n        vector<int>ans(32);\\n        \\n\\t\\t//setting highest bit to 1 if a[i]=1\\n        for(int i=0;i<32;i++)\\n        {\\n            if(a[i] && cnt)\\n            {\\n                ans[i]=1;\\n                cnt--;\\n            }\\n        }\\n        int i=31;\\n      \\n\\t\\t//if no. of setbits is more in num2 than num1\\n        while(i>=0 && cnt)\\n        {\\n            if(a[i]==0)\\n            {\\n                ans[i]=1;\\n                cnt--;\\n            }\\n            i--;\\n        }\\n        int res=0;\\n        //forming the answer\\n        for(int i=31;i>=0;i--)\\n        {\\n            if(ans[i])\\n            {\\n                res=res+(1<<(31-i));\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        \\n        int cnt=0;\\n        vector<int>a(32);\\n        for(int i=0;i<=31;i++)\\n        {\\n            if(num2 & (1<<i))\\n            {\\n                cnt++;\\n            }\\n\\t\\t\\t//Storing the num1 bits in array\\n            if(num1 & (1<<i))\\n            {\\n                a[31-i]=1;\\n            }\\n        }\\n        vector<int>ans(32);\\n        \\n\\t\\t//setting highest bit to 1 if a[i]=1\\n        for(int i=0;i<32;i++)\\n        {\\n            if(a[i] && cnt)\\n            {\\n                ans[i]=1;\\n                cnt--;\\n            }\\n        }\\n        int i=31;\\n      \\n\\t\\t//if no. of setbits is more in num2 than num1\\n        while(i>=0 && cnt)\\n        {\\n            if(a[i]==0)\\n            {\\n                ans[i]=1;\\n                cnt--;\\n            }\\n            i--;\\n        }\\n        int res=0;\\n        //forming the answer\\n        for(int i=31;i>=0;i--)\\n        {\\n            if(ans[i])\\n            {\\n                res=res+(1<<(31-i));\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648784,
                "title": "minimize-xor-simple-c-solution-bitwise-xor",
                "content": "**Explaination**\\n\\n**Step 1::**\\nCount set bits in num1 and num2\\nLet pnt and cnt be the count of set bits in num1 and num2 respectively.\\n\\n**Step 2::**\\nNow we want to minimize the xor of x and num1.\\n\\n\\nThere are two cases ::\\nCase 1::\\ncnt<=pnt i.e. set bits in x are less than or equal to num1\\n\\nWe will try to set as many bits as possible high in x on positions where bits of num1 are also high from left to right (MSB--->LSB)\\n(beacuse xor of 1 and 1 is zero, and our target is to destroy higher magnitude bits, hence MSB to LSB)\\n\\nCase 2::\\ncnt>pnt i.e. set bits in x are greater than num1\\n1. Make all  postions high in x which are high in num1 (we are done with pnt bits)\\n2. Set (cnt-pnt) no. of  bits high from right to left (LSB to MSB) in x.\\n```\\nclass Solution \\n{\\npublic:\\n    int minimizeXor(int num1, int num2) \\n    {\\n       int cnt =0;\\n        // count set bits in num2\\n        while(num2)\\n        {\\n            if(num2&1)\\n                cnt++;\\n            num2>>=1;\\n        }\\n        \\n        \\n        int pnt =0;\\n        // count setbits in num1\\n        int num = num1;\\n          while(num)\\n        {\\n            if(num&1)\\n                pnt++;\\n            num>>=1;\\n        }\\n        \\n        int ans=0;\\n        if(cnt<=pnt)  \\n        {\\n            \\n            for(int i=30;i>=0;i--) \\n            {\\n                if(num1&(1<<i))   \\n                {\\n                   if(cnt)\\n                   {\\n                        ans|=(1<<i);\\n                       cnt--;\\n                   }    \\n                    \\n                }\\n            }\\n        }\\n        else\\n        {\\n            int make_set= cnt-pnt;\\n            \\n            for(int i=0;i<=30;i++)\\n            {\\n                if((num1&(1<<i)))\\n                {\\n                     ans|=(1<<i);\\n                }\\n                else\\n                {\\n                    if(make_set)\\n                    {\\n                       ans|=(1<<i);\\n                        make_set--;\\n                    } \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimizeXor(int num1, int num2) \\n    {\\n       int cnt =0;\\n        // count set bits in num2\\n        while(num2)\\n        {\\n            if(num2&1)\\n                cnt++;\\n            num2>>=1;\\n        }\\n        \\n        \\n        int pnt =0;\\n        // count setbits in num1\\n        int num = num1;\\n          while(num)\\n        {\\n            if(num&1)\\n                pnt++;\\n            num>>=1;\\n        }\\n        \\n        int ans=0;\\n        if(cnt<=pnt)  \\n        {\\n            \\n            for(int i=30;i>=0;i--) \\n            {\\n                if(num1&(1<<i))   \\n                {\\n                   if(cnt)\\n                   {\\n                        ans|=(1<<i);\\n                       cnt--;\\n                   }    \\n                    \\n                }\\n            }\\n        }\\n        else\\n        {\\n            int make_set= cnt-pnt;\\n            \\n            for(int i=0;i<=30;i++)\\n            {\\n                if((num1&(1<<i)))\\n                {\\n                     ans|=(1<<i);\\n                }\\n                else\\n                {\\n                    if(make_set)\\n                    {\\n                       ans|=(1<<i);\\n                        make_set--;\\n                    } \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648726,
                "title": "python-ac-greedy-bits-easy-to-understand",
                "content": "# Intuition\\nIntuition : XOR of same bit is 0 i.e, 0^0 = 0, 1^1 = 0, 0^1 = 1^0 = 1\\nSo, to minimize x ^ num1, we want as many bits of x to be same as num1, especially the 1s\\n\\n# Approach\\n1. Count no. of 1s in num2. This is the min number of bits in x (as we have to set these many 1s no matter what)\\n2. No. of bits in x = Maximum of num bits in num1, Num 1s in num2\\n3. Use greedy approach. Whatever is maximal bit of num1 that is 1, set that bit of x to 1 and iterate.\\n4. If we still have 1s left (as no. of 1s in num2 might be more than no. of 1s in num1), then go the reverse direction. Set the minimal bit of x that is still 0. Minimal bit as we want to minimize the xor\\n\\n# Complexity\\n- Time complexity:\\nO(number of bits)\\n\\n- Space complexity:\\nO(number of bits)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        numBitsToSet = 0\\n        while num2:\\n            numBitsToSet += num2 & 1\\n            num2 = num2 >> 1\\n        \\n        num1Str = bin(num1)[2:]\\n        num1Len = len(num1Str)\\n        \\n        outLen = max(num1Len, numBitsToSet)\\n        out = [\\'0\\' for i in range(outLen)]\\n        \\n        num1Str = \\'0\\'*(outLen-num1Len) + num1Str\\n        \\n        #print(\\'numBitsToSet\\', numBitsToSet, \\'num1Len\\', num1Len, \\'num1Str\\', num1Str, \\'outLen\\', outLen)\\n        \\n        # Match the 1s of num1\\n        for i in range(outLen):\\n            if numBitsToSet == 0:\\n                break\\n            if num1Str[i] == \\'1\\':\\n                out[i] = \\'1\\'\\n                numBitsToSet -= 1\\n        \\n        # Set minimal bits that are 0\\n        for i in range(outLen-1, -1, -1):\\n            if numBitsToSet == 0:\\n                break\\n            if out[i] == \\'0\\':\\n                out[i] = \\'1\\'\\n                numBitsToSet -= 1\\n        \\n        #print(\\'Modified out\\', out)\\n        return int(\\'\\'.join(out), 2)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        numBitsToSet = 0\\n        while num2:\\n            numBitsToSet += num2 & 1\\n            num2 = num2 >> 1\\n        \\n        num1Str = bin(num1)[2:]\\n        num1Len = len(num1Str)\\n        \\n        outLen = max(num1Len, numBitsToSet)\\n        out = [\\'0\\' for i in range(outLen)]\\n        \\n        num1Str = \\'0\\'*(outLen-num1Len) + num1Str\\n        \\n        #print(\\'numBitsToSet\\', numBitsToSet, \\'num1Len\\', num1Len, \\'num1Str\\', num1Str, \\'outLen\\', outLen)\\n        \\n        # Match the 1s of num1\\n        for i in range(outLen):\\n            if numBitsToSet == 0:\\n                break\\n            if num1Str[i] == \\'1\\':\\n                out[i] = \\'1\\'\\n                numBitsToSet -= 1\\n        \\n        # Set minimal bits that are 0\\n        for i in range(outLen-1, -1, -1):\\n            if numBitsToSet == 0:\\n                break\\n            if out[i] == \\'0\\':\\n                out[i] = \\'1\\'\\n                numBitsToSet -= 1\\n        \\n        #print(\\'Modified out\\', out)\\n        return int(\\'\\'.join(out), 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648677,
                "title": "python-distribute-the-ones-concise-greedy-solution",
                "content": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        bin2 = \"{0:b}\".format(num2)\\n        bin1 = \"{0:b}\".format(num1)\\n        \\n        diff = len(bin2) - len(bin1)\\n        zeros = \"0\" * diff\\n        \\n        bin1 = zeros + bin1\\n        \\n        ones = bin2.count(\\'1\\')\\n        \\n        # Pass one\\n        seen = [False] * len(bin1)\\n        xor_char = [\\'0\\'] * len(bin1)\\n        for index, letter in enumerate(bin1):\\n            if letter == \\'1\\' and ones > 0:\\n                seen[index] = True\\n                xor_char[index] = \\'1\\'\\n                ones -= 1\\n        \\n        # Pass two, convert zeros to ones\\n        i = len(xor_char) - 1\\n        while ones > 0 and i >= 0:\\n            if bin1[i] == \\'0\\'and seen[i] == False:\\n                xor_char[i] = \\'1\\'\\n                ones -= 1\\n            i -= 1\\n\\n        final_bin = \"\".join(xor_char)\\n        final_int = int(final_bin, 2)\\n        return final_int\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        bin2 = \"{0:b}\".format(num2)\\n        bin1 = \"{0:b}\".format(num1)\\n        \\n        diff = len(bin2) - len(bin1)\\n        zeros = \"0\" * diff\\n        \\n        bin1 = zeros + bin1\\n        \\n        ones = bin2.count(\\'1\\')\\n        \\n        # Pass one\\n        seen = [False] * len(bin1)\\n        xor_char = [\\'0\\'] * len(bin1)\\n        for index, letter in enumerate(bin1):\\n            if letter == \\'1\\' and ones > 0:\\n                seen[index] = True\\n                xor_char[index] = \\'1\\'\\n                ones -= 1\\n        \\n        # Pass two, convert zeros to ones\\n        i = len(xor_char) - 1\\n        while ones > 0 and i >= 0:\\n            if bin1[i] == \\'0\\'and seen[i] == False:\\n                xor_char[i] = \\'1\\'\\n                ones -= 1\\n            i -= 1\\n\\n        final_bin = \"\".join(xor_char)\\n        final_int = int(final_bin, 2)\\n        return final_int\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648654,
                "title": "python3-least-bits-o-log-num1",
                "content": "Count the number of bits in num1 and num2. If they\\'re equal, then we can just use num1 as our result for an XOR of 0.\\n\\nOtherwise, we need to either add or subtract the least-significant bits that we can from our result to minimize the XOR.\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        n = bin(num2).count(\\'1\\')\\n        m = bin(num1).count(\\'1\\')\\n        res = num1\\n        i = 1\\n        while m > n:\\n            if res & i:\\n                res -= i\\n                m -= 1\\n            i <<= 1\\n        while m < n:\\n            if res & i == 0:\\n                res += i\\n                m += 1\\n            i <<= 1\\n        return res\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        n = bin(num2).count(\\'1\\')\\n        m = bin(num1).count(\\'1\\')\\n        res = num1\\n        i = 1\\n        while m > n:\\n            if res & i:\\n                res -= i\\n                m -= 1\\n            i <<= 1\\n        while m < n:\\n            if res & i == 0:\\n                res += i\\n                m += 1\\n            i <<= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077066,
                "title": "easy-simple-solution-using-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int setBitCt = __builtin_popcount(num2);\\n        int ans = 0;\\n       int  ct =0, cntr=0;\\n        for( int i =31 ; i>=0; i--)\\n        {\\n            if(num1& ( 1<<(i))){\\n                // cout<<\" set bit found for \" << i<<\" \" <<++cntr<<endl;\\n                if( ct < setBitCt ){\\n                    ans = (ans  | (1 << (i ))); \\n                }\\n                ct++;\\n            }\\n        }\\n        int i =0;\\n        while (ct < setBitCt)\\n        {\\n                 if(ans& ( 1<<(i))){\\n                 }\\n                 else\\n                 {\\n                    ans = (ans  | (1 << (i ))); \\n                    ct++;\\n                 }\\n                 i++;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int setBitCt = __builtin_popcount(num2);\\n        int ans = 0;\\n       int  ct =0, cntr=0;\\n        for( int i =31 ; i>=0; i--)\\n        {\\n            if(num1& ( 1<<(i))){\\n                // cout<<\" set bit found for \" << i<<\" \" <<++cntr<<endl;\\n                if( ct < setBitCt ){\\n                    ans = (ans  | (1 << (i ))); \\n                }\\n                ct++;\\n            }\\n        }\\n        int i =0;\\n        while (ct < setBitCt)\\n        {\\n                 if(ans& ( 1<<(i))){\\n                 }\\n                 else\\n                 {\\n                    ans = (ans  | (1 << (i ))); \\n                    ct++;\\n                 }\\n                 i++;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4076097,
                "title": "minimize-xor-greedy-c",
                "content": "To make the XOR result between num1 and num2 as small as possible, we aim to align their most significant bits (MSBs). This ensures that the bits with the highest value in num1 are identical to those in num2, effectively reducing the XOR value in the most significant part of the binary representation.\\n\\nFirst, we calculate tc, which stands for the \"bit count\" of num2. This count represents the number of set (1) bits in num2.\\n\\nWe initialize a variable ans to 0, which will store the minimized XOR result.\\n\\nWe iterate through each bit position from the 31st (most significant) to the 0th (least significant).\\n\\nIn the first loop, we check if tc is greater than 0 and if the bit at the same position in num1 is set (1). If both conditions are met, we set the corresponding bit in ans to 1 and decrement tc. This step ensures that we match the MSBs of num1 with those of num2.\\nAfter aligning the MSBs, we move on to the less significant bits by iterating from 0 to 30.\\n\\nIn this loop, again, we check if tc is greater than 0, but this time, we check if the bit at the current position in num1 is not set (0). If both conditions are met, we set the corresponding bit in ans to 1 and decrement tc. This step ensures that we fill the remaining less significant bits in num1 with 1s to minimize the XOR result.\\nFinally, we return the ans value, which now represents the minimized XOR between num1 and num2.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int tc = __builtin_popcount(num2);\\n        long long ans =0;\\n        for(int i=31;i>=0;i--){\\n            if(tc){\\n                if((num1>>i) & 1){\\n                    ans|=1<<i;\\n                    tc--;\\n                }\\n            }\\n        }\\n        for(int i = 0;i<31;i++){\\n           if(tc){\\n                if(!((num1>>i) & 1)){\\n                    ans|=1<<i;\\n                    tc--;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int tc = __builtin_popcount(num2);\\n        long long ans =0;\\n        for(int i=31;i>=0;i--){\\n            if(tc){\\n                if((num1>>i) & 1){\\n                    ans|=1<<i;\\n                    tc--;\\n                }\\n            }\\n        }\\n        for(int i = 0;i<31;i++){\\n           if(tc){\\n                if(!((num1>>i) & 1)){\\n                    ans|=1<<i;\\n                    tc--;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043242,
                "title": "c-very-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int countsetbit=0,mask=1;\\n        for(int i=0;i<=31;i++){\\n            if((num2&(1<<i))){\\n                countsetbit++;\\n            }\\n        }\\n        int res=0;\\n        for(int i=31;i>=0;i--){\\n            if(countsetbit==0){\\n                break;\\n            }\\n            int mask=1<<i;\\n            if(num1&mask){\\n                res|=mask;\\n                countsetbit--;\\n            }\\n        }\\n        if(countsetbit!=0){\\n            for(int i=0;i<=31;i++){\\n                if(countsetbit==0){\\n                    break;\\n                }\\n                if((res&(1<<i))==0){\\n                    res|=(1<<i);\\n                    countsetbit--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int countsetbit=0,mask=1;\\n        for(int i=0;i<=31;i++){\\n            if((num2&(1<<i))){\\n                countsetbit++;\\n            }\\n        }\\n        int res=0;\\n        for(int i=31;i>=0;i--){\\n            if(countsetbit==0){\\n                break;\\n            }\\n            int mask=1<<i;\\n            if(num1&mask){\\n                res|=mask;\\n                countsetbit--;\\n            }\\n        }\\n        if(countsetbit!=0){\\n            for(int i=0;i<=31;i++){\\n                if(countsetbit==0){\\n                    break;\\n                }\\n                if((res&(1<<i))==0){\\n                    res|=(1<<i);\\n                    countsetbit--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018526,
                "title": "c-explicit-construction-of-the-result",
                "content": "# Intuition\\nThe first condition gives us exact amount of bits in the number. The second one says that all the ones in the binary representation on num1 should be consumed from left to right. This will give XOR 0. Now, if some other bits yet to be added, we go over 1 bits on num1 from smallest to bigger and them.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int MinimizeXor(int num1, int num2) \\n    {\\n        var totalBitsNum2 = 0;\\n        var binary1 = new Dictionary<int, int>();\\n        var binary2 = new Dictionary<int, int>();\\n        var bound = 30;\\n        for(int i = 0; i <= bound; ++i)\\n        {\\n            binary1.Add(i, (num1 & (1 << i) ) > 0 ? 1 : 0);\\n\\n            binary2.Add(i, (num2 & (1 << i) ) > 0 ? 1 : 0);\\n            totalBitsNum2 += binary2[i];\\n        }\\n\\n        var result = 0;\\n        for(int i = bound; i >= 0 && totalBitsNum2 > 0; --i)\\n        {\\n            if(binary1[i] == 1)\\n            {\\n                result += 1 << i;\\n                --totalBitsNum2;\\n            }\\n        }\\n\\n        for(int i = 0; i <= bound && totalBitsNum2 > 0; ++i)\\n        {\\n            if(binary1[i] == 0)\\n            {\\n                result += 1 << i;\\n                --totalBitsNum2;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinimizeXor(int num1, int num2) \\n    {\\n        var totalBitsNum2 = 0;\\n        var binary1 = new Dictionary<int, int>();\\n        var binary2 = new Dictionary<int, int>();\\n        var bound = 30;\\n        for(int i = 0; i <= bound; ++i)\\n        {\\n            binary1.Add(i, (num1 & (1 << i) ) > 0 ? 1 : 0);\\n\\n            binary2.Add(i, (num2 & (1 << i) ) > 0 ? 1 : 0);\\n            totalBitsNum2 += binary2[i];\\n        }\\n\\n        var result = 0;\\n        for(int i = bound; i >= 0 && totalBitsNum2 > 0; --i)\\n        {\\n            if(binary1[i] == 1)\\n            {\\n                result += 1 << i;\\n                --totalBitsNum2;\\n            }\\n        }\\n\\n        for(int i = 0; i <= bound && totalBitsNum2 > 0; ++i)\\n        {\\n            if(binary1[i] == 0)\\n            {\\n                result += 1 << i;\\n                --totalBitsNum2;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875657,
                "title": "greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while(num2){\\n            num2 = num2 & (num2-1);\\n            count++;\\n        }\\n        int x = 0;\\n        int i = 31;\\n        for(; i>=0; i--){\\n            if(i >= count){\\n                bool bit = num1 & (1<<i);\\n                if(bit) count--;\\n                if(count >=0 )\\n                x = x | (bit << i);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n\\n        while(i>=0){\\n            x = x | (1 << i);\\n            i--;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while(num2){\\n            num2 = num2 & (num2-1);\\n            count++;\\n        }\\n        int x = 0;\\n        int i = 31;\\n        for(; i>=0; i--){\\n            if(i >= count){\\n                bool bit = num1 & (1<<i);\\n                if(bit) count--;\\n                if(count >=0 )\\n                x = x | (bit << i);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n\\n        while(i>=0){\\n            x = x | (1 << i);\\n            i--;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873368,
                "title": "cppp-solution-deka-kar-maja-aajayega-bits",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// step1->dekho bhai log approach. bahut simple pehala\\n//     hum no of set bits count karenge of nums2\\n// step2->hum 31 bit se for loop start karenge jaha \\n//  par bhi humare nums1 ki bit ki value 1 hoyegi jo bhi i ki value \\n//  hoyegi usko hum left shift karke(1<<i) isko ans me add kar denge\\n//  decrease the count(no of set bits)\\n//  eg nums1=3 1st bit=1 (10 ko ans me add kar denge ) \\n                // 0 th bit 1 ha(01 ko ans me add kar denge)\\n//agar ab bhi count bacha ho tho \\n//ab hum left side se traversal shuru karenge jaha bhi bit 0 mile usko \\n// 1 kardo \\n\\n\\n// Here\\'s how the binary representation changes with different values of i for left shift :\\n\\n// 1 << 0: 00000001 (1 in decimal)\\n// 1 << 1: 00000010 (2 in decimal)\\n// 1 << 2: 00000100 (4 in decimal)\\n// 1 << 3: 00001000 (8 in decimal)\\n// 1 << 4: 00010000 (16 in decimal)\\n\\n// Here\\'s how the binary representation changes with different values of i for right shift :\\n\\n// 1 >> 0: 00000001 (1 in decimal)\\n// 1 >> 1: 00000000 (0 in decimal)\\n\\n    int minimizeXor(int num1, int num2) {\\n        int count = __builtin_popcount(num2);\\n        int ans = 0;\\n        for(int i=31; i>-1 && count; --i){\\n            if((num1>>i)&1){\\n                ans += (1<<i);// we can also do or here as bitwise or and addition does the same work\\n                count--;\\n            }\\n        }\\n        for(int j=0; j<32 && count; ++j){\\n            if(!((ans>>j)&1)){\\n                ans += (1<<j);// we can also do or here as bitwise or and addition does the same work\\n                count--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// step1->dekho bhai log approach. bahut simple pehala\\n//     hum no of set bits count karenge of nums2\\n// step2->hum 31 bit se for loop start karenge jaha \\n//  par bhi humare nums1 ki bit ki value 1 hoyegi jo bhi i ki value \\n//  hoyegi usko hum left shift karke(1<<i) isko ans me add kar denge\\n//  decrease the count(no of set bits)\\n//  eg nums1=3 1st bit=1 (10 ko ans me add kar denge ) \\n                // 0 th bit 1 ha(01 ko ans me add kar denge)\\n//agar ab bhi count bacha ho tho \\n//ab hum left side se traversal shuru karenge jaha bhi bit 0 mile usko \\n// 1 kardo \\n\\n\\n// Here\\'s how the binary representation changes with different values of i for left shift :\\n\\n// 1 << 0: 00000001 (1 in decimal)\\n// 1 << 1: 00000010 (2 in decimal)\\n// 1 << 2: 00000100 (4 in decimal)\\n// 1 << 3: 00001000 (8 in decimal)\\n// 1 << 4: 00010000 (16 in decimal)\\n\\n// Here\\'s how the binary representation changes with different values of i for right shift :\\n\\n// 1 >> 0: 00000001 (1 in decimal)\\n// 1 >> 1: 00000000 (0 in decimal)\\n\\n    int minimizeXor(int num1, int num2) {\\n        int count = __builtin_popcount(num2);\\n        int ans = 0;\\n        for(int i=31; i>-1 && count; --i){\\n            if((num1>>i)&1){\\n                ans += (1<<i);// we can also do or here as bitwise or and addition does the same work\\n                count--;\\n            }\\n        }\\n        for(int j=0; j<32 && count; ++j){\\n            if(!((ans>>j)&1)){\\n                ans += (1<<j);// we can also do or here as bitwise or and addition does the same work\\n                count--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869135,
                "title": "c-bit-manipulations-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int number_of_bits{};\\n        int min_value{};\\n        \\n        // find number of bits:\\n        while (num2 != 0) {\\n            if (num2 & 1) { // compare bit @ pos 0\\n            number_of_bits++;\\n            };\\n            num2 >>= 1; // shift to right by 1 bit ==> pos1_bit moves to pos0 // old\\n                        // pos0_bit \\'falls off\\'\\n        };\\n\\n        // the constrain of 1 <= num1, num2 <= 10^9 tells us that the binary number\\n        // can have no more than 30 bits.\\n        // We start from LEFT_POS(MSB) to RIGHT_POS(LSB) and set the bits ==> That\\n        // will make sure that num1 XOR x is minimum\\n\\n        for (int pos = 31; pos >= 0 && number_of_bits; pos--) {\\n            if (num1 & (1 << pos)) {   // check if bit is set @ pos\\n            min_value |= (1 << pos); // if yes, set bit in answer value (min_value)\\n            number_of_bits--;        // we used up one bit ... thus will reduce the\\n                                    // number_of_bits by 1\\n            };\\n        };\\n\\n        // if we have some bits left to place we start from\\n        // RIGHT_POS(LSB) to LEFT_POS(MSB) to keep the min_value as small as possible\\n        for (int pos = 0; pos < 32 && number_of_bits; pos++) {\\n            if (!(min_value & (1 << pos))) {  // we only set bits at positions, which are NOT set (0)\\n            min_value |= (1 << pos);\\n            number_of_bits--;\\n            };\\n        };\\n\\n        return min_value;\\n    };\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int number_of_bits{};\\n        int min_value{};\\n        \\n        // find number of bits:\\n        while (num2 != 0) {\\n            if (num2 & 1) { // compare bit @ pos 0\\n            number_of_bits++;\\n            };\\n            num2 >>= 1; // shift to right by 1 bit ==> pos1_bit moves to pos0 // old\\n                        // pos0_bit \\'falls off\\'\\n        };\\n\\n        // the constrain of 1 <= num1, num2 <= 10^9 tells us that the binary number\\n        // can have no more than 30 bits.\\n        // We start from LEFT_POS(MSB) to RIGHT_POS(LSB) and set the bits ==> That\\n        // will make sure that num1 XOR x is minimum\\n\\n        for (int pos = 31; pos >= 0 && number_of_bits; pos--) {\\n            if (num1 & (1 << pos)) {   // check if bit is set @ pos\\n            min_value |= (1 << pos); // if yes, set bit in answer value (min_value)\\n            number_of_bits--;        // we used up one bit ... thus will reduce the\\n                                    // number_of_bits by 1\\n            };\\n        };\\n\\n        // if we have some bits left to place we start from\\n        // RIGHT_POS(LSB) to LEFT_POS(MSB) to keep the min_value as small as possible\\n        for (int pos = 0; pos < 32 && number_of_bits; pos++) {\\n            if (!(min_value & (1 << pos))) {  // we only set bits at positions, which are NOT set (0)\\n            min_value |= (1 << pos);\\n            number_of_bits--;\\n            };\\n        };\\n\\n        return min_value;\\n    };\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864103,
                "title": "c-solution-using-bit-manipulation-and-bitset",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Initialize bitset of size of 32 to store bits of num1.\\n2) Count no. of set bits in num1 and num2 and store them in co1 and co2.\\n3) If co1>=co2, then unset the bit \\'1\\' in num1 starting from MSB going down to LSB, and add the corresponding answer to ans and decrementing count. If count becomes 0 break ( as we cannot unset more bits ahead).\\n4) If co1<co2, then first unset the possible \\'1\\' bits from MSB going down to LSB. Now count co1 still remains, therefore we need to utilize it ( so the best possible way is to set the 0 bits from LSB going up to MSB, we cannot do the reverse way i.e, MSB to LSB since it will increase the answer)> So set the \\'0\\' bits from LSB going up to MSB adding to ans and decrementing count of co2. If co2 becomes 0 , break.\\n\\nFinally, return ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N), where N is no. of bits\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int ans=0;\\n        bitset<32>b(num1);\\n        int co1=0,co2=0;\\n        int i;\\n        for(i=num2;i>0;i/=2)\\n        {\\n            if(i%2==1)\\n                co2++;\\n        }\\n        for(i=num1;i>0;i/=2)\\n        {\\n            if(i%2==1)\\n                co1++;\\n        }\\n        if(co1>=co2)\\n        {\\n            for(i=31;i>=0;i--)\\n            {\\n                if(co2==0)\\n                    break;\\n                if(b[i]==1)\\n                {\\n                    ans=ans+(1<<i);\\n                    co2--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(i=31;i>=0;i--)\\n            {\\n                if(b[i]==1)\\n                {\\n                    ans=ans+(1<<i);\\n                    co2--;\\n                }\\n            }\\n            for(i=0;i<=31;i++)\\n            {\\n                if(co2==0)\\n                    break;\\n                if(b[i]==0)\\n                {\\n                    ans=ans+(1<<i);\\n                    co2--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int ans=0;\\n        bitset<32>b(num1);\\n        int co1=0,co2=0;\\n        int i;\\n        for(i=num2;i>0;i/=2)\\n        {\\n            if(i%2==1)\\n                co2++;\\n        }\\n        for(i=num1;i>0;i/=2)\\n        {\\n            if(i%2==1)\\n                co1++;\\n        }\\n        if(co1>=co2)\\n        {\\n            for(i=31;i>=0;i--)\\n            {\\n                if(co2==0)\\n                    break;\\n                if(b[i]==1)\\n                {\\n                    ans=ans+(1<<i);\\n                    co2--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(i=31;i>=0;i--)\\n            {\\n                if(b[i]==1)\\n                {\\n                    ans=ans+(1<<i);\\n                    co2--;\\n                }\\n            }\\n            for(i=0;i<=31;i++)\\n            {\\n                if(co2==0)\\n                    break;\\n                if(b[i]==0)\\n                {\\n                    ans=ans+(1<<i);\\n                    co2--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847401,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while(num2>0)\\n        {\\n            if(num2&1)\\n            count++;\\n            \\n            num2>>=1;\\n        }\\n        int ans = 0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            if(num1&(1<<i) && count)\\n            {\\n                count--;\\n                ans+=(1<<i);\\n            }\\n        }\\n        int i = 0;\\n        while(count>0 && i<32)\\n        {\\n            if(!(ans&(1<<i)))\\n            {\\n                count--;\\n                ans+=(1<<i);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while(num2>0)\\n        {\\n            if(num2&1)\\n            count++;\\n            \\n            num2>>=1;\\n        }\\n        int ans = 0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            if(num1&(1<<i) && count)\\n            {\\n                count--;\\n                ans+=(1<<i);\\n            }\\n        }\\n        int i = 0;\\n        while(count>0 && i<32)\\n        {\\n            if(!(ans&(1<<i)))\\n            {\\n                count--;\\n                ans+=(1<<i);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810656,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int countSetBits(int n)\\n    {\\n        int count = 0;\\n        while(n != 0)\\n        {\\n            if((n & 1) == 1) count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n    public int unsetLSB(int n,int t)\\n    {\\n        for(int i = 0;i<32;i++)\\n        {\\n            if(t == 0) break;\\n            int mask = 1<<i;\\n            if((n & mask) != 0)\\n            {\\n                n = n ^ mask;\\n                t--;\\n            }\\n        }\\n        return n;\\n    }\\n    public int setLSB(int n,int t)\\n    {\\n        for(int i = 0;i<32;i++)\\n        {\\n            if(t == 0) break;\\n            int mask = 1<<i;\\n            if((n & mask) == 0)\\n            {\\n                n = n | mask;\\n                t--;\\n            }\\n        }\\n        return n;\\n    }\\n    public int minimizeXor(int num1, int num2) \\n    {\\n        int x = countSetBits(num1);\\n        int y = countSetBits(num2);\\n        int ans = 0;\\n        if(x == y) return num1;\\n        if(x > y)\\n        {\\n            ans = unsetLSB(num1,(x-y));\\n        }\\n        else\\n        {\\n            ans = setLSB(num1,(y-x));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int countSetBits(int n)\\n    {\\n        int count = 0;\\n        while(n != 0)\\n        {\\n            if((n & 1) == 1) count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n    public int unsetLSB(int n,int t)\\n    {\\n        for(int i = 0;i<32;i++)\\n        {\\n            if(t == 0) break;\\n            int mask = 1<<i;\\n            if((n & mask) != 0)\\n            {\\n                n = n ^ mask;\\n                t--;\\n            }\\n        }\\n        return n;\\n    }\\n    public int setLSB(int n,int t)\\n    {\\n        for(int i = 0;i<32;i++)\\n        {\\n            if(t == 0) break;\\n            int mask = 1<<i;\\n            if((n & mask) == 0)\\n            {\\n                n = n | mask;\\n                t--;\\n            }\\n        }\\n        return n;\\n    }\\n    public int minimizeXor(int num1, int num2) \\n    {\\n        int x = countSetBits(num1);\\n        int y = countSetBits(num2);\\n        int ans = 0;\\n        if(x == y) return num1;\\n        if(x > y)\\n        {\\n            ans = unsetLSB(num1,(x-y));\\n        }\\n        else\\n        {\\n            ans = setLSB(num1,(y-x));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796212,
                "title": "beats-100",
                "content": "class Solution {\\npublic:\\n\\n    int minimizeXor(int num1, int num2) {\\n        int cnt= __builtin_popcount(num2);\\n        \\n        int ans=0;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            if(cnt==0)\\n                return ans;\\n            \\n            if((1<<i) & num1)\\n            {\\n                cnt--;\\n                ans|= (1<<i);\\n            }\\n        }\\n        \\n        if(cnt==0)\\n            return ans;\\n        \\n        int i=0;\\n        \\n        while(cnt)\\n        {\\n            if(((1<<i) & ans)==0)\\n            {\\n              ans|= (1<<i);\\n              cnt--;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimizeXor(int num1, int num2) {\\n        int cnt= __builtin_popcount(num2);\\n        \\n        int ans=0;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            if(cnt==0)\\n                return ans;\\n            \\n            if((1<<i) & num1)\\n            {\\n                cnt--;\\n                ans|= (1<<i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3775127,
                "title": "beats-100-kernighan-algorithm",
                "content": "\\n# Approach\\nBasic set bit counting using Kernighan Algorithm.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n       int x = num1;\\n       int num2setbits = setbits(num2);\\n       int count = setbits(x);\\n       while (count > num2setbits)\\n       {\\n           int rmsb= x& -x;\\n           x-=rmsb;\\n           count-=1;\\n       }\\n       if (count<num2setbits)\\n       x=~x;\\n       while (count < num2setbits)\\n       {\\n           int rmsb = x&-x;\\n           x-=rmsb;\\n           count+=1;\\n\\n           if (count==num2setbits)\\n           x=~x;\\n       }\\n       return x;\\n    }\\n\\n\\n\\n\\n    int setbits(int n)\\n    {\\n        int count=0;\\n        while (n!=0)\\n        {\\n            int rmsb = n& -n;\\n            n-=rmsb;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n       int x = num1;\\n       int num2setbits = setbits(num2);\\n       int count = setbits(x);\\n       while (count > num2setbits)\\n       {\\n           int rmsb= x& -x;\\n           x-=rmsb;\\n           count-=1;\\n       }\\n       if (count<num2setbits)\\n       x=~x;\\n       while (count < num2setbits)\\n       {\\n           int rmsb = x&-x;\\n           x-=rmsb;\\n           count+=1;\\n\\n           if (count==num2setbits)\\n           x=~x;\\n       }\\n       return x;\\n    }\\n\\n\\n\\n\\n    int setbits(int n)\\n    {\\n        int count=0;\\n        while (n!=0)\\n        {\\n            int rmsb = n& -n;\\n            n-=rmsb;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764981,
                "title": "bitmanipulation-log-n-c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count1 = __builtin_popcount(num1);\\n        int count2 = __builtin_popcount(num2)-count1;\\n        int ans = num1;\\n        if(count2>0)\\n        { \\n            for(int i=0;i<=29&&count2>0;i++)\\n            {\\n            if((ans&(1<<i))==0){ans+=(1<<i);count2--;}\\n            }\\n        }\\n        else if(count2<0)\\n        {\\n           \\n            for(int i=0;i<=29&&count2<0;i++)\\n            {\\n            if(ans&(1<<i)){ans-=(1<<i);count2++;}\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count1 = __builtin_popcount(num1);\\n        int count2 = __builtin_popcount(num2)-count1;\\n        int ans = num1;\\n        if(count2>0)\\n        { \\n            for(int i=0;i<=29&&count2>0;i++)\\n            {\\n            if((ans&(1<<i))==0){ans+=(1<<i);count2--;}\\n            }\\n        }\\n        else if(count2<0)\\n        {\\n           \\n            for(int i=0;i<=29&&count2<0;i++)\\n            {\\n            if(ans&(1<<i)){ans-=(1<<i);count2++;}\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741487,
                "title": "easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n     int ans = 0;\\n        int count= 0;\\n        while(num2)\\n        {\\n           num2=num2&(num2-1);\\n           count++;\\n        }\\n        for(int i = 31; i>= 0 && count; i--)\\n        {\\n            if( num1 & (1<<i))\\n            {\\n                ans |= (1<<i);\\n                count--;\\n            }\\n        }\\n        for(int i = 0; i <32 && count; i++)\\n        {\\n            if((ans & (1<<i)) == 0 )\\n            {\\n                ans |= (1 << i);\\n                count--;\\n            }\\n                \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n     int ans = 0;\\n        int count= 0;\\n        while(num2)\\n        {\\n           num2=num2&(num2-1);\\n           count++;\\n        }\\n        for(int i = 31; i>= 0 && count; i--)\\n        {\\n            if( num1 & (1<<i))\\n            {\\n                ans |= (1<<i);\\n                count--;\\n            }\\n        }\\n        for(int i = 0; i <32 && count; i++)\\n        {\\n            if((ans & (1<<i)) == 0 )\\n            {\\n                ans |= (1 << i);\\n                count--;\\n            }\\n                \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713929,
                "title": "intuition-for-greedy-xor-bit-problem-similar-problems",
                "content": "# Intuition\\n- len1 = bitcount(num1), len2 = bitcount(num2). if len1 == len2, then answer is always num1. now we only need to solve when len1 != len2\\n\\n- a lot of xor problem greedy is either optimizing from prefix or suffix. This is from suffix.\\n\\n# Approach\\n- start from num1\\n- if len2 > len1, it means we have to add more 1s from num1. To ensure min xor value, we add from the rightest 0. otherwise, for len2 < len1, we need to reduce more 1s from num2 from the rightest 1.\\n- reducing rightest 1 is x&(x-1) trick\\n- adding 1 to rightest 0 can be done by first flipping x to y=~x. then do y&(y-1) trick, then flip y again to ~y = x\\n\\n# Complexity\\n- Time complexity:\\nO(32), the max diff is less than 31\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        diff = num2.bit_count() - num1.bit_count()\\n        flip = diff > 0\\n        res = ~num1 if flip else num1\\n        diff = abs(diff)\\n        while diff:\\n            res &= res-1 # remove rightest set bit\\n            diff -= 1\\n        return res if not flip else ~res        \\n```\\n\\n# similar problems\\nMaximum XOR of Two Numbers in an Array : this try to find solution from prefix\\nBitwise AND of Numbers Range: we try to find common prefix of two ranges\\nplease share more if you know one",
                "solutionTags": [
                    "Python3",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        diff = num2.bit_count() - num1.bit_count()\\n        flip = diff > 0\\n        res = ~num1 if flip else num1\\n        diff = abs(diff)\\n        while diff:\\n            res &= res-1 # remove rightest set bit\\n            diff -= 1\\n        return res if not flip else ~res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713928,
                "title": "intuitive-regarding-xor-bit-problem",
                "content": "# Intuition\\n- len1 = bitcount(num1), len2 = bitcount(num2). if len1 == len2, then answer is always num1. now we only need to solve when len1 != len2\\n\\n- a lot of xor problem greedy is either optimizing from prefix or suffix. This is from suffix.\\n\\n# Approach\\n- start from num1\\n- if len2 > len1, it means we have to add more 1s from num1. To ensure min xor value, we add from the rightest 0. otherwise, for len2 < len1, we need to reduce more 1s from num2 from the rightest 1.\\n- reducing rightest 1 is x&(x-1) trick\\n- adding 1 to rightest 0 can be done by first flipping x to y=~x. then do y&(y-1) trick, then flip y again to ~y = x\\n\\n# Complexity\\n- Time complexity:\\nO(32), the max diff is less than 31\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        diff = num2.bit_count() - num1.bit_count()\\n        flip = diff > 0\\n        res = ~num1 if flip else num1\\n        diff = abs(diff)\\n        while diff:\\n            res &= res-1 # remove rightest set bit\\n            diff -= 1\\n        return res if not flip else ~res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        diff = num2.bit_count() - num1.bit_count()\\n        flip = diff > 0\\n        res = ~num1 if flip else num1\\n        diff = abs(diff)\\n        while diff:\\n            res &= res-1 # remove rightest set bit\\n            diff -= 1\\n        return res if not flip else ~res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709088,
                "title": "easy-c-code-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int n1, int n2) {\\n        int c1=0;\\n        while(n2>0){\\n            if(n2&1) c1++;\\n            n2=n2>>1;\\n        }\\n        int y=n1;\\n        int c2=0;\\n        while(y>0){\\n            if(y&1) c2++;\\n            y=y>>1;\\n        }\\n        int x=n1;\\n        if(c1<=c2){\\n            int diff=c2-c1;\\n            int z=n1;\\n            int count=0;\\n            while(diff>0){\\n                if(z&1){\\n                    diff--;\\n                    int e=pow(2,count);\\n                    cout<<e<<endl;\\n                    x=x^e;\\n                }\\n                count++;\\n                z=z>>1;\\n            }\\n        }\\n        else{\\n            int diff=c1-c2;\\n            int z=n1;\\n            int count=0;\\n            while(diff>0){\\n                if(!(z&1)){\\n                    diff--;\\n                    int e=pow(2,count);\\n                    x=x^e;\\n                }\\n                count++;\\n                z=z>>1;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int n1, int n2) {\\n        int c1=0;\\n        while(n2>0){\\n            if(n2&1) c1++;\\n            n2=n2>>1;\\n        }\\n        int y=n1;\\n        int c2=0;\\n        while(y>0){\\n            if(y&1) c2++;\\n            y=y>>1;\\n        }\\n        int x=n1;\\n        if(c1<=c2){\\n            int diff=c2-c1;\\n            int z=n1;\\n            int count=0;\\n            while(diff>0){\\n                if(z&1){\\n                    diff--;\\n                    int e=pow(2,count);\\n                    cout<<e<<endl;\\n                    x=x^e;\\n                }\\n                count++;\\n                z=z>>1;\\n            }\\n        }\\n        else{\\n            int diff=c1-c2;\\n            int z=n1;\\n            int count=0;\\n            while(diff>0){\\n                if(!(z&1)){\\n                    diff--;\\n                    int e=pow(2,count);\\n                    x=x^e;\\n                }\\n                count++;\\n                z=z>>1;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3708418,
                "title": "c-bit-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count=__builtin_popcount(num2)-__builtin_popcount(num1);\\n        \\n        \\n        int i=0;\\n        while(count>0){\\n            if(num1>>i & 1);\\n            else{\\n                num1|=1<<i;count--;\\n            }\\n            i++;\\n        }\\n        i=0;\\n        while(count<0){\\n            \\n            if(num1>>i&1){\\n                count++;\\n                num1^=1<<i;\\n            }\\n            i++;\\n        }\\n        \\n        \\n        \\n        return num1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count=__builtin_popcount(num2)-__builtin_popcount(num1);\\n        \\n        \\n        int i=0;\\n        while(count>0){\\n            if(num1>>i & 1);\\n            else{\\n                num1|=1<<i;count--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3689216,
                "title": "bit-manipulation-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        def countBits(num: int):\\n            count = 0\\n            while num > 0:\\n                num &= (num - 1)\\n                count += 1\\n            return count\\n\\n        num1BitLength = countBits(num1)\\n        num2BitLength = countBits(num2)\\n        if num1BitLength > num2BitLength:\\n            while num1BitLength > num2BitLength:\\n                num1 &= num1 - 1\\n                num1BitLength -= 1\\n        elif num1BitLength < num2BitLength:\\n            while num1BitLength < num2BitLength:\\n                for i in range(32):\\n                    if num1 & 1 << i == 0:\\n                        num1 |= 1 << i\\n                        break\\n                num1BitLength += 1\\n        return num1\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        def countBits(num: int):\\n            count = 0\\n            while num > 0:\\n                num &= (num - 1)\\n                count += 1\\n            return count\\n\\n        num1BitLength = countBits(num1)\\n        num2BitLength = countBits(num2)\\n        if num1BitLength > num2BitLength:\\n            while num1BitLength > num2BitLength:\\n                num1 &= num1 - 1\\n                num1BitLength -= 1\\n        elif num1BitLength < num2BitLength:\\n            while num1BitLength < num2BitLength:\\n                for i in range(32):\\n                    if num1 & 1 << i == 0:\\n                        num1 |= 1 << i\\n                        break\\n                num1BitLength += 1\\n        return num1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683484,
                "title": "easy-bit-musk-python-solution-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        bit2 = num2.bit_count()\\n        bit1 = num1.bit_count()\\n        \\n        \\n        if bit1-bit2>=0:\\n            for _ in range(bit1-bit2):\\n                num1&=num1-1\\n            \\n            return num1\\n        else:\\n            count = bit2-bit1\\n           \\n            for i in range(32):\\n                if num1&(1<<i)==0:\\n                    num1 |=1<<i\\n                    count-=1\\n                if count==0:\\n                    \\n                    return num1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        bit2 = num2.bit_count()\\n        bit1 = num1.bit_count()\\n        \\n        \\n        if bit1-bit2>=0:\\n            for _ in range(bit1-bit2):\\n                num1&=num1-1\\n            \\n            return num1\\n        else:\\n            count = bit2-bit1\\n           \\n            for i in range(32):\\n                if num1&(1<<i)==0:\\n                    num1 |=1<<i\\n                    count-=1\\n                if count==0:\\n                    \\n                    return num1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675197,
                "title": "c-100",
                "content": "\\n\\n# Code\\n```\\n\\n    int minimizeXor(int num1, int num2) {\\n        int c1=0;\\n        while(num2){ //number of 1s in num1\\n            if(num2&1)c1++;\\n            num2=(num2>>1);\\n        }\\n        int temp=num1;\\n        int c2=0;\\n        while(temp){ //number of 1s in num2\\n            if(temp&1)c2++;\\n            temp=(temp>>1);\\n        }\\n        if(c1==c2)return num1;\\n        int ans=num1;\\n        if(c1<c2){\\n            int curr=0;\\n            c1=c2-c1;\\n            while(c1>0){ //remove extra 1s from num1(starting from lowest bit)\\n                if((num1&(1<<curr))==(1<<curr)){\\n                    ans=(ans^(1<<curr));\\n                    c1--;\\n                }\\n                curr++;\\n            }\\n        }\\n        else{\\n            int curr=0;\\n            c1=c1-c2;\\n            while(c1){ //start adding remaining 1s to num1 (starting from lowest bits)\\n                if((num1&(1<<curr))==0){\\n                    ans|=(1<<curr);\\n                    c1--;\\n                }\\n                curr++;\\n            } \\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n    int minimizeXor(int num1, int num2) {\\n        int c1=0;\\n        while(num2){ //number of 1s in num1\\n            if(num2&1)c1++;\\n            num2=(num2>>1);\\n        }\\n        int temp=num1;\\n        int c2=0;\\n        while(temp){ //number of 1s in num2\\n            if(temp&1)c2++;\\n            temp=(temp>>1);\\n        }\\n        if(c1==c2)return num1;\\n        int ans=num1;\\n        if(c1<c2){\\n            int curr=0;\\n            c1=c2-c1;\\n            while(c1>0){ //remove extra 1s from num1(starting from lowest bit)\\n                if((num1&(1<<curr))==(1<<curr)){\\n                    ans=(ans^(1<<curr));\\n                    c1--;\\n                }\\n                curr++;\\n            }\\n        }\\n        else{\\n            int curr=0;\\n            c1=c1-c2;\\n            while(c1){ //start adding remaining 1s to num1 (starting from lowest bits)\\n                if((num1&(1<<curr))==0){\\n                    ans|=(1<<curr);\\n                    c1--;\\n                }\\n                curr++;\\n            } \\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664771,
                "title": "easy-c-commented-code-with-explanation-bits-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we will count the setbits in num2 using builtin function.\\nTo minimise the result we neet to set the bits of our ans equal to the bit at that particular place of num1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse the num1 from starting and set bits to 1 when num1[i]=1\\nNow similarly traverse from back and set the remaining set bits\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        //stor the number of setbits -->\\n        int setct= __builtin_popcount(num2);\\n        //create a vector to store bits of num1\\n        vector<int> v(32,0);\\n        int i=0;\\n        // store the bits of num1 in our vector v\\n        while(num1>0){\\n            int digit=num1%10;\\n            if(digit%2==0) v[i]=0;\\n            else v[i]=1;\\n            i++;\\n            num1/=2;\\n        }\\n        reverse(v.begin(),v.end());\\n        // create our ans vector to store the bits of resultant ans\\n        vector<int> res(32,0);\\n        // traverse from front , to minimise the value we set res[i]=1, whenever we ecounter setbit\\n        for(int i=0;i<=31;i++){\\n            if(setct==0) break;\\n            if(v[i]==1){\\n                setct--;\\n                res[i]=1;\\n            }\\n        }\\n        //Similarly traverse from back\\n        for(int i=31;i>=0;i--){\\n            if(setct==0) break;\\n            if(v[i]==0){\\n                setct--;\\n                res[i]=1;\\n            }\\n        }\\n        // converting our ans vector to integer\\n        int fans=0;\\n        for(int i=31;i>=0;i--){\\n            fans+=(res[i]*(pow(2,31-i)));\\n        }\\n        return fans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        //stor the number of setbits -->\\n        int setct= __builtin_popcount(num2);\\n        //create a vector to store bits of num1\\n        vector<int> v(32,0);\\n        int i=0;\\n        // store the bits of num1 in our vector v\\n        while(num1>0){\\n            int digit=num1%10;\\n            if(digit%2==0) v[i]=0;\\n            else v[i]=1;\\n            i++;\\n            num1/=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3659803,
                "title": "bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int n=num1;\\n        int m=num2;\\n        int t=0;\\n        while( n || m)\\n        {\\n            int bit1=n&1;\\n            int bit2=m&1;\\n            if(bit1 && !bit2)\\n            t--;\\n            else if(!bit1 && bit2)\\n            t++;\\n            n=n>>1;\\n            m=m>>1;\\n        }\\n        int x=num1;\\n        if(t<0)\\n        {\\n            t=-t;\\n            for(int i=0; i<32; i++)\\n            {\\n                if((x>>i)&1 && t>0)\\n                {\\n                    x=x&(~(1<<i));\\n                    t--;\\n                }\\n            }\\n        }\\n        else if(t>0)\\n        {\\n            for(int i=0; i<32; i++)\\n            {\\n                if(!((x>>i)&1) && t>0)\\n                {\\n                    x=x|((1<<i));\\n                    t--;\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int n=num1;\\n        int m=num2;\\n        int t=0;\\n        while( n || m)\\n        {\\n            int bit1=n&1;\\n            int bit2=m&1;\\n            if(bit1 && !bit2)\\n            t--;\\n            else if(!bit1 && bit2)\\n            t++;\\n            n=n>>1;\\n            m=m>>1;\\n        }\\n        int x=num1;\\n        if(t<0)\\n        {\\n            t=-t;\\n            for(int i=0; i<32; i++)\\n            {\\n                if((x>>i)&1 && t>0)\\n                {\\n                    x=x&(~(1<<i));\\n                    t--;\\n                }\\n            }\\n        }\\n        else if(t>0)\\n        {\\n            for(int i=0; i<32; i++)\\n            {\\n                if(!((x>>i)&1) && t>0)\\n                {\\n                    x=x|((1<<i));\\n                    t--;\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635085,
                "title": "simple-rust-solution-with-explanation-and-comments",
                "content": "# Intuition\\nTo get the smallest `x` possible, we start off with `num1` and either add or remove 1s starting on the left hand side.\\n\\n# Approach\\nIf the number of set bits in num1 is less than the number of set bits in num2, then we need to add 1s to num1 starting from the left hand side. To accompish this, we find the first NON-SET bit in num1 and set it. We continue this until num1 has the same number of set bits as num2.\\n\\nIf the number of set bits in num1 is greater than the number of set bits in num2, then we need to remove 1s from num1 starting from the left hand side. TO accomplish this, we find the first SET bit in num1 and clear it. We continue this until num1 has the same number of set bits as num2.\\n\\n# Complexity\\n- Time complexity: Constant\\n\\n- Space complexity: Constant\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimize_xor(num1: i32, num2: i32) -> i32 {\\n        let set_bits = num2.count_ones(); // How many bits we need to have set\\n        let current_bits = num1.count_ones(); // How many bits are set in our current answer\\n\\n        let mut ans = num1; // Start answer off to be the same as num1\\n        let mut n1 = num1;  // Clone of num1\\n        let mut offset = 0; // Bit offset\\n\\n        // Need to add more 1s to ans\\n        if set_bits > current_bits {\\n            while ans.count_ones() != set_bits {\\n                if n1 % 2 == 0 {\\n                    ans ^= 1 << offset;\\n                }\\n\\n                offset += 1;\\n                n1 >>= 1;\\n            }\\n        }\\n        // Need to remove 1s from answer\\n        else if set_bits < current_bits {\\n            while ans.count_ones() != set_bits {\\n                if n1 % 2 == 1 {\\n                    ans ^= 1 << offset;\\n                }\\n                offset += 1;\\n                n1 >>= 1;\\n            }\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimize_xor(num1: i32, num2: i32) -> i32 {\\n        let set_bits = num2.count_ones(); // How many bits we need to have set\\n        let current_bits = num1.count_ones(); // How many bits are set in our current answer\\n\\n        let mut ans = num1; // Start answer off to be the same as num1\\n        let mut n1 = num1;  // Clone of num1\\n        let mut offset = 0; // Bit offset\\n\\n        // Need to add more 1s to ans\\n        if set_bits > current_bits {\\n            while ans.count_ones() != set_bits {\\n                if n1 % 2 == 0 {\\n                    ans ^= 1 << offset;\\n                }\\n\\n                offset += 1;\\n                n1 >>= 1;\\n            }\\n        }\\n        // Need to remove 1s from answer\\n        else if set_bits < current_bits {\\n            while ans.count_ones() != set_bits {\\n                if n1 % 2 == 1 {\\n                    ans ^= 1 << offset;\\n                }\\n                offset += 1;\\n                n1 >>= 1;\\n            }\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3604590,
                "title": "100ms-log-n-easy-c-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.We have to minimize the value,so most significant bits should be unset in the answer.\\n2.So first count number of bits in num2 say req.\\n3.Now we know that for even same bits xor is 0 else 1.\\n4.Therefore our first priority is to have set bits in answer at the position of set bits in num 1 from left to right until req is exhausted(i.e. becomes 0).\\n5.If some req are left then our priority is to set bits in ans at position of unset bits.\\n6.in num1 from right to left,so that it contributes to less value of answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(max(num1,num2)))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n\\nclass Solution {\\nprivate:\\n    int count(int n){\\n        if(n==0)return 0;\\n        return (n&1)+count(n>>1);\\n    }\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int req=count(num2);\\n        int x=1<<30;\\n        int ans=0;\\n        // cout<<req<<endl;\\n        int c=1;\\n        while(x&&req){\\n            if(num1&x){\\n                // cout<<c<<\" \"<<x<<endl;\\n                ans=ans|x;//set that bit\\n                --req;\\n            }\\n            ++c;\\n            x=x>>1;\\n        }\\n        // cout<<req<<endl;\\n        x=1;\\n        while(req){\\n            if(!(num1&x)){\\n                ans=ans|x;//set that bit;\\n                --req;\\n            }\\n            x=x<<1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution {\\nprivate:\\n    int count(int n){\\n        if(n==0)return 0;\\n        return (n&1)+count(n>>1);\\n    }\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int req=count(num2);\\n        int x=1<<30;\\n        int ans=0;\\n        // cout<<req<<endl;\\n        int c=1;\\n        while(x&&req){\\n            if(num1&x){\\n                // cout<<c<<\" \"<<x<<endl;\\n                ans=ans|x;//set that bit\\n                --req;\\n            }\\n            ++c;\\n            x=x>>1;\\n        }\\n        // cout<<req<<endl;\\n        x=1;\\n        while(req){\\n            if(!(num1&x)){\\n                ans=ans|x;//set that bit;\\n                --req;\\n            }\\n            x=x<<1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3581692,
                "title": "c-bit-manipulation-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        vector<int> v1(40, 0);\\n        vector<int> v2(40, 0);\\n        int num1Copy = num1;\\n        int count1 = 0;\\n        int i=0;\\n        while(num1) {\\n            if(num1%2==1) {\\n                v1[i]=1;\\n                count1++;\\n            } else {\\n                v1[i]=0;\\n            }\\n            i++;\\n            num1 /= 2;\\n        }\\n\\n        int count2 = 0;\\n        while(num2) {\\n            if(num2%2==1) {\\n                count2++;\\n            }\\n            num2 /= 2;\\n        }\\n        \\n        \\n\\n        if(count1 == count2) {\\n            return num1Copy;\\n        } else if(count1 > count2) {\\n            for(int i=39;i>=0 && count2>0;i--) {\\n                if(v1[i] == 1) {\\n                    v2[i] = 1;\\n                    count2--;\\n                }\\n            }\\n        } else {\\n            for(int i=39;i>=0 && count2>0;i--) {\\n                if(v1[i] == 1) {\\n                    v2[i] = 1;\\n                    count2--;\\n                }\\n            }\\n            for(int i=0;i<40 && count2>0;i++) {\\n                if(v2[i]==0) {\\n                    v2[i] = 1;\\n                    count2--;\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i=0;i<40;i++) {\\n            if(v2[i] == 1) {\\n                ans += pow(2, i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        vector<int> v1(40, 0);\\n        vector<int> v2(40, 0);\\n        int num1Copy = num1;\\n        int count1 = 0;\\n        int i=0;\\n        while(num1) {\\n            if(num1%2==1) {\\n                v1[i]=1;\\n                count1++;\\n            } else {\\n                v1[i]=0;\\n            }\\n            i++;\\n            num1 /= 2;\\n        }\\n\\n        int count2 = 0;\\n        while(num2) {\\n            if(num2%2==1) {\\n                count2++;\\n            }\\n            num2 /= 2;\\n        }\\n        \\n        \\n\\n        if(count1 == count2) {\\n            return num1Copy;\\n        } else if(count1 > count2) {\\n            for(int i=39;i>=0 && count2>0;i--) {\\n                if(v1[i] == 1) {\\n                    v2[i] = 1;\\n                    count2--;\\n                }\\n            }\\n        } else {\\n            for(int i=39;i>=0 && count2>0;i--) {\\n                if(v1[i] == 1) {\\n                    v2[i] = 1;\\n                    count2--;\\n                }\\n            }\\n            for(int i=0;i<40 && count2>0;i++) {\\n                if(v2[i]==0) {\\n                    v2[i] = 1;\\n                    count2--;\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i=0;i<40;i++) {\\n            if(v2[i] == 1) {\\n                ans += pow(2, i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563850,
                "title": "beats-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(32)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int countSetBits(int n){\\n        int cnt = 0;\\n        while(n>0){\\n            if(n&1){\\n                cnt++;\\n            }\\n            n >>= 1;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int n = countSetBits(num2);\\n        int ans = 0;\\n        for(int i=31; i>=0; i--){\\n            if(num1&(1<<i)){\\n                ans |= (1<<i);\\n                n--;\\n            }\\n            if(n==0){\\n                return ans;\\n            }\\n        }\\n        for(int i=0; i<32; i++){\\n            if(!(num1&(1<<i))){\\n                ans |= (1<<i);\\n                n--;\\n            }\\n            if(n==0){\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int countSetBits(int n){\\n        int cnt = 0;\\n        while(n>0){\\n            if(n&1){\\n                cnt++;\\n            }\\n            n >>= 1;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int n = countSetBits(num2);\\n        int ans = 0;\\n        for(int i=31; i>=0; i--){\\n            if(num1&(1<<i)){\\n                ans |= (1<<i);\\n                n--;\\n            }\\n            if(n==0){\\n                return ans;\\n            }\\n        }\\n        for(int i=0; i<32; i++){\\n            if(!(num1&(1<<i))){\\n                ans |= (1<<i);\\n                n--;\\n            }\\n            if(n==0){\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504583,
                "title": "share-my-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int set2 = Integer.bitCount(num2);\\n        int set1 = Integer.bitCount(num1);\\n        int res = 0;\\n\\n        if (set1 == set2) return num1;\\n\\n        if (set1 > set2) {\\n            int need = set2;\\n            for (int i = 31; i >= 0 && need > 0; i--) {\\n                if ((num1 >> i & 1) == 1) {\\n                    res |= 1 << i;\\n                    need--;\\n                }\\n            }\\n        }\\n\\n        if (set1 < set2) {\\n            int need = set2 - set1;\\n            res = num1;\\n            for (int i = 0; i < 32 && need > 0; i++) {\\n                if ((num1 >> i & 1) == 0) {\\n                    res |= 1 << i;\\n                    need--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int set2 = Integer.bitCount(num2);\\n        int set1 = Integer.bitCount(num1);\\n        int res = 0;\\n\\n        if (set1 == set2) return num1;\\n\\n        if (set1 > set2) {\\n            int need = set2;\\n            for (int i = 31; i >= 0 && need > 0; i--) {\\n                if ((num1 >> i & 1) == 1) {\\n                    res |= 1 << i;\\n                    need--;\\n                }\\n            }\\n        }\\n\\n        if (set1 < set2) {\\n            int need = set2 - set1;\\n            res = num1;\\n            for (int i = 0; i < 32 && need > 0; i++) {\\n                if ((num1 >> i & 1) == 0) {\\n                    res |= 1 << i;\\n                    need--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456704,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nint minimizeXor(int num1, int num2){\\n    int num2bit=__builtin_popcount(num2);\\n    int num1bit=__builtin_popcount(num1);\\n    if(num1bit==num2bit) return num1;\\n    int res=num1;\\n    for(int i=0;i<32;i++){\\n        if((((uint32_t)1<<i)&num1)==0 && num2bit>num1bit){\\n            res^=1<<i;\\n            num1bit++;\\n        }\\n        if((((uint32_t)1<<i)&num1)!=0 && num2bit<num1bit){\\n            res^=1<<i;\\n            num1bit--;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizeXor(int num1, int num2){\\n    int num2bit=__builtin_popcount(num2);\\n    int num1bit=__builtin_popcount(num1);\\n    if(num1bit==num2bit) return num1;\\n    int res=num1;\\n    for(int i=0;i<32;i++){\\n        if((((uint32_t)1<<i)&num1)==0 && num2bit>num1bit){\\n            res^=1<<i;\\n            num1bit++;\\n        }\\n        if((((uint32_t)1<<i)&num1)!=0 && num2bit<num1bit){\\n            res^=1<<i;\\n            num1bit--;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3454792,
                "title": "java-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public boolean checkSetBit(int n,int i)\\n    {\\n        return (n>>i)%2==1;\\n    }\\n    public int minimizeXor(int nums1, int nums2) {\\n        int ans=0;\\n        int k=Integer.bitCount(nums2);\\n        for(int i=31;i>=0;i--)\\n        {\\n            if(checkSetBit(nums1,i))\\n            {\\n                ans|=(1<<i);\\n                k--;\\n                if(k==0)\\n                    break;\\n            }\\n        }\\n        if(k>0)\\n        {\\n            for(int i=0;i<32;i++)\\n            {\\n                if(!checkSetBit(nums1,i))\\n                {\\n                    ans|=(1<<i);\\n                    k--;\\n                    if(k==0)\\n                        break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkSetBit(int n,int i)\\n    {\\n        return (n>>i)%2==1;\\n    }\\n    public int minimizeXor(int nums1, int nums2) {\\n        int ans=0;\\n        int k=Integer.bitCount(nums2);\\n        for(int i=31;i>=0;i--)\\n        {\\n            if(checkSetBit(nums1,i))\\n            {\\n                ans|=(1<<i);\\n                k--;\\n                if(k==0)\\n                    break;\\n            }\\n        }\\n        if(k>0)\\n        {\\n            for(int i=0;i<32;i++)\\n            {\\n                if(!checkSetBit(nums1,i))\\n                {\\n                    ans|=(1<<i);\\n                    k--;\\n                    if(k==0)\\n                        break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381033,
                "title": "c-use-bitset-as-array",
                "content": "```\\nclass Solution {\\npublic:\\n    // coutn number of bits in num2\\n    // then minimize rightmost bits in num1\\n    // then increase right most bits as needed\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while (num2 > 0){\\n            count += num2 & 1;\\n            num2 /= 2;\\n        }\\n        bitset<32> a(num1);\\n        bitset<32> ans;\\n        for (int i = 31; i >= 0 && count > 0; --i){\\n            if (a[i] == 1){\\n                --count;\\n                ans[i] = 1;\\n            }\\n        }\\n        for (int i = 0; i < 32 && count > 0; ++i){\\n            if (ans[i] == 0){\\n                --count;\\n                ans[i] = 1;\\n            }\\n        }\\n        long sum = 0, cur = 1;\\n        for (int i = 0; i <= 32; ++i){\\n            sum += (ans[i] == 1) * cur;\\n            cur *= 2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // coutn number of bits in num2\\n    // then minimize rightmost bits in num1\\n    // then increase right most bits as needed\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while (num2 > 0){\\n            count += num2 & 1;\\n            num2 /= 2;\\n        }\\n        bitset<32> a(num1);\\n        bitset<32> ans;\\n        for (int i = 31; i >= 0 && count > 0; --i){\\n            if (a[i] == 1){\\n                --count;\\n                ans[i] = 1;\\n            }\\n        }\\n        for (int i = 0; i < 32 && count > 0; ++i){\\n            if (ans[i] == 0){\\n                --count;\\n                ans[i] = 1;\\n            }\\n        }\\n        long sum = 0, cur = 1;\\n        for (int i = 0; i <= 32; ++i){\\n            sum += (ans[i] == 1) * cur;\\n            cur *= 2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3379966,
                "title": "c-simple-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2)\\n    {\\n        int n = __builtin_popcount(num2);\\n        int ans = 0;\\n        \\n        for (int i = 31; n && i >= 0; i--)\\n        {\\n            if (num1 & (1 << i))\\n            {\\n                ans|=(1<<i);\\n                n--;\\n            }\\n        }\\n\\n        for (int i = 0; n && i < 31; i++)\\n        {            \\n            if (!(num1&(1 << i)))\\n            {\\n                ans |= (1 << i);\\n                n--;\\n            }\\n        }\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2)\\n    {\\n        int n = __builtin_popcount(num2);\\n        int ans = 0;\\n        \\n        for (int i = 31; n && i >= 0; i--)\\n        {\\n            if (num1 & (1 << i))\\n            {\\n                ans|=(1<<i);\\n                n--;\\n            }\\n        }\\n\\n        for (int i = 0; n && i < 31; i++)\\n        {            \\n            if (!(num1&(1 << i)))\\n            {\\n                ans |= (1 << i);\\n                n--;\\n            }\\n        }\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355900,
                "title": "c-constant-time-solution-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int k = __builtin_popcount(num2);\\n        int ans = 0;\\n        vector<int> v1(32, 0);\\n        for(int i=31;i>=0 && k > 0;i--)\\n        {\\n            if(num1&(1<<i))\\n            {\\n                v1[i] = 1;\\n                k--;\\n            }\\n        }\\n        for(int i=0;i<32 && k > 0;i++)\\n        {\\n            if(num1&(1<<i)){}\\n            else\\n            {\\n                v1[i] = 1;\\n                k--;\\n            }\\n        }\\n        // for(auto &x : v1)cout << x << \" \";cout <<\\'\\\\n\\';\\n        for(int i=0;i<32;i++)ans += (v1[i]*(1 << i));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int k = __builtin_popcount(num2);\\n        int ans = 0;\\n        vector<int> v1(32, 0);\\n        for(int i=31;i>=0 && k > 0;i--)\\n        {\\n            if(num1&(1<<i))\\n            {\\n                v1[i] = 1;\\n                k--;\\n            }\\n        }\\n        for(int i=0;i<32 && k > 0;i++)\\n        {\\n            if(num1&(1<<i)){}\\n            else\\n            {\\n                v1[i] = 1;\\n                k--;\\n            }\\n        }\\n        // for(auto &x : v1)cout << x << \" \";cout <<\\'\\\\n\\';\\n        for(int i=0;i<32;i++)ans += (v1[i]*(1 << i));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3316071,
                "title": "time-space-o-logn-python-3-with-out-left-shift-and-right-shift",
                "content": "# Intuition\\nidentify pattren based on digits (binary)\\n\\n# Approach\\nour goal is to change the result based on set count bit in num2\\nexample:\\nnum1=21[10110] num2=15[1111]\\nby using 3 1s in nums2 makes nums1 ones zero{res=[1,0,1,1,0]} \\nstill we have one bit to add in res so choose optimum based on nums1 digit so make res=[1,0,1,1,1] \\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        sn2=num2.bit_count()#set bits in num2\\n        bs1=list(bin(num1)[2:])#binary representation\\n        res=[0]*len(bs1)#final ans\\n        i=0\\n        while i<len(bs1) and sn2>0:\\n            if bs1[i]==\\'1\\':\\n                res[i]=1\\n                sn2-=1\\n            i+=1\\n        tres=[]#temp res to append ones as shown  in 2nd example question\\n        i=len(bs1)-1\\n        while sn2 and i>=0:\\n            if bs1[i]==\\'0\\':\\n                res[i]=1\\n                sn2-=1\\n            i-=1\\n        for i in range(sn2):\\n            tres.append(1)\\n        res=tres+res\\n        res=\\'\\'.join(map(str,res))\\n        res=\\'0b\\'+res\\n        return int(res,2)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        sn2=num2.bit_count()#set bits in num2\\n        bs1=list(bin(num1)[2:])#binary representation\\n        res=[0]*len(bs1)#final ans\\n        i=0\\n        while i<len(bs1) and sn2>0:\\n            if bs1[i]==\\'1\\':\\n                res[i]=1\\n                sn2-=1\\n            i+=1\\n        tres=[]#temp res to append ones as shown  in 2nd example question\\n        i=len(bs1)-1\\n        while sn2 and i>=0:\\n            if bs1[i]==\\'0\\':\\n                res[i]=1\\n                sn2-=1\\n            i-=1\\n        for i in range(sn2):\\n            tres.append(1)\\n        res=tres+res\\n        res=\\'\\'.join(map(str,res))\\n        res=\\'0b\\'+res\\n        return int(res,2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310858,
                "title": "simple-c-solution-faster-than-100",
                "content": "# Intuition\\nWe first count the number of bits set in num2. \\nSince we need to minimze the xor we will set only those bits which are set in num1 starting from leftmost bit which will reduce the value of result the most and if we still have some bits that we can set then we start from leftmost bit in x which will contribute the lowest value to the overall result.\\n\\n# Complexity\\n- Time complexity: O(32) or constant\\n\\n- Space complexity: O(1) since we only use some variables to store count\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while(num2) {\\n            count += num2&1;\\n            num2>>=1;\\n        }\\n        int x = 0;\\n        for(int i=31;i>=0 && count;i--) {\\n            int temp = 1<<i;\\n            if(num1&temp) {\\n                x |= temp;\\n                count--;\\n            }\\n        }\\n        // cout<<x<<\" \"<<count<<\"\\\\n\";\\n        for(int i=0;i<32 && count; i++) {\\n            int temp = 1<<i;\\n            // cout<<temp<<\"\\\\n\";\\n            if((x&temp) == 0) {\\n                // cout<<temp<<\" \"<<count<<\"\\\\n\";\\n                x |= temp;\\n                count--;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while(num2) {\\n            count += num2&1;\\n            num2>>=1;\\n        }\\n        int x = 0;\\n        for(int i=31;i>=0 && count;i--) {\\n            int temp = 1<<i;\\n            if(num1&temp) {\\n                x |= temp;\\n                count--;\\n            }\\n        }\\n        // cout<<x<<\" \"<<count<<\"\\\\n\";\\n        for(int i=0;i<32 && count; i++) {\\n            int temp = 1<<i;\\n            // cout<<temp<<\"\\\\n\";\\n            if((x&temp) == 0) {\\n                // cout<<temp<<\" \"<<count<<\"\\\\n\";\\n                x |= temp;\\n                count--;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3309765,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int d1 = __builtin_popcount(num1);\\n        int d2 = __builtin_popcount(num2);\\n        if(d1 == d2)\\n            return num1 ;\\n        int ret = 0 ;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            if(((num1 >> i) & 1) == 1)\\n            {\\n                ret |= (1 << i) ;\\n                d2-- ;\\n                if(d2 == 0)\\n                    return ret ;\\n            }\\n        }\\n        \\n        for(int i = 0; i < 32; i++)\\n        {\\n            if(((num1 >> i) & 1) == 0)\\n            {\\n                ret |= (1 << i) ;\\n                d2-- ;\\n                if(d2 == 0)\\n                    return ret ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int d1 = __builtin_popcount(num1);\\n        int d2 = __builtin_popcount(num2);\\n        if(d1 == d2)\\n            return num1 ;\\n        int ret = 0 ;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            if(((num1 >> i) & 1) == 1)\\n            {\\n                ret |= (1 << i) ;\\n                d2-- ;\\n                if(d2 == 0)\\n                    return ret ;\\n            }\\n        }\\n        \\n        for(int i = 0; i < 32; i++)\\n        {\\n            if(((num1 >> i) & 1) == 0)\\n            {\\n                ret |= (1 << i) ;\\n                d2-- ;\\n                if(d2 == 0)\\n                    return ret ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262781,
                "title": "c-easy-bitcount",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       int minimizeXor(int num1, int num2) {\\n        int a = __builtin_popcount(num1), b = __builtin_popcount(num2), res = num1;\\n        for (int i = 0; i < 32; ++i) {\\n            if (a > b && ((1 << i) & num1) > 0) {\\n                res ^= 1 << i;\\n                a--;\\n            }\\n            if (a < b && ((1 << i) & num1) == 0) {\\n                res ^= 1 << i;\\n                a++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int minimizeXor(int num1, int num2) {\\n        int a = __builtin_popcount(num1), b = __builtin_popcount(num2), res = num1;\\n        for (int i = 0; i < 32; ++i) {\\n            if (a > b && ((1 << i) & num1) > 0) {\\n                res ^= 1 << i;\\n                a--;\\n            }\\n            if (a < b && ((1 << i) & num1) == 0) {\\n                res ^= 1 << i;\\n                a++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250620,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int c1 = __builtin_popcount(num1);\\n        int c2 = __builtin_popcount(num2);\\n        int ans=num1;\\n        if(c1==c2) return ans;\\n        else if(c1<c2){\\n            c2-=c1;\\n            for(int i=0;i<32 && c2>0 ;i++){\\n                if((num1&(1<<i))==0){\\n                    c2--;\\n                    ans+=pow(2, i);\\n                }\\n            }\\n        }\\n        else{\\n            ans=0;\\n            c1-=c2;\\n            for(int i=0;i<32;i++){\\n                if((num1&(1<<i))){\\n                    c1--;\\n                    ans+=pow(2, i);\\n                }\\n                if(c1<=0) break;\\n            }\\n            ans=num1-ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int c1 = __builtin_popcount(num1);\\n        int c2 = __builtin_popcount(num2);\\n        int ans=num1;\\n        if(c1==c2) return ans;\\n        else if(c1<c2){\\n            c2-=c1;\\n            for(int i=0;i<32 && c2>0 ;i++){\\n                if((num1&(1<<i))==0){\\n                    c2--;\\n                    ans+=pow(2, i);\\n                }\\n            }\\n        }\\n        else{\\n            ans=0;\\n            c1-=c2;\\n            for(int i=0;i<32;i++){\\n                if((num1&(1<<i))){\\n                    c1--;\\n                    ans+=pow(2, i);\\n                }\\n                if(c1<=0) break;\\n            }\\n            ans=num1-ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247696,
                "title": "c-intuitive-bit-manipulation",
                "content": "\\n# Approach\\nCount number of bits in num2=b.\\nLook for 1\\'s is num1 from MSB, if you find 1, add 1 to corresponding bit in result. If bis greater than number of bits in num1, start adding 1 bits in result from LSB.\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int x=0;int b2=0;\\n\\n        int n2=num2;\\n        while(n2>0){\\n            if((n2&1)==1)\\n                b2++;\\n            n2=n2>>1;\\n        }\\n        uint32_t count=31;\\n        uint32_t mask=1<<31;\\n\\n        while(b2>0 && mask>0){\\n            if((num1 & mask) != 0){\\n                x+=mask;\\n                b2--;\\n            }\\n            count--;\\n            mask=mask>>1;\\n        }\\n        if(b2>0){\\n            \\n            mask=1;\\n            while(b2>0){\\n\\n                if((x & mask) == 0){\\n                    x+=mask;\\n                    b2--;\\n                }\\n                mask=mask<<1;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int x=0;int b2=0;\\n\\n        int n2=num2;\\n        while(n2>0){\\n            if((n2&1)==1)\\n                b2++;\\n            n2=n2>>1;\\n        }\\n        uint32_t count=31;\\n        uint32_t mask=1<<31;\\n\\n        while(b2>0 && mask>0){\\n            if((num1 & mask) != 0){\\n                x+=mask;\\n                b2--;\\n            }\\n            count--;\\n            mask=mask>>1;\\n        }\\n        if(b2>0){\\n            \\n            mask=1;\\n            while(b2>0){\\n\\n                if((x & mask) == 0){\\n                    x+=mask;\\n                    b2--;\\n                }\\n                mask=mask<<1;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217251,
                "title": "c-bit-operation-faster-than-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int res = 0, count = 0, index = 0, total = 0, tmp_num1 = num1;\\n        while(num2 > 0){\\n            if(num2 & 1 == 1){\\n                count += 1;\\n            }\\n            num2 >>= 1;\\n        }\\n        vector<int> rec(35, 0);\\n        while(num1 > 0){\\n            if(num1 & 1 == 1){\\n                rec[index] = 1;\\n                total++;\\n            }\\n            index++;\\n            num1 >>= 1;\\n        }\\n        if(count == total){\\n            return tmp_num1;\\n        }\\n        else if(count < total){\\n            for(int i=30, tmp = 0;i>=0 && tmp < count;i--){\\n                if(rec[i]){\\n                    res += pow(2, i);\\n                    tmp++;\\n                }\\n            }\\n        }\\n        else{\\n            res = tmp_num1;\\n            for(int i=0, tmp = 0;i<rec.size() && tmp < count-total;i++){\\n                if(!rec[i]){\\n                    res += pow(2, i);\\n                    tmp++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int res = 0, count = 0, index = 0, total = 0, tmp_num1 = num1;\\n        while(num2 > 0){\\n            if(num2 & 1 == 1){\\n                count += 1;\\n            }\\n            num2 >>= 1;\\n        }\\n        vector<int> rec(35, 0);\\n        while(num1 > 0){\\n            if(num1 & 1 == 1){\\n                rec[index] = 1;\\n                total++;\\n            }\\n            index++;\\n            num1 >>= 1;\\n        }\\n        if(count == total){\\n            return tmp_num1;\\n        }\\n        else if(count < total){\\n            for(int i=30, tmp = 0;i>=0 && tmp < count;i--){\\n                if(rec[i]){\\n                    res += pow(2, i);\\n                    tmp++;\\n                }\\n            }\\n        }\\n        else{\\n            res = tmp_num1;\\n            for(int i=0, tmp = 0;i<rec.size() && tmp < count-total;i++){\\n                if(!rec[i]){\\n                    res += pow(2, i);\\n                    tmp++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202598,
                "title": "easy-and-clean-solution-using-bit-manipulation-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BitManipulation\\n{\\n    public BitManipulation()\\n    {\\n    }\\n\\n    public int CountSetBits(int num)\\n    {\\n        int count = 0;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            if(((num >> i) & 1) == 1)\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    public int GetMinNum(int num, int countSetBits)\\n    {\\n        int min = 0;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            int bit = (num >> i) & 1;\\n            if(bit == 1 && countSetBits > 0)\\n            {\\n                min = min | (1 << i);\\n                countSetBits--;\\n            }\\n        }\\n        for(int i = 0; i <= 31; i++)\\n        {\\n            if(countSetBits == 0)\\n            return min;\\n            int bit = (min >> i) & 1;\\n            if(bit == 0)\\n            {\\n                min = min | (1 << i);\\n                countSetBits--;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n}\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        BitManipulation bitManipulation = new BitManipulation();\\n        int countSetBits = bitManipulation.CountSetBits(num2);\\n        return bitManipulation.GetMinNum(num1, countSetBits);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass BitManipulation\\n{\\n    public BitManipulation()\\n    {\\n    }\\n\\n    public int CountSetBits(int num)\\n    {\\n        int count = 0;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            if(((num >> i) & 1) == 1)\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    public int GetMinNum(int num, int countSetBits)\\n    {\\n        int min = 0;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            int bit = (num >> i) & 1;\\n            if(bit == 1 && countSetBits > 0)\\n            {\\n                min = min | (1 << i);\\n                countSetBits--;\\n            }\\n        }\\n        for(int i = 0; i <= 31; i++)\\n        {\\n            if(countSetBits == 0)\\n            return min;\\n            int bit = (min >> i) & 1;\\n            if(bit == 0)\\n            {\\n                min = min | (1 << i);\\n                countSetBits--;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n}\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        BitManipulation bitManipulation = new BitManipulation();\\n        int countSetBits = bitManipulation.CountSetBits(num2);\\n        return bitManipulation.GetMinNum(num1, countSetBits);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189466,
                "title": "java-easy-solution-50-faster",
                "content": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        String st1=Integer.toBinaryString(num1);\\n        String st2=Integer.toBinaryString(num2);\\n        int n1=0,n2=0,l1=st1.length(),l2=st2.length();\\n        for(int i=0;i<l1;i++) if(st1.charAt(i)==\\'1\\') n1++;\\n        for(int i=0;i<l2;i++) if(st2.charAt(i)==\\'1\\') n2++;\\n        if(n1==n2) return num1;\\n        else if(n2>n1){\\n            int diff=n2-n1;\\n            while(diff-->0) num1=num1|(num1+1);\\n            return num1;\\n        }\\n        else{\\n            int diff=n1-n2;\\n            while(diff-->0) num1=num1&(num1-1);\\n            return num1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        String st1=Integer.toBinaryString(num1);\\n        String st2=Integer.toBinaryString(num2);\\n        int n1=0,n2=0,l1=st1.length(),l2=st2.length();\\n        for(int i=0;i<l1;i++) if(st1.charAt(i)==\\'1\\') n1++;\\n        for(int i=0;i<l2;i++) if(st2.charAt(i)==\\'1\\') n2++;\\n        if(n1==n2) return num1;\\n        else if(n2>n1){\\n            int diff=n2-n1;\\n            while(diff-->0) num1=num1|(num1+1);\\n            return num1;\\n        }\\n        else{\\n            int diff=n1-n2;\\n            while(diff-->0) num1=num1&(num1-1);\\n            return num1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156000,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    int countOnes(int num) {\\n        int count = 0;\\n        while(num) {\\n            num -= (num & -num);\\n            count++;\\n        }\\n        return count;\\n    }\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = countOnes(num2) - countOnes(num1);\\n        for(int i = 0; count > 0; i++) {\\n            if((num1 & (1 << i)) != 0) continue;\\n            num1 = num1 | (1 << i);\\n            count--;\\n        }\\n        for(int i = 0; count < 0; i++) {\\n            if((num1 & (1 << i)) != 0) {\\n                num1 = num1 ^ (1 << i);\\n                count++;\\n            }\\n        }\\n        return num1;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countOnes(num int) int {\\n    var count = 0\\n    for num > 0 {\\n        num -= (num & -num)\\n        count++\\n    }\\n    return count\\n}\\nfunc minimizeXor(num1 int, num2 int) int {\\n    var count int = countOnes(num2) - countOnes(num1)\\n    for i := 0; count > 0; i++ {\\n        if (num1 & (1 << i)) == 0 {\\n            num1 = num1 | (1 << i)\\n            count--\\n        }\\n    }\\n    for i := 0; count < 0; i++ {\\n        if (num1 & (1 << i)) != 0 {\\n            num1 = num1 ^ (1 << i)\\n            count++\\n        }\\n    }\\n    return num1\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    int countOnes(int num) {\\n        int count = 0;\\n        while(num) {\\n            num -= (num & -num);\\n            count++;\\n        }\\n        return count;\\n    }\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = countOnes(num2) - countOnes(num1);\\n        for(int i = 0; count > 0; i++) {\\n            if((num1 & (1 << i)) != 0) continue;\\n            num1 = num1 | (1 << i);\\n            count--;\\n        }\\n        for(int i = 0; count < 0; i++) {\\n            if((num1 & (1 << i)) != 0) {\\n                num1 = num1 ^ (1 << i);\\n                count++;\\n            }\\n        }\\n        return num1;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countOnes(num int) int {\\n    var count = 0\\n    for num > 0 {\\n        num -= (num & -num)\\n        count++\\n    }\\n    return count\\n}\\nfunc minimizeXor(num1 int, num2 int) int {\\n    var count int = countOnes(num2) - countOnes(num1)\\n    for i := 0; count > 0; i++ {\\n        if (num1 & (1 << i)) == 0 {\\n            num1 = num1 | (1 << i)\\n            count--\\n        }\\n    }\\n    for i := 0; count < 0; i++ {\\n        if (num1 & (1 << i)) != 0 {\\n            num1 = num1 ^ (1 << i)\\n            count++\\n        }\\n    }\\n    return num1\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095851,
                "title": "java-construct-the-binary",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int count1 = getCount(num1);\\n        int count2 = getCount(num2);\\n        if (count2 < count1) {\\n            String strnum1 = Integer.toBinaryString(num1);\\n            char[] charnum2 = new char[strnum1.length()];\\n            Arrays.fill(charnum2, \\'0\\');\\n            int i = 0;\\n            while (count2 > 0) {\\n                if (strnum1.charAt(i) == \\'1\\') {\\n                    charnum2[i] = \\'1\\';\\n                    count2--;\\n                }\\n                i++;\\n            }\\n            num1 = Integer.parseInt(new String(charnum2), 2);\\n        } else if (count2 > count1) {\\n            String strnum1 = Integer.toBinaryString(num1);\\n            char[] charnum1 = new char[32];\\n            Arrays.fill(charnum1, \\'0\\');\\n            for (int i = strnum1.length() - 1, j = 31; i >= 0; i--, j--) {\\n                if (strnum1.charAt(i) == \\'1\\') {\\n                    charnum1[j] = \\'1\\';\\n                }\\n            }\\n            int diff = count2 - count1;\\n            for (int j = 31; j >= 0 && diff > 0; j--) {\\n                if (charnum1[j] == \\'0\\') {\\n                    charnum1[j] = \\'1\\';\\n                    diff--;\\n                }\\n            }\\n            num1 = Integer.parseInt(new String(charnum1), 2);\\n        }\\n        return num1;\\n    }\\n\\n    private int getCount(int num) {\\n        int count = 0;\\n        while (num > 0) {\\n            if ((num & 1) == 1) count++;\\n            num >>>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int count1 = getCount(num1);\\n        int count2 = getCount(num2);\\n        if (count2 < count1) {\\n            String strnum1 = Integer.toBinaryString(num1);\\n            char[] charnum2 = new char[strnum1.length()];\\n            Arrays.fill(charnum2, \\'0\\');\\n            int i = 0;\\n            while (count2 > 0) {\\n                if (strnum1.charAt(i) == \\'1\\') {\\n                    charnum2[i] = \\'1\\';\\n                    count2--;\\n                }\\n                i++;\\n            }\\n            num1 = Integer.parseInt(new String(charnum2), 2);\\n        } else if (count2 > count1) {\\n            String strnum1 = Integer.toBinaryString(num1);\\n            char[] charnum1 = new char[32];\\n            Arrays.fill(charnum1, \\'0\\');\\n            for (int i = strnum1.length() - 1, j = 31; i >= 0; i--, j--) {\\n                if (strnum1.charAt(i) == \\'1\\') {\\n                    charnum1[j] = \\'1\\';\\n                }\\n            }\\n            int diff = count2 - count1;\\n            for (int j = 31; j >= 0 && diff > 0; j--) {\\n                if (charnum1[j] == \\'0\\') {\\n                    charnum1[j] = \\'1\\';\\n                    diff--;\\n                }\\n            }\\n            num1 = Integer.parseInt(new String(charnum1), 2);\\n        }\\n        return num1;\\n    }\\n\\n    private int getCount(int num) {\\n        int count = 0;\\n        while (num > 0) {\\n            if ((num & 1) == 1) count++;\\n            num >>>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081797,
                "title": "java-best-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        \\n        int c1=countSetBit( num1 );\\n        int c2=countSetBit( num2 );\\n        if( c1==c2 )\\n            return num1;\\n        else if( c1>c2 )\\n        {\\n            int diff=c1-c2;\\n            while( diff-->0 )\\n                num1=num1&(num1-1);\\n\\n            return num1;\\n        }\\n        else\\n        {\\n            int diff=c2-c1;\\n            while( diff-->0 )\\n                num1=num1|(num1+1);\\n\\n            return num1;\\n        }\\n    }\\n\\n    public int countSetBit( int n )\\n    {\\n        int count=0;\\n        while( n>0 )\\n        {\\n            count+=(n&1);\\n            n>>=1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        \\n        int c1=countSetBit( num1 );\\n        int c2=countSetBit( num2 );\\n        if( c1==c2 )\\n            return num1;\\n        else if( c1>c2 )\\n        {\\n            int diff=c1-c2;\\n            while( diff-->0 )\\n                num1=num1&(num1-1);\\n\\n            return num1;\\n        }\\n        else\\n        {\\n            int diff=c2-c1;\\n            while( diff-->0 )\\n                num1=num1|(num1+1);\\n\\n            return num1;\\n        }\\n    }\\n\\n    public int countSetBit( int n )\\n    {\\n        int count=0;\\n        while( n>0 )\\n        {\\n            count+=(n&1);\\n            n>>=1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065228,
                "title": "bit-manipulation-approach-c-explaination-100-faster",
                "content": "# Intuition\\nIn either to make the xor minimum we have to choose that number(X) by which after xor operation the rightmost set bits of nums1 can be made zero so that the result will be minimum..\\n\\n---\\n\\n\\n# Approach\\nHere we will find the number of set bits(n) in nums2. Now we will find that number(X) which will make the operation (X xor nums1) minimum. Now here we are going to perform xor operation, so our main motive is to unset the left most set bits in A up to n number of set bits after xor operation so that the result will be minimum. If in case the number of set bits in nums2 is greater that the no of set bit in nums1, then we will assign the minimum value of X by setting the bits from right to left till we have and equal no of set bits in X and B. **Please go through my code you will get it what I am trying to say.**\\n\\n---\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(31) 31 bits...\\n\\n- Space complexity:\\nO(1)\\n\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int set =0;\\n        while(num2>0){\\n            if(num2&1){\\n                set++;\\n            }\\n            num2 = num2>>1;\\n        }\\n        int last = ceil(log(num1)/log(2));\\n        int ans =0;\\n        while(last > 0 && set >0){\\n            if(num1&(1<<last)){\\n                ans += pow(2,last);\\n                set--;\\n            }\\n            last--;\\n        }\\n        int j =0;\\n        while(set > 0){\\n            if(!(ans&(1<<j))){\\n                ans += pow(2,j);\\n                set--;\\n            }\\n            j++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int set =0;\\n        while(num2>0){\\n            if(num2&1){\\n                set++;\\n            }\\n            num2 = num2>>1;\\n        }\\n        int last = ceil(log(num1)/log(2));\\n        int ans =0;\\n        while(last > 0 && set >0){\\n            if(num1&(1<<last)){\\n                ans += pow(2,last);\\n                set--;\\n            }\\n            last--;\\n        }\\n        int j =0;\\n        while(set > 0){\\n            if(!(ans&(1<<j))){\\n                ans += pow(2,j);\\n                set--;\\n            }\\n            j++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052232,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while(num2!=0) {\\n            if((num2&1)!=0) {\\n                count++;\\n            }\\n            num2>>=1;\\n        }\\n\\n\\n        int res = 0;\\n        for(int i=31;i>=0;i--) {\\n            if(count == 0) {\\n                break;\\n            }\\n            if(((1<<i)&num1) != 0) {\\n                res |= (1<<i);\\n                count--;\\n            }\\n        }\\n        if(count == 0) {\\n            return res;\\n        }\\n        \\n        for(int i=0;i<31;i++) {\\n            bool flag = (1<<i)&res;\\n            if(!flag) {\\n                count--;\\n                res |= (1<<i);\\n            }\\n            if(count == 0) {\\n                break;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int count = 0;\\n        while(num2!=0) {\\n            if((num2&1)!=0) {\\n                count++;\\n            }\\n            num2>>=1;\\n        }\\n\\n\\n        int res = 0;\\n        for(int i=31;i>=0;i--) {\\n            if(count == 0) {\\n                break;\\n            }\\n            if(((1<<i)&num1) != 0) {\\n                res |= (1<<i);\\n                count--;\\n            }\\n        }\\n        if(count == 0) {\\n            return res;\\n        }\\n        \\n        for(int i=0;i<31;i++) {\\n            bool flag = (1<<i)&res;\\n            if(!flag) {\\n                count--;\\n                res |= (1<<i);\\n            }\\n            if(count == 0) {\\n                break;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008454,
                "title": "swift-solution",
                "content": "# Approach\\n1. Find the number of 1\\'s in num1 and num2.\\n2. Create a variable called \"a\" equal to the number of 1\\'s in num1, and a variable called \"b\" equal to the number of 1\\'s in num2.\\n3. Create a variable called \"res\" equal to num1.\\n4. Create a for loop that iterates through the 32 bits of num1.\\n5. If the number of 1\\'s in num1 is greater than the number of 1\\'s in num2, and the bit at the index of the for loop is 1, then XOR the bit at the index of the for loop with the result variable and subtract 1 from the number of 1\\'s in num1.\\n6. If the number of 1\\'s in num1 is less than the number of 1\\'s in num2, and the bit at the index of the for loop is 0, then XOR the bit at the index of the for loop with the result variable and add 1 to the number of 1\\'s in num1.\\n7. Return the result variable.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func minimizeXor(_ num1: Int, _ num2: Int) -> Int {\\n        var a = num1.nonzeroBitCount, b = num2.nonzeroBitCount, res = num1\\n        for i in 0..<32 {\\n            if a > b && (1 << i & num1) > 0 {\\n                res ^= 1 << i\\n                a -= 1\\n            }\\n            if a < b && (1 << i & num1) == 0 {\\n                res ^= 1 << i\\n                a += 1\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizeXor(_ num1: Int, _ num2: Int) -> Int {\\n        var a = num1.nonzeroBitCount, b = num2.nonzeroBitCount, res = num1\\n        for i in 0..<32 {\\n            if a > b && (1 << i & num1) > 0 {\\n                res ^= 1 << i\\n                a -= 1\\n            }\\n            if a < b && (1 << i & num1) == 0 {\\n                res ^= 1 << i\\n                a += 1\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997198,
                "title": "python3-8-lines-extremely-simple-code",
                "content": "Adapted and translated from:\\nhttps://leetcode.cn/problems/minimize-xor/solution/o1-kong-jian-fu-za-du-zuo-fa-by-endlessc-ywio/\\n\\n$$c_1$$ is the number of set bits of $$num_1$$, and $$c_2$$ is the number of set bits of $$num_2$$.\\n\\nIf $$c_1 == c_2$$, we simply return $$num_1$$, because $$num_1$$ XOR $$num_1$$ == 0\\n\\nIf $$c_1 > c_2$$, then turn the last $$(c_1 - c_2)$$ \\u201C1\\u201Ds of $$num_1$$ into \\u201C0\\u201Ds.\\nFor example, if $$num_1$$ = 100101**1**0**1**, $$c_1$$ = 5, $$c_2$$ = 3,\\nthen turn the last (5 - 3) \\u201C1\\u201Ds of $$num_1$$ into \\u201C0\\u201Ds.\\nThe answer is 100101**0**0**0**\\nThe following code turns the last \\u201C1\\u201D into \\u201C0\\u201D, and we can use it for $$(c_1 - c_2)$$ times:\\n```\\nnum &= num \\u2013 1\\n```\\n\\n\\nIf $$c_1 < c_2$$, then turn the last $$(c_2 - c_1)$$ \\u201C0\\u201Ds of $$num_1$$ into \\u201C1\\u201Ds.\\nFor example, if $$num_1$$ = 10**0**1**0**11**0**1, $$c_1$$ = 5, $$c_2$$ = 8,\\nthen turn the last (8 - 5) \\u201C0\\u201Ds of $$num_1$$ into \\u201C1\\u201Ds.\\nThe answer is 10**1**1**1**11**1**1\\nThe following code turns the last \\u201C0\\u201D into \\u201C1\\u201D, and we can use it for $$(c_2 - c_1)$$ times:\\n```\\nnum |= num + 1\\n```\\n\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        c1, c2 = num1.bit_count(), num2.bit_count()\\n        if c1 > c2:\\n            for _ in range(c1 - c2):\\n                num1 &= num1 - 1\\n        elif c1 < c2:\\n            for _ in range(c2 - c1):\\n                num1 |= num1 + 1\\n        return num1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nnum &= num \\u2013 1\\n```\n```\\nnum |= num + 1\\n```\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        c1, c2 = num1.bit_count(), num2.bit_count()\\n        if c1 > c2:\\n            for _ in range(c1 - c2):\\n                num1 &= num1 - 1\\n        elif c1 < c2:\\n            for _ in range(c2 - c1):\\n                num1 |= num1 + 1\\n        return num1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994330,
                "title": "simplest-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) \\n    {\\n        int no_bit = 0,n1 = num1,n2 = num2;\\n        while (n2 != 0)\\n        {\\n            if (n2 & 1)\\n                no_bit++;\\n            n2 = n2 >> 1;\\n        }\\n        vector<int> vp;\\n        int a = 1;\\n        while(n1 != 0)\\n        {\\n            if (n1 & 1){\\n                vp.push_back(a);\\n            }\\n            a = (a << 1);\\n            n1 = n1 >> 1;\\n        }\\n        int ans = 0;\\n        for (int i = vp.size()-1; i >= 0 && no_bit > 0; i--){\\n            ans += vp[i];\\n            no_bit--;\\n        }\\n        a = 1;\\n        int i = 0;\\n        while(no_bit > 0)\\n        {\\n            if (i < vp.size() && vp[i] == a)\\n            {\\n                i++;\\n                a = a << 1;\\n            }\\n            else\\n            {\\n                ans += a; \\n                a = a << 1;\\n                no_bit--;\\n            }\\n        }\\n        //cout << ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) \\n    {\\n        int no_bit = 0,n1 = num1,n2 = num2;\\n        while (n2 != 0)\\n        {\\n            if (n2 & 1)\\n                no_bit++;\\n            n2 = n2 >> 1;\\n        }\\n        vector<int> vp;\\n        int a = 1;\\n        while(n1 != 0)\\n        {\\n            if (n1 & 1){\\n                vp.push_back(a);\\n            }\\n            a = (a << 1);\\n            n1 = n1 >> 1;\\n        }\\n        int ans = 0;\\n        for (int i = vp.size()-1; i >= 0 && no_bit > 0; i--){\\n            ans += vp[i];\\n            no_bit--;\\n        }\\n        a = 1;\\n        int i = 0;\\n        while(no_bit > 0)\\n        {\\n            if (i < vp.size() && vp[i] == a)\\n            {\\n                i++;\\n                a = a << 1;\\n            }\\n            else\\n            {\\n                ans += a; \\n                a = a << 1;\\n                no_bit--;\\n            }\\n        }\\n        //cout << ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2966899,
                "title": "easy-java-solution-tc-o-n-sc-o-1",
                "content": "class Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int count1=Integer.bitCount(num1);\\n        int count2=Integer.bitCount(num2);\\n        if(count1==count2)\\n        {\\n            return num1;\\n        }\\n        else if(count1<count2)\\n        {\\n            for(int i=0;i<32 && count1!=count2;i++)\\n            {\\n                if((num1&(1<<i))==0)\\n                {\\n                    num1=num1|(1<<i);\\n                    count1++;\\n                }\\n            }\\n        }\\n        else if(count1>count2)\\n        {\\n            for(int i=0;i<32 && count1!=count2;i++)\\n            {\\n                if((num1&(1<<i))!=0)\\n                {\\n                    num1=num1& ~(1<<i);\\n                    count1--;\\n                }\\n            }\\n        }\\n        return num1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int count1=Integer.bitCount(num1);\\n        int count2=Integer.bitCount(num2);\\n        if(count1==count2)\\n        {\\n            return num1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2962842,
                "title": "c-simple-approach-with-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake 2 array of size 32 ad store the position of bits where bits are set (we are using `arr1` & `arr2`). Now, count the no of one\\'s in arr2 (since it is mentioned in the question that set bits should be same as num2). Lets call it as `ctr`.\\n\\nNow, take one more array (of size 32, lets call it `res`). Since our intention is to minimize the XOR result with num1, we need to set the bits in the `res` array at positions where num1 bits are set.\\n\\nSo, in a loop, we should start from the most significant bit (i.e, 31) and set the bit where num1 bit is also set and count the set bits, as `count` (we should continue till `count` is less than `ctr`). \\n\\nIf `count` is less than `ctr`, then we need to set the remaining bits too (because count of set bits in `res` should be equal to `ctr`). Now, we start from the LSB and set the bits till the `ctr` value.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        bool arr1[32], arr2[32], res[32];\\n        fill_n(arr1, 32, 0);\\n        fill_n(arr2, 32, 0);\\n        fill_n(res, 32, 0);\\n        int i= 0;\\n        int n = num1;\\n        while (num1) {\\n            arr1[i] = num1& 1;\\n            num1 = num1>>1;\\n            i++;\\n        }\\n        i = 0;\\n        while (num2) {\\n            arr2[i] = num2& 1;\\n            num2 = num2>>1;\\n            i++;\\n        }\\n        int ctr = 0;\\n        for (auto t: arr2) {\\n            if (t) ctr++;\\n        }\\n        int count= 0;\\n        for (i=31; i>=0; i--) {\\n            if (arr1[i]) {\\n                count++;\\n                res[i] = true;\\n                if (count == ctr) break;\\n            }\\n        }\\n        ctr = ctr- count;\\n        i =0;\\n        while (ctr >0 && i < 32) {\\n            if (!res[i]) {\\n                res[i] = true;\\n                ctr--;\\n            }\\n            i++;\\n        }\\n        int num = 0;\\n        for (i =0; i<32; i++) {\\n            if (res[i]) num = num + pow(2,i);\\n        }\\n        return num;\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        bool arr1[32], arr2[32], res[32];\\n        fill_n(arr1, 32, 0);\\n        fill_n(arr2, 32, 0);\\n        fill_n(res, 32, 0);\\n        int i= 0;\\n        int n = num1;\\n        while (num1) {\\n            arr1[i] = num1& 1;\\n            num1 = num1>>1;\\n            i++;\\n        }\\n        i = 0;\\n        while (num2) {\\n            arr2[i] = num2& 1;\\n            num2 = num2>>1;\\n            i++;\\n        }\\n        int ctr = 0;\\n        for (auto t: arr2) {\\n            if (t) ctr++;\\n        }\\n        int count= 0;\\n        for (i=31; i>=0; i--) {\\n            if (arr1[i]) {\\n                count++;\\n                res[i] = true;\\n                if (count == ctr) break;\\n            }\\n        }\\n        ctr = ctr- count;\\n        i =0;\\n        while (ctr >0 && i < 32) {\\n            if (!res[i]) {\\n                res[i] = true;\\n                ctr--;\\n            }\\n            i++;\\n        }\\n        int num = 0;\\n        for (i =0; i<32; i++) {\\n            if (res[i]) num = num + pow(2,i);\\n        }\\n        return num;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935935,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeXor(self, num1, num2):\\n        count1 = bin(num2)[2:].count(\"1\")\\n        count2 = bin(num1)[2:].count(\"1\")\\n        res, i = num1, 1\\n\\n        # count2 is the number of set bits in num1\\n        # count1 is the number of set bits in x\\n\\n        while count2 > count1:\\n            if res & i:\\n                res -= i\\n                count2 -= 1\\n            \\n            i = i<<1\\n\\n        while count2 < count1:\\n            if res & i == 0:\\n                res += i\\n                count2 += 1\\n\\n            i = i<<1\\n\\n        return res\\n\\n\\n\\n\\n    \\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1, num2):\\n        count1 = bin(num2)[2:].count(\"1\")\\n        count2 = bin(num1)[2:].count(\"1\")\\n        res, i = num1, 1\\n\\n        # count2 is the number of set bits in num1\\n        # count1 is the number of set bits in x\\n\\n        while count2 > count1:\\n            if res & i:\\n                res -= i\\n                count2 -= 1\\n            \\n            i = i<<1\\n\\n        while count2 < count1:\\n            if res & i == 0:\\n                res += i\\n                count2 += 1\\n\\n            i = i<<1\\n\\n        return res\\n\\n\\n\\n\\n    \\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917518,
                "title": "minimize-xor",
                "content": "# Intuition\\nTO MINIMIZE THE XOR SHIFT AS MANY ONE\\'S TO RIGHT AS POSSIBLE\\n\\n# Approach\\nWE WILL CALCULATE DIFFERENCE OF SET BITS AND REVERT THE BITS OF NUM1 UNTIL DIFFERENCE IS NOT EQUAL TO ZERO\\nIF NUMBER OF SET BITS IN NUM1 IS LESS THAN NUM2 THEN WE WILL MAKE 0\\'S TO 1\\'S FROM RIGHT SIDE\\nIF NUMBER OF SET BITS IN NUM1 IS GREATER THAN NUM2 THEN WE WILL MAKE 1\\'S TO 0\\'S FROM RIGHT SIDE\\nAND FOR FLIPPING THE BITS WE WILL USE XOR\\n\\n# Complexity\\n- Time complexity = O(LOGN)\\n\\n- Space complexity = O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int x=__builtin_popcount(num1);\\n        int y=__builtin_popcount(num2);\\n        int ans=y-x;\\n        if(ans==0) return num1;\\n//FIRST CASE\\n        if(ans>0){\\n            int i=0;\\n            while(i!=31){\\n            if((num1&(1<<i))==0) {num1^=(1<<i);ans--;}\\n            if(!ans) break;\\n            i++;\\n        }\\n        }\\n//SECOND CASE\\n        else{\\n            int i=0;\\n            ans=-ans;\\n            while(i!=31){\\n            if((num1&(1<<i))) {num1^=(1<<i);ans--;}\\n            if(!ans) break;\\n            i++;\\n        }\\n        }\\n        return num1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int x=__builtin_popcount(num1);\\n        int y=__builtin_popcount(num2);\\n        int ans=y-x;\\n        if(ans==0) return num1;\\n//FIRST CASE\\n        if(ans>0){\\n            int i=0;\\n            while(i!=31){\\n            if((num1&(1<<i))==0) {num1^=(1<<i);ans--;}\\n            if(!ans) break;\\n            i++;\\n        }\\n        }\\n//SECOND CASE\\n        else{\\n            int i=0;\\n            ans=-ans;\\n            while(i!=31){\\n            if((num1&(1<<i))) {num1^=(1<<i);ans--;}\\n            if(!ans) break;\\n            i++;\\n        }\\n        }\\n        return num1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903294,
                "title": "c-100-faster-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int minimizeXor(int num1, int num2) {\\n        ll set_bit1=0,set_bit2=0,answer=0;\\n        for(ll i=32;i>=0;i--){\\n            if(num1&(1LL<<i)){\\n                set_bit1++;\\n            }\\n            if(num2&(1LL<<i)){\\n                set_bit2++;\\n            }\\n        }\\n        if(set_bit1==set_bit2){\\n            return num1;\\n        }\\n        else if(set_bit1>set_bit2){\\n            for(ll i=32;i>=0;i--){\\n                if(num1&(1LL<<i) && set_bit2>0){\\n                    set_bit2--;\\n                    answer+=(1LL<<i);\\n                }\\n            }\\n        }\\n        else{\\n            ll count=set_bit2-set_bit1;\\n            for(ll i=0;i<=32;i++){\\n                if(num1&(1LL<<i)){\\n                    answer+=(1LL<<i);\\n                }\\n                else if(count>0){\\n                    count--;\\n                    answer+=(1LL<<i);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int minimizeXor(int num1, int num2) {\\n        ll set_bit1=0,set_bit2=0,answer=0;\\n        for(ll i=32;i>=0;i--){\\n            if(num1&(1LL<<i)){\\n                set_bit1++;\\n            }\\n            if(num2&(1LL<<i)){\\n                set_bit2++;\\n            }\\n        }\\n        if(set_bit1==set_bit2){\\n            return num1;\\n        }\\n        else if(set_bit1>set_bit2){\\n            for(ll i=32;i>=0;i--){\\n                if(num1&(1LL<<i) && set_bit2>0){\\n                    set_bit2--;\\n                    answer+=(1LL<<i);\\n                }\\n            }\\n        }\\n        else{\\n            ll count=set_bit2-set_bit1;\\n            for(ll i=0;i<=32;i++){\\n                if(num1&(1LL<<i)){\\n                    answer+=(1LL<<i);\\n                }\\n                else if(count>0){\\n                    count--;\\n                    answer+=(1LL<<i);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845436,
                "title": "python3-a-lot-of-binary-operators-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are two conditions:\\n1) Use as many ones as num2 has\\n2) minimize x ^ num1\\n\\nTherefore we at first need to find out how many ones num2 has, we do that by converting to binary string and count ones. Otherwise we could do that by shifting and comparing last bit like\\n\\n```\\ncounter = 0\\nwhile num2:\\n    if num2&1:\\n        counter += 1\\n    num2 = num2 >> 1\\n```\\n\\nThe second condition is what we really need to think about. Key idea: an xor gets minimal if we put ones where num1 also has ones as these cancel out. We should cancel out the highest ones of num1 first.\\n\\nIf we then have ones left we need to place, we should place them in the lowest possible index of the binary number as they do minimal damage there.\\n\\nWe can place ones by shifting a 1 to the right place and use the or operation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe count the ones in num2 and get a binary representation of num1.\\n\\nThen we use a loop from the highest significant bit (highest 1 in binary) to the lowest ones of num1 and place 1 in our result there to cancel these ones. We break if we do not have ones left (from num2). We shift our one down with each operation.\\n\\nIn the second loop we place 1 where num1 has zeros and we have not already placed a one in the result. We start at the lowest significant bit.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(num2))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n\\n        # find the numbers of ones in nums\\n        two_ones = bin(num2).count(\"1\")\\n\\n        # now count the number of ones in num1 we want to\\n        # delete\\n        ones_bin = bin(num1)[2:]\\n\\n        # find the highest bit in ones\\n        highest_bit = (1 << (len(ones_bin)-1)) if len(ones_bin) > 1 or ones_bin[0] == \\'1\\' else 0\\n\\n        # set all ones that are included in num1 so we minimize the xor\\n        # as 1^1 = 0\\n        result = 0\\n        for ch in ones_bin:\\n\\n            # guard clause\\n            if not two_ones:\\n                break\\n\\n            if ch == \\'1\\':\\n                result |= highest_bit\\n                two_ones -= 1\\n            highest_bit = highest_bit >> 1\\n        \\n        # now go through binary one and set the leftover ones\\n        comp = 1\\n        while two_ones:\\n            if not result&comp:\\n                result |= comp\\n                two_ones -= 1\\n            comp = comp << 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ncounter = 0\\nwhile num2:\\n    if num2&1:\\n        counter += 1\\n    num2 = num2 >> 1\\n```\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n\\n        # find the numbers of ones in nums\\n        two_ones = bin(num2).count(\"1\")\\n\\n        # now count the number of ones in num1 we want to\\n        # delete\\n        ones_bin = bin(num1)[2:]\\n\\n        # find the highest bit in ones\\n        highest_bit = (1 << (len(ones_bin)-1)) if len(ones_bin) > 1 or ones_bin[0] == \\'1\\' else 0\\n\\n        # set all ones that are included in num1 so we minimize the xor\\n        # as 1^1 = 0\\n        result = 0\\n        for ch in ones_bin:\\n\\n            # guard clause\\n            if not two_ones:\\n                break\\n\\n            if ch == \\'1\\':\\n                result |= highest_bit\\n                two_ones -= 1\\n            highest_bit = highest_bit >> 1\\n        \\n        # now go through binary one and set the leftover ones\\n        comp = 1\\n        while two_ones:\\n            if not result&comp:\\n                result |= comp\\n                two_ones -= 1\\n            comp = comp << 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825951,
                "title": "python-bit-count-and-replace",
                "content": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        binarynum = bin(num1)[2:].rjust(len(bin(num2)[2:]),\\'0\\')     \\n        cnt1 = binarynum.count(\\'1\\')\\n        cnt2 = bin(num2)[2:].count(\\'1\\')\\n        \\n        if cnt1 == cnt2:\\n            return num1\\n        elif cnt1 < cnt2:\\n            binarynum = binarynum[::-1].replace(\\'0\\',\\'1\\',cnt2-cnt1)[::-1]\\n            return int(binarynum,2)\\n        else:\\n            binarynum = binarynum[::-1].replace(\\'1\\',\\'0\\',cnt1-cnt2)[::-1]\\n            return int(binarynum,2)\\n```\\n\\t\\n\\t\\nExplanation\\n\\n1. if the number of \\'1\\' in bits is same like 3 & 5 , then just return num1.\\n\\n2. if the number of \\'1\\' in bit is different, then there are two way.\\n\\n\\t1. number1\\'s bit count > number2\\'s bit count.\\n\\t\\n\\texample) 79 ,74\\n\\t\\n\\tnum1: 79 -> 010011**11**\\n\\tnum2: 74 -> 01001010\\n\\n\\tThen, we just make 01001100 using three \\'1\\' of 74.\\n\\tit is same as removing right two \\'1\\' of num1.\\n\\n\\t\\n\\t2. number1\\'s bit count < number2\\' bit count, then place spare \\'1\\' from right to left.\\n\\t\\n\\texample) 65 84\\n\\tnum1: 65 -> 01000001\\n\\tnum2: 84 -> 01010100\\n\\t\\n\\t=>010000**1**1\\n\\t\\n\\treplace num1\\'s \\'0\\' from right by difference in bit count.\\n\\t\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        binarynum = bin(num1)[2:].rjust(len(bin(num2)[2:]),\\'0\\')     \\n        cnt1 = binarynum.count(\\'1\\')\\n        cnt2 = bin(num2)[2:].count(\\'1\\')\\n        \\n        if cnt1 == cnt2:\\n            return num1\\n        elif cnt1 < cnt2:\\n            binarynum = binarynum[::-1].replace(\\'0\\',\\'1\\',cnt2-cnt1)[::-1]\\n            return int(binarynum,2)\\n        else:\\n            binarynum = binarynum[::-1].replace(\\'1\\',\\'0\\',cnt1-cnt2)[::-1]\\n            return int(binarynum,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822332,
                "title": "golang-bit-operations-easy-to-understand",
                "content": "```go\\nfunc minimizeXor(num1 int, num2 int) int {\\n  c1 := hammingWeight(num1) // number of 1 bits\\n  c2 := hammingWeight(num2)\\n  var res int\\n  if c1 == c2 { // same popcount we can minimize XOR to 0\\n    return num1\\n  } else if c2 > c1 {\\n    // We can unset all the bits in num1 but we have to set c2-c1 bits in the\\n    // result. We\\'ll do that to the least significant unset bits of num1\\n    x := c2 - c1\\n    i := 0\\n    res = num1\\n    for x > 0 {\\n      if (num1 >> i) & 1 == 0 {\\n        res |= (1 << i)\\n        x--\\n      }\\n      i++\\n    }\\n  } else { // c1 > c2\\n    // Let\\'s start turning off the left most 1-bits as much as possible\\n    maxLen := len(strconv.FormatInt(int64(num1), 2))\\n    for i := maxLen-1; i >= 0 && c2 > 0; i-- {\\n      if (num1 >> i) & 1 == 1 {\\n        res |= (1 << i)\\n        c2--\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nfunc hammingWeight(num int) int {\\n  var mask int = 1\\n  var ones int\\n  for mask != 0 {\\n    if num & mask != 0 {\\n      ones++\\n    }\\n    mask = mask << 1\\n  }\\n  return ones\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```go\\nfunc minimizeXor(num1 int, num2 int) int {\\n  c1 := hammingWeight(num1) // number of 1 bits\\n  c2 := hammingWeight(num2)\\n  var res int\\n  if c1 == c2 { // same popcount we can minimize XOR to 0\\n    return num1\\n  } else if c2 > c1 {\\n    // We can unset all the bits in num1 but we have to set c2-c1 bits in the\\n    // result. We\\'ll do that to the least significant unset bits of num1\\n    x := c2 - c1\\n    i := 0\\n    res = num1\\n    for x > 0 {\\n      if (num1 >> i) & 1 == 0 {\\n        res |= (1 << i)\\n        x--\\n      }\\n      i++\\n    }\\n  } else { // c1 > c2\\n    // Let\\'s start turning off the left most 1-bits as much as possible\\n    maxLen := len(strconv.FormatInt(int64(num1), 2))\\n    for i := maxLen-1; i >= 0 && c2 > 0; i-- {\\n      if (num1 >> i) & 1 == 1 {\\n        res |= (1 << i)\\n        c2--\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nfunc hammingWeight(num int) int {\\n  var mask int = 1\\n  var ones int\\n  for mask != 0 {\\n    if num & mask != 0 {\\n      ones++\\n    }\\n    mask = mask << 1\\n  }\\n  return ones\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2821066,
                "title": "cpp-solution-basic-solution",
                "content": "Please UPVOTE :)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int setBitsNum1 = 0;\\n        int setBitsNum2 = 0;\\n\\n        int cpy = num1;\\n        while(cpy != 0){\\n            int rmsb = (cpy & -cpy);\\n            cpy = cpy - rmsb;\\n            setBitsNum1++;\\n        }\\n\\n        cpy = num2;\\n        while(cpy != 0)\\n        {\\n            int rmsb = (cpy & -cpy);\\n            cpy = cpy - rmsb;\\n            setBitsNum2++;\\n        }\\n\\n        if(setBitsNum1 > setBitsNum2){\\n            int count = setBitsNum2;\\n            int mask = 1;\\n            int ind = 31;\\n            int ans = 0;\\n            while(count > 0){\\n                if((num1 & (mask << ind)) != 0){\\n                    count--;\\n                    ans = (ans | (mask << ind));\\n                }\\n                ind--;\\n            }\\n\\n            return ans;\\n        }else if(setBitsNum2 > setBitsNum1){\\n            int count = setBitsNum1;\\n            int mask = 1;\\n            int ind = 31;\\n            int ans = 0;\\n            while(count > 0){\\n                if((num1 & (mask << ind)) != 0){\\n                    count--;\\n                    ans = (ans | (mask << ind));\\n                }\\n                ind--;\\n            }\\n\\n            int rem = setBitsNum2-setBitsNum1;\\n            ind = 0;\\n            while(rem > 0){\\n                if((ans & (mask << ind)) == 0){\\n                    rem--;\\n                    ans = (ans | (mask << ind));\\n                }\\n                ind++;\\n            }\\n            return ans;\\n        }\\n\\n        return num1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int setBitsNum1 = 0;\\n        int setBitsNum2 = 0;\\n\\n        int cpy = num1;\\n        while(cpy != 0){\\n            int rmsb = (cpy & -cpy);\\n            cpy = cpy - rmsb;\\n            setBitsNum1++;\\n        }\\n\\n        cpy = num2;\\n        while(cpy != 0)\\n        {\\n            int rmsb = (cpy & -cpy);\\n            cpy = cpy - rmsb;\\n            setBitsNum2++;\\n        }\\n\\n        if(setBitsNum1 > setBitsNum2){\\n            int count = setBitsNum2;\\n            int mask = 1;\\n            int ind = 31;\\n            int ans = 0;\\n            while(count > 0){\\n                if((num1 & (mask << ind)) != 0){\\n                    count--;\\n                    ans = (ans | (mask << ind));\\n                }\\n                ind--;\\n            }\\n\\n            return ans;\\n        }else if(setBitsNum2 > setBitsNum1){\\n            int count = setBitsNum1;\\n            int mask = 1;\\n            int ind = 31;\\n            int ans = 0;\\n            while(count > 0){\\n                if((num1 & (mask << ind)) != 0){\\n                    count--;\\n                    ans = (ans | (mask << ind));\\n                }\\n                ind--;\\n            }\\n\\n            int rem = setBitsNum2-setBitsNum1;\\n            ind = 0;\\n            while(rem > 0){\\n                if((ans & (mask << ind)) == 0){\\n                    rem--;\\n                    ans = (ans | (mask << ind));\\n                }\\n                ind++;\\n            }\\n            return ans;\\n        }\\n\\n        return num1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807636,
                "title": "o-logn-time-easy-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int setBit = 0;\\n        while(num2 > 0){\\n            setBit+= (num2 & 1);\\n            num2>>=1;\\n        }\\n        String str = Integer.toBinaryString(num1);\\n        int n = str.length();\\n        char[] arr = new char[n];\\n        for(int i=0;i<n;i++){\\n            if(setBit>0 && str.charAt(i) == \\'1\\'){\\n                arr[i] = \\'1\\';\\n                setBit--;\\n            }else arr[i] = \\'0\\';\\n        }\\n        for(int i = n-1;i>=0;i--)\\n            if(setBit>0 && arr[i] == \\'0\\'){\\n                    arr[i] = \\'1\\';\\n                    setBit--;\\n            }\\n        Integer ans = Integer.parseInt(\"\"+String.valueOf(arr),2);\\n        while(setBit>0){\\n            ans +=(1<<n);\\n            n++;\\n            setBit--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int setBit = 0;\\n        while(num2 > 0){\\n            setBit+= (num2 & 1);\\n            num2>>=1;\\n        }\\n        String str = Integer.toBinaryString(num1);\\n        int n = str.length();\\n        char[] arr = new char[n];\\n        for(int i=0;i<n;i++){\\n            if(setBit>0 && str.charAt(i) == \\'1\\'){\\n                arr[i] = \\'1\\';\\n                setBit--;\\n            }else arr[i] = \\'0\\';\\n        }\\n        for(int i = n-1;i>=0;i--)\\n            if(setBit>0 && arr[i] == \\'0\\'){\\n                    arr[i] = \\'1\\';\\n                    setBit--;\\n            }\\n        Integer ans = Integer.parseInt(\"\"+String.valueOf(arr),2);\\n        while(setBit>0){\\n            ans +=(1<<n);\\n            n++;\\n            setBit--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807078,
                "title": "c-bit-count-solution-100-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int countbit (int n) {\\n        int count = 0;\\n        while(n) {\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    int bitlength(int n) {\\n        return n ? floor(log2(n)) + 1:  0;\\n    }\\n    int minimizeXor(int num1, int num2) {\\n/**\\n  Algo: use greedy approach\\n    \\n    1) get the count for no. of set nit in num1 and num2\\n    2) if cnum1 == cnum2\\n        then return num1  \\n        because count is same so minimum value will be 0 after num1 xor with itself\\n    3) else \\n    we need to disable most significant bits of num1 till count of set bit of num2 is zero\\n    then we will get minimum xor value\\n    4) if there is leftover bit after disabling all the set bit of num 1 then\\n        we will start enabling the least significant bit till  count of set bit of num2 == 0\\n        to  get minimal value;\\n    example 1: num1 = 3 : num2 = 5\\n        3 = 011  = cnum1 = 2\\n        5 = 101  = cnum2 = 2\\n        minimal value 0  \\n        and cnum1 =   011\\n              x   =   011\\n        2)num1 =  7, num2= 8\\n            num1 = 0111 = cnum1 = 3\\n            num2 = 1000 = cnum2 = 1\\n            \\n            0111\\n          ^ 0100 -> 4 is the ans\\n            ----\\n            0011 - 3 mimum xor value \\n        \\n        \\n        3)\\n       num1 =  8, num2= 7\\n            num1 = 1000 = cnum1 = 1\\n            num2 = 0111 = cnum2  = 3\\n            \\n            num1 = 1000\\n                   1000  // disable most significant bit of num1\\n                   then as cnum2 = 2 then we need to enable 2 leftover bit , so here we will eable to least significant bit \\n                   to get minmum value\\n                   \\n                   1000\\n                ^  1011 \\n                   ----\\n                   0011 - 3 mimumm xor value\\n                   \\n                   1011 = 11 is the return\\n**/\\n        \\n        int cnum1 = countbit(num1);\\n        int cnum2 = countbit(num2);\\n        \\n        if(cnum1 == cnum2)\\n            return num1;\\n        \\n        int res = 0;\\n        \\n        // length of most significant bit in num1 \\n        int blen = bitlength(num1) - 1;\\n        \\n        // disable the 1\\'s bit of start with left most signifant bit num1 till cnum2 ==0 and till bitlen of cnum1 > -1 \\n        while(cnum2 && blen>=0) {\\n            int bit = (1<<blen) &  num1; // start with most significant left bit\\n            res |=  bit; // add to result\\n            blen--; // decrease bit len\\n            if(bit)// if it 1\\'s bit add to result\\n                cnum2--; // decrease cnum2 count\\n        }\\n        \\n        // leftover bit or cnum2 > 0\\n        blen = 0;\\n        while(cnum2) { // enable the leftover bit of result till count of num2 == 0\\n            int bit = ((res >> blen) & 1) ^ 1; // start with least significant bit and flip the bit as we need  to eable it\\n            res |= (bit<<blen); //  add to the result\\n            blen++; // inc bit length\\n            if(bit) // if bit is 1 or it is enable then dec the count \\n                cnum2--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countbit (int n) {\\n        int count = 0;\\n        while(n) {\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    int bitlength(int n) {\\n        return n ? floor(log2(n)) + 1:  0;\\n    }\\n    int minimizeXor(int num1, int num2) {\\n/**\\n  Algo: use greedy approach\\n    \\n    1) get the count for no. of set nit in num1 and num2\\n    2) if cnum1 == cnum2\\n        then return num1  \\n        because count is same so minimum value will be 0 after num1 xor with itself\\n    3) else \\n    we need to disable most significant bits of num1 till count of set bit of num2 is zero\\n    then we will get minimum xor value\\n    4) if there is leftover bit after disabling all the set bit of num 1 then\\n        we will start enabling the least significant bit till  count of set bit of num2 == 0\\n        to  get minimal value;\\n    example 1: num1 = 3 : num2 = 5\\n        3 = 011  = cnum1 = 2\\n        5 = 101  = cnum2 = 2\\n        minimal value 0  \\n        and cnum1 =   011\\n              x   =   011\\n        2)num1 =  7, num2= 8\\n            num1 = 0111 = cnum1 = 3\\n            num2 = 1000 = cnum2 = 1\\n            \\n            0111\\n          ^ 0100 -> 4 is the ans\\n            ----\\n            0011 - 3 mimum xor value \\n        \\n        \\n        3)\\n       num1 =  8, num2= 7\\n            num1 = 1000 = cnum1 = 1\\n            num2 = 0111 = cnum2  = 3\\n            \\n            num1 = 1000\\n                   1000  // disable most significant bit of num1\\n                   then as cnum2 = 2 then we need to enable 2 leftover bit , so here we will eable to least significant bit \\n                   to get minmum value\\n                   \\n                   1000\\n                ^  1011 \\n                   ----\\n                   0011 - 3 mimumm xor value\\n                   \\n                   1011 = 11 is the return\\n**/\\n        \\n        int cnum1 = countbit(num1);\\n        int cnum2 = countbit(num2);\\n        \\n        if(cnum1 == cnum2)\\n            return num1;\\n        \\n        int res = 0;\\n        \\n        // length of most significant bit in num1 \\n        int blen = bitlength(num1) - 1;\\n        \\n        // disable the 1\\'s bit of start with left most signifant bit num1 till cnum2 ==0 and till bitlen of cnum1 > -1 \\n        while(cnum2 && blen>=0) {\\n            int bit = (1<<blen) &  num1; // start with most significant left bit\\n            res |=  bit; // add to result\\n            blen--; // decrease bit len\\n            if(bit)// if it 1\\'s bit add to result\\n                cnum2--; // decrease cnum2 count\\n        }\\n        \\n        // leftover bit or cnum2 > 0\\n        blen = 0;\\n        while(cnum2) { // enable the leftover bit of result till count of num2 == 0\\n            int bit = ((res >> blen) & 1) ^ 1; // start with least significant bit and flip the bit as we need  to eable it\\n            res |= (bit<<blen); //  add to the result\\n            blen++; // inc bit length\\n            if(bit) // if bit is 1 or it is enable then dec the count \\n                cnum2--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799736,
                "title": "fundamental-approach-c-math-trick",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countBits(int n) {\\n        int c = 0;\\n        while(n > 0) {\\n            int rmsb = n&(-n);\\n            n -= rmsb;\\n            c++;\\n        }\\n        return c;\\n    }\\n    int minimizeXor(int num1, int num2) {\\n        int c = countBits(num2);\\n        int x = 0;\\n        for(int i=31;i>=0;i--) {\\n            if(c > 0 and (num1 & (1 << i))>0) {\\n                c--;\\n                x |= (1<<i);\\n            }\\n        }\\n        for(int i=0;i<32;i++) {\\n            if(c > 0 and (x & (1 << i)) == 0) {\\n                c--;\\n                x |= (1<<i);\\n            }\\n        }\\n        return x;\\n    }\\n};\\n// Consider upvoting if the solution helped! Thank you :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countBits(int n) {\\n        int c = 0;\\n        while(n > 0) {\\n            int rmsb = n&(-n);\\n            n -= rmsb;\\n            c++;\\n        }\\n        return c;\\n    }\\n    int minimizeXor(int num1, int num2) {\\n        int c = countBits(num2);\\n        int x = 0;\\n        for(int i=31;i>=0;i--) {\\n            if(c > 0 and (num1 & (1 << i))>0) {\\n                c--;\\n                x |= (1<<i);\\n            }\\n        }\\n        for(int i=0;i<32;i++) {\\n            if(c > 0 and (x & (1 << i)) == 0) {\\n                c--;\\n                x |= (1<<i);\\n            }\\n        }\\n        return x;\\n    }\\n};\\n// Consider upvoting if the solution helped! Thank you :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793673,
                "title": "bit-manipulations-90-speed",
                "content": "![image](https://assets.leetcode.com/users/images/9351d355-cccd-4e48-b541-ac4dba14045f_1667923847.4143174.png)\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        # determine number of 1\\'s in binary representation\\n        # which is also equal to bin(num2[1:]).count(\"1\")\\n        n2 = 0\\n        while num2:\\n            if num2 & 1:    # last bit is 1\\n                n2 += 1     # increase count\\n            num2 >>= 1      # shift the binary number to the right\\n\\n        # search for indices for 0\\'s and 1\\'s\\n        # n = 110 (binary form) => bits1{0: [0], 1: [1, 2]}\\n        bits1 = {0: [], 1: []}\\n        i = 0    # index from the right side\\n        while num1:\\n            if num1 & 1:   # decide which list to append\\n                bits1[1].append(i)\\n            else:\\n                bits1[0].append(i)\\n            i += 1        # increase index\\n            num1 >>= 1    # shift the number to the right\\n\\n        # list of positions - reversed for 1 (left to right)\\n        # straight for 0 (right to left)\\n        target_pos = bits1[1][::-1] + bits1[0]    # positions for 1\\n        # if we need more 1\\'s to be placed into the target number\\n        if len(target_pos) < n2:\\n            next_pos = target_pos[0] + 1    # most left position\\n            # fill it in with consecutive positions\\n            target_pos += list(range(next_pos,\\n                                     next_pos + n2 - len(target_pos)))\\n        # cut the list to the required length n2\\n        target_pos = target_pos[:n2]\\n        # find the final number by shifting 1\\'s to the target positions\\n        # e.g. target = 101 == 100 + 001 in binary\\n        return sum(1 << pos for pos in target_pos)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        # determine number of 1\\'s in binary representation\\n        # which is also equal to bin(num2[1:]).count(\"1\")\\n        n2 = 0\\n        while num2:\\n            if num2 & 1:    # last bit is 1\\n                n2 += 1     # increase count\\n            num2 >>= 1      # shift the binary number to the right\\n\\n        # search for indices for 0\\'s and 1\\'s\\n        # n = 110 (binary form) => bits1{0: [0], 1: [1, 2]}\\n        bits1 = {0: [], 1: []}\\n        i = 0    # index from the right side\\n        while num1:\\n            if num1 & 1:   # decide which list to append\\n                bits1[1].append(i)\\n            else:\\n                bits1[0].append(i)\\n            i += 1        # increase index\\n            num1 >>= 1    # shift the number to the right\\n\\n        # list of positions - reversed for 1 (left to right)\\n        # straight for 0 (right to left)\\n        target_pos = bits1[1][::-1] + bits1[0]    # positions for 1\\n        # if we need more 1\\'s to be placed into the target number\\n        if len(target_pos) < n2:\\n            next_pos = target_pos[0] + 1    # most left position\\n            # fill it in with consecutive positions\\n            target_pos += list(range(next_pos,\\n                                     next_pos + n2 - len(target_pos)))\\n        # cut the list to the required length n2\\n        target_pos = target_pos[:n2]\\n        # find the final number by shifting 1\\'s to the target positions\\n        # e.g. target = 101 == 100 + 001 in binary\\n        return sum(1 << pos for pos in target_pos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790272,
                "title": "c-solution-easy-faster-understandable",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(31)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n//first minimize first n set bits from msb of num1 where n is number of set bits in num2 then after getting result then if we xor result with num1 we get our desired ans\\n    int minimizeXor(int num1, int num2) {\\n        //count bits of num2\\n        int n = __builtin_popcount(num2);\\n        int n2 = __builtin_popcount(num1);\\n        int ans = 0;\\n\\n        if(n2 == n) return num1;\\n        else if(n2 < n){\\n            //increase unset bits from lsb until it becomes equal to n\\n            ans = num1;\\n            n = n - n2;\\n            for(int i=0;i<=31;i++){\\n                int bit = ans & (1<<i);\\n                if(bit == 0){\\n                    ans = ans | (1<<i);\\n                    n--;\\n                }\\n                if(n==0) break;\\n            }\\n        }\\n        else{\\n            int newNum1 = num1;\\n            for(int i=31;i>=0;i--){\\n                int bit = (newNum1 >> i)&1;\\n                if(bit == 1 && n>0){\\n                    newNum1 = newNum1 ^ (1<<i);\\n                    n--;\\n                }\\n            }\\n            ans = newNum1 ^ num1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//first minimize first n set bits from msb of num1 where n is number of set bits in num2 then after getting result then if we xor result with num1 we get our desired ans\\n    int minimizeXor(int num1, int num2) {\\n        //count bits of num2\\n        int n = __builtin_popcount(num2);\\n        int n2 = __builtin_popcount(num1);\\n        int ans = 0;\\n\\n        if(n2 == n) return num1;\\n        else if(n2 < n){\\n            //increase unset bits from lsb until it becomes equal to n\\n            ans = num1;\\n            n = n - n2;\\n            for(int i=0;i<=31;i++){\\n                int bit = ans & (1<<i);\\n                if(bit == 0){\\n                    ans = ans | (1<<i);\\n                    n--;\\n                }\\n                if(n==0) break;\\n            }\\n        }\\n        else{\\n            int newNum1 = num1;\\n            for(int i=31;i>=0;i--){\\n                int bit = (newNum1 >> i)&1;\\n                if(bit == 1 && n>0){\\n                    newNum1 = newNum1 ^ (1<<i);\\n                    n--;\\n                }\\n            }\\n            ans = newNum1 ^ num1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782771,
                "title": "c-solution",
                "content": "# Approach\\nMain idea is to remember the properties of xor 1^1 = 0, first, loop through the 2nd number and count the number of bits set(i.e. number of 1s), call it bitCount2. \\n\\nSecond, loop through the first number and set all the 1s from the left side of the bit representation, add it to the new number(num) and decrement bitCount2. \\n\\nFinally, if we still have bitcount2 left, take the result num from above and iterate through its bit representation from right side this time. Set any bit that is not set until bitcount2 == 0.\\n\\n# Complexity\\n\\n- Time complexity:\\n    - O(32) - We do three iterations of 32 each\\n\\n- Space complexity:\\n    - O(1) - one variable, constant space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int bitCount2 = 0;\\n        for (int i = 0; i < 32; i++) {\\n           if (num2 & 1<<i) {\\n               bitCount2++;\\n           }\\n        } \\n        int num = 0;\\n        int val = -1;\\n        for (int i = 31; i >= 0; i--) {\\n           if (num1 & 1<<i && bitCount2) {\\n               bitCount2--;\\n               num |= 1<<i;\\n           }\\n        } \\n        \\n        for (int i = 0; i < 32; i++) {\\n           if (!(num & 1<<i) && bitCount2) {\\n               bitCount2--;\\n               num |= 1<<i;\\n           }\\n        } \\n        \\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeXor(int num1, int num2) {\\n        int bitCount2 = 0;\\n        for (int i = 0; i < 32; i++) {\\n           if (num2 & 1<<i) {\\n               bitCount2++;\\n           }\\n        } \\n        int num = 0;\\n        int val = -1;\\n        for (int i = 31; i >= 0; i--) {\\n           if (num1 & 1<<i && bitCount2) {\\n               bitCount2--;\\n               num |= 1<<i;\\n           }\\n        } \\n        \\n        for (int i = 0; i < 32; i++) {\\n           if (!(num & 1<<i) && bitCount2) {\\n               bitCount2--;\\n               num |= 1<<i;\\n           }\\n        } \\n        \\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776885,
                "title": "easy-solution-using-python-bit-manipulation",
                "content": "# PYTHON SOLUTION\\n\\n\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        def count_bits(n):\\n            c = 0\\n            while n>0:\\n                if n&1 == 1:\\n                    c +=1\\n                \\n                n = n>>1\\n            return c\\n        bits = count_bits(num2)\\n        \\n        ans = 0\\n        total = 0\\n        if num1 == num2:\\n            return num1\\n       \\n        for i in range(31,-1,-1):\\n            if (num1>>i)&1 == 1:\\n                ans +=2**i\\n                total+=1\\n\\n                if total == bits:\\n                    break\\n        i = 0\\n        a = ans\\n        while total<bits:\\n            if a&1 == 0:\\n                ans = ans+ (2**i)\\n                total +=1\\n            i+=1\\n            a = a>>1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        def count_bits(n):\\n            c = 0\\n            while n>0:\\n                if n&1 == 1:\\n                    c +=1\\n                \\n                n = n>>1\\n            return c\\n        bits = count_bits(num2)\\n        \\n        ans = 0\\n        total = 0\\n        if num1 == num2:\\n            return num1\\n       \\n        for i in range(31,-1,-1):\\n            if (num1>>i)&1 == 1:\\n                ans +=2**i\\n                total+=1\\n\\n                if total == bits:\\n                    break\\n        i = 0\\n        a = ans\\n        while total<bits:\\n            if a&1 == 0:\\n                ans = ans+ (2**i)\\n                total +=1\\n            i+=1\\n            a = a>>1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769188,
                "title": "solution",
                "content": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  int minimizeXor(const int num1, const int num2) {\\n    int bits = get_bits(num2);\\n    int ret = 0;\\n    for (int offset = 30; offset > -1 && bits > 0; --offset) {\\n      if (((num1 >> offset) & 0b1) == 0b1) {\\n        --bits;\\n        ret |= (1 << offset);\\n      }\\n    }\\n    \\n    for (int offset = 0; offset < 31 && bits > 0; ++offset) {\\n      if (((ret >> offset) & 0b1) == 0b0) {\\n        --bits;\\n        ret |= (1 << offset);\\n      }\\n    }\\n    \\n    return ret;\\n  }\\n  \\n private:\\n  int get_bits(int n) {\\n    int ret = 0;\\n    while (n > 0) {\\n      n &= n - 1;\\n      ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  int minimizeXor(const int num1, const int num2) {\\n    int bits = get_bits(num2);\\n    int ret = 0;\\n    for (int offset = 30; offset > -1 && bits > 0; --offset) {\\n      if (((num1 >> offset) & 0b1) == 0b1) {\\n        --bits;\\n        ret |= (1 << offset);\\n      }\\n    }\\n    \\n    for (int offset = 0; offset < 31 && bits > 0; ++offset) {\\n      if (((ret >> offset) & 0b1) == 0b0) {\\n        --bits;\\n        ret |= (1 << offset);\\n      }\\n    }\\n    \\n    return ret;\\n  }\\n  \\n private:\\n  int get_bits(int n) {\\n    int ret = 0;\\n    while (n > 0) {\\n      n &= n - 1;\\n      ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768543,
                "title": "javascript-without-bit-operation-just-using-javascript-functions",
                "content": "Not really more efficient but if anyone has problem with remembering those bitwise operation, that might be a good alternative:\\n```\\nvar minimizeXor = function(num1, num2) {\\n   function getOnes(num) {\\n      let curr = num\\n      let res = 0\\n      \\n      while(curr) {\\n          res += curr % 2\\n          curr = Math.floor(curr/2)\\n      }\\n      \\n      return res\\n   }\\n    \\n   const bits = getOnes(num2)\\n   const resArr = new Array(32).fill(\\'0\\')\\n   const bitsNum2Arr = Number(num2).toString(2).padStart(32, \\'0\\').split(\\'\\')\\n   const bitsNum1Arr = Number(num1).toString(2).padStart(32, \\'0\\').split(\\'\\')\\n   let onesCount = bits\\n   \\n   for(let i = 0; i < 32 && onesCount>0; i++) {\\n      if(bitsNum1Arr[i]===\\'1\\') {\\n          resArr[i] = \\'1\\'\\n          onesCount--\\n      } \\n   }\\n    \\n   for(let i = 31; i >= 0 && onesCount>0; i--) {\\n      if(resArr[i]===\\'0\\') {\\n          resArr[i] = \\'1\\'\\n          onesCount--\\n      } \\n   }\\n    \\n   return parseInt(resArr.join(\\'\\'),2)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizeXor = function(num1, num2) {\\n   function getOnes(num) {\\n      let curr = num\\n      let res = 0\\n      \\n      while(curr) {\\n          res += curr % 2\\n          curr = Math.floor(curr/2)\\n      }\\n      \\n      return res\\n   }\\n    \\n   const bits = getOnes(num2)\\n   const resArr = new Array(32).fill(\\'0\\')\\n   const bitsNum2Arr = Number(num2).toString(2).padStart(32, \\'0\\').split(\\'\\')\\n   const bitsNum1Arr = Number(num1).toString(2).padStart(32, \\'0\\').split(\\'\\')\\n   let onesCount = bits\\n   \\n   for(let i = 0; i < 32 && onesCount>0; i++) {\\n      if(bitsNum1Arr[i]===\\'1\\') {\\n          resArr[i] = \\'1\\'\\n          onesCount--\\n      } \\n   }\\n    \\n   for(let i = 31; i >= 0 && onesCount>0; i--) {\\n      if(resArr[i]===\\'0\\') {\\n          resArr[i] = \\'1\\'\\n          onesCount--\\n      } \\n   }\\n    \\n   return parseInt(resArr.join(\\'\\'),2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764920,
                "title": "javascript-count-one-bits",
                "content": "```\\n/**\\n * @param {number} num1\\n * @param {number} num2\\n * @return {number}\\n */\\nvar minimizeXor = function (num1, num2) {\\n  let a = countOneBits(num1);\\n  let b = countOneBits(num2);\\n  let ans = num1;\\n\\n  for (let i = 0; i < 32; i++) {\\n    const currentBit = num1 & (1 << i);\\n\\n    if (a > b && currentBit > 0) {\\n      ans -= 1 << i;\\n      a--;\\n    } else if (a < b && currentBit === 0) {\\n      ans += 1 << i;\\n      a++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\nfunction countOneBits(num) {\\n  let count = 0;\\n  while (num > 0) {\\n    if ((num & 1) > 0) {\\n      count++;\\n    }\\n    num >>= 1;\\n  }\\n  return count;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} num1\\n * @param {number} num2\\n * @return {number}\\n */\\nvar minimizeXor = function (num1, num2) {\\n  let a = countOneBits(num1);\\n  let b = countOneBits(num2);\\n  let ans = num1;\\n\\n  for (let i = 0; i < 32; i++) {\\n    const currentBit = num1 & (1 << i);\\n\\n    if (a > b && currentBit > 0) {\\n      ans -= 1 << i;\\n      a--;\\n    } else if (a < b && currentBit === 0) {\\n      ans += 1 << i;\\n      a++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\nfunction countOneBits(num) {\\n  let count = 0;\\n  while (num > 0) {\\n    if ((num & 1) > 0) {\\n      count++;\\n    }\\n    num >>= 1;\\n  }\\n  return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750089,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSetBits(int n)\\n    {\\n        int ans=0;\\n        while(n)\\n        {\\n            n=(n&(n-1));\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    int minimizeXor(int num1, int num2) \\n    {\\n        int n2=numSetBits(num2);\\n        int n1=numSetBits(num1);\\n        if (n1==n2) return num1;\\n        if (n1>n2)\\n        {\\n            int cnt=n1;\\n            int temp=num1;\\n            while(cnt!=n2)\\n            {\\n                temp=(temp&(temp-1));\\n                cnt--;\\n            }\\n            return temp;\\n        }\\n            int temp=num1;\\n            int a=0;\\n            while(n1!=n2)\\n            {\\n                if ((num1&(1<<a))==0)\\n                {\\n                    temp^=(1<<a);\\n                    n1++;\\n                }\\n                a++;\\n            }\\n            return temp;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int numSetBits(int n)\\n    {\\n        int ans=0;\\n        while(n)\\n        {\\n            n=(n&(n-1));\\n            ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2737313,
                "title": "python3-greedy",
                "content": "# Intuition\\nEach bit we return is independant of every other bit (with the only caveat that you cannot flip the same bit twice, since this would not increase the resultant bit count).  Generally speaking, any system in which the next independent counter is at least a multiple of 2 higher can be approached in a greedy manner.   Each bit will EITHER add its value or subtract its value after XORing with num1, so we can minimize the changes independantly.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        r, choices = 0, sorted([(num1^(1<<i)) - num1 for i in range(32)])\\n\\n        while num2:\\n            while not num2 & 1:\\n                num2>>=1\\n            num2>>=1\\n            r += abs(choices.pop(0))\\n\\n        return r\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        r, choices = 0, sorted([(num1^(1<<i)) - num1 for i in range(32)])\\n\\n        while num2:\\n            while not num2 & 1:\\n                num2>>=1\\n            num2>>=1\\n            r += abs(choices.pop(0))\\n\\n        return r\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735983,
                "title": "python3-o-logn-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        s = bin(num1)[2:]\\n        t = bin(num2)[2:]\\n        ones = t.count(\\'1\\')\\n        diff = max(0,len(t) - len(s))\\n        s = \\'0\\'*diff + s\\n        arr = [0 for _ in range(len(s))]\\n        n = len(arr)\\n        for i in range(n):\\n            if s[i] == \\'1\\' and ones > 0:\\n                arr[i] = 1\\n                ones -= 1\\n        for i in range(n-1,-1,-1):\\n            if arr[i] == 0 and ones > 0:\\n                arr[i] = 1\\n                ones -= 1\\n        \\n        return int(\\'\\'.join(str(el) for el in arr),2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        s = bin(num1)[2:]\\n        t = bin(num2)[2:]\\n        ones = t.count(\\'1\\')\\n        diff = max(0,len(t) - len(s))\\n        s = \\'0\\'*diff + s\\n        arr = [0 for _ in range(len(s))]\\n        n = len(arr)\\n        for i in range(n):\\n            if s[i] == \\'1\\' and ones > 0:\\n                arr[i] = 1\\n                ones -= 1\\n        for i in range(n-1,-1,-1):\\n            if arr[i] == 0 and ones > 0:\\n                arr[i] = 1\\n                ones -= 1\\n        \\n        return int(\\'\\'.join(str(el) for el in arr),2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729472,
                "title": "java-faster-than-90",
                "content": "Please upvote if you like the code :)\\n\\nclass Solution {\\n\\n    public int minimizeXor(int num1, int num2) {\\n        \\n        int num2Setbits = noOfSetbits(num2);\\n        int n = num1;\\n        int k = 0;\\n\\t\\t//finds total number of bits (both zeros and ones) num1 e.g (5)->(101) = 3\\n        while(n!=0) {\\n            k++;\\n            n=n>>1;\\n        }\\n        int ans=0;\\n        n=num1;\\n        int i=0;\\n        while(num2Setbits!=0)\\n        {\\n            if((n&(1<<k-1))>0)   //checks if Left Most Bit if 1\\n            {   \\n                ans = ans | (1<<k-1);\\n                num2Setbits--;\\n                n = n ^ (1 << (k-1));\\n            }\\n            else if(n==0 && num2Setbits!=0)  // means we still have bits to set after overlapping setBits with num2\\n            {\\n                if((ans&(1<<i))==0)\\n                {\\n                    ans = (ans ^ (1 << (i)));   // sets the right most 0 to 1\\n                    num2Setbits--;\\n                }\\n                i++;\\n            }\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n\\t// counts the number of set bits\\n    static int noOfSetbits(int n) {\\n        int c=0;\\n        while(n!=0){\\n            if((n&1)==1)\\n            c++;\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\n    public int minimizeXor(int num1, int num2) {\\n        \\n        int num2Setbits = noOfSetbits(num2);\\n        int n = num1;\\n        int k = 0;\\n\\t\\t//finds total number of bits (both zeros and ones) num1 e.g (5)->(101) = 3\\n        while(n!=0) {\\n            k++;\\n            n=n>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2719594,
                "title": "matthew-s-version-w-bitwise-stuff-this-time",
                "content": "At first, I was stubbornly avoiding using bitwise operations and got [this solution](https://leetcode.com/problems/minimize-xor/discuss/2666689/Matthews-Amazing-String-Manipulation-Solution). But I relented and thought it was time to refresh my almost-never-used bitwise knowledge. This is what happened: (commentless version first)\\n```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int numBit1 = Integer.bitCount(num1), numBit2 = Integer.bitCount(num2);\\n        if(numBit1 == numBit2) return num1;\\n        int r = num1;\\n        byte xSize = (byte) Math.max( \\n            (int) (Math.log(num1) / Math.log(2)), \\n            (int) (Math.log(num2) / Math.log(2))\\n        );\\n        byte i = 0;\\n        while(i <= xSize && numBit1 != numBit2) {\\n            int curBit = 1 << i++, bitExtant = curBit & num1;\\n            boolean twoIsLarger = (numBit2 > numBit1), beZero = (bitExtant == 0);\\n            if(twoIsLarger ^ beZero) continue;\\n            if(beZero) {\\n                r ^= curBit;\\n                numBit1++;\\n                continue;\\n            }\\n            r ^= curBit;\\n            numBit1--; \\n        }\\n        return r; \\n    }\\n}\\n```\\nWith my stream of stream of consciousness style comments:\\n```\\nclass Solution {\\n    /*\\n        Finished V1.0...\\n        1 ms, faster than 93.04%?\\n        40.9 MB, less than 70.23%?\\n        Let\\'s see what else we can try...\\n    */\\n    public int minimizeXor(int num1, int num2) {\\n        int numBit1 = Integer.bitCount(num1), numBit2 = Integer.bitCount(num2);\\n        if(numBit1 == numBit2) return num1;\\n        int r = num1; // r for \\'return value\\'\\n        // int ret = 0; // ???\\n        // xSize can be, at most, 30. So we can use a smaller number type for this and\\n        // also the iterator later and save a tiny bit of memory, maybe!\\n        byte xSize = (byte) Math.max( \\n            (int) (Math.log(num1) / Math.log(2)), \\n            (int) (Math.log(num2) / Math.log(2))\\n        );\\n        byte i = 0;\\n        while(i <= xSize && numBit1 != numBit2) {\\n            // ret = r; // ???\\n            // System.out.printf(\"r = %d\\\\n\", r);\\n            int curBit = 1 << i++; // The position we\\'re scrutinizing this pass\\n            int bitExtant = curBit & num1;\\n            /*\\n                Alright, I need a truth table:\\n                \\n                    a = numBit2 > numBit1\\n                    b = bitExtant == 0\\n                    \\n                            a\\n                        | 1 | 0 |\\n                        |-------|\\n                      1 | y | z |\\n                    b   | - | - |\\n                      0 | z | x |\\n                      \\n                    x = do the numBit1-- routine\\n                    y = do the numBit1++ routine\\n                    z = do nothing\\n                    \\n                That\\'s funny, the z\\'s align with XOR...\\n                So, I can check for z, then if that\\'s true, continue, else just \\n                check only one of a or b to see whether it\\'s x or y:\\n            */\\n            boolean twoIsLarger = (numBit2 > numBit1), beZero = (bitExtant == 0); // the only two things we need to know at this point\\n            if(twoIsLarger ^ beZero) {\\n                // System.out.println(\"\\\\tSkip\");\\n                continue;\\n            }\\n            if(beZero) {\\n                // System.out.println(\"\\\\tplus\");\\n                r ^= curBit;\\n                numBit1++; // Since we\\'re adding a bit\\n                continue;\\n            }\\n            /* \\n                We already know numBit1 != numBit2 and numBit1 !< numBit2 at this point\\n                Oh, and also that bitExtant != 0, if I add a continue to the above if...\\n                But if I need to choose one to check for sure each time, which is faster?\\n                Oh wait that\\'s wrong, we\\'d only know one or more of the contitions were\\n                false. Well, maybe comparing a var to a number is a little faster than \\n                comparing two vars, so I\\'ll swap the contitions. No, I need to go back \\n                in time and make a truth table!\\n            */\\n                // System.out.println(\"\\\\tminus \" + curBit);\\n            r ^= curBit;\\n            numBit1--; // Since we\\'re removing a bit\\n            // System.out.println(\"r now \" + r);\\n        }\\n        // System.out.printf(\"Here at the end, r = %d\\\\n\", r);\\n        // Why did \\'r\\' stop working, but only for one test case??? And Secondly, why did it Start working again when I created another var with the exact same scope???\\n        // What? now it\\'s not happening anymore >:-( Noone will believe me now!\\n        return r; \\n    }\\n}\\n/*\\n    3\\n    5\\n    1\\n    12\\n    40\\n    40\\n    10765\\n    1024\\n    25\\n    72\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int numBit1 = Integer.bitCount(num1), numBit2 = Integer.bitCount(num2);\\n        if(numBit1 == numBit2) return num1;\\n        int r = num1;\\n        byte xSize = (byte) Math.max( \\n            (int) (Math.log(num1) / Math.log(2)), \\n            (int) (Math.log(num2) / Math.log(2))\\n        );\\n        byte i = 0;\\n        while(i <= xSize && numBit1 != numBit2) {\\n            int curBit = 1 << i++, bitExtant = curBit & num1;\\n            boolean twoIsLarger = (numBit2 > numBit1), beZero = (bitExtant == 0);\\n            if(twoIsLarger ^ beZero) continue;\\n            if(beZero) {\\n                r ^= curBit;\\n                numBit1++;\\n                continue;\\n            }\\n            r ^= curBit;\\n            numBit1--; \\n        }\\n        return r; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    /*\\n        Finished V1.0...\\n        1 ms, faster than 93.04%?\\n        40.9 MB, less than 70.23%?\\n        Let\\'s see what else we can try...\\n    */\\n    public int minimizeXor(int num1, int num2) {\\n        int numBit1 = Integer.bitCount(num1), numBit2 = Integer.bitCount(num2);\\n        if(numBit1 == numBit2) return num1;\\n        int r = num1; // r for \\'return value\\'\\n        // int ret = 0; // ???\\n        // xSize can be, at most, 30. So we can use a smaller number type for this and\\n        // also the iterator later and save a tiny bit of memory, maybe!\\n        byte xSize = (byte) Math.max( \\n            (int) (Math.log(num1) / Math.log(2)), \\n            (int) (Math.log(num2) / Math.log(2))\\n        );\\n        byte i = 0;\\n        while(i <= xSize && numBit1 != numBit2) {\\n            // ret = r; // ???\\n            // System.out.printf(\"r = %d\\\\n\", r);\\n            int curBit = 1 << i++; // The position we\\'re scrutinizing this pass\\n            int bitExtant = curBit & num1;\\n            /*\\n                Alright, I need a truth table:\\n                \\n                    a = numBit2 > numBit1\\n                    b = bitExtant == 0\\n                    \\n                            a\\n                        | 1 | 0 |\\n                        |-------|\\n                      1 | y | z |\\n                    b   | - | - |\\n                      0 | z | x |\\n                      \\n                    x = do the numBit1-- routine\\n                    y = do the numBit1++ routine\\n                    z = do nothing\\n                    \\n                That\\'s funny, the z\\'s align with XOR...\\n                So, I can check for z, then if that\\'s true, continue, else just \\n                check only one of a or b to see whether it\\'s x or y:\\n            */\\n            boolean twoIsLarger = (numBit2 > numBit1), beZero = (bitExtant == 0); // the only two things we need to know at this point\\n            if(twoIsLarger ^ beZero) {\\n                // System.out.println(\"\\\\tSkip\");\\n                continue;\\n            }\\n            if(beZero) {\\n                // System.out.println(\"\\\\tplus\");\\n                r ^= curBit;\\n                numBit1++; // Since we\\'re adding a bit\\n                continue;\\n            }\\n            /* \\n                We already know numBit1 != numBit2 and numBit1 !< numBit2 at this point\\n                Oh, and also that bitExtant != 0, if I add a continue to the above if...\\n                But if I need to choose one to check for sure each time, which is faster?\\n                Oh wait that\\'s wrong, we\\'d only know one or more of the contitions were\\n                false. Well, maybe comparing a var to a number is a little faster than \\n                comparing two vars, so I\\'ll swap the contitions. No, I need to go back \\n                in time and make a truth table!\\n            */\\n                // System.out.println(\"\\\\tminus \" + curBit);\\n            r ^= curBit;\\n            numBit1--; // Since we\\'re removing a bit\\n            // System.out.println(\"r now \" + r);\\n        }\\n        // System.out.printf(\"Here at the end, r = %d\\\\n\", r);\\n        // Why did \\'r\\' stop working, but only for one test case??? And Secondly, why did it Start working again when I created another var with the exact same scope???\\n        // What? now it\\'s not happening anymore >:-( Noone will believe me now!\\n        return r; \\n    }\\n}\\n/*\\n    3\\n    5\\n    1\\n    12\\n    40\\n    40\\n    10765\\n    1024\\n    25\\n    72\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705632,
                "title": "python-simple-bit-solution",
                "content": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        count = str(bin(num2))[2:].count(\"1\")\\n        num1_bin = str(bin(num1))[2:]\\n        ans = \"\"\\n        for i in range(len(num1_bin)):\\n            if len(num1_bin) - i <= count:\\n                ans += \"1\"*count\\n                break\\n            if num1_bin[i] == \"1\" and count != 0:\\n                ans += \"1\"\\n                count -= 1\\n            else:\\n                ans += \"0\"\\n        return int(ans, 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeXor(self, num1: int, num2: int) -> int:\\n        count = str(bin(num2))[2:].count(\"1\")\\n        num1_bin = str(bin(num1))[2:]\\n        ans = \"\"\\n        for i in range(len(num1_bin)):\\n            if len(num1_bin) - i <= count:\\n                ans += \"1\"*count\\n                break\\n            if num1_bin[i] == \"1\" and count != 0:\\n                ans += \"1\"\\n                count -= 1\\n            else:\\n                ans += \"0\"\\n        return int(ans, 2)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1743372,
                "content": [
                    {
                        "username": "shivansh157",
                        "content": "I am pretty bad at bit manipulation questions,Please give any suggestion how to get better at it."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "Can you solve them if the inputs are strings which are the binary representations of the numbers?"
                    },
                    {
                        "username": "mpung2319",
                        "content": "The question seems a little ambiguous in how it is interpreting an answer. It is specified that we are given two positive integers, but not that the answer should also be a positive integer or that it should be treated as an unsigned integer. For the first test case, -2,147,483,646 has two set bits (assuming 32-bit integers), and -2,147,483,646 XOR 3 = -2,147,483,647, which is significantly smaller than the provided answer of 0.\n\nI think it is reasonable to assume through the nature of the problem that the answers will be interpreted as unsigned integers, but I still think it should be clarified in the problem description.\n"
                    },
                    {
                        "username": "AJReach",
                        "content": "Very good question on Bit Manipulation"
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "Bro, is it just me who is getting more confused with the question and the explanation??\\nI mean cant they just ask, return the set bits of the XORed value?\\nOr am I getting it wrong?"
                    }
                ]
            },
            {
                "id": 1632014,
                "content": [
                    {
                        "username": "shivansh157",
                        "content": "I am pretty bad at bit manipulation questions,Please give any suggestion how to get better at it."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "Can you solve them if the inputs are strings which are the binary representations of the numbers?"
                    },
                    {
                        "username": "mpung2319",
                        "content": "The question seems a little ambiguous in how it is interpreting an answer. It is specified that we are given two positive integers, but not that the answer should also be a positive integer or that it should be treated as an unsigned integer. For the first test case, -2,147,483,646 has two set bits (assuming 32-bit integers), and -2,147,483,646 XOR 3 = -2,147,483,647, which is significantly smaller than the provided answer of 0.\n\nI think it is reasonable to assume through the nature of the problem that the answers will be interpreted as unsigned integers, but I still think it should be clarified in the problem description.\n"
                    },
                    {
                        "username": "AJReach",
                        "content": "Very good question on Bit Manipulation"
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "Bro, is it just me who is getting more confused with the question and the explanation??\\nI mean cant they just ask, return the set bits of the XORed value?\\nOr am I getting it wrong?"
                    }
                ]
            },
            {
                "id": 2030923,
                "content": [
                    {
                        "username": "shivansh157",
                        "content": "I am pretty bad at bit manipulation questions,Please give any suggestion how to get better at it."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "Can you solve them if the inputs are strings which are the binary representations of the numbers?"
                    },
                    {
                        "username": "mpung2319",
                        "content": "The question seems a little ambiguous in how it is interpreting an answer. It is specified that we are given two positive integers, but not that the answer should also be a positive integer or that it should be treated as an unsigned integer. For the first test case, -2,147,483,646 has two set bits (assuming 32-bit integers), and -2,147,483,646 XOR 3 = -2,147,483,647, which is significantly smaller than the provided answer of 0.\n\nI think it is reasonable to assume through the nature of the problem that the answers will be interpreted as unsigned integers, but I still think it should be clarified in the problem description.\n"
                    },
                    {
                        "username": "AJReach",
                        "content": "Very good question on Bit Manipulation"
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "Bro, is it just me who is getting more confused with the question and the explanation??\\nI mean cant they just ask, return the set bits of the XORed value?\\nOr am I getting it wrong?"
                    }
                ]
            },
            {
                "id": 2005914,
                "content": [
                    {
                        "username": "shivansh157",
                        "content": "I am pretty bad at bit manipulation questions,Please give any suggestion how to get better at it."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "Can you solve them if the inputs are strings which are the binary representations of the numbers?"
                    },
                    {
                        "username": "mpung2319",
                        "content": "The question seems a little ambiguous in how it is interpreting an answer. It is specified that we are given two positive integers, but not that the answer should also be a positive integer or that it should be treated as an unsigned integer. For the first test case, -2,147,483,646 has two set bits (assuming 32-bit integers), and -2,147,483,646 XOR 3 = -2,147,483,647, which is significantly smaller than the provided answer of 0.\n\nI think it is reasonable to assume through the nature of the problem that the answers will be interpreted as unsigned integers, but I still think it should be clarified in the problem description.\n"
                    },
                    {
                        "username": "AJReach",
                        "content": "Very good question on Bit Manipulation"
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "Bro, is it just me who is getting more confused with the question and the explanation??\\nI mean cant they just ask, return the set bits of the XORed value?\\nOr am I getting it wrong?"
                    }
                ]
            }
        ]
    }
]