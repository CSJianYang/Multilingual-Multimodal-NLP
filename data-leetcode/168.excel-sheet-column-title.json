[
    {
        "title": "Text Justification",
        "question_content": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\n\n\tA word is defined as a character sequence consisting of non-space characters only.\n\tEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n\tThe input array words contains at least one word.\n\n&nbsp;\nExample 1:\n\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n&nbsp; &nbsp;\"This &nbsp; &nbsp;is &nbsp; &nbsp;an\",\n&nbsp; &nbsp;\"example &nbsp;of text\",\n&nbsp; &nbsp;\"justification. &nbsp;\"\n]\nExample 2:\n\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n&nbsp; \"What &nbsp; must &nbsp; be\",\n&nbsp; \"acknowledgment &nbsp;\",\n&nbsp; \"shall be &nbsp; &nbsp; &nbsp; &nbsp;\"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\nExample 3:\n\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n&nbsp; \"Science &nbsp;is &nbsp;what we\",\n  \"understand &nbsp; &nbsp; &nbsp;well\",\n&nbsp; \"enough to explain to\",\n&nbsp; \"a &nbsp;computer. &nbsp;Art is\",\n&nbsp; \"everything &nbsp;else &nbsp;we\",\n&nbsp; \"do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\"\n]\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 300\n\t1 <= words[i].length <= 20\n\twords[i] consists of only English letters and symbols.\n\t1 <= maxWidth <= 100\n\twords[i].length <= maxWidth",
        "solutions": [
            {
                "id": 24902,
                "title": "java-easy-to-understand-broken-into-several-functions",
                "content": "We start with left being the first word.\\n\\nfindRight: Then we greedily try to go as far right as possible until we fill our current line.\\n\\nThen we justify one line at a time.\\n\\njustify: In all cases we pad the right side with spaces until we reach max width for the line;\\n1. If it's one word then it is easy, the result is just that word.\\n2. If it's the last line then the result is all words separated by a single space.\\n3. Otherwise we calculate the size of each space evenly and if there is a remainder we distribute an extra space until it is gone.\\n\\n```\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace('\\\\0', ' ');\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace('\\\\0', ' ');\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24891,
                "title": "concise-python-solution-10-lines",
                "content": "--------------------------------------------\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        return res + [\\' \\'.join(cur).ljust(maxWidth)]\\n\\nHow does it work? Well in the question statement, the sentence \"Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right\" was just a really long and awkward way to say *round robin*. The following line implements the round robin logic: \\n\\n    for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n\\nWhat does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The \"or 1\" part is for dealing with the edge case len(cur) == 1.\\n\\n###### Note: I found that this problem & solution is directly being used in the \"Elements of Programming Interviews in Python\" book. Cool I guess, but the book should include an acknowledgement or link to this source.\\n--------------------------------------------\\n\\nThe following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time.\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                if len(cur) == 1:\\n                    res.append( cur[0] + \\' \\'*(maxWidth - num_of_letters) )\\n                else:\\n                    num_spaces = maxWidth - num_of_letters\\n                    space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1)\\n                    for i in range(num_extra_spaces):\\n                        cur[i] += \\' \\'\\n                    res.append( (\\' \\'*space_between_words).join(cur) )\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        res.append( \\' \\'.join(cur) + \\' \\'*(maxWidth - num_of_letters - len(cur) + 1) )\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "--------------------------------------------\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        return res + [\\' \\'.join(cur).ljust(maxWidth)]\\n\\nHow does it work? Well in the question statement, the sentence \"Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right\" was just a really long and awkward way to say *round robin*. The following line implements the round robin logic: \\n\\n    for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n\\nWhat does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The \"or 1\" part is for dealing with the edge case len(cur) == 1.\\n\\n###### Note: I found that this problem & solution is directly being used in the \"Elements of Programming Interviews in Python\" book. Cool I guess, but the book should include an acknowledgement or link to this source.\\n--------------------------------------------\\n\\nThe following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time.\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                if len(cur) == 1:\\n                    res.append( cur[0] + \\' \\'*(maxWidth - num_of_letters) )\\n                else:\\n                    num_spaces = maxWidth - num_of_letters\\n                    space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1)\\n                    for i in range(num_extra_spaces):\\n                        cur[i] += \\' \\'\\n                    res.append( (\\' \\'*space_between_words).join(cur) )\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        res.append( \\' \\'.join(cur) + \\' \\'*(maxWidth - num_of_letters - len(cur) + 1) )\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2992661,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        \\n        cur_wlist  = []\\n        cur_ch_cnt = 0   # for the space consideration\\n     \\n        for w in words: \\n            if cur_ch_cnt + len(cur_wlist) + len(w) > maxWidth:\\n                for i in range(maxWidth - cur_ch_cnt):  # insert space\\n                    cur_wlist[i%(len(cur_wlist) - 1 or 1)] += \\' \\'\\n               \\n                res.append(\\'\\'.join(cur_wlist)) # insert a this row \\n                cur_wlist, cur_ch_cnt = [], 0 # prepare a new row, resetting\\n                \\n            cur_wlist += [w]\\n            cur_ch_cnt += len(w)\\n            \\n        return res + [\\' \\'.join(cur_wlist).ljust(maxWidth)]\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n\\n        int word = 0;\\n\\n        while(word<words.length){\\n\\n            int j = word-1;\\n            int characters = 0;\\n\\n\\n            while(j+1<words.length && characters+words[j+1].length() + j+1-word<=maxWidth)\\n            {\\n                j++;\\n                characters+=words[j].length();\\n            }\\n            result.add(line(words , word , j, characters , maxWidth));\\n            word = j+1;\\n        }\\n        return result;\\n    }\\n      public String line(String words[],int start,int end, int Linelen,int max)\\n    {\\n        StringBuilder a = new StringBuilder();\\n        int p=1,q=0;\\n        if(end!=start)\\n        {\\n            p=(max-Linelen)/(end-start);\\n            q=(max-Linelen)%(end-start);\\n        }\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            a.append(words[i]);\\n            if(i!=end)\\n            {\\n                if(end==words.length-1) a.append(\" \");\\n                else {\\n                    for(int j=1;j<=p;j++) a.append(\" \");\\n                    if(q-->=1) a.append(\" \");\\n                }\\n            }\\n        }\\n        while(a.length()<max) a.append(\" \");\\n        return a.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        \\n        cur_wlist  = []\\n        cur_ch_cnt = 0   # for the space consideration\\n     \\n        for w in words: \\n            if cur_ch_cnt + len(cur_wlist) + len(w) > maxWidth:\\n                for i in range(maxWidth - cur_ch_cnt):  # insert space\\n                    cur_wlist[i%(len(cur_wlist) - 1 or 1)] += \\' \\'\\n               \\n                res.append(\\'\\'.join(cur_wlist)) # insert a this row \\n                cur_wlist, cur_ch_cnt = [], 0 # prepare a new row, resetting\\n                \\n            cur_wlist += [w]\\n            cur_ch_cnt += len(w)\\n            \\n        return res + [\\' \\'.join(cur_wlist).ljust(maxWidth)]\\n```\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n\\n        int word = 0;\\n\\n        while(word<words.length){\\n\\n            int j = word-1;\\n            int characters = 0;\\n\\n\\n            while(j+1<words.length && characters+words[j+1].length() + j+1-word<=maxWidth)\\n            {\\n                j++;\\n                characters+=words[j].length();\\n            }\\n            result.add(line(words , word , j, characters , maxWidth));\\n            word = j+1;\\n        }\\n        return result;\\n    }\\n      public String line(String words[],int start,int end, int Linelen,int max)\\n    {\\n        StringBuilder a = new StringBuilder();\\n        int p=1,q=0;\\n        if(end!=start)\\n        {\\n            p=(max-Linelen)/(end-start);\\n            q=(max-Linelen)%(end-start);\\n        }\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            a.append(words[i]);\\n            if(i!=end)\\n            {\\n                if(end==words.length-1) a.append(\" \");\\n                else {\\n                    for(int j=1;j<=p;j++) a.append(\" \");\\n                    if(q-->=1) a.append(\" \");\\n                }\\n            }\\n        }\\n        while(a.length()<max) a.append(\" \");\\n        return a.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24873,
                "title": "share-my-concise-c-solution-less-than-20-lines",
                "content": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> res;\\n        for(int i = 0, k, l; i < words.size(); i += k) {\\n            for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n                l += words[i+k].size();\\n            }\\n            string tmp = words[i];\\n            for(int j = 0; j < k - 1; j++) {\\n                if(i + k >= words.size()) tmp += \" \";\\n                else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), ' ');\\n                tmp += words[i+j+1];\\n            }\\n            tmp += string(L - tmp.size(), ' ');\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n\\nFor each line, I first figure out which words can fit in. According to the code, these words are words[i] through words[i+k-1]. Then spaces are added between the words. The trick here is to use mod operation to manage the spaces that can't be evenly distrubuted: the first (L-l) % (k-1) gaps acquire an additional space.",
                "solutionTags": [],
                "code": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> res;\\n        for(int i = 0, k, l; i < words.size(); i += k) {\\n            for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n                l += words[i+k].size();\\n            }\\n            string tmp = words[i];\\n            for(int j = 0; j < k - 1; j++) {\\n                if(i + k >= words.size()) tmp += \" \";\\n                else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), ' ');\\n                tmp += words[i+j+1];\\n            }\\n            tmp += string(L - tmp.size(), ' ');\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n\\nFor each line, I first figure out which words can fit in. According to the code, these words are words[i] through words[i+k-1]. Then spaces are added between the words. The trick here is to use mod operation to manage the spaces that can't be evenly distrubuted: the first (L-l) % (k-1) gaps acquire an additional space.",
                "codeTag": "Unknown"
            },
            {
                "id": 24876,
                "title": "simple-java-solution",
                "content": "    public class Solution {\\n        public List<String> fullJustify(String[] words, int L) {\\n            List<String> lines = new ArrayList<String>();\\n            \\n            int index = 0;\\n            while (index < words.length) {\\n                int count = words[index].length();\\n                int last = index + 1;\\n                while (last < words.length) {\\n                    if (words[last].length() + count + 1 > L) break;\\n                    count += words[last].length() + 1;\\n                    last++;\\n                }\\n                \\n                StringBuilder builder = new StringBuilder();\\n                int diff = last - index - 1;\\n                // if last line or number of words in the line is 1, left-justified\\n                if (last == words.length || diff == 0) {\\n                    for (int i = index; i < last; i++) {\\n                        builder.append(words[i] + \" \");\\n                    }\\n                    builder.deleteCharAt(builder.length() - 1);\\n                    for (int i = builder.length(); i < L; i++) {\\n                        builder.append(\" \");\\n                    }\\n                } else {\\n                    // middle justified\\n                    int spaces = (L - count) / diff;\\n                    int r = (L - count) % diff;\\n                    for (int i = index; i < last; i++) {\\n                        builder.append(words[i]);\\n                        if (i < last - 1) {\\n                            for (int j = 0; j <= (spaces + ((i - index) < r ? 1 : 0)); j++) {\\n                                builder.append(\" \");\\n                            }\\n                        }\\n                    }\\n                }\\n                lines.add(builder.toString());\\n                index = last;\\n            }\\n            \\n            \\n            return lines;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> fullJustify(String[] words, int L) {\\n            List<String> lines = new ArrayList<String>();\\n            \\n            int index = 0;\\n            while (index < words.length) {\\n                int count = words[index].length();\\n                int last = index + 1;\\n                while (last < words.length) {\\n                    if (words[last].length() + count + 1 > L) break;\\n                    count += words[last].length() + 1;\\n                    last++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 24965,
                "title": "easy-understanding-solution",
                "content": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> ans, vs;\\n        string str;\\n        \\n        int len = 0;\\n        for (int i = 0; i < words.size(); ++i) {\\n            if (len + vs.size() + words[i].size() <= L) {\\n                // vs not full, need to get more words in the line\\n                vs.push_back(words[i]);\\n                len += words[i].size();\\n            }\\n            else {\\n                // vs full, get the whole line\\n                if (vs.size() == 1) {\\n                    // just one word, the left justify\\n                    str = vs[0];\\n                    str.append(L - str.size(), ' ');\\n                    ans.push_back(str);\\n                }\\n                else if (vs.size() > 1) {\\n                    // the first \"mod\" words get \"div+1\" spaces\\n                    // the remaining words get \"div\" spaces\\n                    int div = (L - len) / (vs.size() - 1);\\n                    int mod = (L - len) % (vs.size() - 1);\\n                    str = vs[0];\\n                    for (int j = 1; j < vs.size(); ++j) {\\n                        if (j <= mod) str.append(div+1, ' '); // one more space\\n                        else str.append(div, ' ');\\n                        str += vs[j];\\n                    }\\n                    ans.push_back(str);\\n                }\\n                \\n                vs.clear();\\n                vs.push_back(words[i]);\\n                len = words[i].size();\\n            }\\n        }\\n        \\n        // the last line, left justified and no extra space is inserted between words\\n        str = vs[0];\\n        for (int j = 1; j < vs.size(); ++j) str += ' ' + vs[j];\\n        str.append(L-str.size(), ' ');\\n        ans.push_back(str);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> ans, vs;\\n        string str;\\n        \\n        int len = 0;\\n        for (int i = 0; i < words.size(); ++i) {\\n            if (len + vs.size() + words[i].size() <= L) {\\n                // vs not full, need to get more words in the line\\n                vs.push_back(words[i]);\\n                len += words[i].size();\\n            }\\n            else {\\n                // vs full, get the whole line\\n                if (vs.size() == 1) {\\n                    // just one word, the left justify\\n                    str = vs[0];\\n                    str.append(L - str.size(), ' ');\\n                    ans.push_back(str);\\n                }\\n                else if (vs.size() > 1) {\\n                    // the first \"mod\" words get \"div+1\" spaces\\n                    // the remaining words get \"div\" spaces\\n                    int div = (L - len) / (vs.size() - 1);\\n                    int mod = (L - len) % (vs.size() - 1);\\n                    str = vs[0];\\n                    for (int j = 1; j < vs.size(); ++j) {\\n                        if (j <= mod) str.append(div+1, ' '); // one more space\\n                        else str.append(div, ' ');\\n                        str += vs[j];\\n                    }\\n                    ans.push_back(str);\\n                }\\n                \\n                vs.clear();\\n                vs.push_back(words[i]);\\n                len = words[i].size();\\n            }\\n        }\\n        \\n        // the last line, left justified and no extra space is inserted between words\\n        str = vs[0];\\n        for (int j = 1; j < vs.size(); ++j) str += ' ' + vs[j];\\n        str.append(L-str.size(), ' ');\\n        ans.push_back(str);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1243483,
                "title": "intuitive-code-with-explanation",
                "content": "**This problem can be divided into main 2 parts :-**\\n*  First part is to find enough number of words in each line but length of each line should be less then maxWidth(which is pretty straight forward).\\n\\n*  Second part is to format each line.(which is difficult)\\n\\n**Code is written in C++ but after reading explanation you can translate it in your favourite language.**\\n\\n**1. first part:-**\\nThe below function is doing 1st part, it\\'s calling spaceJustifer function just before inserting output string into result vector(or else we can just insert strings without justification into result vector then we can justify each line at the end). just to make sure we are on same page spaceJustifier is getting a input like this `\"This is an\"`  i.e single space to seperate each word, and spaceJustifier is returning us string like this `\"This    is    an\"` i.e inserting 1 space between `this` and `is` . \\n```\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result; //result vector which will store each line\\n        string output = words[0]; //add first word to output string\\n        for (int i = 1; i<words.size(); i++){\\n            if(output.length() + words[i].length() + 1 <= maxWidth) //+1 for space \\n\\t\\t\\t\\n\\t\\t\\t\\t\\toutput += \" \"+words[i]; //add space before adding word\\n            \\n            else{ \\n\\t\\t\\t   //this else will be executed when current line can\\'t add current words \\n                output = spaceJustifier(output, maxWidth, 0); //formatting space before adding it to result \\n                result.push_back(output);\\n                //now we added output to result vector now we can start a new line \\n                output = words[i]; //add current word to output(start of new line)\\n            }\\n        }\\n        //the above loop will not add last line to result because last line to will always satify (output.length()+words[i].length()+1<=maxWidth) condition\\n        output = spaceJustifier(output, maxWidth, 1); //justifying spaces in last line\\n        result.push_back(output); //adding last line to result array\\n        return result;\\n    }\\n```\\n**2. The below function is doing main part of justification.**\\n   `spaceJustifier(string str, int maxWidth, int isLast)` function accepting 3 parameters :-\\n   1. first is str which will accept string/line ex - `\"This is an\"`\\n   2. Second is maxWidth.\\n   3. Third is a flag which will tell us, is the current string is last line or not.\\n    why we intereseted in last line? because last line must be left-justified instead of fully-justified.\\n\\t\\nbelow are the condition/operations we are checking.\\n\\n1. The first condition is **`str.length() == maxWidth`** for string whose length is already equal to max width so we **return line as it is.**\\n\\n2. Now if **`str.length() < maxWidth`** we will calculate spaces which are already in the string. Ex- `\"This is an\"` has 2 spaces.\\n\\n3. After finding number of spaces we will check if `spacesInString == 0 || isLast == 1 ` i.e if number of spaces is equal to 0 and if the current string is last line or not. if string has 0 spaces it means there is only one word inside string. for one word string has to be left-justified same as last line. that is why both conditions are put together\\n\\n4. Now if 1st and 3st condition are checked and we haven\\'t returned the string it means we have to fully justify the line. \\n\\tto do this we need to calculate number of spaces which need to be inserted to make string equal to `maxWidth` we can do this by ``spaceToBeInserted = maxWidth - str.length()``\\n\\tnow we need to find how much spaces we should insert at `each slot` (slot is index of space in the string) to make the given string equal to `maxWidth`. ex- `\"This is an\"` and `maxWidth` is 16. spaces we need to insert in the string to make it equal to maxWidth is 6 [16-10(length of string)]\\n\\tthe above ex has 2 slots or spaces already, so we need add 6 more spaces equally. we can find how much extra space `each slot` will get by dividing `spaceToBeInserted` by `spaces in strings` i.e `eachSlot = spacesToBeInserted / spacesInString`\\n\\t\\nThe above condition will work till `spacesToBeInserted` is fully divisible by `spacesInString`. \\n\\n5. Let us take another example where  `spacesToBeInserted` is not fully divisible by `spacesInString` :-\\nSuppose string is  `\"so fine That all the\"`(maxWidth is 25) here `spacesToBeInserted` is 5 and `spacesInString`is 4, now we can\\'t divide spaces     evenly. In this case according to question we should divide the string as evenly as possible. To divide it evenly we will find reminder when `spacesToBeInserted` is divided by `spacesInString` which will tells us `leftOverSpaces` which we need to insert from left to right. below\\nhere first will find `eachSlot` value which is 5/4 = 1 and `leftOverSpaces` will be 5%4 = 1. now we will fill spaces from left to right :-\\n`\"so_ _fine_ _That_ _all_ _the\"` (underscore represent spaces)1 space is added at each slot now all slot have 2 spaces. \\nnow from left to right we will be adding 1 space to each slot till `leftOverSpaces` become zero.\\n`\"so_ _ _fine_ _That_ _all_ _the\"` after inserting space at first slot `leftOverSpaces` become 0 so no more space is added after that.\\n\\nbelow code add both `eachSlot` space and `leftOverSpaces` at same time so it will directly add 3 spaces between `\"so_ _ _fine\"`  instead of 2 spaces.\\n\\n**if there is a mistake please comment.**\\n\\n\\t\\n    string spaceJustifier(string str, int maxWidth, int isLast){\\n        //condition if line length is equal to maxWidth so return line as it is.\\n        if(str.length() == maxWidth)\\n            return str;\\n        \\n        int spacesInString = 0; //count total spaces in the line \\n        for(int i = 0; i<str.length(); i++){\\n            if(str[i] == \\' \\')\\n                spacesInString++;\\n        }\\n        int spacesToBeInserted = maxWidth - str.length(); //spaces to be inserted will be maxWidth - line length\\n        //Left Justifier \\n        //if line has only 1 word(number of spaces in one word is 0 ex \"hi\") || it\\'s last line then left justify the line\\n        if(spacesInString == 0 || isLast == 1){ \\n            str.insert(str.length(), spacesToBeInserted,\\' \\'); //insert required spaces in right of line ex \"do                  \"\\n            return str;\\n        }\\n        int eachSlot = spacesToBeInserted / spacesInString; \\n        int leftOverSpace = spacesToBeInserted % spacesInString; \\n        //EXPLANATION FOR EACH SLOT\\n        //(spacesToBeInserted / spacesInString) will tell us how much space should we insert at eachSlot\\n        //ex - (spacesToBeInserted = 6)/(spaces in string = 2) then each slot will get 3 extra spaces ex - \"hi_hi\" => \"hi_ _ _ _hi_ _ _ _\" will be output\\n        \\n        //EXPLANATION FOR LEFT OVER SPACE\\n        //when the spacesToBeInserted is not divisibe by spacesInString \\n        //EX if we spacesToBeInserted = 5 and spaces in string = 2.\\n        //since 5/2 is not fully Divisble we will find remainder 5%2 to get left overspace.\\n        \\n        \\n        //EX - so_fine_That_all_the. and maxWidth is 25\\n        //      in above case spacesToBeInserted = 5 and spaces in stirng = 4.\\n        //      eachSlot will be 5/4 is 1. ie increase spaces by 1 \\n        \\n        //output will be -> so_ _fine_ _That_ _all_ _the\\n        \\n        //      since 5/4 is not fully divisible. we will find leftOverSpaces = 5%4 = 1;\\n        //      this leftOverSpace will be distributed from left to right ie each slot will get 1,1,1 from left to right\\n        \\n        //output will be -> so_ _ _fine_ _That_ _all_ _the\\n        //                        \\u2191\\n        //                    leftOverSpace added \\n        \\n        //if we had more leftoverspaces then it will be added to next slot.\\n        \\n        for(int i = 0; i<str.length(); i++){\\n            if(str[i] == \\' \\' && (eachSlot > 0 || leftOverSpace >0 )){ //we add spaces till (eachSlot > 0 || leftOverSpace >0)\\n                //required noOfSpaces = eachSlot + (leftOverSpace-- > 0 ? 1:0)\\n                //((leftOverSpace--) > 0 ? 1:0) will return 1 if leftoverspace>0.\\n                //(leftOverSpace--) post decrement\\n                int noOfSpaces = eachSlot + ((leftOverSpace--) > 0 ? 1:0);\\n                str.insert(i, noOfSpaces , \\' \\'); //inserting spaces\\n                i+=noOfSpaces;   //increament count with no of spaces inserted each time \\n            }\\n            \\n        }\\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result; //result vector which will store each line\\n        string output = words[0]; //add first word to output string\\n        for (int i = 1; i<words.size(); i++){\\n            if(output.length() + words[i].length() + 1 <= maxWidth) //+1 for space \\n\\t\\t\\t\\n\\t\\t\\t\\t\\toutput += \" \"+words[i]; //add space before adding word\\n            \\n            else{ \\n\\t\\t\\t   //this else will be executed when current line can\\'t add current words \\n                output = spaceJustifier(output, maxWidth, 0); //formatting space before adding it to result \\n                result.push_back(output);\\n                //now we added output to result vector now we can start a new line \\n                output = words[i]; //add current word to output(start of new line)\\n            }\\n        }\\n        //the above loop will not add last line to result because last line to will always satify (output.length()+words[i].length()+1<=maxWidth) condition\\n        output = spaceJustifier(output, maxWidth, 1); //justifying spaces in last line\\n        result.push_back(output); //adding last line to result array\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952119,
                "title": "94-14-2-approaches-greedy",
                "content": "# Interview Problem Understanding\\n\\nIn interviews, understanding the problem at hand is half the battle. Let\\'s break down the \"Text Justification\" challenge:\\n\\n**The Scenario**: Imagine you\\'re building a word processor, and you need to implement the \"Justify\" alignment feature. This means that when a user selects a group of words and chooses the \"Justify\" option, the text is adjusted so that each line spans the entire width of the available space. Words are spaced out, and additional spaces are added between them to achieve this uniform width.\\n\\n**The Challenge**: Given an array of strings (or words) and a defined maximum width for each line:\\n- Your task is to format the text such that each line is exactly the specified maximum width.\\n- Each line should be both left and right justified. This means the words on each line are separated by one or more spaces to ensure the line extends from the very left to the very right.\\n- There\\'s a catch, though. For lines that aren\\'t the last, if the spaces don\\'t divide evenly, the leftmost gaps get more spaces. For the very last line or a line with a single word, it should be left-justified, and the extra spaces are added to the end.\\n\\n**Example**:\\nSuppose you\\'re given the words `[\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]` and a `maxWidth` of 16. This means each line of the output can only be 16 characters wide. Your output should resemble:\\n\\n```\\n[\\n  \"This    is    an\",\\n  \"example  of text\",\\n  \"justification.  \"\\n]\\n```\\n\\n**Input/Output**:\\n- **Input**: You\\'re provided with an array of words and a maximum width for each line.\\n- **Output**: Your goal is to return a list of strings, where each string is a line of text that adheres to the justification rules.\\n\\n---\\n\\n# Live Coding + Explenation Modulo-based\\nhttps://youtu.be/KGfXrj7G0W0?si=VmyOm2RqX6yfMm9w\\n\\n---\\n\\n## Approach 1: Modulo-based Space Distribution\\n\\nTo solve the \"Text Justification\" problem using this approach, we pack words into each line using a greedy strategy. We then distribute spaces among the words on each line, using modulo arithmetic to decide where to place the extra spaces.\\n\\n### Key Data Structures:\\n- **List**: To store the current words for a line and the result.\\n\\n### Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - We start by initializing empty lists for the result and the current line words.\\n   - A counter is also initialized to keep track of the total length of words in the current line.\\n   \\n2. **Processing Each Word**:\\n   - For each word, we check if adding the next word to the current line would make it exceed the maximum width.\\n   - If it does, we proceed to justify the current line. This involves distributing spaces among the words. The modulo arithmetic is handy here, ensuring that extra spaces are evenly spread among the words.\\n   - Once the line is justified, we reset the lists and counter for the next line.\\n   - A special case is the last line, where we simply left-justify the words.\\n\\n3. **Wrap-up**:\\n   - Once all the words are processed and lines are justified, we return the result list.\\n\\n## Example:\\n\\nGiven the `words = [\"This\", \"is\", \"an\", \"example\"]` and `maxWidth = 16`:\\n\\n- The word \"This\" is added to the current line.\\n- The word \"is\" is added to the current line.\\n- The word \"an\" is added to the current line, completing it with the string \"This    is    an\".\\n- The word \"example\" starts a new line.\\n\\n---\\n\\n## Approach 2: Gap-based Space Distribution\\n\\nIn this method, the way we pack words into each line remains similar to the first approach. However, when it comes to distributing spaces, the logic is a tad different. Instead of using modulo arithmetic directly, we compute the number of gaps between words and then decide how many spaces to put in each gap. This makes the logic more intuitive.\\n\\n### Key Data Structures:\\n- **List**: To store the current words for a line and the result.\\n\\n### Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - As before, we initialize empty lists for the result and the current line words.\\n   - A counter keeps track of the total length of words in the current line.\\n   \\n2. **Processing Each Word**:\\n   - For every word, we check if adding it to the current line would cross the maximum width.\\n   - If yes, we justify the current line. This time, we compute the total number of spaces required for the current line. This is based on the maximum width and the length of words on the line.\\n   - We then determine how many gaps exist between the words and compute the number of spaces that can be evenly distributed across these gaps.\\n   - Any extra spaces that can\\'t be evenly distributed are then added to the gaps from left to right.\\n   - The last line is handled specially, where we left-justify the words.\\n\\n3. **Wrap-up**:\\n   - After processing all the words and justifying the lines, we return the result list.\\n\\n---\\n\\n# Complexity:\\n\\n**Time Complexity:** Both approaches process each word once and have a time complexity of $$O(n)$$, where $$n$$ is the number of words.\\n\\n**Space Complexity:** The space complexity for both methods is $$O(n \\\\times m)$$, where $$n$$ is the number of words and $$m$$ is the average length of the words.\\n\\n---\\n\\n# Performance:\\n\\n| Language    | Runtime (ms) | Memory (MB) |\\n|-------------|--------------|-------------|\\n| Rust        | 1 ms         | 2.1 MB      |\\n| Go          | 1 ms         | 2.1 MB      |\\n| Java        | 1 ms         | 40.7 MB     |\\n| C++         | 4 ms         | 7.6 MB      |\\n| Python3 (v2)| 34 ms        | 16.3 MB     |\\n| Python3 (v1)| 34 ms        | 16.1 MB     |\\n| JavaScript  | 55 ms        | 42.2 MB     |\\n| C#          | 139 ms       | 43.7 MB     |\\n\\n![p2a.png](https://assets.leetcode.com/users/images/4e42f0d5-2bfd-476c-b39e-40984d1d300a_1692839284.047317.png)\\n\\n# Code Modulo-based\\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, line, width = [], [], 0\\n\\n        for w in words:\\n            if width + len(w) + len(line) > maxWidth:\\n                for i in range(maxWidth - width): line[i % (len(line) - 1 or 1)] += \\' \\'\\n                res, line, width = res + [\\'\\'.join(line)], [], 0\\n            line += [w]\\n            width += len(w)\\n\\n        return res + [\\' \\'.join(line).ljust(maxWidth)]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res;\\n        std::vector<std::string> cur;\\n        int num_of_letters = 0;\\n\\n        for (std::string word : words) {\\n            if (word.size() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.size() - 1 ? cur.size() - 1 : 1)] += \\' \\';\\n                }\\n                res.push_back(\"\");\\n                for (std::string s : cur) res.back() += s;\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push_back(word);\\n            num_of_letters += word.size();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (std::string s : cur) last_line += s + \\' \\';\\n        last_line = last_line.substr(0, last_line.size()-1);  // remove trailing space\\n        while (last_line.size() < maxWidth) last_line += \\' \\';\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int num_of_letters = 0;\\n\\n        for (String word : words) {\\n            if (word.length() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur.set(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1), cur.get(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1)) + \" \");\\n                }\\n                StringBuilder sb = new StringBuilder();\\n                for (String s : cur) sb.append(s);\\n                res.add(sb.toString());\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.add(word);\\n            num_of_letters += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder();\\n        for (int i = 0; i < cur.size(); i++) {\\n            lastLine.append(cur.get(i));\\n            if (i != cur.size() - 1) lastLine.append(\" \");\\n        }\\n        while (lastLine.length() < maxWidth) lastLine.append(\" \");\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let cur = [];\\n        let num_of_letters = 0;\\n\\n        for (let word of words) {\\n            if (word.length + cur.length + num_of_letters > maxWidth) {\\n                for (let i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.length - 1 || 1)] += \\' \\';\\n                }\\n                res.push(cur.join(\\'\\'));\\n                cur = [];\\n                num_of_letters = 0;\\n            }\\n            cur.push(word);\\n            num_of_letters += word.length;\\n        }\\n\\n        let lastLine = cur.join(\\' \\');\\n        while (lastLine.length < maxWidth) lastLine += \\' \\';\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        var res = new List<string>();\\n        var cur = new List<string>();\\n        int num_of_letters = 0;\\n\\n        foreach (var word in words) {\\n            if (word.Length + cur.Count + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.Count - 1 > 0 ? cur.Count - 1 : 1)] += \" \";\\n                }\\n                res.Add(string.Join(\"\", cur));\\n                cur.Clear();\\n                num_of_letters = 0;\\n            }\\n            cur.Add(word);\\n            num_of_letters += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", cur);\\n        while (lastLine.Length < maxWidth) lastLine += \" \";\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\\n``` Go []\\nfunc fullJustify(words []string, maxWidth int) []string {\\n    var res []string\\n    var cur []string\\n    num_of_letters := 0\\n\\n    for _, word := range words {\\n        if len(word) + len(cur) + num_of_letters > maxWidth {\\n            for i := 0; i < maxWidth - num_of_letters; i++ {\\n                cur[i % max(1, len(cur) - 1)] += \" \"\\n            }\\n            res = append(res, strings.Join(cur, \"\"))\\n            cur = cur[:0]\\n            num_of_letters = 0\\n        }\\n        cur = append(cur, word)\\n        num_of_letters += len(word)\\n    }\\n\\n    lastLine := strings.Join(cur, \" \")\\n    for len(lastLine) < maxWidth {\\n        lastLine += \" \"\\n    }\\n    res = append(res, lastLine)\\n\\n    return res\\n}\\n\\n// Helper function to get the maximum of two integers\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\\n        let mut res = Vec::new();\\n        let mut cur = Vec::new();\\n        let mut num_of_letters: i32 = 0;\\n\\n        for word in &words {\\n            if word.len() as i32 + cur.len() as i32 + num_of_letters > max_width {\\n                for i in 0..(max_width - num_of_letters) {\\n                    let idx = i as usize % (if cur.len() > 1 { cur.len() - 1 } else { cur.len() });\\n                    cur[idx] = format!(\"{} \", cur[idx]);\\n                }\\n                res.push(cur.join(\"\"));\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push(word.clone());\\n            num_of_letters += word.len() as i32;\\n        }\\n\\n        let last_line = cur.join(\" \");\\n        res.push(format!(\"{:<width$}\", last_line, width=max_width as usize));\\n\\n        res\\n    }\\n}\\n```\\n\\n# Code Gap-based\\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, cur_words, cur_len = [], [], 0\\n\\n        for word in words:\\n            if cur_len + len(word) + len(cur_words) > maxWidth:\\n                total_spaces = maxWidth - cur_len\\n                gaps = len(cur_words) - 1\\n                if gaps == 0:\\n                    res.append(cur_words[0] + \\' \\' * total_spaces)\\n                else:\\n                    space_per_gap = total_spaces // gaps\\n                    extra_spaces = total_spaces % gaps\\n                    line = \\'\\'\\n                    for i, w in enumerate(cur_words):\\n                        line += w\\n                        if i < gaps:\\n                            line += \\' \\' * space_per_gap\\n                            if i < extra_spaces:\\n                                line += \\' \\'\\n                    res.append(line)\\n                cur_words, cur_len = [], 0\\n            cur_words.append(word)\\n            cur_len += len(word)\\n\\n        last_line = \\' \\'.join(cur_words)\\n        remaining_spaces = maxWidth - len(last_line)\\n        res.append(last_line + \\' \\' * remaining_spaces)\\n\\n        return res\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res, cur_words;\\n        int cur_len = 0;\\n\\n        for (const std::string& word : words) {\\n            if (cur_len + word.length() + cur_words.size() > maxWidth) {\\n                int total_spaces = maxWidth - cur_len;\\n                int gaps = cur_words.size() - 1;\\n                if (gaps == 0) {\\n                    res.push_back(cur_words[0] + std::string(total_spaces, \\' \\'));\\n                } else {\\n                    int space_per_gap = total_spaces / gaps;\\n                    int extra_spaces = total_spaces % gaps;\\n                    std::string line = \"\";\\n                    for (int i = 0; i < cur_words.size(); ++i) {\\n                        line += cur_words[i];\\n                        if (i < gaps) {\\n                            line += std::string(space_per_gap, \\' \\');\\n                            if (i < extra_spaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push_back(line);\\n                }\\n                cur_words.clear();\\n                cur_len = 0;\\n            }\\n            cur_words.push_back(word);\\n            cur_len += word.length();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (const std::string& word : cur_words) {\\n            if (!last_line.empty()) {\\n                last_line += \\' \\';\\n            }\\n            last_line += word;\\n        }\\n        last_line += std::string(maxWidth - last_line.length(), \\' \\');\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> curWords = new ArrayList<>();\\n        int curLen = 0;\\n\\n        for (String word : words) {\\n            if (curLen + word.length() + curWords.size() > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.size() - 1;\\n                if (gaps == 0) {\\n                    res.add(curWords.get(0) + \" \".repeat(totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.size(); i++) {\\n                        line.append(curWords.get(i));\\n                        if (i < gaps) {\\n                            line.append(\" \".repeat(spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.add(line.toString());\\n                }\\n                curWords.clear();\\n                curLen = 0;\\n            }\\n            curWords.add(word);\\n            curLen += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", curWords));\\n        while (lastLine.length() < maxWidth) {\\n            lastLine.append(\\' \\');\\n        }\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        List<string> curWords = new List<string>();\\n        int curLen = 0;\\n\\n        foreach (string word in words) {\\n            if (curLen + word.Length + curWords.Count > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.Count - 1;\\n                if (gaps == 0) {\\n                    res.Add(curWords[0] + new string(\\' \\', totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.Count; i++) {\\n                        line.Append(curWords[i]);\\n                        if (i < gaps) {\\n                            line.Append(new string(\\' \\', spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.Append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.Add(line.ToString());\\n                }\\n                curWords.Clear();\\n                curLen = 0;\\n            }\\n            curWords.Add(word);\\n            curLen += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", curWords);\\n        while (lastLine.Length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let curWords = [];\\n        let curLen = 0;\\n\\n        for (let word of words) {\\n            if (curLen + word.length + curWords.length > maxWidth) {\\n                let totalSpaces = maxWidth - curLen;\\n                let gaps = curWords.length - 1;\\n                if (gaps === 0) {\\n                    res.push(curWords[0] + \\' \\'.repeat(totalSpaces));\\n                } else {\\n                    let spacePerGap = Math.floor(totalSpaces / gaps);\\n                    let extraSpaces = totalSpaces % gaps;\\n                    let line = \\'\\';\\n                    for (let i = 0; i < curWords.length; i++) {\\n                        line += curWords[i];\\n                        if (i < gaps) {\\n                            line += \\' \\'.repeat(spacePerGap);\\n                            if (i < extraSpaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push(line);\\n                }\\n                curWords = [];\\n                curLen = 0;\\n            }\\n            curWords.push(word);\\n            curLen += word.length;\\n        }\\n\\n        let lastLine = curWords.join(\\' \\');\\n        while (lastLine.length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```\\n\\nThe choice between the two methods will depend on the specific use-case and the preference for clarity vs. conciseness. Both approaches offer an efficient way to tackle the problem of text justification. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "String"
                ],
                "code": "```\\n[\\n  \"This    is    an\",\\n  \"example  of text\",\\n  \"justification.  \"\\n]\\n```\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, line, width = [], [], 0\\n\\n        for w in words:\\n            if width + len(w) + len(line) > maxWidth:\\n                for i in range(maxWidth - width): line[i % (len(line) - 1 or 1)] += \\' \\'\\n                res, line, width = res + [\\'\\'.join(line)], [], 0\\n            line += [w]\\n            width += len(w)\\n\\n        return res + [\\' \\'.join(line).ljust(maxWidth)]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res;\\n        std::vector<std::string> cur;\\n        int num_of_letters = 0;\\n\\n        for (std::string word : words) {\\n            if (word.size() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.size() - 1 ? cur.size() - 1 : 1)] += \\' \\';\\n                }\\n                res.push_back(\"\");\\n                for (std::string s : cur) res.back() += s;\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push_back(word);\\n            num_of_letters += word.size();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (std::string s : cur) last_line += s + \\' \\';\\n        last_line = last_line.substr(0, last_line.size()-1);  // remove trailing space\\n        while (last_line.size() < maxWidth) last_line += \\' \\';\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int num_of_letters = 0;\\n\\n        for (String word : words) {\\n            if (word.length() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur.set(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1), cur.get(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1)) + \" \");\\n                }\\n                StringBuilder sb = new StringBuilder();\\n                for (String s : cur) sb.append(s);\\n                res.add(sb.toString());\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.add(word);\\n            num_of_letters += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder();\\n        for (int i = 0; i < cur.size(); i++) {\\n            lastLine.append(cur.get(i));\\n            if (i != cur.size() - 1) lastLine.append(\" \");\\n        }\\n        while (lastLine.length() < maxWidth) lastLine.append(\" \");\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let cur = [];\\n        let num_of_letters = 0;\\n\\n        for (let word of words) {\\n            if (word.length + cur.length + num_of_letters > maxWidth) {\\n                for (let i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.length - 1 || 1)] += \\' \\';\\n                }\\n                res.push(cur.join(\\'\\'));\\n                cur = [];\\n                num_of_letters = 0;\\n            }\\n            cur.push(word);\\n            num_of_letters += word.length;\\n        }\\n\\n        let lastLine = cur.join(\\' \\');\\n        while (lastLine.length < maxWidth) lastLine += \\' \\';\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        var res = new List<string>();\\n        var cur = new List<string>();\\n        int num_of_letters = 0;\\n\\n        foreach (var word in words) {\\n            if (word.Length + cur.Count + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.Count - 1 > 0 ? cur.Count - 1 : 1)] += \" \";\\n                }\\n                res.Add(string.Join(\"\", cur));\\n                cur.Clear();\\n                num_of_letters = 0;\\n            }\\n            cur.Add(word);\\n            num_of_letters += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", cur);\\n        while (lastLine.Length < maxWidth) lastLine += \" \";\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\n``` Go []\\nfunc fullJustify(words []string, maxWidth int) []string {\\n    var res []string\\n    var cur []string\\n    num_of_letters := 0\\n\\n    for _, word := range words {\\n        if len(word) + len(cur) + num_of_letters > maxWidth {\\n            for i := 0; i < maxWidth - num_of_letters; i++ {\\n                cur[i % max(1, len(cur) - 1)] += \" \"\\n            }\\n            res = append(res, strings.Join(cur, \"\"))\\n            cur = cur[:0]\\n            num_of_letters = 0\\n        }\\n        cur = append(cur, word)\\n        num_of_letters += len(word)\\n    }\\n\\n    lastLine := strings.Join(cur, \" \")\\n    for len(lastLine) < maxWidth {\\n        lastLine += \" \"\\n    }\\n    res = append(res, lastLine)\\n\\n    return res\\n}\\n\\n// Helper function to get the maximum of two integers\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\\n        let mut res = Vec::new();\\n        let mut cur = Vec::new();\\n        let mut num_of_letters: i32 = 0;\\n\\n        for word in &words {\\n            if word.len() as i32 + cur.len() as i32 + num_of_letters > max_width {\\n                for i in 0..(max_width - num_of_letters) {\\n                    let idx = i as usize % (if cur.len() > 1 { cur.len() - 1 } else { cur.len() });\\n                    cur[idx] = format!(\"{} \", cur[idx]);\\n                }\\n                res.push(cur.join(\"\"));\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push(word.clone());\\n            num_of_letters += word.len() as i32;\\n        }\\n\\n        let last_line = cur.join(\" \");\\n        res.push(format!(\"{:<width$}\", last_line, width=max_width as usize));\\n\\n        res\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, cur_words, cur_len = [], [], 0\\n\\n        for word in words:\\n            if cur_len + len(word) + len(cur_words) > maxWidth:\\n                total_spaces = maxWidth - cur_len\\n                gaps = len(cur_words) - 1\\n                if gaps == 0:\\n                    res.append(cur_words[0] + \\' \\' * total_spaces)\\n                else:\\n                    space_per_gap = total_spaces // gaps\\n                    extra_spaces = total_spaces % gaps\\n                    line = \\'\\'\\n                    for i, w in enumerate(cur_words):\\n                        line += w\\n                        if i < gaps:\\n                            line += \\' \\' * space_per_gap\\n                            if i < extra_spaces:\\n                                line += \\' \\'\\n                    res.append(line)\\n                cur_words, cur_len = [], 0\\n            cur_words.append(word)\\n            cur_len += len(word)\\n\\n        last_line = \\' \\'.join(cur_words)\\n        remaining_spaces = maxWidth - len(last_line)\\n        res.append(last_line + \\' \\' * remaining_spaces)\\n\\n        return res\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res, cur_words;\\n        int cur_len = 0;\\n\\n        for (const std::string& word : words) {\\n            if (cur_len + word.length() + cur_words.size() > maxWidth) {\\n                int total_spaces = maxWidth - cur_len;\\n                int gaps = cur_words.size() - 1;\\n                if (gaps == 0) {\\n                    res.push_back(cur_words[0] + std::string(total_spaces, \\' \\'));\\n                } else {\\n                    int space_per_gap = total_spaces / gaps;\\n                    int extra_spaces = total_spaces % gaps;\\n                    std::string line = \"\";\\n                    for (int i = 0; i < cur_words.size(); ++i) {\\n                        line += cur_words[i];\\n                        if (i < gaps) {\\n                            line += std::string(space_per_gap, \\' \\');\\n                            if (i < extra_spaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push_back(line);\\n                }\\n                cur_words.clear();\\n                cur_len = 0;\\n            }\\n            cur_words.push_back(word);\\n            cur_len += word.length();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (const std::string& word : cur_words) {\\n            if (!last_line.empty()) {\\n                last_line += \\' \\';\\n            }\\n            last_line += word;\\n        }\\n        last_line += std::string(maxWidth - last_line.length(), \\' \\');\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> curWords = new ArrayList<>();\\n        int curLen = 0;\\n\\n        for (String word : words) {\\n            if (curLen + word.length() + curWords.size() > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.size() - 1;\\n                if (gaps == 0) {\\n                    res.add(curWords.get(0) + \" \".repeat(totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.size(); i++) {\\n                        line.append(curWords.get(i));\\n                        if (i < gaps) {\\n                            line.append(\" \".repeat(spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.add(line.toString());\\n                }\\n                curWords.clear();\\n                curLen = 0;\\n            }\\n            curWords.add(word);\\n            curLen += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", curWords));\\n        while (lastLine.length() < maxWidth) {\\n            lastLine.append(\\' \\');\\n        }\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        List<string> curWords = new List<string>();\\n        int curLen = 0;\\n\\n        foreach (string word in words) {\\n            if (curLen + word.Length + curWords.Count > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.Count - 1;\\n                if (gaps == 0) {\\n                    res.Add(curWords[0] + new string(\\' \\', totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.Count; i++) {\\n                        line.Append(curWords[i]);\\n                        if (i < gaps) {\\n                            line.Append(new string(\\' \\', spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.Append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.Add(line.ToString());\\n                }\\n                curWords.Clear();\\n                curLen = 0;\\n            }\\n            curWords.Add(word);\\n            curLen += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", curWords);\\n        while (lastLine.Length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let curWords = [];\\n        let curLen = 0;\\n\\n        for (let word of words) {\\n            if (curLen + word.length + curWords.length > maxWidth) {\\n                let totalSpaces = maxWidth - curLen;\\n                let gaps = curWords.length - 1;\\n                if (gaps === 0) {\\n                    res.push(curWords[0] + \\' \\'.repeat(totalSpaces));\\n                } else {\\n                    let spacePerGap = Math.floor(totalSpaces / gaps);\\n                    let extraSpaces = totalSpaces % gaps;\\n                    let line = \\'\\';\\n                    for (let i = 0; i < curWords.length; i++) {\\n                        line += curWords[i];\\n                        if (i < gaps) {\\n                            line += \\' \\'.repeat(spacePerGap);\\n                            if (i < extraSpaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push(line);\\n                }\\n                curWords = [];\\n                curLen = 0;\\n            }\\n            curWords.push(word);\\n            curLen += word.length;\\n        }\\n\\n        let lastLine = curWords.join(\\' \\');\\n        while (lastLine.length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191149,
                "title": "readable-python-solution-which-beats-99-65",
                "content": "The challenge  is to answer  two questions:\\n1.  How many words we need to form each line;  \\n2.  How many spaces we should insert between two words.\\n\\nThe first question is solved by the helper function: getKwords(), and the second question is solved by the helper function: insertSpace().\\n``` \\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \\'\\'\\'\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \\'\\'\\'\\n        n = len(words)\\n        L = maxWidth\\n        i = 0     # the index of the current word   \\n        ans = [] \\n        \\n        def getKwords(i):\\n            k = 0 # figure out how many words can fit into a line\\n            l = \\' \\'.join(words[i:i+k]) \\n            while len(l) <= L and i+k <= n:\\n                k += 1\\n                l = \\' \\'.join(words[i:i+k])\\n            k -= 1 \\n            return k\\n        \\n        \\n        def insertSpace(i, k):\\n            \\'\\'\\' concatenate words[i:i+k] into one line\\'\\'\\'\\n            l = \\' \\'.join(words[i:i+k])       \\n            if k == 1 or i + k == n:        # if the line contains only one word or it is the last line  \\n                spaces = L - len(l)         # we just need to left assigned it\\n                line = l + \\' \\' * spaces \\n            else:                           \\n                spaces = L - len(l) + (k-1) # total number of spaces we need insert  \\n                space = spaces // (k-1)     # average number of spaces we should insert between two words\\n                left = spaces % (k-1)       # number of \\'left\\' words, i.e. words that have 1 more space than the other words on the right side\\n                if left > 0:\\n                    line = ( \" \" * (space + 1) ).join(words[i:i+left])  # left words\\n                    line += \" \" * (space + 1)                           # spaces between left words & right words\\n                    line += (\" \" * space).join(words[i+left:i+k])       # right woreds\\n                else: \\n                    line = (\" \" * space).join(words[i:i+k])\\n            return line\\n        \\n\\n        while i < n: \\n            k = getKwords(i)  \\n            line = insertSpace(i, k) # create a line which contains words from words[i] to words[i+k-1]\\n            ans.append(line) \\n            i += k \\n        return ans\\t\\t\\n``` ",
                "solutionTags": [],
                "code": "``` \\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \\'\\'\\'\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \\'\\'\\'\\n        n = len(words)\\n        L = maxWidth\\n        i = 0     # the index of the current word   \\n        ans = [] \\n        \\n        def getKwords(i):\\n            k = 0 # figure out how many words can fit into a line\\n            l = \\' \\'.join(words[i:i+k]) \\n            while len(l) <= L and i+k <= n:\\n                k += 1\\n                l = \\' \\'.join(words[i:i+k])\\n            k -= 1 \\n            return k\\n        \\n        \\n        def insertSpace(i, k):\\n            \\'\\'\\' concatenate words[i:i+k] into one line\\'\\'\\'\\n            l = \\' \\'.join(words[i:i+k])       \\n            if k == 1 or i + k == n:        # if the line contains only one word or it is the last line  \\n                spaces = L - len(l)         # we just need to left assigned it\\n                line = l + \\' \\' * spaces \\n            else:                           \\n                spaces = L - len(l) + (k-1) # total number of spaces we need insert  \\n                space = spaces // (k-1)     # average number of spaces we should insert between two words\\n                left = spaces % (k-1)       # number of \\'left\\' words, i.e. words that have 1 more space than the other words on the right side\\n                if left > 0:\\n                    line = ( \" \" * (space + 1) ).join(words[i:i+left])  # left words\\n                    line += \" \" * (space + 1)                           # spaces between left words & right words\\n                    line += (\" \" * space).join(words[i+left:i+k])       # right woreds\\n                else: \\n                    line = (\" \" * space).join(words[i:i+k])\\n            return line\\n        \\n\\n        while i < n: \\n            k = getKwords(i)  \\n            line = insertSpace(i, k) # create a line which contains words from words[i] to words[i+k-1]\\n            ans.append(line) \\n            i += k \\n        return ans\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572814,
                "title": "one-pass-easy-to-understand-with-comments-o-n",
                "content": "We\\'ll build the result array line by line while iterating over words in the input. Whenever the current line gets too big, we\\'ll appropriately format it and proceed with the next line until for loop is over. Last but not least, we\\'ll need to left-justify the last line.\\n\\nTime complexity is **O(n)**:\\nThere is just one for loop, which iterates over words provided as input.\\nSpace complexity: **O(n + l)**\\nWhere **n** is lenght of words, and **l** max length of words in one line. Worst case scenario **l = n**, which will add up to **O(2n)** but in asymptotic analysis we don\\'t care about constants so final complexity is linear: **O(n)**\\n\\n```\\nclass Solution:\\n\\t# Why slots: https://docs.python.org/3/reference/datamodel.html#slots\\n    # TLDR: 1. faster attribute access. 2. space savings in memory.\\n    # For letcode problems this can save ~ 0.1MB of memory <insert is something meme>\\n    __slots__ = ()\\n\\t\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n\\t    # Init return array in which, we\\'ll store justified lines\\n        lines = []\\n\\t\\t# current line width\\n        width = 0\\n\\t\\t# current line words\\n        line = []\\n        \\n        for word in words:\\n\\t\\t\\t# Gather as many words that will fit under maxWidth restrictions.\\n\\t\\t\\t# Line length is a sum of:\\n\\t\\t\\t# 1) Current word length\\n\\t\\t\\t# 2) Sum of words already in the current line\\n\\t\\t\\t# 3) Number of spaces (each word needs to be separated by at least one space)\\n            if (len(word) + width + len(line)) <= maxWidth:\\n                width += len(word)\\n                line.append(word)\\n                continue\\n            \\n\\t\\t\\t# If the current line only contains one word, fill the remaining string with spaces.\\n            if len(line) == 1:\\n\\t\\t\\t\\t# Use the format function to fill the remaining string with spaces easily and readable.\\n\\t\\t\\t\\t# For letcode police, yes you could do something like:\\n\\t\\t\\t\\t#     line = \" \".join(line)\\n\\t\\t\\t\\t#     line += \" \" * (maxWidth - len(line))\\n\\t\\t\\t\\t#     lines.append(line)\\n\\t\\t\\t\\t# to be more \"raw\", but I see no point in that.\\n                lines.append(\\n                    \"{0: <{width}}\".format( \" \".join(line), width=maxWidth)\\n                )\\n            else:\\n\\t\\t\\t    # Else calculate how many common spaces and extra spaces are there for the current line.\\n\\t\\t\\t\\t# Example:\\n                #  line = [\\'a\\', \\'computer.\\', \\'Art\\', \\'is\\']\\n\\t\\t\\t\\t# width left in line equals to: maxWidth - width: 20 - 15 = 5\\n\\t\\t\\t\\t# len(line) - 1 because to the last word, we aren\\'t adding any spaces\\n\\t\\t\\t\\t# Now divmod will give us how many spaces are for all words and how many extra to distribute.\\n\\t\\t\\t\\t# divmod(5, 3) = 1, 2\\n\\t\\t\\t\\t# This means there should be one common space for each word, and for the first two, add one extra space.\\n                space, extra = divmod(\\n                    maxWidth - width,\\n                    len(line) - 1\\n                )\\n                \\n                i = 0\\n\\t\\t\\t\\t# Distribute extra spaces first\\n\\t\\t\\t\\t# There cannot be a case where extra spaces count is greater or equal to number words in the current line.\\n                while extra > 0:\\n                    line[i] += \" \"\\n                    extra -= 1\\n                    i += 1\\n                \\n\\t\\t\\t\\t# Join line array into a string by common spaces, and append to justified lines.\\n                lines.append(\\n                    (\" \" * space).join(line)\\n                )\\n            \\n\\t\\t\\t# Create new line array with the current word in iteration, and reset current line width as well.\\n            line = [word]\\n            width = len(word)\\n        \\n\\t\\t# Last but not least format last line to be left-justified with no extra space inserted between words.\\n\\t\\t# No matter the input, there always be the last line at the end of for loop, which makes things even easier considering the requirement.\\n        lines.append(\\n            \"{0: <{width}}\".format(\" \".join(line), width=maxWidth)\\n        )\\n        \\n        return lines\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\t# Why slots: https://docs.python.org/3/reference/datamodel.html#slots\\n    # TLDR: 1. faster attribute access. 2. space savings in memory.\\n    # For letcode problems this can save ~ 0.1MB of memory <insert is something meme>\\n    __slots__ = ()\\n\\t\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n\\t    # Init return array in which, we\\'ll store justified lines\\n        lines = []\\n\\t\\t# current line width\\n        width = 0\\n\\t\\t# current line words\\n        line = []\\n        \\n        for word in words:\\n\\t\\t\\t# Gather as many words that will fit under maxWidth restrictions.\\n\\t\\t\\t# Line length is a sum of:\\n\\t\\t\\t# 1) Current word length\\n\\t\\t\\t# 2) Sum of words already in the current line\\n\\t\\t\\t# 3) Number of spaces (each word needs to be separated by at least one space)\\n            if (len(word) + width + len(line)) <= maxWidth:\\n                width += len(word)\\n                line.append(word)\\n                continue\\n            \\n\\t\\t\\t# If the current line only contains one word, fill the remaining string with spaces.\\n            if len(line) == 1:\\n\\t\\t\\t\\t# Use the format function to fill the remaining string with spaces easily and readable.\\n\\t\\t\\t\\t# For letcode police, yes you could do something like:\\n\\t\\t\\t\\t#     line = \" \".join(line)\\n\\t\\t\\t\\t#     line += \" \" * (maxWidth - len(line))\\n\\t\\t\\t\\t#     lines.append(line)\\n\\t\\t\\t\\t# to be more \"raw\", but I see no point in that.\\n                lines.append(\\n                    \"{0: <{width}}\".format( \" \".join(line), width=maxWidth)\\n                )\\n            else:\\n\\t\\t\\t    # Else calculate how many common spaces and extra spaces are there for the current line.\\n\\t\\t\\t\\t# Example:\\n                #  line = [\\'a\\', \\'computer.\\', \\'Art\\', \\'is\\']\\n\\t\\t\\t\\t# width left in line equals to: maxWidth - width: 20 - 15 = 5\\n\\t\\t\\t\\t# len(line) - 1 because to the last word, we aren\\'t adding any spaces\\n\\t\\t\\t\\t# Now divmod will give us how many spaces are for all words and how many extra to distribute.\\n\\t\\t\\t\\t# divmod(5, 3) = 1, 2\\n\\t\\t\\t\\t# This means there should be one common space for each word, and for the first two, add one extra space.\\n                space, extra = divmod(\\n                    maxWidth - width,\\n                    len(line) - 1\\n                )\\n                \\n                i = 0\\n\\t\\t\\t\\t# Distribute extra spaces first\\n\\t\\t\\t\\t# There cannot be a case where extra spaces count is greater or equal to number words in the current line.\\n                while extra > 0:\\n                    line[i] += \" \"\\n                    extra -= 1\\n                    i += 1\\n                \\n\\t\\t\\t\\t# Join line array into a string by common spaces, and append to justified lines.\\n                lines.append(\\n                    (\" \" * space).join(line)\\n                )\\n            \\n\\t\\t\\t# Create new line array with the current word in iteration, and reset current line width as well.\\n            line = [word]\\n            width = len(word)\\n        \\n\\t\\t# Last but not least format last line to be left-justified with no extra space inserted between words.\\n\\t\\t# No matter the input, there always be the last line at the end of for loop, which makes things even easier considering the requirement.\\n        lines.append(\\n            \"{0: <{width}}\".format(\" \".join(line), width=maxWidth)\\n        )\\n        \\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24972,
                "title": "i-guess-i-just-wrote-an-essay-but-finally-passed-all-test-cases-ugh",
                "content": "    public List<String> fullJustify(String[] words, int L) {\\n        int length = L;\\n        ArrayList<String> cur_line = new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        if(words[0]==\"\")\\n        {\\n            String resNull =\"\";\\n            for(int i=0; i<L;i++)\\n                resNull=resNull+\" \";\\n            res.add(resNull);\\n            return res;\\n        }\\n        for(int i=0; i<words.length; i++)\\n        {\\n            //there is room left for current line ex:\"this is a bat  \"\\n            if(length-(words[i].length()+1)>0)  \\n            {\\n                length=length-(words[i].length()+1); //get remainning available spaces in cur line\\n                cur_line.add(words[i]); //add the word to the list \\n            }\\n            //just fit in current line   ex:\"this is a book\" or \"this is a bat \"\\n            else if(length-(words[i].length()+1)==-1 ||length-(words[i].length()+1)==0) \\n            {\\n                cur_line.add(words[i]); //add the last word to the list\\n                //proccess line\\n                boolean lastLine;\\n                if(i==words.length-1) lastLine=true;\\n                else lastLine=false;\\n                res.add(processLine(cur_line, L, lastLine));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line = new ArrayList<String>();\\n            }\\n            //there is no room to fit this one\\n            else if(length-(words[i].length()+1)<-1)\\n            {\\n                //first proccess cur line\\n                res.add(processLine(cur_line, L, false));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line=new ArrayList<String>();\\n                //put this one it it\\n                length=length-(words[i].length()+1);\\n                cur_line.add(words[i]);\\n            }\\n        }\\n        if(cur_line.size()!=0)\\n            res.add(processLine(cur_line, L, true));\\n        return res;\\n    }\\n    public String processLine(ArrayList<String>words, int L, boolean lastLine)\\n    {\\n        String lineString=\"\";\\n        if(words.size()==1)\\n        {\\n            String singleWord = words.get(0);\\n            int len =singleWord.length();\\n            for(int i=0;i<L-len;i++)\\n                singleWord = singleWord+\" \";\\n            return singleWord;\\n        }\\n        int reminder = L;\\n        for(String word: words)\\n            reminder = reminder-word.length();\\n        if(lastLine==true)\\n        {\\n            for(String word:words)\\n            {\\n                if(reminder!=0)\\n                    lineString = lineString+word+\" \";\\n                else\\n                    lineString = lineString+word;\\n                reminder--;\\n            }\\n            for(int i=0; i<reminder;i++)\\n                lineString = lineString+\" \";\\n            return lineString;\\n        }\\n        //there is extra spaces-->reminder\\n        int flag = reminder % (words.size()-1);\\n        int commonSpace = reminder/(words.size()-1);\\n        int extra = flag>0? 1:0;\\n        for(int i=0; i<words.size()-1;i++)\\n        {\\n            String spaces=\"\";\\n            for(int count =0; count<(commonSpace+extra);count++)\\n                 spaces = spaces+\" \";\\n            lineString = lineString +words.get(i)+spaces;\\n            flag--;\\n            extra = flag>0? 1:0;\\n        }\\n        lineString = lineString +words.get(words.size()-1);\\n        return lineString;\\n    }",
                "solutionTags": [],
                "code": "    public List<String> fullJustify(String[] words, int L) {\\n        int length = L;\\n        ArrayList<String> cur_line = new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        if(words[0]==\"\")\\n        {\\n            String resNull =\"\";\\n            for(int i=0; i<L;i++)\\n                resNull=resNull+\" \";\\n            res.add(resNull);\\n            return res;\\n        }\\n        for(int i=0; i<words.length; i++)\\n        {\\n            //there is room left for current line ex:\"this is a bat  \"\\n            if(length-(words[i].length()+1)>0)  \\n            {\\n                length=length-(words[i].length()+1); //get remainning available spaces in cur line\\n                cur_line.add(words[i]); //add the word to the list \\n            }\\n            //just fit in current line   ex:\"this is a book\" or \"this is a bat \"\\n            else if(length-(words[i].length()+1)==-1 ||length-(words[i].length()+1)==0) \\n            {\\n                cur_line.add(words[i]); //add the last word to the list\\n                //proccess line\\n                boolean lastLine;\\n                if(i==words.length-1) lastLine=true;\\n                else lastLine=false;\\n                res.add(processLine(cur_line, L, lastLine));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line = new ArrayList<String>();\\n            }\\n            //there is no room to fit this one\\n            else if(length-(words[i].length()+1)<-1)\\n            {\\n                //first proccess cur line\\n                res.add(processLine(cur_line, L, false));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line=new ArrayList<String>();\\n                //put this one it it\\n                length=length-(words[i].length()+1);\\n                cur_line.add(words[i]);\\n            }\\n        }\\n        if(cur_line.size()!=0)\\n            res.add(processLine(cur_line, L, true));\\n        return res;\\n    }\\n    public String processLine(ArrayList<String>words, int L, boolean lastLine)\\n    {\\n        String lineString=\"\";\\n        if(words.size()==1)\\n        {\\n            String singleWord = words.get(0);\\n            int len =singleWord.length();\\n            for(int i=0;i<L-len;i++)\\n                singleWord = singleWord+\" \";\\n            return singleWord;\\n        }\\n        int reminder = L;\\n        for(String word: words)\\n            reminder = reminder-word.length();\\n        if(lastLine==true)\\n        {\\n            for(String word:words)\\n            {\\n                if(reminder!=0)\\n                    lineString = lineString+word+\" \";\\n                else\\n                    lineString = lineString+word;\\n                reminder--;\\n            }\\n            for(int i=0; i<reminder;i++)\\n                lineString = lineString+\" \";\\n            return lineString;\\n        }\\n        //there is extra spaces-->reminder\\n        int flag = reminder % (words.size()-1);\\n        int commonSpace = reminder/(words.size()-1);\\n        int extra = flag>0? 1:0;\\n        for(int i=0; i<words.size()-1;i++)\\n        {\\n            String spaces=\"\";\\n            for(int count =0; count<(commonSpace+extra);count++)\\n                 spaces = spaces+\" \";\\n            lineString = lineString +words.get(i)+spaces;\\n            flag--;\\n            extra = flag>0? 1:0;\\n        }\\n        lineString = lineString +words.get(words.size()-1);\\n        return lineString;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 390686,
                "title": "straightforward-python-solution-with-detailed-explanation",
                "content": "```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justifySingleLine(line, width, max_width):\\n            num_words = len(line)\\n            total_spaces = max_width - width\\n            if num_words == 1:\\n                # if there is only word in line\\n                # just insert total_spaces for the remainder of line\\n                return line[0] + \\' \\' * total_spaces\\n            else:\\n                locations = num_words - 1\\n                # spaces_inserted[i] is the number of spaces inserted between the words line[i] and line[i+1]\\n                spaces_inserted = locations * [total_spaces // locations]\\n                # distribute the remaining spaces to the left positions\\n                for i in range(total_spaces % locations):\\n                    spaces_inserted[i] += 1\\n                s = \\'\\'\\n                for i in range(locations):\\n                    s += line[i] # add the word line[i]\\n                    s += spaces_inserted[i] * \\' \\'# insert spaces\\n                s += line[-1] # add the last word\\n                return s\\n\\n        answer = []\\n        line, width = [], 0\\n        for word in words:\\n            if width + len(word) + len(line) <= maxWidth:\\n                # keep adding words until we can fill out maxWidth\\n                # width = sum of length of all words\\n                # len(word) = length of current word\\n                # len(line) = least number of spaces needed to be inserted\\n                line.append(word)\\n                width += len(word)\\n            else:\\n                # justify the line and add it to result\\n                answer.append(justifySingleLine(line, width, maxWidth))\\n                # reset new line and new width\\n                line, width = [word], len(word)\\n        remaining_spaces = maxWidth - width - len(line)\\n        answer.append(\\' \\'.join(line) + (remaining_spaces + 1) * \\' \\')\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justifySingleLine(line, width, max_width):\\n            num_words = len(line)\\n            total_spaces = max_width - width\\n            if num_words == 1:\\n                # if there is only word in line\\n                # just insert total_spaces for the remainder of line\\n                return line[0] + \\' \\' * total_spaces\\n            else:\\n                locations = num_words - 1\\n                # spaces_inserted[i] is the number of spaces inserted between the words line[i] and line[i+1]\\n                spaces_inserted = locations * [total_spaces // locations]\\n                # distribute the remaining spaces to the left positions\\n                for i in range(total_spaces % locations):\\n                    spaces_inserted[i] += 1\\n                s = \\'\\'\\n                for i in range(locations):\\n                    s += line[i] # add the word line[i]\\n                    s += spaces_inserted[i] * \\' \\'# insert spaces\\n                s += line[-1] # add the last word\\n                return s\\n\\n        answer = []\\n        line, width = [], 0\\n        for word in words:\\n            if width + len(word) + len(line) <= maxWidth:\\n                # keep adding words until we can fill out maxWidth\\n                # width = sum of length of all words\\n                # len(word) = length of current word\\n                # len(line) = least number of spaces needed to be inserted\\n                line.append(word)\\n                width += len(word)\\n            else:\\n                # justify the line and add it to result\\n                answer.append(justifySingleLine(line, width, maxWidth))\\n                # reset new line and new width\\n                line, width = [word], len(word)\\n        remaining_spaces = maxWidth - width - len(line)\\n        answer.append(\\' \\'.join(line) + (remaining_spaces + 1) * \\' \\')\\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149785,
                "title": "clean-javascript-solution",
                "content": "```javascript\\nconst fullJustify = (words, maxWidth) => {\\n  const n = words.length;\\n  const res = [];\\n\\n  for (var i = 0; i < n; i = j) {\\n    // Step 1. Use j to find out where to cut the row (i ... j-1)\\n    let len = -1;\\n    for (var j = i; j < n && len + 1 + words[j].length <= maxWidth; j++) {\\n      len += 1 + words[j].length;\\n    }\\n\\n    // Step 2. Calculate how many spaces to add for each word\\n    let spaces = 1; // avg. spaces reserved for each word\\n    let extra = 0; // extra left spaces\\n\\n    if (j !== i + 1 && j !== n) {\\n      spaces = (maxWidth - len) / (j - 1 - i) + 1;\\n      extra = (maxWidth - len) % (j - 1 - i);\\n    }\\n\\n    // Step 3. Build the row with spaces + extra space + word\\n    let row = words[i];\\n    for (let k = i + 1; k < j; k++, extra--) {\\n      row += \\' \\'.repeat(spaces + (extra > 0 ? 1 : 0)) + words[k];\\n    }\\n    row += \\' \\'.repeat(maxWidth - row.length);\\n\\n    // Step 4. Push the row to final result\\n    res.push(row);\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst fullJustify = (words, maxWidth) => {\\n  const n = words.length;\\n  const res = [];\\n\\n  for (var i = 0; i < n; i = j) {\\n    // Step 1. Use j to find out where to cut the row (i ... j-1)\\n    let len = -1;\\n    for (var j = i; j < n && len + 1 + words[j].length <= maxWidth; j++) {\\n      len += 1 + words[j].length;\\n    }\\n\\n    // Step 2. Calculate how many spaces to add for each word\\n    let spaces = 1; // avg. spaces reserved for each word\\n    let extra = 0; // extra left spaces\\n\\n    if (j !== i + 1 && j !== n) {\\n      spaces = (maxWidth - len) / (j - 1 - i) + 1;\\n      extra = (maxWidth - len) % (j - 1 - i);\\n    }\\n\\n    // Step 3. Build the row with spaces + extra space + word\\n    let row = words[i];\\n    for (let k = i + 1; k < j; k++, extra--) {\\n      row += \\' \\'.repeat(spaces + (extra > 0 ? 1 : 0)) + words[k];\\n    }\\n    row += \\' \\'.repeat(maxWidth - row.length);\\n\\n    // Step 4. Push the row to final result\\n    res.push(row);\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181479,
                "title": "very-easy-java-solution-with-explanation-beats-100",
                "content": "- The idea is to get the window from the words which can fit in a line.\\n    - while getting this window, we also keep following track:\\n        - len : len for the window from start to end including one space as minimum req \\n            Example len = 10 for \"THIS IS AN\"\\n        - count : keeps track of space holders in the string. Initial kept to -1.\\n            Example count = 2 for \"THIS IS AN\"\\n    - Upon getting the window, we now call a function addLine() which creates a line keeping track of 4 things\\n        - same : The equals spaces every word pair will have between them\\n        - extra : The extra ones, which are given one by one from left and decremented every time\\n        - trail : For cases such as last line OR only one word in the line, we need to append trail number of spaces to the line.\\n    \\n    Time Complexity : O(N*maxWidth) : N is number of lines\\n    Space Complexity : O(maxWidth)  : Space for a single line\\n\\t\\t\\n```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n         \\n        List<String> result = new ArrayList<>();\\n        int len = -1 , count = -1, start = 0;\\n        \\n        for(int i=0;i<words.length;i++){            \\n            if(len+words[i].length()+1<=maxWidth){\\n                len += words[i].length()+1;\\n                count++;                \\n            }\\n            else{                 \\n                addLine(words,start,i-1,len,count,maxWidth,result,false);\\n                start = i;\\n                i--;\\n                len = -1;\\n                count= -1;\\n            }\\n        }\\n        addLine(words,start,words.length-1,len,count,maxWidth,result,true);\\n        return result;\\n    }\\n    \\n    public void addLine(String[] words,int start, int end, int len, int count, int maxWidth, List<String> result,boolean isLast){\\n        \\n            int spaces = maxWidth-len;\\n            spaces += count;         \\n            int same = isLast || (count==0)? 0 : spaces/count;\\n            int extra = isLast || (count==0)? count : spaces%count;        \\n            int trail = isLast || (count==0) ? maxWidth-len : 0;\\n\\t\\t\\t\\t\\t\\t\\n            StringBuilder line = new StringBuilder();\\n                \\n            while(start<=end){\\n                line.append(words[start]);                    \\n                for(int k=0;k<same && start!=end;k++)\\n                    line.append(\\' \\');\\n                    \\n                if(extra>0){\\n                    line.append(\\' \\');\\n                    extra--;\\n                }\\n                start++;\\n            }        \\n            while(trail>0){\\n                line.append(\\' \\');\\n                trail--;\\n            }                \\n            result.add(line.toString());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n         \\n        List<String> result = new ArrayList<>();\\n        int len = -1 , count = -1, start = 0;\\n        \\n        for(int i=0;i<words.length;i++){            \\n            if(len+words[i].length()+1<=maxWidth){\\n                len += words[i].length()+1;\\n                count++;                \\n            }\\n            else{                 \\n                addLine(words,start,i-1,len,count,maxWidth,result,false);\\n                start = i;\\n                i--;\\n                len = -1;\\n                count= -1;\\n            }\\n        }\\n        addLine(words,start,words.length-1,len,count,maxWidth,result,true);\\n        return result;\\n    }\\n    \\n    public void addLine(String[] words,int start, int end, int len, int count, int maxWidth, List<String> result,boolean isLast){\\n        \\n            int spaces = maxWidth-len;\\n            spaces += count;         \\n            int same = isLast || (count==0)? 0 : spaces/count;\\n            int extra = isLast || (count==0)? count : spaces%count;        \\n            int trail = isLast || (count==0) ? maxWidth-len : 0;\\n\\t\\t\\t\\t\\t\\t\\n            StringBuilder line = new StringBuilder();\\n                \\n            while(start<=end){\\n                line.append(words[start]);                    \\n                for(int k=0;k<same && start!=end;k++)\\n                    line.append(\\' \\');\\n                    \\n                if(extra>0){\\n                    line.append(\\' \\');\\n                    extra--;\\n                }\\n                start++;\\n            }        \\n            while(trail>0){\\n                line.append(\\' \\');\\n                trail--;\\n            }                \\n            result.add(line.toString());\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25002,
                "title": "share-my-2-ms-30-lines-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> fullJustify(vector<string> &words, int L) {\\n            vector<string> ans;\\n            int begin = 0;\\n            while (begin < words.size()) {\\n                int last = begin;\\n                int linesize = words[begin++].size();\\n                while (begin < words.size() && linesize + 1 + words[begin].size() <= L) {\\n                    linesize += 1 + words[begin].size();\\n                    begin++;\\n                }\\n                \\n                int spaces = 1, extra = 0;\\n                if (begin < words.size() && begin != last + 1) {\\n                    spaces = (L - linesize) / (begin - last - 1) + 1;\\n                    extra = (L - linesize) % (begin - last - 1);\\n                }\\n                \\n                ans.push_back(words[last++]);\\n                while (extra--) {\\n                    ans.back().append(spaces+1, ' ');\\n                    ans.back().append(words[last++]);\\n                }\\n                while (last < begin) {\\n                    ans.back().append(spaces, ' ');\\n                    ans.back().append(words[last++]);\\n                }\\n                ans.back().append(L-ans.back().size(), ' ');\\n            }\\n            \\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> fullJustify(vector<string> &words, int L) {\\n            vector<string> ans;\\n            int begin = 0;\\n            while (begin < words.size()) {\\n                int last = begin;\\n                int linesize = words[begin++].size();\\n                while (begin < words.size() && linesize + 1 + words[begin].size() <= L) {\\n                    linesize += 1 + words[begin].size();\\n                    begin++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3952309,
                "title": "100-fast-easy-code-with-explanation-c-java-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust use loops .Try to understand the problem otherwise question is easy.\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach\\n\\n1. Initialize an empty vector `res` to store the justified lines of text.\\n\\n2. Iterate through the input `words` vector using an index `i` to keep track of the current word being processed.\\n\\n3. In each iteration, find a range of words that can fit within the `maxWidth` limit. To do this, increment the index `j` while the accumulated length of the words (including spaces) remains within the limit.\\n\\n4. There are three cases to consider for formatting the words into a line:\\n\\n   a. If the range `[i, j)` contains only one word, or it\\'s the last line, left-justify the words. Add spaces between each word and pad the line with spaces on the right to achieve the `maxWidth`.\\n\\n   b. If the line has more than one word but it\\'s not the last line, calculate the total number of words in the line `tw` and the total space available `ts`. Divide `ts` by `(tw - 1)` to determine the standard space between words, and calculate the extra spaces that need to be distributed.\\n\\n5. Construct the justified line of text:\\n\\n   a. Initialize an empty string `s` to build the line.\\n\\n   b. For each word in the range `[i, j)`, append the word to `s`.\\n\\n   c. If it\\'s not the last word in the line, add the standard spacing calculated earlier. Distribute the extra spaces if available.\\n\\n6. Push the constructed line `s` into the result vector `res`.\\n\\n7. Update the index `i` to the value of `j - 1` to move to the next line.\\n\\n8. Repeat the process until all words are processed.\\n\\n9. Return the `res` vector containing the justified lines of text.\\n\\n**Explanation**:\\n\\nThe approach divides the problem into two main cases based on the number of words in a line. For lines containing only one word or being the last line, the words are left-justified with spaces added to reach the `maxWidth`. For lines with multiple words that are not the last line, spaces are distributed evenly between words to achieve the target width.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![Screenshot (312).png](https://assets.leetcode.com/users/images/0c825012-e2c3-4f4e-9d13-5f02764c3ba8_1692850690.487161.png)\\n\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            int j=i+1;\\n            int c=words[i].size();\\n            int wc=words[i].size();\\n            while(j<n&&c+words[j].size()+1<=maxWidth){\\n                c+=words[j].size()+1;\\n                wc+=words[j].length();\\n                j++;\\n            }\\n           if(j==n||(j-i)==1){\\n               string s=\"\";\\n               for(int p=i;p<j;p++){\\n                   s+=words[p];\\n                   if(p!=j-1)\\n                   s+=\\' \\';\\n               }\\n               int ts=maxWidth-s.size();\\n               for(int k=0;k<ts;k++){\\n                   s+=\\' \\';\\n               }\\n               res.push_back(s);\\n               i=j-1;\\n           }\\n           else{\\n             int tw=j-i;\\n             int ts=maxWidth-wc;\\n             int es=ts/(tw-1);\\n             int extra=ts%(tw-1);\\n             string s=\"\";\\n             for(int p=i;p<j;p++){\\n                 s+=words[p];\\n                 if(extra>0){\\n                    s+=\\' \\';\\n                    extra--;\\n                 }\\n                 if(p!=j-1){\\n                for(int k=0;k<es;k++){\\n                   s+=\\' \\';\\n               }\\n                 }\\n             }\\n             res.push_back(s);\\n              i=j-1;\\n           }\\n           i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int n = words.length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].length();\\n            int wc = words[i].length();\\n            while (j < n && c + words[j].length() + 1 <= maxWidth) {\\n                c += words[j].length() + 1;\\n                wc += words[j].length();\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (p != j - 1)\\n                        s.append(\\' \\');\\n                }\\n                int ts = maxWidth - s.length();\\n                for (int k = 0; k < ts; k++) {\\n                    s.append(\\' \\');\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (extra > 0) {\\n                        s.append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        for (int k = 0; k < es; k++) {\\n                            s.append(\\' \\');\\n                        }\\n                    }\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        n = len(words)\\n        i = 0\\n        while i < n:\\n            j = i + 1\\n            c = len(words[i])\\n            wc = len(words[i])\\n            while j < n and c + len(words[j]) + 1 <= maxWidth:\\n                c += len(words[j]) + 1\\n                wc += len(words[j])\\n                j += 1\\n            if j == n or j - i == 1:\\n                s = \\' \\'.join(words[i:j])\\n                ts = maxWidth - len(s)\\n                s += \\' \\' * ts\\n                res.append(s)\\n                i = j\\n            else:\\n                tw = j - i\\n                ts = maxWidth - wc\\n                es = ts // (tw - 1)\\n                extra = ts % (tw - 1)\\n                s = \\'\\'\\n                for p in range(i, j):\\n                    s += words[p]\\n                    if extra > 0:\\n                        s += \\' \\'\\n                        extra -= 1\\n                    if p != j - 1:\\n                        s += \\' \\' * es\\n                res.append(s)\\n                i = j\\n            i += 1\\n        return res\\n\\n```\\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        int n = words.Length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].Length;\\n            int wc = words[i].Length;\\n            while (j < n && c + words[j].Length + 1 <= maxWidth) {\\n                c += words[j].Length + 1;\\n                wc += words[j].Length;\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (p != j - 1)\\n                        s.Append(\\' \\');\\n                }\\n                int ts = maxWidth - s.Length;\\n                s.Append(\\' \\', ts);\\n                res.Add(s.ToString());\\n                i = j;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (extra > 0) {\\n                        s.Append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        s.Append(\\' \\', es);\\n                    }\\n                }\\n                res.Add(s.ToString());\\n                i = j;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            int j=i+1;\\n            int c=words[i].size();\\n            int wc=words[i].size();\\n            while(j<n&&c+words[j].size()+1<=maxWidth){\\n                c+=words[j].size()+1;\\n                wc+=words[j].length();\\n                j++;\\n            }\\n           if(j==n||(j-i)==1){\\n               string s=\"\";\\n               for(int p=i;p<j;p++){\\n                   s+=words[p];\\n                   if(p!=j-1)\\n                   s+=\\' \\';\\n               }\\n               int ts=maxWidth-s.size();\\n               for(int k=0;k<ts;k++){\\n                   s+=\\' \\';\\n               }\\n               res.push_back(s);\\n               i=j-1;\\n           }\\n           else{\\n             int tw=j-i;\\n             int ts=maxWidth-wc;\\n             int es=ts/(tw-1);\\n             int extra=ts%(tw-1);\\n             string s=\"\";\\n             for(int p=i;p<j;p++){\\n                 s+=words[p];\\n                 if(extra>0){\\n                    s+=\\' \\';\\n                    extra--;\\n                 }\\n                 if(p!=j-1){\\n                for(int k=0;k<es;k++){\\n                   s+=\\' \\';\\n               }\\n                 }\\n             }\\n             res.push_back(s);\\n              i=j-1;\\n           }\\n           i++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int n = words.length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].length();\\n            int wc = words[i].length();\\n            while (j < n && c + words[j].length() + 1 <= maxWidth) {\\n                c += words[j].length() + 1;\\n                wc += words[j].length();\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (p != j - 1)\\n                        s.append(\\' \\');\\n                }\\n                int ts = maxWidth - s.length();\\n                for (int k = 0; k < ts; k++) {\\n                    s.append(\\' \\');\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (extra > 0) {\\n                        s.append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        for (int k = 0; k < es; k++) {\\n                            s.append(\\' \\');\\n                        }\\n                    }\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        n = len(words)\\n        i = 0\\n        while i < n:\\n            j = i + 1\\n            c = len(words[i])\\n            wc = len(words[i])\\n            while j < n and c + len(words[j]) + 1 <= maxWidth:\\n                c += len(words[j]) + 1\\n                wc += len(words[j])\\n                j += 1\\n            if j == n or j - i == 1:\\n                s = \\' \\'.join(words[i:j])\\n                ts = maxWidth - len(s)\\n                s += \\' \\' * ts\\n                res.append(s)\\n                i = j\\n            else:\\n                tw = j - i\\n                ts = maxWidth - wc\\n                es = ts // (tw - 1)\\n                extra = ts % (tw - 1)\\n                s = \\'\\'\\n                for p in range(i, j):\\n                    s += words[p]\\n                    if extra > 0:\\n                        s += \\' \\'\\n                        extra -= 1\\n                    if p != j - 1:\\n                        s += \\' \\' * es\\n                res.append(s)\\n                i = j\\n            i += 1\\n        return res\\n\\n```\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        int n = words.Length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].Length;\\n            int wc = words[i].Length;\\n            while (j < n && c + words[j].Length + 1 <= maxWidth) {\\n                c += words[j].Length + 1;\\n                wc += words[j].Length;\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (p != j - 1)\\n                        s.Append(\\' \\');\\n                }\\n                int ts = maxWidth - s.Length;\\n                s.Append(\\' \\', ts);\\n                res.Add(s.ToString());\\n                i = j;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (extra > 0) {\\n                        s.Append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        s.Append(\\' \\', es);\\n                    }\\n                }\\n                res.Add(s.ToString());\\n                i = j;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987109,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n     public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n}\\n```\\n\\n***JavaScript***\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n     private  val SEPARATOR = \" \" \\n    \\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n\\n        val result = mutableListOf<String>() // keeps the lines as a sting in a paragraph\\n        val currentLineWords = mutableListOf<String>()// keeps track of all the words for the current line\\n        var availableSpacePerLine = maxWidth //  keeps track of the available space in the current line\\n\\n        words.forEach { word ->\\n            availableSpacePerLine -= word.length\\n            when {\\n                (availableSpacePerLine == 0) -> { // the words perfectly fit\\n                    currentLineWords.add(word)\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    availableSpacePerLine = maxWidth\\n                }\\n                (availableSpacePerLine < 0) -> { // too much words in a line adjust!\\n                    availableSpacePerLine += (word.length + 1) //remove the claimed space for current\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine = maxWidth - (word.length + 1)\\n                }\\n                (availableSpacePerLine > 0) -> { // space is still available in the current line\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine--\\n                }\\n            }\\n        }\\n\\n        // Process the last line if there is one\\n        if (currentLineWords.isNotEmpty()) {\\n            result.add(toLineString(availableSpacePerLine + 1, currentLineWords, true))\\n        }\\n        return result\\n    }\\n    \\n\\n    private fun toLineString(\\n        noOfSpaceToBeDistributed: Int,\\n        wordsInLine: MutableList<String>,\\n        isLastLine: Boolean = false\\n    ): String {\\n        return if (wordsInLine.size == 1 || isLastLine) { // if there is only one word in a line or if the line is the last one , all the remaining spaces should just go to the end of the sentence\\n            wordsInLine.joinToString(SEPARATOR) + SEPARATOR.repeat(noOfSpaceToBeDistributed)\\n        } else { // other wise we have to evenly distribute the remaining lines\\n            val spaceToBeAddedToAllWords = (Math.floorDiv(\\n                noOfSpaceToBeDistributed,\\n                wordsInLine.lastIndex\\n            )) + 1 // the +1 is because we already take in to consideration a space when calculating noOfSpaceToBeDistributed\\n            \\n            for (i in 0 until noOfSpaceToBeDistributed % wordsInLine.lastIndex) {\\n                wordsInLine[i] += SEPARATOR\\n            }\\n            wordsInLine.joinToString(SEPARATOR.repeat(spaceToBeAddedToAllWords))\\n        }\\n    }\\n  \\n  \\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n     public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n}\\n```\n```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```\n```\\nclass Solution {\\n     private  val SEPARATOR = \" \" \\n    \\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n\\n        val result = mutableListOf<String>() // keeps the lines as a sting in a paragraph\\n        val currentLineWords = mutableListOf<String>()// keeps track of all the words for the current line\\n        var availableSpacePerLine = maxWidth //  keeps track of the available space in the current line\\n\\n        words.forEach { word ->\\n            availableSpacePerLine -= word.length\\n            when {\\n                (availableSpacePerLine == 0) -> { // the words perfectly fit\\n                    currentLineWords.add(word)\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    availableSpacePerLine = maxWidth\\n                }\\n                (availableSpacePerLine < 0) -> { // too much words in a line adjust!\\n                    availableSpacePerLine += (word.length + 1) //remove the claimed space for current\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine = maxWidth - (word.length + 1)\\n                }\\n                (availableSpacePerLine > 0) -> { // space is still available in the current line\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine--\\n                }\\n            }\\n        }\\n\\n        // Process the last line if there is one\\n        if (currentLineWords.isNotEmpty()) {\\n            result.add(toLineString(availableSpacePerLine + 1, currentLineWords, true))\\n        }\\n        return result\\n    }\\n    \\n\\n    private fun toLineString(\\n        noOfSpaceToBeDistributed: Int,\\n        wordsInLine: MutableList<String>,\\n        isLastLine: Boolean = false\\n    ): String {\\n        return if (wordsInLine.size == 1 || isLastLine) { // if there is only one word in a line or if the line is the last one , all the remaining spaces should just go to the end of the sentence\\n            wordsInLine.joinToString(SEPARATOR) + SEPARATOR.repeat(noOfSpaceToBeDistributed)\\n        } else { // other wise we have to evenly distribute the remaining lines\\n            val spaceToBeAddedToAllWords = (Math.floorDiv(\\n                noOfSpaceToBeDistributed,\\n                wordsInLine.lastIndex\\n            )) + 1 // the +1 is because we already take in to consideration a space when calculating noOfSpaceToBeDistributed\\n            \\n            for (i in 0 until noOfSpaceToBeDistributed % wordsInLine.lastIndex) {\\n                wordsInLine[i] += SEPARATOR\\n            }\\n            wordsInLine.joinToString(SEPARATOR.repeat(spaceToBeAddedToAllWords))\\n        }\\n    }\\n  \\n  \\n}\\n```\n```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446139,
                "title": "well-commented-javascript-solution",
                "content": "```javascript\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let buf = [];\\n    let width = maxWidth;\\n    \\n    // Greedy pack each line\\n    // when that fails add the line to the result with the added padding\\n    // and start a new line\\n    words.forEach(word => {\\n        // Check if the word fits in the current line\\n        // A word fits if theres enough room for the word and\\n        // a space between it and the word to the left\\n        if (word.length <= (width - buf.length)) {\\n            buf.push(word);\\n            width -= word.length;\\n        } else {\\n            // The word did not fit on the line, send this line for padding\\n            addWordToResult(res, buf.slice(), maxWidth);\\n            \\n            // Start a new line with the current word\\n            buf = [word];\\n            // reset the current line width\\n            width = maxWidth - word.length;\\n        }\\n    });\\n    \\n    // This is the final lines processing\\n    // According the rules this should only be left justified\\n    // so add all padding to the right not between the words\\n    if (buf.length) {\\n        let str = buf.join(\\' \\');\\n        str += \\' \\'.repeat(maxWidth - str.length);\\n        res.push(str);\\n    }\\n    \\n    return res;\\n};\\n\\n// Max words are on each line now pad them with spaces\\nfunction addWordToResult(res, buf, maxWidth) {\\n    // How many spaces are needed\\n    let spaces = maxWidth - buf.reduce((acc, cur) => cur.length + acc, 0);\\n    \\n    // If there is only one word on the line\\n    // then just add the padding to the end and return\\n    if (buf.length === 1) {\\n        buf[0] += \\' \\'.repeat(spaces);\\n        res.push(buf[0]);\\n        return;\\n    }\\n    \\n    // If the line has more than one word,\\n    // decrement the spaces which are created during the buf.join(\\' \\')\\n    // which is n - 1 spaces\\n    spaces -= buf.length - 1;\\n    \\n    // All words except the last should have spaces added to their string\\n    const end = buf.length - 1;\\n    let index = 0;\\n    \\n    // If there are spaces to distribute, distribute them\\n    // evenly looping back to the beginning of the buffer\\n    while (spaces-- > 0) {\\n        buf[index] += \\' \\';\\n        \\n        index = (index + 1) % end;\\n    }\\n    \\n    res.push(buf.join(\\' \\'))\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let buf = [];\\n    let width = maxWidth;\\n    \\n    // Greedy pack each line\\n    // when that fails add the line to the result with the added padding\\n    // and start a new line\\n    words.forEach(word => {\\n        // Check if the word fits in the current line\\n        // A word fits if theres enough room for the word and\\n        // a space between it and the word to the left\\n        if (word.length <= (width - buf.length)) {\\n            buf.push(word);\\n            width -= word.length;\\n        } else {\\n            // The word did not fit on the line, send this line for padding\\n            addWordToResult(res, buf.slice(), maxWidth);\\n            \\n            // Start a new line with the current word\\n            buf = [word];\\n            // reset the current line width\\n            width = maxWidth - word.length;\\n        }\\n    });\\n    \\n    // This is the final lines processing\\n    // According the rules this should only be left justified\\n    // so add all padding to the right not between the words\\n    if (buf.length) {\\n        let str = buf.join(\\' \\');\\n        str += \\' \\'.repeat(maxWidth - str.length);\\n        res.push(str);\\n    }\\n    \\n    return res;\\n};\\n\\n// Max words are on each line now pad them with spaces\\nfunction addWordToResult(res, buf, maxWidth) {\\n    // How many spaces are needed\\n    let spaces = maxWidth - buf.reduce((acc, cur) => cur.length + acc, 0);\\n    \\n    // If there is only one word on the line\\n    // then just add the padding to the end and return\\n    if (buf.length === 1) {\\n        buf[0] += \\' \\'.repeat(spaces);\\n        res.push(buf[0]);\\n        return;\\n    }\\n    \\n    // If the line has more than one word,\\n    // decrement the spaces which are created during the buf.join(\\' \\')\\n    // which is n - 1 spaces\\n    spaces -= buf.length - 1;\\n    \\n    // All words except the last should have spaces added to their string\\n    const end = buf.length - 1;\\n    let index = 0;\\n    \\n    // If there are spaces to distribute, distribute them\\n    // evenly looping back to the beginning of the buffer\\n    while (spaces-- > 0) {\\n        buf[index] += \\' \\';\\n        \\n        index = (index + 1) % end;\\n    }\\n    \\n    res.push(buf.join(\\' \\'))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953480,
                "title": "c-string-faster-than-100-day-24",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &w, int check)\\n    {\\n        vector<string> ans;\\n        int i = 0;\\n        while (i < w.size())\\n        {\\n            int end = i;\\n            int space = 0;\\n            int word = 0;\\n            string s = \"\";\\n            int word_length = 0;\\n            for (int j = i; j < w.size(); j++)\\n            {\\n                if (j == i)\\n                {\\n                    word++;\\n                    word_length += w[j].size();\\n                }\\n                else\\n                {\\n                    if (word_length + space + 1 + w[j].size() > check)\\n                        break;\\n                    else\\n                    {\\n                        space++;\\n                        word++;\\n                        word_length += w[j].size();\\n                        end = j;\\n                    }\\n                }\\n            }\\n            if (end != w.size() - 1)\\n            {\\n                int extra = 0;\\n                int spc = 0;\\n                if (space)\\n                {\\n                    spc = (check - word_length) / space;\\n                    extra = (check - word_length) % space;\\n                }\\n                for (int j = i; j <= end; j++)\\n                {\\n                    s += w[j];\\n                    for (int k = 0; k < spc && j != end; k++)\\n                    {\\n                        s += \" \";\\n                    }\\n                    if (extra)\\n                    {\\n                        extra--;\\n                        s += \" \";\\n                    }\\n                }\\n                if (space == 0)\\n                {\\n                    int k = s.size();\\n                    for (int j = 1; j <= (check - k); j++)\\n                    {\\n                        s += \" \";\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for (int j = i; j <= end; j++)\\n                {\\n                    if (j == i)\\n                        s += w[j];\\n                    else\\n                    {\\n                        s += \" \";\\n                        s += w[j];\\n                    }\\n                }\\n                int k = s.size();\\n                for (int j = 1; j <= (check - k); j++)\\n                {\\n                    s += \" \";\\n                }\\n            }\\n            i = end + 1;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c55adefd-96e8-4eb9-93ba-fd2b676955cd_1692866831.3735065.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &w, int check)\\n    {\\n        vector<string> ans;\\n        int i = 0;\\n        while (i < w.size())\\n        {\\n            int end = i;\\n            int space = 0;\\n            int word = 0;\\n            string s = \"\";\\n            int word_length = 0;\\n            for (int j = i; j < w.size(); j++)\\n            {\\n                if (j == i)\\n                {\\n                    word++;\\n                    word_length += w[j].size();\\n                }\\n                else\\n                {\\n                    if (word_length + space + 1 + w[j].size() > check)\\n                        break;\\n                    else\\n                    {\\n                        space++;\\n                        word++;\\n                        word_length += w[j].size();\\n                        end = j;\\n                    }\\n                }\\n            }\\n            if (end != w.size() - 1)\\n            {\\n                int extra = 0;\\n                int spc = 0;\\n                if (space)\\n                {\\n                    spc = (check - word_length) / space;\\n                    extra = (check - word_length) % space;\\n                }\\n                for (int j = i; j <= end; j++)\\n                {\\n                    s += w[j];\\n                    for (int k = 0; k < spc && j != end; k++)\\n                    {\\n                        s += \" \";\\n                    }\\n                    if (extra)\\n                    {\\n                        extra--;\\n                        s += \" \";\\n                    }\\n                }\\n                if (space == 0)\\n                {\\n                    int k = s.size();\\n                    for (int j = 1; j <= (check - k); j++)\\n                    {\\n                        s += \" \";\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for (int j = i; j <= end; j++)\\n                {\\n                    if (j == i)\\n                        s += w[j];\\n                    else\\n                    {\\n                        s += \" \";\\n                        s += w[j];\\n                    }\\n                }\\n                int k = s.size();\\n                for (int j = 1; j <= (check - k); j++)\\n                {\\n                    s += \" \";\\n                }\\n            }\\n            i = end + 1;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042723,
                "title": "intuitive-readable-python-solution-beats-95-90",
                "content": "I was just given a variant of this question on a Karat, so I wanted to solve it on LC. I noticed a lot of the discussion answers were a bit rough to read, so I wanted to share this readible yet performant answer.\\n\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24989,
                "title": "easy-java-implementation",
                "content": "- I divide the solution to this question into two parts:\\n - one is for counting the valid number of words which can fit into one line, i.e. helper() function does it and also passes the next index to be traversed in the next turn (it can be modified as iterative way if you are more comfortable with).\\n\\n - the other part serves as a string editor, i.e. addList() uses the actual valid words lengths (len) and index of start (i, inclusive) and end (j, exclusive) to count the spaces to be added.\\n\\n-\\n\\n    public class Solution {\\n    private List<String> result;\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        result = new ArrayList<String>();\\n        if (words == null || words.length == 0 || maxWidth < 0) return result;\\n        if (maxWidth == 0) {\\n            result.add(\"\");\\n            return result;\\n        }\\n        helper(words, 0, maxWidth);\\n        return result;\\n    }\\n    \\n    public void helper(String[] words, int start, int L) {\\n        if (start >= words.length) return;\\n        \\n        int i = start, len = 0, total = 0, next = -1;\\n        while (total < L && i < words.length) {\\n            total += words[i].length();\\n            if (total > L) { // only in this case we need skip i++\\n                next = i;\\n                break;\\n            }\\n            len += words[i].length();\\n            total++; // count space\\n            i++;\\n        }\\n        \\n        if (next == -1) next = i;\\n        addList(words, start, next, len, L);\\n        \\n        helper(words, next, L);\\n    }\\n    \\n    public void addList(String[] words, int i, int j, int len, int L) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int count = j-i-1, space = 0, more = 0, s = 0;\\n        if (count == 0 || j == words.length) { // the last line\\n            for (int k = i; k < j; k++) {\\n                sb.append(words[k]);\\n                if (k == j-1) break;\\n                sb.append(\" \");\\n            }\\n            space = L - sb.length();\\n            s = 0;\\n            while (s++ < space) sb.append(\" \");\\n        } else {\\n            space = (L - len) / count; more = (L - len) % count;\\n            for (int k = i; k < j; k++) {\\n                sb.append(words[k]);\\n                s = 0;\\n                if (k == j-1) break;\\n                while (s++ < space) sb.append(\" \");\\n                if (more-- > 0) sb.append(\" \");\\n            }\\n        }\\n        \\n        result.add(sb.toString());\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private List<String> result;\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        result = new ArrayList<String>();\\n        if (words == null || words.length == 0 || maxWidth < 0) return result;\\n        if (maxWidth == 0) {\\n            result.add(\"\");\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1810892,
                "title": "java-simple-approach-with-explanation-runtime-0-ms-100-faster",
                "content": "# **Please upvote if you like the solution**\\n\\n```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int start = 0, length = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            /**\\n             * Try to add words till its under maxWidth length\\n             */\\n            if (words[i].length() <= (maxWidth - length)) {\\n                // + 1 because after each word there should be a space\\n                length += words[i].length() + 1;\\n                continue;\\n            }\\n            /**\\n             * Process the words which can be part of the justified sentence\\n             */\\n            else {\\n                /**\\n                 * Intention is try to get the remaining Spaces number and number of words part of the sentence\\n                 * As we have to distribute the spaces as evenly as possible, we can figure put the in between spaces\\n                 * between the words by doing remainingSpaces / noOfWords\\n                 * and there is a possibility that after evenly distributed the spaces also there can be some extra spaces\\n                 * which are pending.\\n                 *  Like for an example\\n                 *      remainingSpaces = 8 and noOfWords = 3\\n                 *      So in between spaces will be 8 / 3 = 2 spaces. But still 8 - (3 * 2) = 2 spaces are remaining\\n                 *      As per the problem those spaces can be placed sequentially between the words (till possible)\\n                 */\\n\\n                /**\\n                 * Adding + 1 because none of the justified sentence should end with \" \" (space) and we have added space\\n                 * for each word while calculating the length of the words. So, just removing the space after last word\\n                 */\\n                int remainingSpaces = maxWidth - length + 1;\\n\\n                /**\\n                 * Decreasing the number of word by 1 because\\n                 * If for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 *  There should not be any trailing spaces.\\n                 */\\n                int noOfWords = i - start - 1;\\n                int extraSpaceBetweenWords = 0;\\n\\n                if (noOfWords > 0) {\\n                    extraSpaceBetweenWords = remainingSpaces / noOfWords;\\n                    remainingSpaces = remainingSpaces % noOfWords;\\n                }\\n\\n                /**\\n                 * Append the word, extra space & remainingSpaces (if present)\\n                 * Iterating till (i - 1) position as we want to add those extra spaces in between words not at end\\n                 * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 */\\n                while (start < i - 1) {\\n                    sb.append(words[start++]).append(\" \");\\n                    int k = 0;\\n                    while (k < extraSpaceBetweenWords) {\\n                        sb.append(\" \");\\n                        k++;\\n                    }\\n                    if (remainingSpaces > 0) {\\n                        sb.append(\" \");\\n                        remainingSpaces--;\\n                    }\\n                }\\n                // Appending the last word part of sentence\\n                sb.append(words[start]);\\n\\n                /**\\n                 *  This will execute only for the cases where there is only 1 word part of the sentence\\n                 *  and its not covered as part of the previous while loop\\n                 */\\n                while (remainingSpaces > 0) {\\n                    sb.append(\" \");\\n                    remainingSpaces--;\\n                }\\n                result.add(sb.toString());\\n\\n                /**\\n                 * reset start position to current position\\n                 * update the length of the current word\\n                 * resetting the StringBuilder\\n                 */\\n                start = i;\\n                length = words[i].length() + 1;\\n                sb.setLength(0);\\n            }\\n        }\\n\\n        /**\\n         * Processing the last sentence, which should be left-justified and no extra space is inserted between words.\\n         *\\n         * Iterating till (words.length - 1) position as we want to add those extra spaces in between words not at end\\n         * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n         *  (word1 - word2) And (word2 - word3)\\n         */\\n        sb.setLength(0);\\n        while (start < words.length - 1) {\\n            sb.append(words[start++]).append(\" \");\\n        }\\n        // Appending the last word part of sentence\\n        sb.append(words[start]);\\n\\n        /**\\n         * Filling the rest position with extra spaces\\n         */\\n        while (sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        result.add(sb.toString());\\n\\n        return result;\\n    }\\n    \\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/016be550-127a-490a-9021-3a5610a1fcb3_1646168702.7983997.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int start = 0, length = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            /**\\n             * Try to add words till its under maxWidth length\\n             */\\n            if (words[i].length() <= (maxWidth - length)) {\\n                // + 1 because after each word there should be a space\\n                length += words[i].length() + 1;\\n                continue;\\n            }\\n            /**\\n             * Process the words which can be part of the justified sentence\\n             */\\n            else {\\n                /**\\n                 * Intention is try to get the remaining Spaces number and number of words part of the sentence\\n                 * As we have to distribute the spaces as evenly as possible, we can figure put the in between spaces\\n                 * between the words by doing remainingSpaces / noOfWords\\n                 * and there is a possibility that after evenly distributed the spaces also there can be some extra spaces\\n                 * which are pending.\\n                 *  Like for an example\\n                 *      remainingSpaces = 8 and noOfWords = 3\\n                 *      So in between spaces will be 8 / 3 = 2 spaces. But still 8 - (3 * 2) = 2 spaces are remaining\\n                 *      As per the problem those spaces can be placed sequentially between the words (till possible)\\n                 */\\n\\n                /**\\n                 * Adding + 1 because none of the justified sentence should end with \" \" (space) and we have added space\\n                 * for each word while calculating the length of the words. So, just removing the space after last word\\n                 */\\n                int remainingSpaces = maxWidth - length + 1;\\n\\n                /**\\n                 * Decreasing the number of word by 1 because\\n                 * If for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 *  There should not be any trailing spaces.\\n                 */\\n                int noOfWords = i - start - 1;\\n                int extraSpaceBetweenWords = 0;\\n\\n                if (noOfWords > 0) {\\n                    extraSpaceBetweenWords = remainingSpaces / noOfWords;\\n                    remainingSpaces = remainingSpaces % noOfWords;\\n                }\\n\\n                /**\\n                 * Append the word, extra space & remainingSpaces (if present)\\n                 * Iterating till (i - 1) position as we want to add those extra spaces in between words not at end\\n                 * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 */\\n                while (start < i - 1) {\\n                    sb.append(words[start++]).append(\" \");\\n                    int k = 0;\\n                    while (k < extraSpaceBetweenWords) {\\n                        sb.append(\" \");\\n                        k++;\\n                    }\\n                    if (remainingSpaces > 0) {\\n                        sb.append(\" \");\\n                        remainingSpaces--;\\n                    }\\n                }\\n                // Appending the last word part of sentence\\n                sb.append(words[start]);\\n\\n                /**\\n                 *  This will execute only for the cases where there is only 1 word part of the sentence\\n                 *  and its not covered as part of the previous while loop\\n                 */\\n                while (remainingSpaces > 0) {\\n                    sb.append(\" \");\\n                    remainingSpaces--;\\n                }\\n                result.add(sb.toString());\\n\\n                /**\\n                 * reset start position to current position\\n                 * update the length of the current word\\n                 * resetting the StringBuilder\\n                 */\\n                start = i;\\n                length = words[i].length() + 1;\\n                sb.setLength(0);\\n            }\\n        }\\n\\n        /**\\n         * Processing the last sentence, which should be left-justified and no extra space is inserted between words.\\n         *\\n         * Iterating till (words.length - 1) position as we want to add those extra spaces in between words not at end\\n         * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n         *  (word1 - word2) And (word2 - word3)\\n         */\\n        sb.setLength(0);\\n        while (start < words.length - 1) {\\n            sb.append(words[start++]).append(\" \");\\n        }\\n        // Appending the last word part of sentence\\n        sb.append(words[start]);\\n\\n        /**\\n         * Filling the rest position with extra spaces\\n         */\\n        while (sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        result.add(sb.toString());\\n\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495455,
                "title": "simple-10-lines-c-solution-0ms-100-8-9mb-100",
                "content": "For the current line, the idea is to select a number of words based on their length. The selection is represented by the interval `[i,j)`. Each time a word is selected, we reduce the remaining `room`, until the next word doesn\\'t fit the line.\\n\\nThen, we compute the `gap` as the **quotient** of the `room` and the number of words *minus one* (`gap = room / (j - i - 1)`). There is possibly remaining `room` as the **remainder** of this division isn\\'t necessarily null (`room -= gap * (j - i - 1)`) . Therefore we add `gap + 1` spaces for the `room` first gaps and `gap` spaces for the others, i.e. `gap + (room-- > 0 ? 1 : 0)`.\\n\\nOnce the line is done (`i == j`), we start a new line and this until all words have been consumed (`i == n`).\\n\\n**Note :** One should pay attention that the *last* word of a line is treated differently.\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size(), room, gap;\\n        vector<string> text;\\n        \\n        for (int i = 0, j = 0; i < n;) { // Two pointers i and j\\n            for (room = maxWidth; j < n and room >= j - i + words[j].length();) // While there is enough room\\n                room -= words[j++].length();\\n\\n            gap = (j - i == 1) or (j == n) ? 0 : room / (j - i - 1); // If one word or last line gap is null\\n            room -= gap * (j - i - 1); // Remainder\\n            \\n            text.push_back(\"\");\\n            while (i < j - 1)\\n                text.back().append(words[i++]).append(gap + (room-- > 0 ? 1 : 0), \\' \\');\\n            text.back().append(words[i++]).append(max(room, 0), \\' \\');\\n        }\\n        \\n        return text;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size(), room, gap;\\n        vector<string> text;\\n        \\n        for (int i = 0, j = 0; i < n;) { // Two pointers i and j\\n            for (room = maxWidth; j < n and room >= j - i + words[j].length();) // While there is enough room\\n                room -= words[j++].length();\\n\\n            gap = (j - i == 1) or (j == n) ? 0 : room / (j - i - 1); // If one word or last line gap is null\\n            room -= gap * (j - i - 1); // Remainder\\n            \\n            text.push_back(\"\");\\n            while (i < j - 1)\\n                text.back().append(words[i++]).append(gap + (room-- > 0 ? 1 : 0), \\' \\');\\n            text.back().append(words[i++]).append(max(room, 0), \\' \\');\\n        }\\n        \\n        return text;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24898,
                "title": "short-javascript-o-n-solution",
                "content": "The two-pass version where we preprocess the words into rows is easier to understand:\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [[]];\\n    res[0].letters = 0;\\n    for (let word of words) {\\n        let row = res[res.length - 1];\\n        if (row.length && row.letters + row.length + word.length > maxWidth) {\\n            res.push([]);\\n            row = res[res.length - 1];\\n            row.letters = 0;\\n        }\\n        row.push(word);\\n        row.letters += word.length;\\n    }\\n    for (let r = 0; r < res.length; r++) {\\n        let row = res[r];\\n        if (row.length === 1 || r === res.length - 1) {\\n            res[r] = row.join(' ') + ' '.repeat(maxWidth - row.letters - row.length + 1);\\n            continue;\\n        }\\n        let line = row[0];\\n        let spaces = maxWidth - row.letters;\\n        let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n        let addSpace = spaces % (row.length - 1);\\n        for (let w = 1; w < row.length; w++) {\\n            line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n        }\\n        res[r] = line;\\n    }\\n    return res;\\n};\\n```\\nWe can also do this in one pass:\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    for (let res = [[]], i = 0, letters = 0; i <= words.length; letters += words[i++].length) {\\n        let row = res[res.length - 1];\\n        if (i === words.length || row.length && letters + row.length + words[i].length > maxWidth) {\\n            if (row.length === 1 || i === words.length) {\\n                res[res.length - 1] = row.join(' ') + ' '.repeat(maxWidth - letters - row.length + 1);\\n                if (i === words.length) return res;\\n            } else {\\n                let line = row[0];\\n                let spaces = maxWidth - letters;\\n                let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n                let addSpace = spaces % (row.length - 1);\\n                for (let w = 1; w < row.length; w++) {\\n                    line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n                }\\n                res[res.length - 1] = line;\\n            }\\n            res.push([]);\\n            letters = 0;\\n        }\\n        res[res.length - 1].push(words[i]);\\n    }\\n};\\n```\\nI prefer the longer version, as there isn't any speed/space advantage either way.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [[]];\\n    res[0].letters = 0;\\n    for (let word of words) {\\n        let row = res[res.length - 1];\\n        if (row.length && row.letters + row.length + word.length > maxWidth) {\\n            res.push([]);\\n            row = res[res.length - 1];\\n            row.letters = 0;\\n        }\\n        row.push(word);\\n        row.letters += word.length;\\n    }\\n    for (let r = 0; r < res.length; r++) {\\n        let row = res[r];\\n        if (row.length === 1 || r === res.length - 1) {\\n            res[r] = row.join(' ') + ' '.repeat(maxWidth - row.letters - row.length + 1);\\n            continue;\\n        }\\n        let line = row[0];\\n        let spaces = maxWidth - row.letters;\\n        let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n        let addSpace = spaces % (row.length - 1);\\n        for (let w = 1; w < row.length; w++) {\\n            line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n        }\\n        res[r] = line;\\n    }\\n    return res;\\n};\\n```\n```\\nvar fullJustify = function(words, maxWidth) {\\n    for (let res = [[]], i = 0, letters = 0; i <= words.length; letters += words[i++].length) {\\n        let row = res[res.length - 1];\\n        if (i === words.length || row.length && letters + row.length + words[i].length > maxWidth) {\\n            if (row.length === 1 || i === words.length) {\\n                res[res.length - 1] = row.join(' ') + ' '.repeat(maxWidth - letters - row.length + 1);\\n                if (i === words.length) return res;\\n            } else {\\n                let line = row[0];\\n                let spaces = maxWidth - letters;\\n                let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n                let addSpace = spaces % (row.length - 1);\\n                for (let w = 1; w < row.length; w++) {\\n                    line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n                }\\n                res[res.length - 1] = line;\\n            }\\n            res.push([]);\\n            letters = 0;\\n        }\\n        res[res.length - 1].push(words[i]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24962,
                "title": "15-line-python-solution-40ms",
                "content": "    def fullJustify(self, words, maxWidth):\\n        i, N, result = 0, len(words), []\\n        while i < N:\\n            # decide how many words to be put in one line\\n            oneLine, j, currWidth, positionNum, spaceNum = [words[i]], i + 1, len(words[i]), 0, maxWidth - len(words[i])\\n            while j < N and currWidth + 1 + len(words[j]) <= maxWidth:\\n                oneLine.append(words[j])\\n                currWidth += 1 + len(words[j])\\n                spaceNum -= len(words[j])\\n                positionNum, j = positionNum + 1, j + 1\\n            i = j\\n            # decide the layout of one line\\n            if i < N and positionNum:\\n                spaces = [' ' * (spaceNum / positionNum + (k < spaceNum % positionNum)) for k in range(positionNum)] + ['']\\n            else: # last line or the line only has one word\\n                spaces = [' '] * positionNum + [' ' * (maxWidth - currWidth)]\\n            result.append(''.join([s for pair in zip(oneLine, spaces) for s in pair]))\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def fullJustify(self, words, maxWidth):\\n        i, N, result = 0, len(words), []\\n        while i < N:\\n            # decide how many words to be put in one line\\n            oneLine, j, currWidth, positionNum, spaceNum = [words[i]], i + 1, len(words[i]), 0, maxWidth - len(words[i])\\n            while j < N and currWidth + 1 + len(words[j]) <= maxWidth:\\n                oneLine.append(words[j])\\n                currWidth += 1 + len(words[j])\\n                spaceNum -= len(words[j])\\n                positionNum, j = positionNum + 1, j + 1\\n            i = j\\n            # decide the layout of one line\\n            if i < N and positionNum:\\n                spaces = [' ' * (spaceNum / positionNum + (k < spaceNum % positionNum)) for k in range(positionNum)] + ['']\\n            else: # last line or the line only has one word\\n                spaces = [' '] * positionNum + [' ' * (maxWidth - currWidth)]\\n            result.append(''.join([s for pair in zip(oneLine, spaces) for s in pair]))\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 3952295,
                "title": "ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nThe algorithm justifies a given list of words into lines with a specified maximum width. It iterates through the words, adding them to a line if they fit within the width limit, or starts a new line if not. After splitting the text into lines, it evenly distributes extra spaces among words to justify the lines, ensuring the last line is left-justified. The final justified lines are returned as a result.\\n\\n---\\n\\n\\n# Solution Video\\nUsually, I put a video to visualize solution but today I have to go on business trip and come back at late night. Please subscribe to my channel from URL below and don\\'t miss my latest solution videos in the future.\\n\\nI have 247 videos as of August 24th, 2023. Currently there are 2,071 subscribers.\\n\\n\\u25A0 Subscribe URL\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. **Initialization of Variables:**\\n   - Initialize an empty list `result` to store the final justified lines.\\n   - Initialize an empty list `line` to temporarily store words for the current line being processed.\\n   - Initialize an integer variable `line_length` to track the length of words in the current line.\\n\\n2. **Loop through Words:**\\n   - Loop through each word in the `words` list.\\n   - Check if adding the current `word` to the current line would exceed the `maxWidth` for the line.\\n   - If the addition doesn\\'t exceed, append the `word` to the `line` and update the `line_length` accordingly.\\n   - If the addition exceeds, append the current `line` to the `result`, start a new line with the current `word`, and update `line_length`.\\n\\n3. **Append Last Line:**\\n   - Append the last `line` to the `result`.\\n\\n4. **Initialization for Justified Lines:**\\n   - Initialize an empty list `justified_lines` to store the lines after justification.\\n\\n5. **Loop through Lines for Justification:**\\n   - Loop through each line in `result` except the last one (from 0 to `len(result) - 2`).\\n   - Get the current `line` from the `result`.\\n   - Calculate the total number of words in the `line` as `num_words`.\\n   - Calculate the total number of spaces available for justification as `num_spaces` by subtracting the sum of lengths of words in the line from `maxWidth`.\\n\\n6. **Handle Zero Space Gaps:**\\n   - Calculate the number of space gaps (`space_gaps`) by taking the maximum of `num_words - 1` and 1 (to ensure there\\'s at least one gap).\\n\\n7. **Calculate Spaces per Gap:**\\n   - Calculate the number of spaces per gap (`spaces_per_gap`) by performing integer division `num_spaces // space_gaps`.\\n\\n8. **Calculate Extra Spaces:**\\n   - Calculate the remaining extra spaces (`extra_spaces`) after distributing spaces evenly among gaps using modulo `num_spaces % space_gaps`.\\n\\n9. **Building Justified Line:**\\n   - Initialize an empty string `justified_line` to build the justified line.\\n   - Iterate through each `word` in the `line`.\\n   - Concatenate the `word` to the `justified_line`.\\n   - Check if there are more spaces to distribute (`space_gaps > 0`).\\n   - If yes, calculate the number of spaces to add (`spaces_to_add`) by adding `spaces_per_gap` and an extra space if `extra_spaces` is greater than 0.\\n   - Concatenate the calculated number of spaces to the `justified_line`.\\n   - Decrement `extra_spaces` and `space_gaps`.\\n\\n10. **Append Justified Line:**\\n    - Append the `justified_line` to the `justified_lines` list.\\n\\n11. **Construct the Last Line:**\\n    - Join the words in the last `result` line with a single space to form the `last_line`.\\n    - Add the required number of spaces at the end to make the total length `maxWidth`.\\n\\n12. **Append Last Line to Justified Lines:**\\n    - Append the `last_line` to the `justified_lines` list.\\n\\n13. **Return Justified Lines:**\\n    - Return the list of `justified_lines`.\\n\\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []  # To store the final justified lines\\n        line = []    # To temporarily store words for current line\\n        line_length = 0  # To track the length of the words in the current line\\n        \\n        # Loop through each word in the input words list\\n        for word in words:\\n            # Check if adding the current word exceeds the maxWidth for the line\\n            if line_length + len(line) + len(word) <= maxWidth:\\n                line.append(word)  # Add the word to the line\\n                line_length += len(word)  # Update the line length\\n            else:\\n                result.append(line)  # Add the words in the line to the result\\n                line = [word]  # Start a new line with the current word\\n                line_length = len(word)  # Set the line length to the word\\'s length\\n        \\n        result.append(line)  # Append the last line to the result\\n        \\n        justified_lines = []\\n        \\n        # Loop through each line except the last one\\n        for i in range(len(result) - 1):\\n            line = result[i]\\n            num_words = len(line)\\n            num_spaces = maxWidth - sum(len(word) for word in line)\\n            \\n            # Handle the case when space_gaps is zero\\n            space_gaps = max(num_words - 1, 1)\\n            \\n            spaces_per_gap = num_spaces // space_gaps\\n            extra_spaces = num_spaces % space_gaps\\n\\n            justified_line = \"\"\\n            \\n            # Iterate through each word in the line\\n            for word in line:\\n                justified_line += word\\n                \\n                # Check if there are more spaces to distribute\\n                if space_gaps > 0:\\n                    spaces_to_add = spaces_per_gap + (1 if extra_spaces > 0 else 0)\\n                    justified_line += \" \" * spaces_to_add\\n                    extra_spaces -= 1\\n                    space_gaps -= 1\\n\\n            justified_lines.append(justified_line)\\n\\n        last_line = \" \".join(result[-1])\\n        last_line += \" \" * (maxWidth - len(last_line))\\n        justified_lines.append(last_line)\\n\\n        return justified_lines\\n```\\n```javascript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const result = [];\\n    let line = [];\\n    let lineLength = 0;\\n\\n    for (const word of words) {\\n        if (lineLength + line.length + word.length <= maxWidth) {\\n            line.push(word);\\n            lineLength += word.length;\\n        } else {\\n            result.push(line);\\n            line = [word];\\n            lineLength = word.length;\\n        }\\n    }\\n\\n    result.push(line);\\n\\n    const justifiedLines = [];\\n    for (let i = 0; i < result.length - 1; i++) {\\n        line = result[i];\\n        const numWords = line.length;\\n        const numSpaces = maxWidth - line.reduce((acc, word) => acc + word.length, 0);\\n\\n        let spaceGaps = Math.max(numWords - 1, 1);\\n        const spacesPerGap = Math.floor(numSpaces / spaceGaps);\\n        let extraSpaces = numSpaces % spaceGaps;\\n\\n        let justifiedLine = \"\";\\n        for (const word of line) {\\n            justifiedLine += word;\\n\\n            if (spaceGaps > 0) {\\n                const spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                justifiedLine += \" \".repeat(spacesToAdd);\\n                extraSpaces -= 1;\\n                spaceGaps -= 1;\\n            }\\n        }\\n\\n        justifiedLines.push(justifiedLine);\\n    }\\n\\n    const lastLine = result[result.length - 1].join(\" \");\\n    justifiedLines.push(lastLine + \" \".repeat(maxWidth - lastLine.length));\\n\\n    return justifiedLines;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> result = new ArrayList<>();\\n        List<String> line = new ArrayList<>();\\n        int lineLength = 0;\\n\\n        for (String word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.add(word);\\n                lineLength += word.length();\\n            } else {\\n                result.add(line);\\n                line = new ArrayList<>();\\n                line.add(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.add(line);\\n\\n        List<String> justifiedLines = new ArrayList<>();\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result.get(i);\\n            int numWords = line.size();\\n            int numSpaces = maxWidth - line.stream().mapToInt(String::length).sum();\\n\\n            int spaceGaps = Math.max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            StringBuilder justifiedLine = new StringBuilder();\\n            for (String word : line) {\\n                justifiedLine.append(word);\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine.append(\" \".repeat(spacesToAdd));\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.add(justifiedLine.toString());\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", result.get(result.size() - 1)));\\n        lastLine.append(\" \".repeat(maxWidth - lastLine.length()));\\n        justifiedLines.add(lastLine.toString());\\n\\n        return justifiedLines;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        std::vector<std::vector<std::string>> result;\\n        std::vector<std::string> line;\\n        int lineLength = 0;\\n\\n        for (const std::string& word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.push_back(word);\\n                lineLength += word.length();\\n            } else {\\n                result.push_back(line);\\n                line.clear();\\n                line.push_back(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.push_back(line);\\n\\n        std::vector<std::string> justifiedLines;\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result[i];\\n            int numWords = line.size();\\n            int numSpaces = maxWidth;\\n            for (const std::string& word : line) {\\n                numSpaces -= word.length();\\n            }\\n\\n            int spaceGaps = std::max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            std::string justifiedLine = \"\";\\n            for (const std::string& word : line) {\\n                justifiedLine += word;\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine += std::string(spacesToAdd, \\' \\');\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.push_back(justifiedLine);\\n        }\\n\\n        std::string lastLine = \"\";\\n        for (const std::string& word : result[result.size() - 1]) {\\n            lastLine += word + \" \";\\n        }\\n        lastLine.pop_back();\\n        lastLine += std::string(maxWidth - lastLine.length(), \\' \\');\\n        justifiedLines.push_back(lastLine);\\n\\n        return justifiedLines;      \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []  # To store the final justified lines\\n        line = []    # To temporarily store words for current line\\n        line_length = 0  # To track the length of the words in the current line\\n        \\n        # Loop through each word in the input words list\\n        for word in words:\\n            # Check if adding the current word exceeds the maxWidth for the line\\n            if line_length + len(line) + len(word) <= maxWidth:\\n                line.append(word)  # Add the word to the line\\n                line_length += len(word)  # Update the line length\\n            else:\\n                result.append(line)  # Add the words in the line to the result\\n                line = [word]  # Start a new line with the current word\\n                line_length = len(word)  # Set the line length to the word\\'s length\\n        \\n        result.append(line)  # Append the last line to the result\\n        \\n        justified_lines = []\\n        \\n        # Loop through each line except the last one\\n        for i in range(len(result) - 1):\\n            line = result[i]\\n            num_words = len(line)\\n            num_spaces = maxWidth - sum(len(word) for word in line)\\n            \\n            # Handle the case when space_gaps is zero\\n            space_gaps = max(num_words - 1, 1)\\n            \\n            spaces_per_gap = num_spaces // space_gaps\\n            extra_spaces = num_spaces % space_gaps\\n\\n            justified_line = \"\"\\n            \\n            # Iterate through each word in the line\\n            for word in line:\\n                justified_line += word\\n                \\n                # Check if there are more spaces to distribute\\n                if space_gaps > 0:\\n                    spaces_to_add = spaces_per_gap + (1 if extra_spaces > 0 else 0)\\n                    justified_line += \" \" * spaces_to_add\\n                    extra_spaces -= 1\\n                    space_gaps -= 1\\n\\n            justified_lines.append(justified_line)\\n\\n        last_line = \" \".join(result[-1])\\n        last_line += \" \" * (maxWidth - len(last_line))\\n        justified_lines.append(last_line)\\n\\n        return justified_lines\\n```\n```javascript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const result = [];\\n    let line = [];\\n    let lineLength = 0;\\n\\n    for (const word of words) {\\n        if (lineLength + line.length + word.length <= maxWidth) {\\n            line.push(word);\\n            lineLength += word.length;\\n        } else {\\n            result.push(line);\\n            line = [word];\\n            lineLength = word.length;\\n        }\\n    }\\n\\n    result.push(line);\\n\\n    const justifiedLines = [];\\n    for (let i = 0; i < result.length - 1; i++) {\\n        line = result[i];\\n        const numWords = line.length;\\n        const numSpaces = maxWidth - line.reduce((acc, word) => acc + word.length, 0);\\n\\n        let spaceGaps = Math.max(numWords - 1, 1);\\n        const spacesPerGap = Math.floor(numSpaces / spaceGaps);\\n        let extraSpaces = numSpaces % spaceGaps;\\n\\n        let justifiedLine = \"\";\\n        for (const word of line) {\\n            justifiedLine += word;\\n\\n            if (spaceGaps > 0) {\\n                const spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                justifiedLine += \" \".repeat(spacesToAdd);\\n                extraSpaces -= 1;\\n                spaceGaps -= 1;\\n            }\\n        }\\n\\n        justifiedLines.push(justifiedLine);\\n    }\\n\\n    const lastLine = result[result.length - 1].join(\" \");\\n    justifiedLines.push(lastLine + \" \".repeat(maxWidth - lastLine.length));\\n\\n    return justifiedLines;    \\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> result = new ArrayList<>();\\n        List<String> line = new ArrayList<>();\\n        int lineLength = 0;\\n\\n        for (String word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.add(word);\\n                lineLength += word.length();\\n            } else {\\n                result.add(line);\\n                line = new ArrayList<>();\\n                line.add(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.add(line);\\n\\n        List<String> justifiedLines = new ArrayList<>();\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result.get(i);\\n            int numWords = line.size();\\n            int numSpaces = maxWidth - line.stream().mapToInt(String::length).sum();\\n\\n            int spaceGaps = Math.max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            StringBuilder justifiedLine = new StringBuilder();\\n            for (String word : line) {\\n                justifiedLine.append(word);\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine.append(\" \".repeat(spacesToAdd));\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.add(justifiedLine.toString());\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", result.get(result.size() - 1)));\\n        lastLine.append(\" \".repeat(maxWidth - lastLine.length()));\\n        justifiedLines.add(lastLine.toString());\\n\\n        return justifiedLines;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        std::vector<std::vector<std::string>> result;\\n        std::vector<std::string> line;\\n        int lineLength = 0;\\n\\n        for (const std::string& word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.push_back(word);\\n                lineLength += word.length();\\n            } else {\\n                result.push_back(line);\\n                line.clear();\\n                line.push_back(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.push_back(line);\\n\\n        std::vector<std::string> justifiedLines;\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result[i];\\n            int numWords = line.size();\\n            int numSpaces = maxWidth;\\n            for (const std::string& word : line) {\\n                numSpaces -= word.length();\\n            }\\n\\n            int spaceGaps = std::max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            std::string justifiedLine = \"\";\\n            for (const std::string& word : line) {\\n                justifiedLine += word;\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine += std::string(spacesToAdd, \\' \\');\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.push_back(justifiedLine);\\n        }\\n\\n        std::string lastLine = \"\";\\n        for (const std::string& word : result[result.size() - 1]) {\\n            lastLine += word + \" \";\\n        }\\n        lastLine.pop_back();\\n        lastLine += std::string(maxWidth - lastLine.length(), \\' \\');\\n        justifiedLines.push_back(lastLine);\\n\\n        return justifiedLines;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048424,
                "title": "short-python-code-with-explanation",
                "content": "If you like my code, please hit ^ button. \\uD83D\\uDE0A Good luck at the interview!\\n```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        # We\\'ll pop from words so reversing it first\\n        words = list(reversed(words))\\n        result = []\\n        \\n        while words:\\n            line = []\\n            \\n            # while the next word, wont be too much, I keep adding\\n            while words and len(\\'\\'.join(line)) + len(words[-1]) <= maxWidth:        \\n                line.append(words.pop() + \\' \\')\\n                \\n            # fixing the last word by removing extra space\\n            line[-1] = line[-1][:-1]\\n                \\n            # if last line or single word, I\\'ll just left justify the line\\n            if not words or len(line) == 1:\\n                result.append(\\'\\'.join(line).ljust(maxWidth))\\n                \\n            # otherwise, I\\'ll add spaces to all words except to last one\\n            # until we reach the desired maxWidth\\n            else:\\n                n = len(\\'\\'.join(line))\\n                while n < maxWidth:\\n                    for i in range(len(line) -1):\\n                        if n == maxWidth: break\\n                        line[i] += \\' \\'\\n                        n += 1\\n                        \\n                result.append(\\'\\'.join(line))\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        # We\\'ll pop from words so reversing it first\\n        words = list(reversed(words))\\n        result = []\\n        \\n        while words:\\n            line = []\\n            \\n            # while the next word, wont be too much, I keep adding\\n            while words and len(\\'\\'.join(line)) + len(words[-1]) <= maxWidth:        \\n                line.append(words.pop() + \\' \\')\\n                \\n            # fixing the last word by removing extra space\\n            line[-1] = line[-1][:-1]\\n                \\n            # if last line or single word, I\\'ll just left justify the line\\n            if not words or len(line) == 1:\\n                result.append(\\'\\'.join(line).ljust(maxWidth))\\n                \\n            # otherwise, I\\'ll add spaces to all words except to last one\\n            # until we reach the desired maxWidth\\n            else:\\n                n = len(\\'\\'.join(line))\\n                while n < maxWidth:\\n                    for i in range(len(line) -1):\\n                        if n == maxWidth: break\\n                        line[i] += \\' \\'\\n                        n += 1\\n                        \\n                result.append(\\'\\'.join(line))\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952704,
                "title": "100-fast-easy-greedy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**The key intuition behind this problem is to understand how to distribute the spaces between words in each line in order to achieve both left and right justification.**\\n\\nSee the code you will be easily understand.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int start = 0;\\n\\n        while (start <words.size()) {\\n            int end = start;\\n            int lineLength = words[end].length();\\n\\n            while (end + 1 < words.size() && lineLength + words[end + 1].length() + (end + 1 - start) <= maxWidth) {\\n                ++end;\\n                lineLength += words[end].length();\\n            }\\n\\n            string line = words[start];\\n            int numWords = end - start;\\n\\n            if (end == words.size() - 1 || numWords == 0) { // Left justify for last line or single word line\\n                for (int i = start + 1; i <= end; ++i) {\\n                    line += \" \" + words[i];\\n                }\\n                line += string(maxWidth - line.length(), \\' \\');\\n            } else {\\n                int totalSpaces = maxWidth - lineLength;\\n                int spacesBetweenWords = totalSpaces / numWords;\\n                int extraSpaces = totalSpaces % numWords;\\n\\n                for (int i = start + 1; i <= end; ++i) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line += string(spaces, \\' \\') + words[i];\\n                }\\n            }\\n\\n            result.push_back(line);\\n            start = end + 1;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\\n# PLS UPVOTE IF HELPFUL.",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int start = 0;\\n\\n        while (start <words.size()) {\\n            int end = start;\\n            int lineLength = words[end].length();\\n\\n            while (end + 1 < words.size() && lineLength + words[end + 1].length() + (end + 1 - start) <= maxWidth) {\\n                ++end;\\n                lineLength += words[end].length();\\n            }\\n\\n            string line = words[start];\\n            int numWords = end - start;\\n\\n            if (end == words.size() - 1 || numWords == 0) { // Left justify for last line or single word line\\n                for (int i = start + 1; i <= end; ++i) {\\n                    line += \" \" + words[i];\\n                }\\n                line += string(maxWidth - line.length(), \\' \\');\\n            } else {\\n                int totalSpaces = maxWidth - lineLength;\\n                int spacesBetweenWords = totalSpaces / numWords;\\n                int extraSpaces = totalSpaces % numWords;\\n\\n                for (int i = start + 1; i <= end; ++i) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line += string(spaces, \\' \\') + words[i];\\n                }\\n            }\\n\\n            result.push_back(line);\\n            start = end + 1;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778961,
                "title": "easy-modulated-c-solution-100-faster-no-kidding-with-comments",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\n// function to find the length of the words in the temp vector used to storing answer of every row\\nint findLen(vector<string> s) {\\n    int cnt = 0;\\n    for(auto it: s) {\\n        cnt += it.length();\\n    }\\n    return cnt;\\n}\\n\\n// function used to make the string -> more than 1 string in 1 row\\nstring makeString(vector<string> s, int div, int rem) {\\n    string news = \"\";\\n    for(int i = 0; i < s.size(); i++) {\\n        news += s[i];\\n        if(i != s.size() - 1) {\\n            for(int j = 0; j < div; j++) news += \" \";\\n            if(rem > 0) {\\n                news += \" \";\\n                rem--;\\n            }\\n        }\\n    }\\n    return news;\\n}\\n\\n// function used to make the string -> 1 string in 1 row\\nstring makeStringOne(vector<string> temp, int maxWidth) {\\n    string s = \"\";\\n    for(int i = 0; i < temp.size(); i++) {\\n        s += temp[i];\\n        if(i != temp.size() - 1) s += \" \";\\n    }\\n    int left = maxWidth - s.length();\\n    while(left--) s += \" \";\\n    return s;\\n}\\n\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int n = words.size();\\n    vector<string> ans;\\n    vector<string> temp;\\n    int left = maxWidth;\\n    bool isFirst = true;\\n    for(int i = 0; i < n; i++) {\\n        // we\\'re checking the length of every word, if the length of the word plus the one space needed before it(if it\\'s not the first word) is less than equal to the length left, then we add it else we add it to the next row.\\n        int wordLen = words[i].length();\\n        if(isFirst && wordLen <= left) {\\n            temp.push_back(words[i]);\\n            left -= wordLen;\\n            isFirst = false;\\n        } else if(!isFirst && wordLen + 1 <= left) {\\n            temp.push_back(words[i]);\\n            left -= (wordLen + 1);\\n        } else {\\n            string s = \"\";\\n            int totalLen = findLen(temp);\\n            int spacesLeft = maxWidth - totalLen;\\n            int wordCount = temp.size();\\n            // if there is one word in the vector we add it specially as the spaces would be different than the ones with more than 1 word in the vector.\\n            if(wordCount == 1) {\\n                s = makeStringOne(temp, maxWidth); \\n            } else {\\n                int div = 0, rem = 0;\\n                div = spacesLeft / (wordCount - 1);\\n                if(spacesLeft % (wordCount-1) != 0)\\n                rem = spacesLeft % (wordCount-1);\\n                s = makeString(temp, div, rem);\\n            }\\n            ans.push_back(s); \\n            temp.clear();\\n            left = maxWidth;\\n            isFirst = true;\\n            i--;\\n        }\\n    }\\n    if(temp.size() > 0) {\\n        string s = \"\";\\n        s = makeStringOne(temp, maxWidth);\\n        ans.push_back(s);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\n// function to find the length of the words in the temp vector used to storing answer of every row\\nint findLen(vector<string> s) {\\n    int cnt = 0;\\n    for(auto it: s) {\\n        cnt += it.length();\\n    }\\n    return cnt;\\n}\\n\\n// function used to make the string -> more than 1 string in 1 row\\nstring makeString(vector<string> s, int div, int rem) {\\n    string news = \"\";\\n    for(int i = 0; i < s.size(); i++) {\\n        news += s[i];\\n        if(i != s.size() - 1) {\\n            for(int j = 0; j < div; j++) news += \" \";\\n            if(rem > 0) {\\n                news += \" \";\\n                rem--;\\n            }\\n        }\\n    }\\n    return news;\\n}\\n\\n// function used to make the string -> 1 string in 1 row\\nstring makeStringOne(vector<string> temp, int maxWidth) {\\n    string s = \"\";\\n    for(int i = 0; i < temp.size(); i++) {\\n        s += temp[i];\\n        if(i != temp.size() - 1) s += \" \";\\n    }\\n    int left = maxWidth - s.length();\\n    while(left--) s += \" \";\\n    return s;\\n}\\n\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int n = words.size();\\n    vector<string> ans;\\n    vector<string> temp;\\n    int left = maxWidth;\\n    bool isFirst = true;\\n    for(int i = 0; i < n; i++) {\\n        // we\\'re checking the length of every word, if the length of the word plus the one space needed before it(if it\\'s not the first word) is less than equal to the length left, then we add it else we add it to the next row.\\n        int wordLen = words[i].length();\\n        if(isFirst && wordLen <= left) {\\n            temp.push_back(words[i]);\\n            left -= wordLen;\\n            isFirst = false;\\n        } else if(!isFirst && wordLen + 1 <= left) {\\n            temp.push_back(words[i]);\\n            left -= (wordLen + 1);\\n        } else {\\n            string s = \"\";\\n            int totalLen = findLen(temp);\\n            int spacesLeft = maxWidth - totalLen;\\n            int wordCount = temp.size();\\n            // if there is one word in the vector we add it specially as the spaces would be different than the ones with more than 1 word in the vector.\\n            if(wordCount == 1) {\\n                s = makeStringOne(temp, maxWidth); \\n            } else {\\n                int div = 0, rem = 0;\\n                div = spacesLeft / (wordCount - 1);\\n                if(spacesLeft % (wordCount-1) != 0)\\n                rem = spacesLeft % (wordCount-1);\\n                s = makeString(temp, div, rem);\\n            }\\n            ans.push_back(s); \\n            temp.clear();\\n            left = maxWidth;\\n            isFirst = true;\\n            i--;\\n        }\\n    }\\n    if(temp.size() > 0) {\\n        string s = \"\";\\n        s = makeStringOne(temp, maxWidth);\\n        ans.push_back(s);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2082328,
                "title": "c-easy-to-understand-break-into-small-functions",
                "content": "May look a bit long but each function should be easy to understand\\n\\n```\\nclass Solution {\\nprivate:\\n    /*\\n    starts from words[index], try pack max number of words into a line\\n    return packed words in \"lineWords\"\\n    be aware \"index\" is passed as reference hence it will be changed for the entire solution\\n    */\\n    void packWords(const vector<string>& words, int maxWidth, int& index, vector<string>& lineWords) {\\n        while (index < words.size()) {\\n            int wordSize = words[index].size();\\n            if (wordSize > maxWidth) { // cant fit any more word\\n                break;\\n            }\\n            maxWidth -= words[index].size();\\n            --maxWidth; // count one space between words\\n            lineWords.push_back(words[index]);\\n            ++index; // point index to next available word\\n        }\\n    }\\n    \\n    /*\\n    justify words to left side for last line and for the line with only one word\\n    return justified result in \"line\"\\n    */\\n    void leftJustify(const vector<string>& words, int maxWidth, string& line) {\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append one space for each word, except last word\\n                line += \" \";\\n            }\\n        }\\n        \\n        // append spaces to fill up the line\\n        int extraSpaces = maxWidth - line.size();\\n        line.append(extraSpaces, \\' \\');\\n    }\\n    \\n    /*\\n    fully justify one line\\n    return justified result in \"line\"\\n    */\\n    void fullJustify(const vector<string>& words, int maxWidth, string& line) {\\n        if (words.size() == 1) { // for lines with only one word we should do left justify\\n            leftJustify(words, maxWidth, line);\\n            return;\\n        }\\n        \\n        int totalCharLen = 0;\\n        for (const auto& word : words) {\\n            totalCharLen += word.size();\\n        }\\n        \\n        int totalSpaces = maxWidth - totalCharLen;\\n        int spaceSize = totalSpaces / (words.size() - 1);\\n        int extraSpaces = totalSpaces % (words.size() - 1);\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append spaces for each word except last one\\n                line.append(spaceSize, \\' \\');\\n                if (extraSpaces > 0) {\\n                    line += \" \";\\n                    --extraSpaces;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        string line = \"\";\\n        vector<string> lineWords; // words to fit into each line\\n        int index = 0;\\n        while (index < words.size()) { // loop through all words\\n            packWords(words, maxWidth, index, lineWords);\\n            if (index < words.size()) {\\n                fullJustify(lineWords, maxWidth, line);\\n            }\\n            else {\\n                leftJustify(lineWords, maxWidth, line);\\n            }\\n            output.push_back(line);\\n            \\n            // clear cache and start processing a new line\\n            line.clear();\\n            lineWords.clear();\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    /*\\n    starts from words[index], try pack max number of words into a line\\n    return packed words in \"lineWords\"\\n    be aware \"index\" is passed as reference hence it will be changed for the entire solution\\n    */\\n    void packWords(const vector<string>& words, int maxWidth, int& index, vector<string>& lineWords) {\\n        while (index < words.size()) {\\n            int wordSize = words[index].size();\\n            if (wordSize > maxWidth) { // cant fit any more word\\n                break;\\n            }\\n            maxWidth -= words[index].size();\\n            --maxWidth; // count one space between words\\n            lineWords.push_back(words[index]);\\n            ++index; // point index to next available word\\n        }\\n    }\\n    \\n    /*\\n    justify words to left side for last line and for the line with only one word\\n    return justified result in \"line\"\\n    */\\n    void leftJustify(const vector<string>& words, int maxWidth, string& line) {\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append one space for each word, except last word\\n                line += \" \";\\n            }\\n        }\\n        \\n        // append spaces to fill up the line\\n        int extraSpaces = maxWidth - line.size();\\n        line.append(extraSpaces, \\' \\');\\n    }\\n    \\n    /*\\n    fully justify one line\\n    return justified result in \"line\"\\n    */\\n    void fullJustify(const vector<string>& words, int maxWidth, string& line) {\\n        if (words.size() == 1) { // for lines with only one word we should do left justify\\n            leftJustify(words, maxWidth, line);\\n            return;\\n        }\\n        \\n        int totalCharLen = 0;\\n        for (const auto& word : words) {\\n            totalCharLen += word.size();\\n        }\\n        \\n        int totalSpaces = maxWidth - totalCharLen;\\n        int spaceSize = totalSpaces / (words.size() - 1);\\n        int extraSpaces = totalSpaces % (words.size() - 1);\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append spaces for each word except last one\\n                line.append(spaceSize, \\' \\');\\n                if (extraSpaces > 0) {\\n                    line += \" \";\\n                    --extraSpaces;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        string line = \"\";\\n        vector<string> lineWords; // words to fit into each line\\n        int index = 0;\\n        while (index < words.size()) { // loop through all words\\n            packWords(words, maxWidth, index, lineWords);\\n            if (index < words.size()) {\\n                fullJustify(lineWords, maxWidth, line);\\n            }\\n            else {\\n                leftJustify(lineWords, maxWidth, line);\\n            }\\n            output.push_back(line);\\n            \\n            // clear cache and start processing a new line\\n            line.clear();\\n            lineWords.clear();\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915710,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954308,
                "title": "100-faster-c-solution-beginner-friendly-two-pointer",
                "content": "# Do upvote, if it helped :)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### The idea here is to see how many words can be added to a line with only one space between the words, and then adding the required padding to the sentences, if needed. And left justify the last line of the paragraph.\\n\\n__Its is easy to understand that__ `n` __words on a line with require__`n-1`__space, at least. Now, if we have `k` words on a line and__ `maxWidth` __as__ `mw`__. Then the extra space available to us will be__ `mw` - `length of all words combine`, __say__ `extra space`.\\nNow This extra space has to be even distributed among the k words, i.e. in `k-1` spaces between the words.__\\n\\n__One more thing to note here is that if only one word can be accomodated in the line, then we just have to fill the rest of the line with spaces,__ `extra space`__.__\\n\\n##### Lets take an Example :\\n`Words: {\"This\",\"is\",\"my\",\"house\"}`, `maxWidth` __= 34\\nNow in order to check how many words can be placed in one line, we can traverse the entire array of words, and we can keep adding the words to a line till the following condition is satisfied:__ \\n\\n`curr_length of words` + `number of words - 1` <= `maxWidth`\\n\\n `number of words - 1` : This is used because we will be putting atleast one space between the words on the same line.\\n\\n__Once the we know the number of words, we can get the minimum spaces that has to be put between the words, For our example__\\n`Length of all words` = 13, `number of words` = 4;\\n__therefore, by the condition mentioned before, all the words can be placed in one line.__\\n`extra space` = `maxWidth` - `length of all words combined`\\n`extra space` = 35 - 13 = 22\\n__So 22 spaces are to filled in 3 blanks, between 4 words__\\npadding : Minimum spaces to be filled in between gaps to reach maxWidth\\n__`padding` = `extra space`/ `number of words - 1` = 22/3 = 7__\\n__We still have 1 space left, that needs to be adjusted, \\nconsider ut as `extra padding`, that is given by \\n`extra space` % `number of words - 1`__\\n__This means 1 extra space will be added to first `x` pairs,__\\n`x` = `extra padding`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n__We will be using a two pointer approach to add the words from the starting index to the ending index. To do this create two variables:\\n `start`: To track the index of the first word of the current line \\n`end` : To track the index of last word of the current line\\n`curr_len` : To store the current length of the sentence__\\n\\n\\n>## Traverse the array of words\\n> `wd` = `end - start + 1` __gives the number of words in the current line__\\n   `curr_len` = `length of the words in the line` + `wd`\\n__adding wd accounts for the minimum number of spaces between each pair of words(i.e. 1).__\\n>### If `curr_len`  + `size of the current word` <= `maxWidth`\\n>> __Add the size of current word to `curr_len`, and incresae the word count, by increasing `end` = `end + 1`__\\n> \\n> ### Else\\n>> __It\\'s time to fix the current line / sentence and move on to the next one__\\n>> __Start the `sentence` as the word at index `start`\\nCalculate the `extra_space` = `maxWidth` - `curr_len`\\n`padding` = `extra_space` / `max(1 , wd - 1)`\\n`extra` = `extra_space` % `max(1 , wd - 1)`__\\n>> ###### __Padding adding is the minimum space that will be added between each pair of words, even distribution__\\n>> ###### __Extra is the uneven distribution of space required to reach the `maxWidth` length__\\n>> __Traverse from index `start + 1` to `end`__\\n>>>__Add the padding to the `sentence`\\nAdd the extra padding\\nAdd the `curr_word`\\nIF there is only one word__\\n>>>> __Fill the rest of the line with space__\\n>>>\\n>>> __Add the `sentence` to the `ans` vector\\nSet :\\n`start` as `end + 1`, \\n`curr_len` = `curr_word.size()`, \\n`end` = `end + 1`__\\n>>\\n> #### __Once the Loop is exited, we are left with the last line, that is to be left-justified__\\n>__Start the `sentence` as the word at index `start`\\nTraverse from index `start + 1` to `end`__\\n>>__Add a space to the `sentence`\\nAdd the `curr_word`__\\n>\\n>__Fill the rest of the line with spaces\\nAdd the `sentence` to the `ans` vector\\nReturn the answer vector `ans`__\\n\\n# Complexity\\n- Time complexity: $$O(n*k*padding)$$ \\n   n = number of words\\n   k = max number of words that can be added in a line\\n   padding = minimum space between a pair of words\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/68402346-1a9f-44f3-847d-4f00250e0d6d_1692880996.3664916.png)\\n\\n\\n# Code\\n``` cpp []\\nclass Solution // 100% faster\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        // Vector to store the sentences\\n        vector<string> ans;\\n        int curr_len = 0, start = 0, end = -1;\\n        for (string s : words)\\n        {\\n            if ((end - start + 1) + curr_len + s.size() <= maxWidth)\\n                curr_len += s.size(), end++;\\n            else\\n            {\\n                // Start the current line as the word at index start\\n                string sentence = words[start];\\n                int extra_space = maxWidth - curr_len, padding = extra_space / max(1, end - start);\\n                // extra is the extra space that has to be adjusted so as to make the length equal to maxWidth\\n                int extra = extra_space % max(1, end - start);\\n                // Now add the words from \\'start index + 1\\' to \\'end index\\'\\n                for (int i = start + 1; i <= end; i++)\\n                {\\n                    // Add the padding first\\n                    for (int j = 0; j < padding; j++)\\n                        sentence += \" \";\\n                    // Add the xtra padding, if needed\\n                    if (extra)\\n                        sentence += \" \", extra--;\\n                    sentence += words[i];\\n                }\\n                // Just in case the sentence has only one word\\n                while (sentence.size() < maxWidth)\\n                    sentence += \" \";\\n                ans.push_back(sentence);\\n                // Set the current word as the starting point of the new line\\n                start = end + 1, curr_len = s.size(), end++;\\n            }\\n        }\\n        // Last line has to be dealt with a bit differently, i.e. left justified\\n        string sentence = words[start];\\n        for (int i = start + 1; i <= end; i++)\\n            sentence += \" \" + words[i];\\n        while (sentence.size() < maxWidth)\\n            sentence += \" \";\\n        ans.push_back(sentence);\\n        return ans;\\n    }\\n};\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/864f254a-ae64-4983-937e-f741badbc63b_1692881287.4776943.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "``` cpp []\\nclass Solution // 100% faster\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        // Vector to store the sentences\\n        vector<string> ans;\\n        int curr_len = 0, start = 0, end = -1;\\n        for (string s : words)\\n        {\\n            if ((end - start + 1) + curr_len + s.size() <= maxWidth)\\n                curr_len += s.size(), end++;\\n            else\\n            {\\n                // Start the current line as the word at index start\\n                string sentence = words[start];\\n                int extra_space = maxWidth - curr_len, padding = extra_space / max(1, end - start);\\n                // extra is the extra space that has to be adjusted so as to make the length equal to maxWidth\\n                int extra = extra_space % max(1, end - start);\\n                // Now add the words from \\'start index + 1\\' to \\'end index\\'\\n                for (int i = start + 1; i <= end; i++)\\n                {\\n                    // Add the padding first\\n                    for (int j = 0; j < padding; j++)\\n                        sentence += \" \";\\n                    // Add the xtra padding, if needed\\n                    if (extra)\\n                        sentence += \" \", extra--;\\n                    sentence += words[i];\\n                }\\n                // Just in case the sentence has only one word\\n                while (sentence.size() < maxWidth)\\n                    sentence += \" \";\\n                ans.push_back(sentence);\\n                // Set the current word as the starting point of the new line\\n                start = end + 1, curr_len = s.size(), end++;\\n            }\\n        }\\n        // Last line has to be dealt with a bit differently, i.e. left justified\\n        string sentence = words[start];\\n        for (int i = start + 1; i <= end; i++)\\n            sentence += \" \" + words[i];\\n        while (sentence.size() < maxWidth)\\n            sentence += \" \";\\n        ans.push_back(sentence);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952302,
                "title": "python-java-c-simple-solution",
                "content": "# ANNOUNCEMENT:\\n**Join the discord and don\\'t forget to Subscribe the youtube channel to access the premium content materials related to computer science and data science in the discord. (For Only first 10,000 Subscribers)**\\n\\n**Happy Learning,  Cheers Guys \\uD83D\\uDE0A**\\n\\n# Click the Link in my Profile to Subscribe\\n\\n# An UPVOTE will be encouraging \\uD83D\\uDC4D\\n\\n#Intuition\\n\\n- Initialize an empty result list to store the justified lines, an empty current line (cur), and a variable to keep track of the total number of letters in the current line (numOfLetters).\\n\\n- Iterate through the list of words one by one.\\n\\nFor each word:\\n\\n- Check if adding the word to the current line would exceed the maximum width. If it would, it\\'s time to justify the current line.\\n- Calculate the number of spaces that need to be added to distribute them evenly. This is done by finding the difference between the maximum width and the total number of letters in the current line.\\n- Distribute these spaces evenly among the words in the current line. The modulo operator is used to ensure that spaces are distributed evenly, even if there are more words than spaces.\\n- Add the justified line to the result list.\\n- Clear the current line and reset the numOfLetters counter.\\n- Continue adding words to the current line until you reach a point where adding the next word would exceed the maximum width.\\n\\n- For the last line of text, left-justify it by adding spaces between words. Ensure that the total width of the line matches the maximum width.\\n\\n- Return the list of justified lines as the final result.\\n\\n```Python []\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        result, cur, num_of_letters = [], [], 0\\n\\n        for word in words:\\n            if num_of_letters + len(word) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i % (len(cur) - 1 or 1)] += \\' \\'\\n                result.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n\\n            cur += [word]\\n            num_of_letters += len(word)\\n\\n        return result + [\\' \\'.join(cur).ljust(maxWidth)]\\n```\\n```Java []\\n\\npublic class TextJustification {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int numOfLetters = 0;\\n\\n        for (String word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur.set(i % (cur.size() - 1), cur.get(i % (cur.size() - 1)) + \" \");\\n                }\\n                result.add(String.join(\"\", cur));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.add(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        result.add(String.join(\" \", cur) + \" \".repeat(maxWidth - numOfLetters - cur.size() + 1));\\n\\n        return result;\\n    }\\n}\\n\\n```\\n```C++ []\\n\\nclass TextJustification {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> cur;\\n        int numOfLetters = 0;\\n\\n        for (const string& word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur[i % (cur.size() - 1)] += \\' \\';\\n                }\\n                result.push_back(accumulate(cur.begin(), cur.end(), string(\"\")));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.push_back(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        string lastLine = accumulate(cur.begin(), cur.end(), string(\" \"));\\n        lastLine += string(maxWidth - numOfLetters - cur.size() + 1, \\' \\');\\n        result.push_back(lastLine);\\n\\n        return result;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        result, cur, num_of_letters = [], [], 0\\n\\n        for word in words:\\n            if num_of_letters + len(word) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i % (len(cur) - 1 or 1)] += \\' \\'\\n                result.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n\\n            cur += [word]\\n            num_of_letters += len(word)\\n\\n        return result + [\\' \\'.join(cur).ljust(maxWidth)]\\n```\n```Java []\\n\\npublic class TextJustification {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int numOfLetters = 0;\\n\\n        for (String word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur.set(i % (cur.size() - 1), cur.get(i % (cur.size() - 1)) + \" \");\\n                }\\n                result.add(String.join(\"\", cur));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.add(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        result.add(String.join(\" \", cur) + \" \".repeat(maxWidth - numOfLetters - cur.size() + 1));\\n\\n        return result;\\n    }\\n}\\n\\n```\n```C++ []\\n\\nclass TextJustification {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> cur;\\n        int numOfLetters = 0;\\n\\n        for (const string& word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur[i % (cur.size() - 1)] += \\' \\';\\n                }\\n                result.push_back(accumulate(cur.begin(), cur.end(), string(\"\")));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.push_back(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        string lastLine = accumulate(cur.begin(), cur.end(), string(\" \"));\\n        lastLine += string(maxWidth - numOfLetters - cur.size() + 1, \\' \\');\\n        result.push_back(lastLine);\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300817,
                "title": "java-solution-with-comments-beats-100",
                "content": "```\\npublic List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;      //index of word in words array\\n        int wordsLen = 0;   // sum of all words that can be put in same line\\n        int spaces = 0;     // sapces that need to be filled\\n        \\n        while(index < words.length) {\\n            if((tempLen + words[index].length()) <= maxLen) {   //check if cur word can be put in cur line\\n                tempLen += words[index].length() + 1;\\n                tempList.add(words[index++]);\\n            }else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size();\\n                spaces = maxLen - wordsLen;\\n                if(tempList.size() == 1) {          // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0));\\n                    for(int i = 0; i < spaces; i++) {\\n                        sb.append(\" \");\\n                    }\\n                    ans.add(sb.toString());\\n                }else if(tempList.size() > 1){      // there\\'s many words in cur line, do the evenly spaceing\\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) {\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \");\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1));\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear();  \\n                tempLen = 0;\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) {\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++)\\n                  sb.append(\" \");\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;      //index of word in words array\\n        int wordsLen = 0;   // sum of all words that can be put in same line\\n        int spaces = 0;     // sapces that need to be filled\\n        \\n        while(index < words.length) {\\n            if((tempLen + words[index].length()) <= maxLen) {   //check if cur word can be put in cur line\\n                tempLen += words[index].length() + 1;\\n                tempList.add(words[index++]);\\n            }else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size();\\n                spaces = maxLen - wordsLen;\\n                if(tempList.size() == 1) {          // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0));\\n                    for(int i = 0; i < spaces; i++) {\\n                        sb.append(\" \");\\n                    }\\n                    ans.add(sb.toString());\\n                }else if(tempList.size() > 1){      // there\\'s many words in cur line, do the evenly spaceing\\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) {\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \");\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1));\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear();  \\n                tempLen = 0;\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) {\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++)\\n                  sb.append(\" \");\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1297598,
                "title": "the-first-hard-level-question-i-ve-ever-solved",
                "content": "The function reorderSpaces is basically a updated version of an easy level problem on leetcode (https://leetcode.com/problems/rearrange-spaces-between-words/) , if you haven\\'t solved that yet just go through it once.\\n```\\nclass Solution:\\n    def reorderSpaces(self, text: str) -> str:\\n        spaces = text.count(\" \")\\n        s = text.split(\" \")\\n        \\n        while \"\" in s :\\n            s.remove(\"\")\\n            \\n        if len(s) == 1:\\n            return s[0] + \" \"*spaces\\n        \\n        #min no of spaces between each word\\n        nsw = spaces//(len(s)-1)\\n        #no. of spaces left \\n        nsl = spaces%(len(s)-1)\\n        result = \"\"\\n        for i in range(len(s)) :\\n            if i != len(s)-1 :\\n                result += s[i] + (\" \")*nsw\\n                if nsl > 0:\\n                    result += \" \"\\n                    nsl -= 1\\n            else:\\n                result += s[i]  \\n        return result\\n            \\n\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        result = []\\n        \\n        last = words.pop(0)\\n        while words:\\n            if len(last) + len(words[0])  >= maxWidth :\\n                t = last + (\" \")*(maxWidth-len(last))\\n                last = words.pop(0)\\n                result.append(t)\\n            \\n            elif len(last) + len(words[0]) < maxWidth :\\n                last = last + \" \" + words.pop(0)             \\n        result.append(last + (\" \")*(maxWidth-len(last)))\\n        \\n        for i in range(len(result)-1):\\n            result[i] = self.reorderSpaces(result[i])\\n            \\n            \\n        return result          \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorderSpaces(self, text: str) -> str:\\n        spaces = text.count(\" \")\\n        s = text.split(\" \")\\n        \\n        while \"\" in s :\\n            s.remove(\"\")\\n            \\n        if len(s) == 1:\\n            return s[0] + \" \"*spaces\\n        \\n        #min no of spaces between each word\\n        nsw = spaces//(len(s)-1)\\n        #no. of spaces left \\n        nsl = spaces%(len(s)-1)\\n        result = \"\"\\n        for i in range(len(s)) :\\n            if i != len(s)-1 :\\n                result += s[i] + (\" \")*nsw\\n                if nsl > 0:\\n                    result += \" \"\\n                    nsl -= 1\\n            else:\\n                result += s[i]  \\n        return result\\n            \\n\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        result = []\\n        \\n        last = words.pop(0)\\n        while words:\\n            if len(last) + len(words[0])  >= maxWidth :\\n                t = last + (\" \")*(maxWidth-len(last))\\n                last = words.pop(0)\\n                result.append(t)\\n            \\n            elif len(last) + len(words[0]) < maxWidth :\\n                last = last + \" \" + words.pop(0)             \\n        result.append(last + (\" \")*(maxWidth-len(last)))\\n        \\n        for i in range(len(result)-1):\\n            result[i] = self.reorderSpaces(result[i])\\n            \\n            \\n        return result          \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065918,
                "title": "java-0ms-clean-code-with-fully-documentation",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // the final justified list of lines to return.\\n        List<String> justified = new ArrayList();\\n       \\n        // a queue to store all the words of a current line.\\n        Queue<String> currentLine = new LinkedList();\\n        \\n        // efficiently build a new line with a string builder.\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // keep track of all the lengths of each word on the current line (to compare to maxWidth).\\n        int currentLineLen = 0;\\n        \\n        for(String word : words){\\n            \\n            // track both the current words length and the count of all the words in the current line \\n            // (this count represents the single space between each word so far)\\n            int n = word.length();\\n            int m = currentLine.size();\\n            \\n            // if all the words so far in the line, plus a single space between each of them, plus the current word length is \\n            // less than or equal to the max width of a line, then add the current word to the current line.\\n            if(currentLineLen + n + m <= maxWidth){\\n                currentLine.add(word);\\n                currentLineLen += n;\\n            \\n            // otherwise, render the current line with the correct spacing between each word and start a new line with the current word.\\n            }else{\\n                int extraSpace = maxWidth - currentLineLen;\\n                justified.add(getLine(extraSpace, currentLine, sb));\\n                \\n                currentLine.add(word);\\n                sb.setLength(0);\\n                currentLineLen = n;\\n            }\\n        }\\n        \\n        // if after looping through each word, there are still words left in the current line\\n        // then add them to the justified list of lines through a special final string.\\n        if(!currentLine.isEmpty()){\\n            int remainingSpace = maxWidth - (currentLineLen + currentLine.size() - 1);\\n            justified.add(generateLastLine(remainingSpace, currentLine, sb));\\n        }\\n        \\n        return justified;\\n    }\\n    \\n    /**\\n     * This method renders a standard line (not the final line) by taking the total amount of space\\n     * left in the line an distributing the space as equally as possible between the words of the, but \\n     * giving words on the left more space between them than words on the right if the remaining free space\\n     * cant be split equally between all the words.\\n    **/\\n    private String getLine(int extraSpace, Queue<String> currentLine, StringBuilder sb){\\n        \\n        int wordCount = currentLine.size() - 1;\\n        \\n        boolean singleWordLine = wordCount == 0;\\n        \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n\\n            if(!currentLine.isEmpty() || singleWordLine){\\n                \\n                int currentSpace = !singleWordLine ? extraSpace / wordCount : extraSpace;\\n                \\n                if(!singleWordLine && extraSpace % wordCount != 0)\\n                    currentSpace++;\\n                \\n                addEmptySpace(currentSpace, sb);\\n                \\n                extraSpace -= currentSpace;\\n                wordCount--;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method renders the final line by placing a single space in between each word and then adding\\n     * any remaing empty space to the end of the line.\\n    **/ \\n    private String generateLastLine(int remainingSpace, Queue<String> currentLine, StringBuilder sb){\\n         \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n            \\n            if(!currentLine.isEmpty())\\n                sb.append(\" \");\\n        }\\n        \\n        if(remainingSpace > 0)\\n            addEmptySpace(remainingSpace, sb);\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method will add the number of empty spaces to the current string builder to match a given length.\\n    **/\\n    private void addEmptySpace(int len, StringBuilder sb){\\n        for(int i = 0; i < len; i++)\\n            sb.append(\" \");\\n    }\\n}\\n```\\n\\nruntime: O(n)\\nspace O(n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // the final justified list of lines to return.\\n        List<String> justified = new ArrayList();\\n       \\n        // a queue to store all the words of a current line.\\n        Queue<String> currentLine = new LinkedList();\\n        \\n        // efficiently build a new line with a string builder.\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // keep track of all the lengths of each word on the current line (to compare to maxWidth).\\n        int currentLineLen = 0;\\n        \\n        for(String word : words){\\n            \\n            // track both the current words length and the count of all the words in the current line \\n            // (this count represents the single space between each word so far)\\n            int n = word.length();\\n            int m = currentLine.size();\\n            \\n            // if all the words so far in the line, plus a single space between each of them, plus the current word length is \\n            // less than or equal to the max width of a line, then add the current word to the current line.\\n            if(currentLineLen + n + m <= maxWidth){\\n                currentLine.add(word);\\n                currentLineLen += n;\\n            \\n            // otherwise, render the current line with the correct spacing between each word and start a new line with the current word.\\n            }else{\\n                int extraSpace = maxWidth - currentLineLen;\\n                justified.add(getLine(extraSpace, currentLine, sb));\\n                \\n                currentLine.add(word);\\n                sb.setLength(0);\\n                currentLineLen = n;\\n            }\\n        }\\n        \\n        // if after looping through each word, there are still words left in the current line\\n        // then add them to the justified list of lines through a special final string.\\n        if(!currentLine.isEmpty()){\\n            int remainingSpace = maxWidth - (currentLineLen + currentLine.size() - 1);\\n            justified.add(generateLastLine(remainingSpace, currentLine, sb));\\n        }\\n        \\n        return justified;\\n    }\\n    \\n    /**\\n     * This method renders a standard line (not the final line) by taking the total amount of space\\n     * left in the line an distributing the space as equally as possible between the words of the, but \\n     * giving words on the left more space between them than words on the right if the remaining free space\\n     * cant be split equally between all the words.\\n    **/\\n    private String getLine(int extraSpace, Queue<String> currentLine, StringBuilder sb){\\n        \\n        int wordCount = currentLine.size() - 1;\\n        \\n        boolean singleWordLine = wordCount == 0;\\n        \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n\\n            if(!currentLine.isEmpty() || singleWordLine){\\n                \\n                int currentSpace = !singleWordLine ? extraSpace / wordCount : extraSpace;\\n                \\n                if(!singleWordLine && extraSpace % wordCount != 0)\\n                    currentSpace++;\\n                \\n                addEmptySpace(currentSpace, sb);\\n                \\n                extraSpace -= currentSpace;\\n                wordCount--;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method renders the final line by placing a single space in between each word and then adding\\n     * any remaing empty space to the end of the line.\\n    **/ \\n    private String generateLastLine(int remainingSpace, Queue<String> currentLine, StringBuilder sb){\\n         \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n            \\n            if(!currentLine.isEmpty())\\n                sb.append(\" \");\\n        }\\n        \\n        if(remainingSpace > 0)\\n            addEmptySpace(remainingSpace, sb);\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method will add the number of empty spaces to the current string builder to match a given length.\\n    **/\\n    private void addEmptySpace(int len, StringBuilder sb){\\n        for(int i = 0; i < len; i++)\\n            sb.append(\" \");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24885,
                "title": "share-my-ac-easy-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        if(maxWidth == 0) return {\"\"};\\n        int i = 0, j = 0;\\n        while(j != words.size()){\\n            int len = -1;\\n            while(j < words.size() && len + words[j].size() + 1 <= maxWidth)\\n                len += words[j++].size() + 1;\\n            int space = maxWidth - len + j - i - 1;\\n            int k = i;\\n            while(space){\\n                words[k++] += \" \";\\n                space--;\\n                if(j != words.size() && (k == j - 1 || k == j)) k = i;\\n                if(j == words.size() && k == j) k = j - 1;\\n            }\\n            string line = \"\";\\n            for(int l = i; l < j; l++)\\n                line += words[l];\\n            res.push_back(line);\\n            i = j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        if(maxWidth == 0) return {\"\"};\\n        int i = 0, j = 0;\\n        while(j != words.size()){\\n            int len = -1;\\n            while(j < words.size() && len + words[j].size() + 1 <= maxWidth)\\n                len += words[j++].size() + 1;\\n            int space = maxWidth - len + j - i - 1;\\n            int k = i;\\n            while(space){\\n                words[k++] += \" \";\\n                space--;\\n                if(j != words.size() && (k == j - 1 || k == j)) k = i;\\n                if(j == words.size() && k == j) k = j - 1;\\n            }\\n            string line = \"\";\\n            for(int l = i; l < j; l++)\\n                line += words[l];\\n            res.push_back(line);\\n            i = j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24969,
                "title": "long-but-working-dp-java-solution",
                "content": "This is based on Roy Tushar's solution. See https://www.youtube.com/watch?v=RORuwHiblPc\\n\\n\\n\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {    \\t\\n        \\n        List<String> results = new LinkedList<>();   \\n        \\n        if(words == null) {\\n            return results;\\n        }        \\n        \\n        int[][] costsMatrix = createCostMatrix(words, maxWidth);\\n        \\n        int len = words.length;\\n        \\n        int[] minCosts = new int[len];\\n        int[] paths = new int[len];\\n        \\n        Arrays.fill(minCosts, Integer.MAX_VALUE);\\n        \\n        for(int i = len-1; i >= 0; i--) {\\n            \\n            minCosts[i] = costsMatrix[i][len-1];\\n            paths[i] = len;         \\n            \\n            for(int j = i+1; j < len; j++) {\\n                \\n                if(costsMatrix[i][j-1] != Integer.MAX_VALUE &&\\n                    minCosts[j] + costsMatrix[i][j-1] < minCosts[i]) {\\n                    \\n                    minCosts[i] = minCosts[j] + costsMatrix[i][j-1];\\n                    paths[i] = j;                            \\n                }\\n            }            \\n        }\\n\\n        JustifierIterator iter = new JustifierIterator(words, paths, maxWidth);\\n        \\n        while(iter.hasNext()) {\\n            results.add(iter.next());\\n        }\\n        \\n        return results;        \\n    }\\n    \\n    private int[][] createCostMatrix(String[] words, int maxWidth) {\\n        \\n        int len = words.length;\\n        int[][] costMatrix = new int[len][len];\\n        \\n        for(int row = 0; row < len-1; row++) {\\n            \\n            int usedSpace = 0;\\n            Arrays.fill(costMatrix[row], Integer.MAX_VALUE);\\n            \\n            for(int col = row; col < len; col++) {\\n                \\n            \\tusedSpace += words[col].length();\\n                if(usedSpace <= maxWidth) {\\n                \\tif(col == len-1) {\\n                \\t\\tcostMatrix[row][col] = 0;\\n                \\t} else {                \\t\\n\\t                \\tint unusedSpace = maxWidth - usedSpace;\\n\\t                    costMatrix[row][col] = unusedSpace * unusedSpace;\\n                \\t}\\n                } else {\\n                \\tif(col > 0) {\\n                \\t\\tcostMatrix[row][col-1] = 0;\\n                \\t}\\n                    break;\\n                }\\n                usedSpace++;\\n            }                        \\n        }\\n        \\n        costMatrix[len-1][len-1] = 0;\\n        \\n        return costMatrix;\\n    }\\n    \\n    private class JustifierIterator {\\n        \\n        String[] words;\\n        int[] paths;\\n        int maxWidth;\\n        \\n        int pathsIndex;\\n        \\n        public JustifierIterator(String[] words, int[] paths, int maxWidth) {\\n        \\tthis.paths = paths;\\n            this.words = words;\\n            this.maxWidth = maxWidth;\\n        }\\n        \\n        public boolean hasNext() {\\n            return pathsIndex < words.length;\\n        }\\n        \\n        public String next() {\\n        \\t\\n            int numWords = paths[pathsIndex] - pathsIndex; \\n            int spacesCount = calculateNumSpaces(pathsIndex, numWords);\\n            \\n            String result = generateSentence(pathsIndex, numWords, spacesCount);\\n            pathsIndex = paths[pathsIndex];\\n            \\n            return result;\\n        }\\n        \\n        private int calculateNumSpaces(int initialIndex, int numWords) {\\n            \\n            int numChars = 0;\\n            \\n            for(int i = 0; i < numWords; i++) {\\n                \\n                numChars += words[initialIndex + i].length();\\n            }\\n            \\n            return maxWidth - numChars;\\n        }\\n        \\n        private String generateSentence(int initialIndex, int numWords, int spacesCount) {\\n            \\n            StringBuilder sentence = new StringBuilder();\\n            \\n            if(numWords == 1) {\\n                sentence.append(words[initialIndex]);\\n                sentence.append(generateSpaces(maxWidth-words[initialIndex].length()));\\n                return sentence.toString();\\n            }\\n            \\n            if(initialIndex + numWords == words.length) {\\n                \\n                int len = 0;\\n                \\n                for(int i = 0; i < numWords; i++) {\\n\\n                    sentence.append(words[initialIndex+i]);\\n                    len += words[initialIndex+i].length();\\n                    \\n                    if(len < maxWidth) {\\n                        sentence.append(\" \");\\n                        len++;\\n                    }\\n                }                \\n                sentence.append(generateSpaces(maxWidth-len));\\n                return sentence.toString();\\n            }\\n            \\n            int evenDivision = spacesCount / (numWords-1);\\n            int leftOverSpaces = spacesCount % (numWords-1);\\n            \\n            for(int i = 0; i < numWords-1; i++) {\\n                \\n                int spacesToAdd = evenDivision;\\n                if(leftOverSpaces > 0) {\\n                    spacesToAdd++;\\n                    leftOverSpaces--;\\n                }\\n                \\n                sentence.append(words[initialIndex+i]);\\n                sentence.append(generateSpaces(spacesToAdd));\\n            }\\n            \\n            sentence.append(words[initialIndex+numWords-1]);\\n            \\n            return sentence.toString();\\n        }\\n        \\n        private char[] generateSpaces(int spacesCount) {\\n            \\n            char[] blankSequence = new char[spacesCount];\\n            Arrays.fill(blankSequence, ' ');\\n            \\n            return blankSequence;\\n        }        \\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "This is based on Roy Tushar's solution. See https://www.youtube.com/watch?v=RORuwHiblPc\\n\\n\\n\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {    \\t\\n        \\n        List<String> results = new LinkedList<>();   \\n        \\n        if(words == null) {\\n            return results;\\n        }        \\n        \\n        int[][] costsMatrix = createCostMatrix(words, maxWidth);\\n        \\n        int len = words.length;\\n        \\n        int[] minCosts = new int[len];\\n        int[] paths = new int[len];\\n        \\n        Arrays.fill(minCosts, Integer.MAX_VALUE);\\n        \\n        for(int i = len-1; i >= 0; i--) {\\n            \\n            minCosts[i] = costsMatrix[i][len-1];\\n            paths[i] = len;         \\n            \\n            for(int j = i+1; j < len; j++) {\\n                \\n                if(costsMatrix[i][j-1] != Integer.MAX_VALUE &&\\n                    minCosts[j] + costsMatrix[i][j-1] < minCosts[i]) {\\n                    \\n                    minCosts[i] = minCosts[j] + costsMatrix[i][j-1];\\n                    paths[i] = j;                            \\n                }\\n            }            \\n        }\\n\\n        JustifierIterator iter = new JustifierIterator(words, paths, maxWidth);\\n        \\n        while(iter.hasNext()) {\\n            results.add(iter.next());\\n        }\\n        \\n        return results;        \\n    }\\n    \\n    private int[][] createCostMatrix(String[] words, int maxWidth) {\\n        \\n        int len = words.length;\\n        int[][] costMatrix = new int[len][len];\\n        \\n        for(int row = 0; row < len-1; row++) {\\n            \\n            int usedSpace = 0;\\n            Arrays.fill(costMatrix[row], Integer.MAX_VALUE);\\n            \\n            for(int col = row; col < len; col++) {\\n                \\n            \\tusedSpace += words[col].length();\\n                if(usedSpace <= maxWidth) {\\n                \\tif(col == len-1) {\\n                \\t\\tcostMatrix[row][col] = 0;\\n                \\t} else {                \\t\\n\\t                \\tint unusedSpace = maxWidth - usedSpace;\\n\\t                    costMatrix[row][col] = unusedSpace * unusedSpace;\\n                \\t}\\n                } else {\\n                \\tif(col > 0) {\\n                \\t\\tcostMatrix[row][col-1] = 0;\\n                \\t}\\n                    break;\\n                }\\n                usedSpace++;\\n            }                        \\n        }\\n        \\n        costMatrix[len-1][len-1] = 0;\\n        \\n        return costMatrix;\\n    }\\n    \\n    private class JustifierIterator {\\n        \\n        String[] words;\\n        int[] paths;\\n        int maxWidth;\\n        \\n        int pathsIndex;\\n        \\n        public JustifierIterator(String[] words, int[] paths, int maxWidth) {\\n        \\tthis.paths = paths;\\n            this.words = words;\\n            this.maxWidth = maxWidth;\\n        }\\n        \\n        public boolean hasNext() {\\n            return pathsIndex < words.length;\\n        }\\n        \\n        public String next() {\\n        \\t\\n            int numWords = paths[pathsIndex] - pathsIndex; \\n            int spacesCount = calculateNumSpaces(pathsIndex, numWords);\\n            \\n            String result = generateSentence(pathsIndex, numWords, spacesCount);\\n            pathsIndex = paths[pathsIndex];\\n            \\n            return result;\\n        }\\n        \\n        private int calculateNumSpaces(int initialIndex, int numWords) {\\n            \\n            int numChars = 0;\\n            \\n            for(int i = 0; i < numWords; i++) {\\n                \\n                numChars += words[initialIndex + i].length();\\n            }\\n            \\n            return maxWidth - numChars;\\n        }\\n        \\n        private String generateSentence(int initialIndex, int numWords, int spacesCount) {\\n            \\n            StringBuilder sentence = new StringBuilder();\\n            \\n            if(numWords == 1) {\\n                sentence.append(words[initialIndex]);\\n                sentence.append(generateSpaces(maxWidth-words[initialIndex].length()));\\n                return sentence.toString();\\n            }\\n            \\n            if(initialIndex + numWords == words.length) {\\n                \\n                int len = 0;\\n                \\n                for(int i = 0; i < numWords; i++) {\\n\\n                    sentence.append(words[initialIndex+i]);\\n                    len += words[initialIndex+i].length();\\n                    \\n                    if(len < maxWidth) {\\n                        sentence.append(\" \");\\n                        len++;\\n                    }\\n                }                \\n                sentence.append(generateSpaces(maxWidth-len));\\n                return sentence.toString();\\n            }\\n            \\n            int evenDivision = spacesCount / (numWords-1);\\n            int leftOverSpaces = spacesCount % (numWords-1);\\n            \\n            for(int i = 0; i < numWords-1; i++) {\\n                \\n                int spacesToAdd = evenDivision;\\n                if(leftOverSpaces > 0) {\\n                    spacesToAdd++;\\n                    leftOverSpaces--;\\n                }\\n                \\n                sentence.append(words[initialIndex+i]);\\n                sentence.append(generateSpaces(spacesToAdd));\\n            }\\n            \\n            sentence.append(words[initialIndex+numWords-1]);\\n            \\n            return sentence.toString();\\n        }\\n        \\n        private char[] generateSpaces(int spacesCount) {\\n            \\n            char[] blankSequence = new char[spacesCount];\\n            Arrays.fill(blankSequence, ' ');\\n            \\n            return blankSequence;\\n        }        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3952544,
                "title": "putta-easy-solution-c-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int L) {\\n    vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int L) {\\n    vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952161,
                "title": "beats-100-js-ts-java-c-c-c-python-python3-kotlin-php",
                "content": "---\\n![header_.png](https://assets.leetcode.com/users/images/ab4510d5-90e7-4616-b1e1-aac91ec90eea_1692159981.2067795.png)\\n\\n---\\n```C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize) {\\n    char **result = (char **)malloc(sizeof(char *) * wordsSize);\\n    *returnSize = 0;\\n    \\n    int start = 0;  // Index of the first word in the current line.\\n    \\n    while (start < wordsSize) {\\n        int end = start;  // Index of the last word in the current line.\\n        int lineLength = 0;  // Length of the words and spaces in the current line.\\n        \\n        // Calculate the number of words and total length that can fit in the current line.\\n        while (end < wordsSize && lineLength + strlen(words[end]) + end - start <= maxWidth) {\\n            lineLength += strlen(words[end]);\\n            end++;\\n        }\\n        \\n        // Calculate the total number of spaces needed in the line.\\n        int totalSpaces = maxWidth - lineLength;\\n        \\n        // If it\\'s the last line or only one word in the line, left-justify.\\n        if (end == wordsSize || end - start == 1) {\\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    result[*returnSize][idx++] = \\' \\';\\n                }\\n            }\\n            while (idx < maxWidth) {\\n                result[*returnSize][idx++] = \\' \\';\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        } else {\\n            int spaceBetweenWords = totalSpaces / (end - start - 1);\\n            int extraSpaces = totalSpaces % (end - start - 1);\\n            \\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    int spaces = spaceBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                    extraSpaces--;\\n                    for (int j = 0; j < spaces; j++) {\\n                        result[*returnSize][idx++] = \\' \\';\\n                    }\\n                }\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        }\\n        \\n        (*returnSize)++;\\n        start = end;\\n    }\\n    \\n    return result;\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0;\\n        \\n        while (i < words.size()) {\\n            int lineLen = words[i].size();\\n            int j = i + 1;\\n            \\n            // Find the words that can fit in the current line\\n            while (j < words.size() && lineLen + 1 + words[j].size() <= maxWidth) {\\n                lineLen += 1 + words[j].size();\\n                j++;\\n            }\\n            \\n            int numWords = j - i;\\n            int totalSpaces = maxWidth - lineLen + numWords - 1;\\n            \\n            // Construct the formatted line\\n            string line = words[i];\\n            if (numWords == 1 || j == words.size()) { // Left-justify\\n                for (int k = i + 1; k < j; k++) {\\n                    line += \" \" + words[k];\\n                }\\n                line += string(maxWidth - line.size(), \\' \\'); // Pad with spaces\\n            } else { // Fully justify\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                for (int k = i + 1; k < j; k++) {\\n                    int spaces = k - i <= extraSpaces ? spacesBetweenWords + 1 : spacesBetweenWords;\\n                    line += string(spaces, \\' \\') + words[k];\\n                }\\n            }\\n            \\n            result.push_back(line);\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n```Typescript []\\nfunction fullJustify(words: string[], maxWidth: number): string[] {\\n    let res = [], str = \"\", i = 0, n = words.length, x = 0;\\n    while( i < n ){\\n        if( (str + words[i]).length === maxWidth ){\\n            str += words[i++];\\n            res.push(str);\\n            str = \"\";\\n            x = i;\\n        }\\n        else if( (str + words[i]).length > maxWidth ){\\n            let j = x, cnt = maxWidth - (str.length - 1);\\n            while( cnt > 0 && j < i - 1 ){\\n                words[j++] += \" \";\\n                cnt--;\\n                if( j === i - 1 && cnt > 0 )j = x\\n            }\\n            let tempStr = \"\"; j = x;\\n            while( j < i )tempStr += j < i - 1 ?  words[j++] + \" \" : words[j++];\\n            while( tempStr.length < maxWidth )tempStr += \" \"\\n            res.push(tempStr);\\n            str = \"\";\\n            x = i;\\n        }\\n        else str += words[i++] + \" \";\\n    }\\n    if( str.length > 0 ){\\n        let cnt = maxWidth - str.length;\\n        while( cnt > 0 ){\\n            str += \" \";\\n            cnt--;\\n        }\\n        res.push(str)\\n    }\\n    return res\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        int index = 0;\\n\\n        while (index < words.length) {\\n            int lineStart = index;\\n            int lineLength = words[index].length();\\n            index++;\\n\\n            while (index < words.length && lineLength + words[index].length() + (index - lineStart) <= maxWidth) {\\n                lineLength += words[index].length();\\n                index++;\\n            }\\n\\n            int totalSpaces = maxWidth - lineLength;\\n            int numWords = index - lineStart;\\n\\n            StringBuilder line = new StringBuilder(words[lineStart]);\\n            \\n            if (numWords == 1 || index == words.length) { // Left-justify last line or single-word lines\\n                for (int i = lineStart + 1; i < index; i++) {\\n                    line.append(\\' \\').append(words[i]);\\n                }\\n                line.append(String.valueOf(\\' \\').repeat(maxWidth - line.length())); // Add extra spaces at the end\\n            } else {\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                \\n                for (int i = lineStart + 1; i < index; i++) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line.append(String.valueOf(\\' \\').repeat(spaces)).append(words[i]);\\n                }\\n            }\\n\\n            result.add(line.toString());\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        result = []\\n        line = []\\n        line_length = 0\\n        \\n        for word in words:\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Justify the current line\\n                spaces_to_add = maxWidth - line_length\\n                if len(line) == 1:\\n                    result.append(line[0] + \\' \\' * spaces_to_add)\\n                else:\\n                    num_gaps = len(line) - 1\\n                    spaces_per_gap = spaces_to_add // num_gaps\\n                    extra_spaces = spaces_to_add % num_gaps\\n                    justified_line = line[0]\\n                    for i in range(1, len(line)):\\n                        spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)\\n                        justified_line += \\' \\' * spaces + line[i]\\n                    result.append(justified_line)\\n                \\n                # Reset line and line_length\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Left-justify the last line\\n        last_line = \\' \\'.join(line)\\n        last_line += \\' \\' * (maxWidth - len(last_line))\\n        result.append(last_line)\\n        \\n        return result\\n```\\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []  # Stores words for the current line\\n        line_length = 0\\n        \\n        for word in words:\\n            # Check if adding the current word to the line exceeds the maxWidth\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Distribute extra spaces between words\\n                num_words = len(line)\\n                total_spaces = maxWidth - line_length\\n                \\n                if num_words == 1:\\n                    # Left-justify if there\\'s only one word in the line\\n                    result.append(line[0] + \\' \\' * (maxWidth - len(line[0])))\\n                else:\\n                    # Calculate even and extra spaces\\n                    spaces_per_word = total_spaces // (num_words - 1)\\n                    extra_spaces = total_spaces % (num_words - 1)\\n                    \\n                    # Create the justified line\\n                    justified_line = \"\"\\n                    for i in range(num_words - 1):\\n                        justified_line += line[i] + \\' \\' * spaces_per_word\\n                        if extra_spaces > 0:\\n                            justified_line += \\' \\'\\n                            extra_spaces -= 1\\n                    justified_line += line[num_words - 1]\\n                    result.append(justified_line)\\n                \\n                # Reset line variables for the next line\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Last line: left-justify and no extra spaces\\n        result.append(\\' \\'.join(line) + \\' \\' * (maxWidth - line_length - len(line) + 1))\\n        \\n        return result\\n```\\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = startIndex;\\n            int lineLength = 0;\\n\\n            // Find the range of words that can fit in the current line\\n            while (endIndex < words.Length && lineLength + words[endIndex].Length + (endIndex - startIndex) <= maxWidth) {\\n                lineLength += words[endIndex].Length;\\n                endIndex++;\\n            }\\n\\n            // Calculate the number of total spaces and gaps between words\\n            int totalSpaces = maxWidth - lineLength;\\n            int totalGaps = endIndex - startIndex - 1;\\n            \\n            StringBuilder lineBuilder = new StringBuilder();\\n\\n            // If it\\'s the last line or only one word in the line, left-justify\\n            if (endIndex == words.Length || totalGaps == 0) {\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        lineBuilder.Append(\\' \\');\\n                    }\\n                }\\n                while (lineBuilder.Length < maxWidth) {\\n                    lineBuilder.Append(\\' \\');\\n                }\\n            } else {\\n                int spacesPerGap = totalSpaces / totalGaps;\\n                int extraSpaces = totalSpaces % totalGaps;\\n\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        int spacesToAdd = spacesPerGap + (i - startIndex < extraSpaces ? 1 : 0);\\n                        lineBuilder.Append(\\' \\', spacesToAdd);\\n                    }\\n                }\\n            }\\n\\n            result.Add(lineBuilder.ToString());\\n            startIndex = endIndex;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```Javascript []\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\\n```Kotlin []\\nclass Solution {\\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n        val result = mutableListOf<String>()\\n        var lineWords = mutableListOf<String>()\\n        var lineLength = 0\\n        \\n        for (word in words) {\\n            if (lineLength + lineWords.size + word.length <= maxWidth) {\\n                lineWords.add(word)\\n                lineLength += word.length\\n            } else {\\n                result.add(constructLine(lineWords, maxWidth, lineLength))\\n                lineWords.clear()\\n                lineWords.add(word)\\n                lineLength = word.length\\n            }\\n        }\\n        \\n        // Last line\\n        if (lineWords.isNotEmpty()) {\\n            val lastLine = lineWords.joinToString(\" \")\\n            result.add(lastLine.padEnd(maxWidth))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private fun constructLine(words: List<String>, maxWidth: Int, lineLength: Int): String {\\n        val numWords = words.size\\n        if (numWords == 1) {\\n            return words[0].padEnd(maxWidth)\\n        }\\n        \\n        val totalSpaces = maxWidth - lineLength\\n        val spaceSlots = numWords - 1\\n        val baseSpace = totalSpaces / spaceSlots\\n        val extraSpaceSlots = totalSpaces % spaceSlots\\n        \\n        val lineBuilder = StringBuilder()\\n        for (i in 0 until numWords - 1) {\\n            lineBuilder.append(words[i])\\n            lineBuilder.append(\" \".repeat(baseSpace))\\n            if (i < extraSpaceSlots) {\\n                lineBuilder.append(\" \")\\n            }\\n        }\\n        lineBuilder.append(words.last())\\n        \\n        return lineBuilder.toString()\\n    }\\n}\\n```\\n```PHP []\\nclass Solution {\\n    /**\\n     * @param String[] $words\\n     * @param Integer $maxWidth\\n     * @return String[]\\n     */\\n    function fullJustify($words, $maxWidth) {\\n        $result = [];\\n        $line = [];\\n        $lineWidth = 0;\\n        \\n        foreach ($words as $word) {\\n            // Check if adding the next word exceeds maxWidth\\n            if ($lineWidth + count($line) + strlen($word) > $maxWidth) {\\n                $formattedLine = $this->formatLine($line, $lineWidth, $maxWidth);\\n                $result[] = $formattedLine;\\n                \\n                $line = [];\\n                $lineWidth = 0;\\n            }\\n            \\n            $line[] = $word;\\n            $lineWidth += strlen($word);\\n        }\\n        \\n        // Handle the last line\\n        $lastLine = implode(\\' \\', $line);\\n        $lastLine .= str_repeat(\\' \\', $maxWidth - strlen($lastLine));\\n        $result[] = $lastLine;\\n        \\n        return $result;\\n    }\\n    \\n    // Helper function to format a line\\n    private function formatLine($line, $lineWidth, $maxWidth) {\\n        $numWords = count($line);\\n        $numSpaces = $maxWidth - $lineWidth;\\n        \\n        if ($numWords === 1) {\\n            return $line[0] . str_repeat(\\' \\', $numSpaces);\\n        }\\n        \\n        $avgSpaces = floor($numSpaces / ($numWords - 1));\\n        $extraSpaces = $numSpaces % ($numWords - 1);\\n        \\n        $formattedLine = $line[0];\\n        \\n        for ($i = 1; $i < $numWords; $i++) {\\n            $numPaddingSpaces = $avgSpaces + ($i <= $extraSpaces ? 1 : 0);\\n            $formattedLine .= str_repeat(\\' \\', $numPaddingSpaces) . $line[$i];\\n        }\\n        \\n        return $formattedLine;\\n    }\\n}\\n```\\n\\n\\n---\\n![download.jpg](https://assets.leetcode.com/users/images/5196fec2-1dd4-4b82-9700-36c5a0e72623_1692159956.9446952.jpeg)\\n\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Kotlin",
                    "PHP",
                    "TypeScript"
                ],
                "code": "```C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize) {\\n    char **result = (char **)malloc(sizeof(char *) * wordsSize);\\n    *returnSize = 0;\\n    \\n    int start = 0;  // Index of the first word in the current line.\\n    \\n    while (start < wordsSize) {\\n        int end = start;  // Index of the last word in the current line.\\n        int lineLength = 0;  // Length of the words and spaces in the current line.\\n        \\n        // Calculate the number of words and total length that can fit in the current line.\\n        while (end < wordsSize && lineLength + strlen(words[end]) + end - start <= maxWidth) {\\n            lineLength += strlen(words[end]);\\n            end++;\\n        }\\n        \\n        // Calculate the total number of spaces needed in the line.\\n        int totalSpaces = maxWidth - lineLength;\\n        \\n        // If it\\'s the last line or only one word in the line, left-justify.\\n        if (end == wordsSize || end - start == 1) {\\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    result[*returnSize][idx++] = \\' \\';\\n                }\\n            }\\n            while (idx < maxWidth) {\\n                result[*returnSize][idx++] = \\' \\';\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        } else {\\n            int spaceBetweenWords = totalSpaces / (end - start - 1);\\n            int extraSpaces = totalSpaces % (end - start - 1);\\n            \\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    int spaces = spaceBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                    extraSpaces--;\\n                    for (int j = 0; j < spaces; j++) {\\n                        result[*returnSize][idx++] = \\' \\';\\n                    }\\n                }\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        }\\n        \\n        (*returnSize)++;\\n        start = end;\\n    }\\n    \\n    return result;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0;\\n        \\n        while (i < words.size()) {\\n            int lineLen = words[i].size();\\n            int j = i + 1;\\n            \\n            // Find the words that can fit in the current line\\n            while (j < words.size() && lineLen + 1 + words[j].size() <= maxWidth) {\\n                lineLen += 1 + words[j].size();\\n                j++;\\n            }\\n            \\n            int numWords = j - i;\\n            int totalSpaces = maxWidth - lineLen + numWords - 1;\\n            \\n            // Construct the formatted line\\n            string line = words[i];\\n            if (numWords == 1 || j == words.size()) { // Left-justify\\n                for (int k = i + 1; k < j; k++) {\\n                    line += \" \" + words[k];\\n                }\\n                line += string(maxWidth - line.size(), \\' \\'); // Pad with spaces\\n            } else { // Fully justify\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                for (int k = i + 1; k < j; k++) {\\n                    int spaces = k - i <= extraSpaces ? spacesBetweenWords + 1 : spacesBetweenWords;\\n                    line += string(spaces, \\' \\') + words[k];\\n                }\\n            }\\n            \\n            result.push_back(line);\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```Typescript []\\nfunction fullJustify(words: string[], maxWidth: number): string[] {\\n    let res = [], str = \"\", i = 0, n = words.length, x = 0;\\n    while( i < n ){\\n        if( (str + words[i]).length === maxWidth ){\\n            str += words[i++];\\n            res.push(str);\\n            str = \"\";\\n            x = i;\\n        }\\n        else if( (str + words[i]).length > maxWidth ){\\n            let j = x, cnt = maxWidth - (str.length - 1);\\n            while( cnt > 0 && j < i - 1 ){\\n                words[j++] += \" \";\\n                cnt--;\\n                if( j === i - 1 && cnt > 0 )j = x\\n            }\\n            let tempStr = \"\"; j = x;\\n            while( j < i )tempStr += j < i - 1 ?  words[j++] + \" \" : words[j++];\\n            while( tempStr.length < maxWidth )tempStr += \" \"\\n            res.push(tempStr);\\n            str = \"\";\\n            x = i;\\n        }\\n        else str += words[i++] + \" \";\\n    }\\n    if( str.length > 0 ){\\n        let cnt = maxWidth - str.length;\\n        while( cnt > 0 ){\\n            str += \" \";\\n            cnt--;\\n        }\\n        res.push(str)\\n    }\\n    return res\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        int index = 0;\\n\\n        while (index < words.length) {\\n            int lineStart = index;\\n            int lineLength = words[index].length();\\n            index++;\\n\\n            while (index < words.length && lineLength + words[index].length() + (index - lineStart) <= maxWidth) {\\n                lineLength += words[index].length();\\n                index++;\\n            }\\n\\n            int totalSpaces = maxWidth - lineLength;\\n            int numWords = index - lineStart;\\n\\n            StringBuilder line = new StringBuilder(words[lineStart]);\\n            \\n            if (numWords == 1 || index == words.length) { // Left-justify last line or single-word lines\\n                for (int i = lineStart + 1; i < index; i++) {\\n                    line.append(\\' \\').append(words[i]);\\n                }\\n                line.append(String.valueOf(\\' \\').repeat(maxWidth - line.length())); // Add extra spaces at the end\\n            } else {\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                \\n                for (int i = lineStart + 1; i < index; i++) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line.append(String.valueOf(\\' \\').repeat(spaces)).append(words[i]);\\n                }\\n            }\\n\\n            result.add(line.toString());\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        result = []\\n        line = []\\n        line_length = 0\\n        \\n        for word in words:\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Justify the current line\\n                spaces_to_add = maxWidth - line_length\\n                if len(line) == 1:\\n                    result.append(line[0] + \\' \\' * spaces_to_add)\\n                else:\\n                    num_gaps = len(line) - 1\\n                    spaces_per_gap = spaces_to_add // num_gaps\\n                    extra_spaces = spaces_to_add % num_gaps\\n                    justified_line = line[0]\\n                    for i in range(1, len(line)):\\n                        spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)\\n                        justified_line += \\' \\' * spaces + line[i]\\n                    result.append(justified_line)\\n                \\n                # Reset line and line_length\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Left-justify the last line\\n        last_line = \\' \\'.join(line)\\n        last_line += \\' \\' * (maxWidth - len(last_line))\\n        result.append(last_line)\\n        \\n        return result\\n```\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []  # Stores words for the current line\\n        line_length = 0\\n        \\n        for word in words:\\n            # Check if adding the current word to the line exceeds the maxWidth\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Distribute extra spaces between words\\n                num_words = len(line)\\n                total_spaces = maxWidth - line_length\\n                \\n                if num_words == 1:\\n                    # Left-justify if there\\'s only one word in the line\\n                    result.append(line[0] + \\' \\' * (maxWidth - len(line[0])))\\n                else:\\n                    # Calculate even and extra spaces\\n                    spaces_per_word = total_spaces // (num_words - 1)\\n                    extra_spaces = total_spaces % (num_words - 1)\\n                    \\n                    # Create the justified line\\n                    justified_line = \"\"\\n                    for i in range(num_words - 1):\\n                        justified_line += line[i] + \\' \\' * spaces_per_word\\n                        if extra_spaces > 0:\\n                            justified_line += \\' \\'\\n                            extra_spaces -= 1\\n                    justified_line += line[num_words - 1]\\n                    result.append(justified_line)\\n                \\n                # Reset line variables for the next line\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Last line: left-justify and no extra spaces\\n        result.append(\\' \\'.join(line) + \\' \\' * (maxWidth - line_length - len(line) + 1))\\n        \\n        return result\\n```\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = startIndex;\\n            int lineLength = 0;\\n\\n            // Find the range of words that can fit in the current line\\n            while (endIndex < words.Length && lineLength + words[endIndex].Length + (endIndex - startIndex) <= maxWidth) {\\n                lineLength += words[endIndex].Length;\\n                endIndex++;\\n            }\\n\\n            // Calculate the number of total spaces and gaps between words\\n            int totalSpaces = maxWidth - lineLength;\\n            int totalGaps = endIndex - startIndex - 1;\\n            \\n            StringBuilder lineBuilder = new StringBuilder();\\n\\n            // If it\\'s the last line or only one word in the line, left-justify\\n            if (endIndex == words.Length || totalGaps == 0) {\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        lineBuilder.Append(\\' \\');\\n                    }\\n                }\\n                while (lineBuilder.Length < maxWidth) {\\n                    lineBuilder.Append(\\' \\');\\n                }\\n            } else {\\n                int spacesPerGap = totalSpaces / totalGaps;\\n                int extraSpaces = totalSpaces % totalGaps;\\n\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        int spacesToAdd = spacesPerGap + (i - startIndex < extraSpaces ? 1 : 0);\\n                        lineBuilder.Append(\\' \\', spacesToAdd);\\n                    }\\n                }\\n            }\\n\\n            result.Add(lineBuilder.ToString());\\n            startIndex = endIndex;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```Javascript []\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\n```Kotlin []\\nclass Solution {\\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n        val result = mutableListOf<String>()\\n        var lineWords = mutableListOf<String>()\\n        var lineLength = 0\\n        \\n        for (word in words) {\\n            if (lineLength + lineWords.size + word.length <= maxWidth) {\\n                lineWords.add(word)\\n                lineLength += word.length\\n            } else {\\n                result.add(constructLine(lineWords, maxWidth, lineLength))\\n                lineWords.clear()\\n                lineWords.add(word)\\n                lineLength = word.length\\n            }\\n        }\\n        \\n        // Last line\\n        if (lineWords.isNotEmpty()) {\\n            val lastLine = lineWords.joinToString(\" \")\\n            result.add(lastLine.padEnd(maxWidth))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private fun constructLine(words: List<String>, maxWidth: Int, lineLength: Int): String {\\n        val numWords = words.size\\n        if (numWords == 1) {\\n            return words[0].padEnd(maxWidth)\\n        }\\n        \\n        val totalSpaces = maxWidth - lineLength\\n        val spaceSlots = numWords - 1\\n        val baseSpace = totalSpaces / spaceSlots\\n        val extraSpaceSlots = totalSpaces % spaceSlots\\n        \\n        val lineBuilder = StringBuilder()\\n        for (i in 0 until numWords - 1) {\\n            lineBuilder.append(words[i])\\n            lineBuilder.append(\" \".repeat(baseSpace))\\n            if (i < extraSpaceSlots) {\\n                lineBuilder.append(\" \")\\n            }\\n        }\\n        lineBuilder.append(words.last())\\n        \\n        return lineBuilder.toString()\\n    }\\n}\\n```\n```PHP []\\nclass Solution {\\n    /**\\n     * @param String[] $words\\n     * @param Integer $maxWidth\\n     * @return String[]\\n     */\\n    function fullJustify($words, $maxWidth) {\\n        $result = [];\\n        $line = [];\\n        $lineWidth = 0;\\n        \\n        foreach ($words as $word) {\\n            // Check if adding the next word exceeds maxWidth\\n            if ($lineWidth + count($line) + strlen($word) > $maxWidth) {\\n                $formattedLine = $this->formatLine($line, $lineWidth, $maxWidth);\\n                $result[] = $formattedLine;\\n                \\n                $line = [];\\n                $lineWidth = 0;\\n            }\\n            \\n            $line[] = $word;\\n            $lineWidth += strlen($word);\\n        }\\n        \\n        // Handle the last line\\n        $lastLine = implode(\\' \\', $line);\\n        $lastLine .= str_repeat(\\' \\', $maxWidth - strlen($lastLine));\\n        $result[] = $lastLine;\\n        \\n        return $result;\\n    }\\n    \\n    // Helper function to format a line\\n    private function formatLine($line, $lineWidth, $maxWidth) {\\n        $numWords = count($line);\\n        $numSpaces = $maxWidth - $lineWidth;\\n        \\n        if ($numWords === 1) {\\n            return $line[0] . str_repeat(\\' \\', $numSpaces);\\n        }\\n        \\n        $avgSpaces = floor($numSpaces / ($numWords - 1));\\n        $extraSpaces = $numSpaces % ($numWords - 1);\\n        \\n        $formattedLine = $line[0];\\n        \\n        for ($i = 1; $i < $numWords; $i++) {\\n            $numPaddingSpaces = $avgSpaces + ($i <= $extraSpaces ? 1 : 0);\\n            $formattedLine .= str_repeat(\\' \\', $numPaddingSpaces) . $line[$i];\\n        }\\n        \\n        return $formattedLine;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3952159,
                "title": "c-strings-with-examples-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe fundamental operations for strings should be known to solve such questions. LC has different kinds of hard questions. To solve this question one does not need special algorithms or tricks.\\nBut it is  very annoying for debugging until to get right answer!\\n\\nMaybe solve the easy question first.\\n[1592. Rearrange Spaces Between Words](https://leetcode.com/problems/rearrange-spaces-between-words/description/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermine which words are in which line.\\nThe function ```print_wIdx``` handles where extra whitespaces to insert.\\n\\nFor 2nd approach, every line is initialized with\\n```\\nline = string(maxWidth, \\' \\');\\n```\\nand then the function copy in C++ algorithm is used for copying the ```words[i]``` to the right place; its performance is better than operator+ and beats 100.00% with runtime 0 ms. It is to mention that if operator+ for strings is used, the string line will be allocated several times.\\n\\nLet\\'s consider the string words=\\n```[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]```\\n\\nTake care where extra whitespaces to insert\\n\\nmaxWidth=20 \\n```\\n|Science  is  what we|\\n|understand      well|\\n|enough to explain to|\\n|a  computer.  Art is|\\n|everything  else  we|\\n|do                  |\\n```\\nmaxWidth=19\\n```\\n|Science  is what we|\\n|understand     well|\\n|enough  to  explain|\\n|to  a computer. Art|\\n|is  everything else|\\n|we do              |\\n```\\nmaxWidth=21\\n```\\n|Science  is  what  we|\\n|understand       well|\\n|enough  to explain to|\\n|a  computer.  Art  is|\\n|everything else we do|\\n```\\nOther testcase:\\n```\\n[\"My\",\"momma\",\"always\",\"said,\",\"\\\\\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you\\'re\",\"gonna\",\"get.\"]\\n20\\n```\\nans\\n```\\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\\n|you\\'re gonna get.   | no extra space\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    string space(int c) {\\n        return string(c, \\' \\');\\n    }\\n\\n    vector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n        for (int i = 0; i < wIdx.size(); i++) {\\n            int numWords = wIdx[i].first.size();\\n            int totalLen = wIdx[i].second;\\n            int totalSpaces = maxWidth - totalLen;\\n            int numGaps = numWords - 1;\\n            int numSpaces = 1;\\n            int remainingSpaces = 0;\\n\\n            if (numGaps > 0) {\\n                numSpaces = totalSpaces / numGaps;\\n                remainingSpaces = totalSpaces % numGaps;\\n            }\\n\\n            string line = words[wIdx[i].first[0]]; // Start with the first word\\n            for (int j = 1; j < numWords; j++) {\\n                if (i == wIdx.size() - 1) {\\n                    // Last line, left justify\\n                    line += space(1);\\n                } \\n                else {\\n                    line+= space(numSpaces+(remainingSpaces>0?1:0));\\n                    remainingSpaces--;\\n                }\\n                line+= words[wIdx[i].first[j]];\\n            }\\n\\n            if (line.size() < maxWidth)\\n                line+= space(maxWidth-line.size());\\n\\n            ans.push_back(line);\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<pair<vector<int>, int>> wIdx(1);\\n        int cur = 0;\\n        int len = 0;\\n        for (int i = 0; i < n; i++) {\\n            //wlen=sum of length of words w/o space in 1 line\\n            int wlen = words[i].size();\\n            len += wlen;\\n            if (len > maxWidth) {\\n                wIdx.push_back({{i}, wlen});\\n                cur++;\\n                len = wlen;\\n            } \\n            else {\\n                wIdx[cur].first.push_back(i);\\n                wIdx[cur].second += wlen;\\n            }\\n            len++; //at least 1 whitespace between words\\n        }\\n\\n        return print_wIdx(words, wIdx, maxWidth);\\n    }\\n};\\n\\n```\\n# Other implementation for print_wIdx using C++ algorithm copy has runtime 0 ms and beats 100.00%\\n```\\nvector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n    vector<string> ans;\\n\\n    for (int i = 0; i < wIdx.size(); i++) {\\n        int numWords = wIdx[i].first.size();\\n        int totalSpaces = maxWidth - wIdx[i].second;\\n        int numGaps = numWords-1;\\n        int numSpaces = 1;\\n        int remainingSpaces = 0;\\n\\n        if (numGaps > 0) {\\n            auto [q, r] = div(totalSpaces, numGaps);\\n            numSpaces = q, remainingSpaces = r;\\n    //        cout<<q<<\"\\\\n\"<<r<<endl;\\n        }\\n\\n        string line = string(maxWidth, \\' \\');\\n        auto& w0 = words[wIdx[i].first[0]];\\n        copy(w0.begin(), w0.end(), line.begin()); // Copy the first word\\n\\n        int pos = w0.size();\\n        for (int j = 1; j < numWords; j++) {\\n            if (i != wIdx.size() - 1) {\\n                pos += numSpaces +(remainingSpaces > 0 ? 1 : 0);\\n                remainingSpaces--;\\n            }\\n            else pos++;\\n            auto& w = words[wIdx[i].first[j]];\\n            copy(w.begin(), w.end(), line.begin() + pos); // Copy each word\\n            pos += w.size();\\n        }\\n        ans.push_back(line);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```print_wIdx```\n```\\nline = string(maxWidth, \\' \\');\\n```\n```words[i]```\n```[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]```\n```\\n|Science  is  what we|\\n|understand      well|\\n|enough to explain to|\\n|a  computer.  Art is|\\n|everything  else  we|\\n|do                  |\\n```\n```\\n|Science  is what we|\\n|understand     well|\\n|enough  to  explain|\\n|to  a computer. Art|\\n|is  everything else|\\n|we do              |\\n```\n```\\n|Science  is  what  we|\\n|understand       well|\\n|enough  to explain to|\\n|a  computer.  Art  is|\\n|everything else we do|\\n```\n```\\n[\"My\",\"momma\",\"always\",\"said,\",\"\\\\\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you\\'re\",\"gonna\",\"get.\"]\\n20\\n```\n```\\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\\n|you\\'re gonna get.   | no extra space\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    string space(int c) {\\n        return string(c, \\' \\');\\n    }\\n\\n    vector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n        for (int i = 0; i < wIdx.size(); i++) {\\n            int numWords = wIdx[i].first.size();\\n            int totalLen = wIdx[i].second;\\n            int totalSpaces = maxWidth - totalLen;\\n            int numGaps = numWords - 1;\\n            int numSpaces = 1;\\n            int remainingSpaces = 0;\\n\\n            if (numGaps > 0) {\\n                numSpaces = totalSpaces / numGaps;\\n                remainingSpaces = totalSpaces % numGaps;\\n            }\\n\\n            string line = words[wIdx[i].first[0]]; // Start with the first word\\n            for (int j = 1; j < numWords; j++) {\\n                if (i == wIdx.size() - 1) {\\n                    // Last line, left justify\\n                    line += space(1);\\n                } \\n                else {\\n                    line+= space(numSpaces+(remainingSpaces>0?1:0));\\n                    remainingSpaces--;\\n                }\\n                line+= words[wIdx[i].first[j]];\\n            }\\n\\n            if (line.size() < maxWidth)\\n                line+= space(maxWidth-line.size());\\n\\n            ans.push_back(line);\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<pair<vector<int>, int>> wIdx(1);\\n        int cur = 0;\\n        int len = 0;\\n        for (int i = 0; i < n; i++) {\\n            //wlen=sum of length of words w/o space in 1 line\\n            int wlen = words[i].size();\\n            len += wlen;\\n            if (len > maxWidth) {\\n                wIdx.push_back({{i}, wlen});\\n                cur++;\\n                len = wlen;\\n            } \\n            else {\\n                wIdx[cur].first.push_back(i);\\n                wIdx[cur].second += wlen;\\n            }\\n            len++; //at least 1 whitespace between words\\n        }\\n\\n        return print_wIdx(words, wIdx, maxWidth);\\n    }\\n};\\n\\n```\n```\\nvector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n    vector<string> ans;\\n\\n    for (int i = 0; i < wIdx.size(); i++) {\\n        int numWords = wIdx[i].first.size();\\n        int totalSpaces = maxWidth - wIdx[i].second;\\n        int numGaps = numWords-1;\\n        int numSpaces = 1;\\n        int remainingSpaces = 0;\\n\\n        if (numGaps > 0) {\\n            auto [q, r] = div(totalSpaces, numGaps);\\n            numSpaces = q, remainingSpaces = r;\\n    //        cout<<q<<\"\\\\n\"<<r<<endl;\\n        }\\n\\n        string line = string(maxWidth, \\' \\');\\n        auto& w0 = words[wIdx[i].first[0]];\\n        copy(w0.begin(), w0.end(), line.begin()); // Copy the first word\\n\\n        int pos = w0.size();\\n        for (int j = 1; j < numWords; j++) {\\n            if (i != wIdx.size() - 1) {\\n                pos += numSpaces +(remainingSpaces > 0 ? 1 : 0);\\n                remainingSpaces--;\\n            }\\n            else pos++;\\n            auto& w = words[wIdx[i].first[j]];\\n            copy(w.begin(), w.end(), line.begin() + pos); // Copy each word\\n            pos += w.size();\\n        }\\n        ans.push_back(line);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 948678,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justify(part, totalLen):\\n        \\n            if len(part) == 1:\\n                return justifyLeft(part, totalLen)\\n            \\n            tatalSpaces = maxWidth - totalLen\\n            minSpaces = tatalSpaces // (len(part) - 1)\\n            extraSpaces = tatalSpaces % (len(part) - 1)\\n            \\n            spaces = [\\'\\'] * len(words)\\n            for i in range(1, len(words)):\\n                space = \\' \\' * minSpaces\\n                if extraSpaces > 0:\\n                    space += \\' \\'\\n                    extraSpaces -= 1\\n                spaces[i] = space\\n\\n            return \"\".join(map(lambda x: x[0] + x[1], zip(spaces, part)))\\n        \\n        def justifyLeft(part, totalLen):\\n            extraSpaces = len(part) - 1 if len(part) >= 2 else 0             \\n            return \" \".join(part) + \\' \\' * (maxWidth - totalLen - extraSpaces)\\n        \\n        result = []\\n        \\n        currentLen = 0\\n        current = []\\n        \\n        for word in words:\\n            spaces = len(current)\\n            \\n            if currentLen + len(word) + spaces > maxWidth:\\n                row = justify(current, currentLen)                    \\n                result.append(row)\\n\\n                currentLen = 0                \\n                current = []\\n                \\n            current.append(word)\\n            currentLen += len(word)\\n\\n        row = justifyLeft(current, currentLen)                    \\n        result.append(row)\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justify(part, totalLen):\\n        \\n            if len(part) == 1:\\n                return justifyLeft(part, totalLen)\\n            \\n            tatalSpaces = maxWidth - totalLen\\n            minSpaces = tatalSpaces // (len(part) - 1)\\n            extraSpaces = tatalSpaces % (len(part) - 1)\\n            \\n            spaces = [\\'\\'] * len(words)\\n            for i in range(1, len(words)):\\n                space = \\' \\' * minSpaces\\n                if extraSpaces > 0:\\n                    space += \\' \\'\\n                    extraSpaces -= 1\\n                spaces[i] = space\\n\\n            return \"\".join(map(lambda x: x[0] + x[1], zip(spaces, part)))\\n        \\n        def justifyLeft(part, totalLen):\\n            extraSpaces = len(part) - 1 if len(part) >= 2 else 0             \\n            return \" \".join(part) + \\' \\' * (maxWidth - totalLen - extraSpaces)\\n        \\n        result = []\\n        \\n        currentLen = 0\\n        current = []\\n        \\n        for word in words:\\n            spaces = len(current)\\n            \\n            if currentLen + len(word) + spaces > maxWidth:\\n                row = justify(current, currentLen)                    \\n                result.append(row)\\n\\n                currentLen = 0                \\n                current = []\\n                \\n            current.append(word)\\n            currentLen += len(word)\\n\\n        row = justifyLeft(current, currentLen)                    \\n        result.append(row)\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952386,
                "title": "beginner-friendly-simple-java-solution-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n#### This code  justifies an array of words within a given `maxWidth`:\\n1. Iterate through words, grouping them into lines that fit within `maxWidth`, and adjust spaces between words to achieve full justification. Add each line to the `result` list.\\n2. Return the `result` list containing justified lines.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize an empty list `result` to store the final justified lines.\\n- Loop through the array of words:\\n         - For each iteration, set i as the current index and initialize `wordCount` and `lineLength` to 0.\\n         - Increment `wordCount` while the accumulated length of words within the line does not exceed `maxWidth`.\\n- Inside the loop, create a `lineBuilder` and start appending the words:\\n            - If `wordCount` is 1 or at the end of the array, append the words with single spaces in between.\\n            - Otherwise, calculate `totalSpaces` and `extraSpaces` for justification.\\n            - Append words with calculated spaces.\\n- Add the completed line (in `lineBuilder`) to the `result` list.\\n- Continue the outer loop using the next index after the current line (`i += wordCount`).\\n- After processing all lines, return the `result` list.\\n\\n    \\n    \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        \\n        for (int i = 0, wordCount, lineLength; i < words.length; i += wordCount) {\\n            for (wordCount = 0, lineLength = 0; \\n                 i + wordCount < words.length && \\n                 lineLength + words[i + wordCount].length() + wordCount <= maxWidth; \\n                 wordCount++) {\\n                lineLength += words[i + wordCount].length();\\n            }\\n            \\n            StringBuilder lineBuilder = new StringBuilder(words[i]);\\n            \\n            if (wordCount == 1 || i + wordCount == words.length) {\\n                for (int j = 1; j < wordCount; j++) {\\n                    lineBuilder.append(\" \").append(words[i + j]);\\n                }\\n                lineBuilder.append(\" \".repeat(maxWidth - lineBuilder.length()));\\n            } else {\\n                int totalSpaces = (maxWidth - lineLength) / (wordCount - 1);\\n                int extraSpaces = (maxWidth - lineLength) % (wordCount - 1);\\n                \\n                for (int j = 1; j < wordCount; j++) {\\n                    int spacesToAdd = totalSpaces + (extraSpaces-- > 0 ? 1 : 0);\\n                    lineBuilder.append(\" \".repeat(spacesToAdd)).append(words[i + j]);\\n                }\\n            } \\n            result.add(lineBuilder.toString());\\n        }   \\n        return result;\\n    }\\n}\\n\\n```\\n# If you like the solution please Upvote.\\n![29c341f2-e223-4bc6-8894-efb9ed7a6744_1692496789.0986528.png](https://assets.leetcode.com/users/images/2c413272-3028-4385-896a-9f49ca949dd3_1692845736.9024503.png)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        \\n        for (int i = 0, wordCount, lineLength; i < words.length; i += wordCount) {\\n            for (wordCount = 0, lineLength = 0; \\n                 i + wordCount < words.length && \\n                 lineLength + words[i + wordCount].length() + wordCount <= maxWidth; \\n                 wordCount++) {\\n                lineLength += words[i + wordCount].length();\\n            }\\n            \\n            StringBuilder lineBuilder = new StringBuilder(words[i]);\\n            \\n            if (wordCount == 1 || i + wordCount == words.length) {\\n                for (int j = 1; j < wordCount; j++) {\\n                    lineBuilder.append(\" \").append(words[i + j]);\\n                }\\n                lineBuilder.append(\" \".repeat(maxWidth - lineBuilder.length()));\\n            } else {\\n                int totalSpaces = (maxWidth - lineLength) / (wordCount - 1);\\n                int extraSpaces = (maxWidth - lineLength) % (wordCount - 1);\\n                \\n                for (int j = 1; j < wordCount; j++) {\\n                    int spacesToAdd = totalSpaces + (extraSpaces-- > 0 ? 1 : 0);\\n                    lineBuilder.append(\" \".repeat(spacesToAdd)).append(words[i + j]);\\n                }\\n            } \\n            result.add(lineBuilder.toString());\\n        }   \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707606,
                "title": "c-readable-modularized-code",
                "content": "```\\nclass Solution {\\nprivate:\\n    /** \\n     * Returns string containing left-aligned line formed using words[low..high]\\n     * @param maxWidth: Total length of the line\\n     */\\n    string getLeftAlignedLine(int low, int high, vector<string>& words, int maxWidth) {\\n        string line;\\n        for(int i = low; i <= high; i++)\\n            line += words[i] + \" \";\\n        line.pop_back();\\n        line += string(maxWidth - line.size(), \\' \\');\\n        return line;\\n    }\\n    \\n    /**\\n     * Returns string containing justified line formed using words[low..high]\\n     * @param extraSpace: Number of extra spaces that need to be spread evenly between\\n     *      the words. This count doesn\\'t include the single spaces that already need\\n     *      to be inserted between each pair of words.\\n     */\\n    string getJustifiedLine(int low, int high, vector<string>& words, int extraSpaces) {\\n        string line;\\n        int n = high - low + 1, slots = n - 1;\\n        \\n        // The number of extra spaces that must be inserted between every pair of words.\\n        // Some pairs might have (space+1) spaces between them if the total is in excess.\\n        int space = slots > 0 ? extraSpaces / slots : -1;        \\n\\n        for(int i = 0; i < n - 1; i++) {\\n            line += words[low + i] + \" \" + string(space, \\' \\');\\n            slots--;\\n            extraSpaces -= space;\\n            \\n            // Greedily add an extra space after the current word if the remaining\\n            // spaces are still in excess.\\n            if(extraSpaces > slots * space) {\\n                line += \" \";\\n                extraSpaces--;\\n            }\\n        }\\n        line += words[high] + string(extraSpaces, \\' \\');\\n        return line;\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        for(int i = 0; i < words.size(); i++) {\\n            int currWidth = 0;\\n            int j = i;\\n            while(j < words.size() && (currWidth + words[j].size()) <= maxWidth)\\n                currWidth += words[j++].size() + 1;\\n            j < words.size()\\n                ? res.push_back(getJustifiedLine(i, j - 1, words, maxWidth - currWidth + 1))\\n                : res.push_back(getLeftAlignedLine(i, j - 1, words, maxWidth));\\n            i = j - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    /** \\n     * Returns string containing left-aligned line formed using words[low..high]\\n     * @param maxWidth: Total length of the line\\n     */\\n    string getLeftAlignedLine(int low, int high, vector<string>& words, int maxWidth) {\\n        string line;\\n        for(int i = low; i <= high; i++)\\n            line += words[i] + \" \";\\n        line.pop_back();\\n        line += string(maxWidth - line.size(), \\' \\');\\n        return line;\\n    }\\n    \\n    /**\\n     * Returns string containing justified line formed using words[low..high]\\n     * @param extraSpace: Number of extra spaces that need to be spread evenly between\\n     *      the words. This count doesn\\'t include the single spaces that already need\\n     *      to be inserted between each pair of words.\\n     */\\n    string getJustifiedLine(int low, int high, vector<string>& words, int extraSpaces) {\\n        string line;\\n        int n = high - low + 1, slots = n - 1;\\n        \\n        // The number of extra spaces that must be inserted between every pair of words.\\n        // Some pairs might have (space+1) spaces between them if the total is in excess.\\n        int space = slots > 0 ? extraSpaces / slots : -1;        \\n\\n        for(int i = 0; i < n - 1; i++) {\\n            line += words[low + i] + \" \" + string(space, \\' \\');\\n            slots--;\\n            extraSpaces -= space;\\n            \\n            // Greedily add an extra space after the current word if the remaining\\n            // spaces are still in excess.\\n            if(extraSpaces > slots * space) {\\n                line += \" \";\\n                extraSpaces--;\\n            }\\n        }\\n        line += words[high] + string(extraSpaces, \\' \\');\\n        return line;\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        for(int i = 0; i < words.size(); i++) {\\n            int currWidth = 0;\\n            int j = i;\\n            while(j < words.size() && (currWidth + words[j].size()) <= maxWidth)\\n                currWidth += words[j++].size() + 1;\\n            j < words.size()\\n                ? res.push_back(getJustifiedLine(i, j - 1, words, maxWidth - currWidth + 1))\\n                : res.push_back(getLeftAlignedLine(i, j - 1, words, maxWidth));\\n            i = j - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633915,
                "title": "fast-and-thoroughly-explained-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529356,
                "title": "python-3-o-n",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        count, cur_words = 0, []\\n        res = []\\n        for word in words:\\n            if count+ len(word) + len(cur_words) > maxWidth:\\n                spaces = maxWidth - count\\n                for i in range(spaces):\\n                    cur_words[i % (len(cur_words)-1 if len(cur_words)>1 else 1)] += \\' \\'\\n                res.append(\"\".join(cur_words))\\n                count, cur_words = 0, []\\n            count+=len(word)\\n            cur_words.append(word)\\n        \\n\\t\\t# last row\\n        spaces = maxWidth - count - (len(cur_words)-1)\\n        res.append(\" \".join(cur_words)+\" \"*spaces)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        count, cur_words = 0, []\\n        res = []\\n        for word in words:\\n            if count+ len(word) + len(cur_words) > maxWidth:\\n                spaces = maxWidth - count\\n                for i in range(spaces):\\n                    cur_words[i % (len(cur_words)-1 if len(cur_words)>1 else 1)] += \\' \\'\\n                res.append(\"\".join(cur_words))\\n                count, cur_words = 0, []\\n            count+=len(word)\\n            cur_words.append(word)\\n        \\n\\t\\t# last row\\n        spaces = maxWidth - count - (len(cur_words)-1)\\n        res.append(\" \".join(cur_words)+\" \"*spaces)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117010,
                "title": "clear-and-readable-c-solution-beats-100",
                "content": "I'm not sure if they upgraded the C# compiler, but this solution appears to be 100ms faster than previous solutions. Additionally, it is intuitive to read.\n\n```\npublic class Line {\n    private readonly int TotalChars;\n    private int CharsLeft;\n    public List<string> Words;\n    \n    public int Spaces {\n        get {\n            int allWordsLen = Words.Aggregate(0, (prev, next) => prev + next.Length);\n            return TotalChars - allWordsLen - (Words.Count - 1);\n        }\n    }\n    public Line(int avail) {\n        TotalChars = avail;\n        CharsLeft = avail;\n        \n        Words = new List<string>();\n    }\n    public bool Consume(string word) {\n        if (word.Length <= CharsLeft) {\n            CharsLeft -= word.Length + 1; //+1 for a space\n            Words.Add(word);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    public override string ToString() {        \n        return Words.Aggregate((prev, next) => string.Format(\"{0} {1}\", prev, next));  \n    }\n}\n\npublic class Solution {\n    \n    public static string Justify(Line line) {\n        //We want to distribute the available spaces into a few different buckets.\n        //To be correct, the last bucket must always contain zero spaces.\n        //This is why I'm % by buckets.Length - 1 in the loop\n        \n        int[] buckets = new int[line.Words.Count];\n        int totalToDistribute = line.Spaces;\n        int index = 0;\n        \n        int totalBuckets = Math.Max(buckets.Length - 1, 1);\n        while (totalToDistribute > 0) {\n            buckets[index]++;\n            totalToDistribute--;\n            index = (index + 1) % totalBuckets;\n        }\n        \n        var withPadding = line.Words.Zip(buckets, (word, bucket) => {\n            return string.Concat(word, new String(' ', bucket));\n        });\n        \n        return withPadding.Aggregate((first, second) => string.Format(\"{0} {1}\", first, second));\n    }\n    \n    public static string LeftJustify(Line line) {\n        return string.Concat(line.ToString(), new String(' ', line.Spaces));\n    }\n    \n    public IList<string> FullJustify(string[] wordsArray, int maxWidth) {\n        Queue<string> words = new Queue<string>(wordsArray);\n        List<Line> lines = new List<Line>();\n        \n        while (words.Count > 0) {\n            Line line = new Line(maxWidth);\n            while (words.Count > 0 && line.Consume(words.Peek())) {\n                words.Dequeue();\n            }\n            lines.Add(line);\n        }\n        \n        //We justify all the lines until the very last\n        List<string> result = new List<string>();\n        for (int i = 0; i < lines.Count - 1; i++) {\n            result.Add(Justify(lines[i]));\n        }\n        //And then do a special left justify on the last.\n        result.Add(LeftJustify(lines.Last()));\n        return result;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\npublic class Line {\n    private readonly int TotalChars;\n    private int CharsLeft;\n    public List<string> Words;\n    \n    public int Spaces {\n        get {\n            int allWordsLen = Words.Aggregate(0, (prev, next) => prev + next.Length);\n            return TotalChars - allWordsLen - (Words.Count - 1);\n        }\n    }\n    public Line(int avail) {\n        TotalChars = avail;\n        CharsLeft = avail;\n        \n        Words = new List<string>();\n    }\n    public bool Consume(string word) {\n        if (word.Length <= CharsLeft) {\n            CharsLeft -= word.Length + 1; //+1 for a space\n            Words.Add(word);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    public override string ToString() {        \n        return Words.Aggregate((prev, next) => string.Format(\"{0} {1}\", prev, next));  \n    }\n}\n\npublic class Solution {\n    \n    public static string Justify(Line line) {\n        //We want to distribute the available spaces into a few different buckets.\n        //To be correct, the last bucket must always contain zero spaces.\n        //This is why I'm % by buckets.Length - 1 in the loop\n        \n        int[] buckets = new int[line.Words.Count];\n        int totalToDistribute = line.Spaces;\n        int index = 0;\n        \n        int totalBuckets = Math.Max(buckets.Length - 1, 1);\n        while (totalToDistribute > 0) {\n            buckets[index]++;\n            totalToDistribute--;\n            index = (index + 1) % totalBuckets;\n        }\n        \n        var withPadding = line.Words.Zip(buckets, (word, bucket) => {\n            return string.Concat(word, new String(' ', bucket));\n        });\n        \n        return withPadding.Aggregate((first, second) => string.Format(\"{0} {1}\", first, second));\n    }\n    \n    public static string LeftJustify(Line line) {\n        return string.Concat(line.ToString(), new String(' ', line.Spaces));\n    }\n    \n    public IList<string> FullJustify(string[] wordsArray, int maxWidth) {\n        Queue<string> words = new Queue<string>(wordsArray);\n        List<Line> lines = new List<Line>();\n        \n        while (words.Count > 0) {\n            Line line = new Line(maxWidth);\n            while (words.Count > 0 && line.Consume(words.Peek())) {\n                words.Dequeue();\n            }\n            lines.Add(line);\n        }\n        \n        //We justify all the lines until the very last\n        List<string> result = new List<string>();\n        for (int i = 0; i < lines.Count - 1; i++) {\n            result.Add(Justify(lines[i]));\n        }\n        //And then do a special left justify on the last.\n        result.Add(LeftJustify(lines.Last()));\n        return result;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 24974,
                "title": "concise-solution-in-ruby",
                "content": "fit as many words into one line as possible, then join the words with proper number of spaces.\\n\\n    def full_justify(words, max_width)\\n      v, line = [], []\\n      words.each do |word|\\n        if (line+[word]).join(' ').size > max_width\\n          v.push(join_line(line, max_width))\\n          line = []\\n        end\\n        line.push(word)\\n      end\\n      v.push(join_line(line, max_width, true))\\n    end\\n    \\n    def join_line(line, max_width, last = false)\\n      return line.join(' ') + ' '*(max_width-line.join(' ').size) if (line.size == 1 or last == true)\\n      space, extra = (max_width-line.join.size).divmod(line.size-1)\\n      line[0..extra].join(' '*(space+1)) + ' '*space + line[extra+1..-1].join(' '*space)\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "fit as many words into one line as possible, then join the words with proper number of spaces.\\n\\n    def full_justify(words, max_width)\\n      v, line = [], []\\n      words.each do |word|\\n        if (line+[word]).join(' ').size > max_width\\n          v.push(join_line(line, max_width))\\n          line = []\\n        end\\n        line.push(word)\\n      end\\n      v.push(join_line(line, max_width, true))\\n    end\\n    \\n    def join_line(line, max_width, last = false)\\n      return line.join(' ') + ' '*(max_width-line.join(' ').size) if (line.size == 1 or last == true)\\n      space, extra = (max_width-line.join.size).divmod(line.size-1)\\n      line[0..extra].join(' '*(space+1)) + ' '*space + line[extra+1..-1].join(' '*space)\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 1324217,
                "title": "python-version-of-the-nicely-broken-java-code",
                "content": "Python version of the amazing Java code https://leetcode.com/problems/text-justification/discuss/24902/Java-easy-to-understand-broken-into-several-functions\\n```\\n\\'\\'\\'\\nAlgorithm: https://leetcode.com/problems/text-justification/discuss/24902/Java-easy-to-understand-broken-into-several-functions\\n1. while there are words:\\n2.     collect words that will go in the same line\\n3.     fix spaces in these words\\n\\'\\'\\'\\nclass Solution:\\n    def findSameLineWords(self, start, maxWidth, words):\\n        chars = 0\\n        \\'\\'\\'\\n        maxWidth + 1 cause the last word of every sentence doesn\\'t have a space, so in case the last word of the sentence fits exactly we need to accomodate the fact that it has no trailing space\\n        \"enough to explain to\" maxWidth=20\\n        \\'\\'\\' \\n        while start < len(words) and chars + len(words[start]) + 1 <= maxWidth + 1:\\n            chars += len(words[start]) + 1\\n            start += 1\\n        return start - 1\\n    \\n    \\n    def fixSpaces(self, start, end, words, maxWidth):\\n        generate_spaces = lambda x: \\' \\' * x\\n        \\n        answer = []\\n        \\n        # if only 1 word: pad spaces at the end\\n        if end == start:\\n            answer.append(words[start])\\n            answer.append(generate_spaces(maxWidth - len(words[start])))\\n            return \\'\\'.join(answer)\\n        \\n        # special care is required for the last line as it has no spaces between words \\n        is_last_line = (end == len(words) - 1)\\n        total_chars = sum(len(words[i]) for i in range(start, end + 1))\\n        total_spaces = maxWidth - total_chars \\n        even_spaces = total_spaces // (end - start) if is_last_line is False else 1\\n        remainder_spaces = total_spaces - even_spaces * (end - start) if is_last_line is False else 0\\n        \\n        # print(words[start : end + 1], \\'total_chars:\\', total_chars, \\'total_spaces:\\', total_spaces, \\'even_spaces:\\', even_spaces, \\'remainder_spaces:\\', remainder_spaces)\\n        \\n        for idx in range(start, end + 1):\\n            answer.append(words[idx])\\n            answer.append(generate_spaces(even_spaces))\\n            if remainder_spaces > 0:\\n                answer.append(generate_spaces(1))\\n                remainder_spaces -= 1\\n        sentence = \\'\\'.join(answer[: -1])     # remove the trailing spaces\\n        if is_last_line is False:            # if not the last sentence return without the trailing spaces\\n            return sentence\\n        else:                                # add the trailing spaces\\n            return sentence + generate_spaces(maxWidth - len(sentence))\\n                \\n        \\n        \\n    def fullJustify(self, words, maxWidth):\\n        start = 0\\n        answer = []\\n        while start < len(words):\\n            end = self.findSameLineWords(start, maxWidth, words)\\n            answer.append(self.fixSpaces(start, end, words, maxWidth))\\n            # print(start, end)\\n            start = end + 1\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nAlgorithm: https://leetcode.com/problems/text-justification/discuss/24902/Java-easy-to-understand-broken-into-several-functions\\n1. while there are words:\\n2.     collect words that will go in the same line\\n3.     fix spaces in these words\\n\\'\\'\\'\\nclass Solution:\\n    def findSameLineWords(self, start, maxWidth, words):\\n        chars = 0\\n        \\'\\'\\'\\n        maxWidth + 1 cause the last word of every sentence doesn\\'t have a space, so in case the last word of the sentence fits exactly we need to accomodate the fact that it has no trailing space\\n        \"enough to explain to\" maxWidth=20\\n        \\'\\'\\' \\n        while start < len(words) and chars + len(words[start]) + 1 <= maxWidth + 1:\\n            chars += len(words[start]) + 1\\n            start += 1\\n        return start - 1\\n    \\n    \\n    def fixSpaces(self, start, end, words, maxWidth):\\n        generate_spaces = lambda x: \\' \\' * x\\n        \\n        answer = []\\n        \\n        # if only 1 word: pad spaces at the end\\n        if end == start:\\n            answer.append(words[start])\\n            answer.append(generate_spaces(maxWidth - len(words[start])))\\n            return \\'\\'.join(answer)\\n        \\n        # special care is required for the last line as it has no spaces between words \\n        is_last_line = (end == len(words) - 1)\\n        total_chars = sum(len(words[i]) for i in range(start, end + 1))\\n        total_spaces = maxWidth - total_chars \\n        even_spaces = total_spaces // (end - start) if is_last_line is False else 1\\n        remainder_spaces = total_spaces - even_spaces * (end - start) if is_last_line is False else 0\\n        \\n        # print(words[start : end + 1], \\'total_chars:\\', total_chars, \\'total_spaces:\\', total_spaces, \\'even_spaces:\\', even_spaces, \\'remainder_spaces:\\', remainder_spaces)\\n        \\n        for idx in range(start, end + 1):\\n            answer.append(words[idx])\\n            answer.append(generate_spaces(even_spaces))\\n            if remainder_spaces > 0:\\n                answer.append(generate_spaces(1))\\n                remainder_spaces -= 1\\n        sentence = \\'\\'.join(answer[: -1])     # remove the trailing spaces\\n        if is_last_line is False:            # if not the last sentence return without the trailing spaces\\n            return sentence\\n        else:                                # add the trailing spaces\\n            return sentence + generate_spaces(maxWidth - len(sentence))\\n                \\n        \\n        \\n    def fullJustify(self, words, maxWidth):\\n        start = 0\\n        answer = []\\n        while start < len(words):\\n            end = self.findSameLineWords(start, maxWidth, words)\\n            answer.append(self.fixSpaces(start, end, words, maxWidth))\\n            # print(start, end)\\n            start = end + 1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129791,
                "title": "java-solution-with-explanation-0-ms",
                "content": "The idea was to keep adding words to a buffer (an ArrayList) while the width is under the maxWidth and build a new line if it overflows.\\nIn particular, a width is the sum of following two values ```A``` and ```B```:\\n\\n- ```A``` Sum of number of characters of words in the buffer\\n- ```B``` Minimal number of necessary spaces for building a line from the words in the buffer\\n\\n```B``` can be simply calculated from the size of the buffer.\\nI.e. if we want to build a line from N words then we need at least N-1 spaces in total to separate each word.\\n\\nWhen we build a new line from the words in the buffer, we will need ```maxWidth - A```  spaces in total.\\nDepending on if it is the last line or not, we need to distribute these spaces accordingly.\\n\\nTime complexity: O(N): N is number of words\\nSpace complexity: O(N): In worst case, I\\'ll store all words to the buffer\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> answer = new ArrayList<>();\\n        \\n        List<String> buffer = new ArrayList<>();\\n        \\n        // Sum of characters of words in the buffer\\n        int sumChars = 0;\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            \\n            // Build a new line when it exceeds the maxWidth if you append the current word to the buffer too.\\n            // buffer.size() represents the minimal number of spaces we need to build a line.\\n            if(word.length() + sumChars + buffer.size() > maxWidth) {\\n                // maxWidth - sumChars is the total number of spaces we need to build this line\\n                String line = buildLine(buffer, maxWidth - sumChars, false);\\n                answer.add(line);\\n                sumChars = 0;\\n                buffer.clear();\\n            }\\n            \\n            sumChars += word.length();\\n            buffer.add(word);\\n            \\n            // Build the last line if it is the last word\\n            if(i == words.length - 1) {\\n                String line = buildLine(buffer, maxWidth - sumChars, true);\\n                answer.add(line);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    // Helper method that builds a line from a list of words and number of spaces to be distributed.\\n    private String buildLine(List<String> words, int spaces, boolean isLastLine) {\\n        StringBuilder builder = new StringBuilder();\\n        \\n        // Last line: separate the words with single spaces\\n        if(isLastLine) {\\n            for(Iterator<String> it = words.iterator(); it.hasNext();) {\\n                builder.append(it.next());\\n                \\n                if(it.hasNext()) {\\n                    builder.append(\" \");\\n                    spaces--;\\n                }\\n            }\\n        // Otherwise, calculate necessary amount of spaces to be add in each iteration\\n        } else {\\n            for(int i = 0; i < words.size(); i++) {\\n                builder.append(words.get(i));\\n                \\n                if(i < words.size() -1) {\\n                    // If we still have N words in the list then we need to distribute the remaining spaces to N-1 slots.\\n                    int divisor = (words.size() - i) - 1;\\n                    int spacesForThisSlot = (spaces + divisor - 1) / divisor; // round up\\n                    \\n                    for(int j = 0; j < spacesForThisSlot; j++) {\\n                        builder.append(\" \");\\n                        spaces--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Fill the rest of the line with spaces when there are leftovers\\n        // This happens if it is the last line or the words list had only one element\\n        for(int i = 0; i < spaces; i++) {\\n            builder.append(\" \");\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```A```\n```B```\n```A```\n```B```\n```B```\n```maxWidth - A```\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> answer = new ArrayList<>();\\n        \\n        List<String> buffer = new ArrayList<>();\\n        \\n        // Sum of characters of words in the buffer\\n        int sumChars = 0;\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            \\n            // Build a new line when it exceeds the maxWidth if you append the current word to the buffer too.\\n            // buffer.size() represents the minimal number of spaces we need to build a line.\\n            if(word.length() + sumChars + buffer.size() > maxWidth) {\\n                // maxWidth - sumChars is the total number of spaces we need to build this line\\n                String line = buildLine(buffer, maxWidth - sumChars, false);\\n                answer.add(line);\\n                sumChars = 0;\\n                buffer.clear();\\n            }\\n            \\n            sumChars += word.length();\\n            buffer.add(word);\\n            \\n            // Build the last line if it is the last word\\n            if(i == words.length - 1) {\\n                String line = buildLine(buffer, maxWidth - sumChars, true);\\n                answer.add(line);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    // Helper method that builds a line from a list of words and number of spaces to be distributed.\\n    private String buildLine(List<String> words, int spaces, boolean isLastLine) {\\n        StringBuilder builder = new StringBuilder();\\n        \\n        // Last line: separate the words with single spaces\\n        if(isLastLine) {\\n            for(Iterator<String> it = words.iterator(); it.hasNext();) {\\n                builder.append(it.next());\\n                \\n                if(it.hasNext()) {\\n                    builder.append(\" \");\\n                    spaces--;\\n                }\\n            }\\n        // Otherwise, calculate necessary amount of spaces to be add in each iteration\\n        } else {\\n            for(int i = 0; i < words.size(); i++) {\\n                builder.append(words.get(i));\\n                \\n                if(i < words.size() -1) {\\n                    // If we still have N words in the list then we need to distribute the remaining spaces to N-1 slots.\\n                    int divisor = (words.size() - i) - 1;\\n                    int spacesForThisSlot = (spaces + divisor - 1) / divisor; // round up\\n                    \\n                    for(int j = 0; j < spacesForThisSlot; j++) {\\n                        builder.append(\" \");\\n                        spaces--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Fill the rest of the line with spaces when there are leftovers\\n        // This happens if it is the last line or the words list had only one element\\n        for(int i = 0; i < spaces; i++) {\\n            builder.append(\" \");\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908663,
                "title": "short-java",
                "content": "The idea is from [@ashish-sjc](https://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines./303690). \\n1. Use List<StringBuilder> to store a line so we can add space after each word without creating a new string.\\n2. Iterate through each word, add to the current line, if current line is full, format the current line and add word to next line.\\n3. In #2, a line is fully justified when the next word does not fit the line. In other words, the current line won\\'t be fully justified until we process the next word. Since the last line does not have the next word, it won\\'t be fully justified. This fits the requirement perfectly because the last line requires a different format, left justification.\\n```\\n\\t public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res=new ArrayList<>();\\n        List<StringBuilder> line=new ArrayList<>();\\n        int totLetters=0;\\n        for(String word:words) {\\n            int len=word.length(), size=line.size();\\n            if(totLetters+size+len>maxWidth) {\\n                int space = maxWidth - totLetters;\\n                if(size==1) {\\n                    res.add(line.get(0).toString()+\" \".repeat(space));\\n                } else {\\n                    int spc=space/(size-1), r=space%(size-1);\\n                    for(int i=0;i<r;i++)\\n                        line.get(i).append(\" \");\\n                    res.add(String.join(\" \".repeat(spc),line));\\n                }\\n                totLetters=0;\\n                line.clear();\\n            }\\n            totLetters+=len;\\n            line.add(new StringBuilder(word));\\n        }\\n        String last=String.join(\" \",line);\\n        res.add(String.format(\"%-\"+maxWidth+\"s\",last));\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\t public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res=new ArrayList<>();\\n        List<StringBuilder> line=new ArrayList<>();\\n        int totLetters=0;\\n        for(String word:words) {\\n            int len=word.length(), size=line.size();\\n            if(totLetters+size+len>maxWidth) {\\n                int space = maxWidth - totLetters;\\n                if(size==1) {\\n                    res.add(line.get(0).toString()+\" \".repeat(space));\\n                } else {\\n                    int spc=space/(size-1), r=space%(size-1);\\n                    for(int i=0;i<r;i++)\\n                        line.get(i).append(\" \");\\n                    res.add(String.join(\" \".repeat(spc),line));\\n                }\\n                totLetters=0;\\n                line.clear();\\n            }\\n            totLetters+=len;\\n            line.add(new StringBuilder(word));\\n        }\\n        String last=String.join(\" \",line);\\n        res.add(String.format(\"%-\"+maxWidth+\"s\",last));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672626,
                "title": "python3-a-concise-solution",
                "content": "This implementation is based on the amazing solution given by @sherlock321 in this [thread](https://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines.). I\\'ve made a few changes to reflect my coding style. Credit goes to the original author. \\n\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans = []\\n        line, width = [], 0\\n        \\n        for word in words: \\n            if width + len(line) + len(word) > maxWidth: \\n                n, k = divmod(maxWidth - width, max(1, len(line)-1))\\n                for i in range(max(1, len(line)-1)): \\n                    line[i] += \" \" * (n + (i < k))\\n                ans.append(\"\".join(line))\\n                line, width = [], 0\\n            line.append(word)\\n            width += len(word)\\n            \\n        ans.append(\" \".join(line).ljust(maxWidth))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans = []\\n        line, width = [], 0\\n        \\n        for word in words: \\n            if width + len(line) + len(word) > maxWidth: \\n                n, k = divmod(maxWidth - width, max(1, len(line)-1))\\n                for i in range(max(1, len(line)-1)): \\n                    line[i] += \" \" * (n + (i < k))\\n                ans.append(\"\".join(line))\\n                line, width = [], 0\\n            line.append(word)\\n            width += len(word)\\n            \\n        ans.append(\" \".join(line).ljust(maxWidth))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 519796,
                "title": "go-0ms-solution-easy-to-understand",
                "content": "```go\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tjustify := []string{}\\n\\tcurrent, curLength := []string{}, 0\\n\\tfor i, w := range words {\\n\\t\\tif curLength + len(current) + len(w) > maxWidth {\\n\\t\\t\\tif len(current) == 1 {\\n\\t\\t\\t\\t// only one word, all spaces are to the right of the word\\n\\t\\t\\t\\tcurLine := current[0] + strings.Repeat(\" \", maxWidth-len(current[0]))\\n\\t\\t\\t\\tjustify = append(justify, curLine)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdiff := maxWidth - curLength\\n\\t\\t\\t\\tspaces := diff / (len(current)-1)\\n\\t\\t\\t\\tmore := diff % (len(current)-1)\\n\\t\\t\\t\\tcurLine := bytes.Buffer{}\\n\\t\\t\\t\\tfor ci, cw := range current {\\n\\t\\t\\t\\t\\tcurLine.WriteString(cw)\\n\\t\\t\\t\\t\\tif ci != len(current) - 1 {\\n\\t\\t\\t\\t\\t\\tmoreBlanks := 0\\n\\t\\t\\t\\t\\t\\tif more > 0 {\\n\\t\\t\\t\\t\\t\\t\\tmoreBlanks = 1\\n\\t\\t\\t\\t\\t\\t\\tmore--\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurLine.WriteString(strings.Repeat(\" \", spaces+ moreBlanks))\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tjustify = append(justify, curLine.String())\\n\\t\\t\\t}\\n\\t\\t\\tcurrent, curLength = []string{}, 0\\n\\t\\t}\\n\\n\\t\\tcurLength += len(w)\\n\\t\\tcurrent = append(current, w)\\n\\n\\t\\t// last line, left justified and no extra space is inserted between words\\n\\t\\tif i == len(words) - 1 {\\n\\t\\t\\tlastLine := strings.Join(current, \" \")\\n\\t\\t\\tlastLine = lastLine + strings.Repeat(\" \", maxWidth-len(lastLine))\\n\\t\\t\\tjustify = append(justify, lastLine)\\n\\t\\t}\\n\\t}\\n\\treturn justify\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tjustify := []string{}\\n\\tcurrent, curLength := []string{}, 0\\n\\tfor i, w := range words {\\n\\t\\tif curLength + len(current) + len(w) > maxWidth {\\n\\t\\t\\tif len(current) == 1 {\\n\\t\\t\\t\\t// only one word, all spaces are to the right of the word\\n\\t\\t\\t\\tcurLine := current[0] + strings.Repeat(\" \", maxWidth-len(current[0]))\\n\\t\\t\\t\\tjustify = append(justify, curLine)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdiff := maxWidth - curLength\\n\\t\\t\\t\\tspaces := diff / (len(current)-1)\\n\\t\\t\\t\\tmore := diff % (len(current)-1)\\n\\t\\t\\t\\tcurLine := bytes.Buffer{}\\n\\t\\t\\t\\tfor ci, cw := range current {\\n\\t\\t\\t\\t\\tcurLine.WriteString(cw)\\n\\t\\t\\t\\t\\tif ci != len(current) - 1 {\\n\\t\\t\\t\\t\\t\\tmoreBlanks := 0\\n\\t\\t\\t\\t\\t\\tif more > 0 {\\n\\t\\t\\t\\t\\t\\t\\tmoreBlanks = 1\\n\\t\\t\\t\\t\\t\\t\\tmore--\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurLine.WriteString(strings.Repeat(\" \", spaces+ moreBlanks))\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tjustify = append(justify, curLine.String())\\n\\t\\t\\t}\\n\\t\\t\\tcurrent, curLength = []string{}, 0\\n\\t\\t}\\n\\n\\t\\tcurLength += len(w)\\n\\t\\tcurrent = append(current, w)\\n\\n\\t\\t// last line, left justified and no extra space is inserted between words\\n\\t\\tif i == len(words) - 1 {\\n\\t\\t\\tlastLine := strings.Join(current, \" \")\\n\\t\\t\\tlastLine = lastLine + strings.Repeat(\" \", maxWidth-len(lastLine))\\n\\t\\t\\tjustify = append(justify, lastLine)\\n\\t\\t}\\n\\t}\\n\\treturn justify\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156704,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        curr_line = []\\n        curr_line_width = 0\\n        lines = []\\n        \\n        for word in words:\\n            if len(word) + curr_line_width + len(curr_line) > maxWidth:\\n                # Need to add justified line\\n                nspaces = len(curr_line) - 1 if len(curr_line) - 1 else 1\\n                for i in range(maxWidth - curr_line_width):\\n                    curr_line[i % nspaces] += \" \"\\n                lines.append(\"\".join(curr_line))\\n                curr_line = []\\n                curr_line_width = 0\\n            curr_line.append(word)\\n            curr_line_width += len(word)\\n        \\n        last_line = \" \".join(curr_line)\\n        last_line = last_line.strip()\\n        last_line = last_line + \" \"*(maxWidth - len(last_line))\\n        lines.append(last_line)\\n        return lines\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        curr_line = []\\n        curr_line_width = 0\\n        lines = []\\n        \\n        for word in words:\\n            if len(word) + curr_line_width + len(curr_line) > maxWidth:\\n                # Need to add justified line\\n                nspaces = len(curr_line) - 1 if len(curr_line) - 1 else 1\\n                for i in range(maxWidth - curr_line_width):\\n                    curr_line[i % nspaces] += \" \"\\n                lines.append(\"\".join(curr_line))\\n                curr_line = []\\n                curr_line_width = 0\\n            curr_line.append(word)\\n            curr_line_width += len(word)\\n        \\n        last_line = \" \".join(curr_line)\\n        last_line = last_line.strip()\\n        last_line = last_line + \" \"*(maxWidth - len(last_line))\\n        lines.append(last_line)\\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955974,
                "title": "c-beats-100-binary-search-detailed-explaination",
                "content": "# Intuition\\nUpon examining the problem, it becomes clear that the task involves determining the number of words that can fit on each line while considering the need for padding. The solution is achieved by first calculating the required padding for even distribution, with any extra padding allocated to the left side of the words.\\n\\nTo illustrate, the arrangement should resemble:\\n[**WORD1**]--*PADDING*--[**WORD2**]--*PADDING*--[**WORD3**]\\n\\nThe goal is to ensure that this entire construction spans a length equal to \"maxWidth\". The process for calculating word counts and arranging padding is elaborated in the forthcoming \"Approach\" section.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach to solving this problem can be divided into several steps:\\n\\n**Word Length Prefix Sum:** Construct an array to hold the lengths of individual words (or you can do the prefix sum directly), and another array for their prefix sum. The prefix sum array, being non-decreasing, allows efficient binary search. This binary search aids in determining the number of words that can fit within a given line length.\\n\\n**Predicate Function** - Feasibility Check: Define a predicate function called isPossible, which checks if a specific word count can fit within a line. This function relies on the prefix sum array and the given conditions to decide if a certain word count is feasible for the line length.\\n\\n**Binary Search**: Utilize binary search to find the optimal word count that can be accommodated in a line, while meeting the length constraint. The binary search narrows down the word count to a feasible range.\\n\\n**Padding Calculation:** Calculate the padding required for distribution. Determine the minimum length of padding between words and the remaining padding that needs to be allocated. Extra padding, if applicable, is distributed starting from the left.\\n\\n**Line Formation:** Create a string named curr with the length of maxWidth, initialized with spaces. Insert words into the curr string, followed by the calculated padding. This process is continued until the desired line length is achieved.\\n\\n**Updating Pointers:** Update the alreadyTaken pointer to indicate the words that have been included in the current line.\\n\\n**Iterative Process:** Iterate through the words while constructing lines until all words are processed.\\n\\nThe provided code implementation employs this approach, integrating binary search, padding distribution, and line formation to produce justified lines of text.\\n\\nThis approach ensures that each line adheres to the \"maxWidth\" criterion while optimizing word distribution and padding arrangement. The binary search and efficient padding calculations contribute to a time complexity of O(N * (maxWidth + log N)), where N represents the number of words in the input. The space complexity is O(N) due to the storage of the word length prefix sum array.\\n\\nCheck the Comments in \"Source Code\".\\nIf you have any question, put them in the comment section.\\nPlease upvote. If you have liked it.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N * (maxWidth + log N))\\n- N : words.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int N;\\n    int maxWidth;\\n    int alreadyTaken;\\n    vector<int> preFixLength;\\n    bool isPossible(int count) {                    // T.C: O(1)\\n        int spaceNeeded = count - alreadyTaken - 1;\\n        int totalWordsLen = preFixLength[count] - preFixLength[alreadyTaken];\\n        return (totalWordsLen + spaceNeeded) <= maxWidth;\\n    }\\n    int fitWords(int fromIndex, vector<string> &words, vector<string> &ans) {\\n        // Binary Search\\n        int l = alreadyTaken, r = N + 1;\\n        // Invariance\\n        // isPossible(l) is always true\\n        // isPossible(r) is always false\\n        while (l + 1 < r) {                         // T.C: O(log n)\\n            int m = l + (r - l) / 2;\\n            if (isPossible(m))\\n                l = m;\\n            else\\n                r = m;\\n        }\\n        // We can place (alreadyTaken, l] in our curr\\n        int wordCount = l - alreadyTaken;\\n        int totalWordsLen = preFixLength[l] - preFixLength[alreadyTaken];\\n        int spaceNeeded = maxWidth - totalWordsLen;\\n        int gapNeeded = 1, extraGap = 0;\\n        if (wordCount > 1 && l != N) {\\n            gapNeeded = spaceNeeded / (wordCount - 1);\\n            extraGap = spaceNeeded % (wordCount - 1);\\n        } \\n        int k = 0;\\n        string curr(maxWidth, \\' \\');                 // T.C: O(maxWidth)\\n        for (int i = alreadyTaken; i < l; i++) {    // T.C: O(maxWidth)\\n            for (int j = 0; j < words[i].size(); j++) {\\n                curr[k++] = words[i][j]; \\n            }\\n            // Put Spaces\\n            k += gapNeeded;\\n            if (extraGap) {\\n                k++;\\n                extraGap--;\\n            }\\n        }\\n        // Update alreadyTaken\\n        alreadyTaken = l;\\n        ans.push_back(curr);\\n        return l;\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int _maxWidth) {\\n        /* Approach:\\n            1. Binary Search -- T.C: O(n * (maxWidth + log n)), S.C: O(n)\\n        */\\n\\n        // Approach 1\\n        alreadyTaken = 0;\\n        N = words.size();\\n        maxWidth = _maxWidth;\\n        preFixLength.assign(N + 1, 0);\\n        // Calculate Prefix Length\\n        for (int i = 1; i <= N; i++) {\\n            preFixLength[i] = preFixLength[i - 1] + words[i - 1].size();\\n        }\\n\\n        vector<string> ans;\\n\\n        int i = 0;\\n        while (i < N) {     // T.C: O(n * (maxWidth + log n))\\n            i = fitWords(i, words, ans);\\n        }\\n        /* Reasoning behind the time complexity:\\n            In the worst case, we are given such words, that our output contains only one word in each line\\n            Complexity of our fitWords() function is O(maxWidth + log (Search Range))\\n            In this case:\\n                i is incremented by 1 and serach space reduces by 1\\n                so the while loop will run \\'N\\' times to call fitWords() function\\n                Time Complexity:\\n                    [maxWidth + log (N)] + [maxWidth + log (N - 1)] + . . . . . [maxWidth + log (2)]\\n                    Which is = N * (maxWidth + log N)\\n        */\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int N;\\n    int maxWidth;\\n    int alreadyTaken;\\n    vector<int> preFixLength;\\n    bool isPossible(int count) {                    // T.C: O(1)\\n        int spaceNeeded = count - alreadyTaken - 1;\\n        int totalWordsLen = preFixLength[count] - preFixLength[alreadyTaken];\\n        return (totalWordsLen + spaceNeeded) <= maxWidth;\\n    }\\n    int fitWords(int fromIndex, vector<string> &words, vector<string> &ans) {\\n        // Binary Search\\n        int l = alreadyTaken, r = N + 1;\\n        // Invariance\\n        // isPossible(l) is always true\\n        // isPossible(r) is always false\\n        while (l + 1 < r) {                         // T.C: O(log n)\\n            int m = l + (r - l) / 2;\\n            if (isPossible(m))\\n                l = m;\\n            else\\n                r = m;\\n        }\\n        // We can place (alreadyTaken, l] in our curr\\n        int wordCount = l - alreadyTaken;\\n        int totalWordsLen = preFixLength[l] - preFixLength[alreadyTaken];\\n        int spaceNeeded = maxWidth - totalWordsLen;\\n        int gapNeeded = 1, extraGap = 0;\\n        if (wordCount > 1 && l != N) {\\n            gapNeeded = spaceNeeded / (wordCount - 1);\\n            extraGap = spaceNeeded % (wordCount - 1);\\n        } \\n        int k = 0;\\n        string curr(maxWidth, \\' \\');                 // T.C: O(maxWidth)\\n        for (int i = alreadyTaken; i < l; i++) {    // T.C: O(maxWidth)\\n            for (int j = 0; j < words[i].size(); j++) {\\n                curr[k++] = words[i][j]; \\n            }\\n            // Put Spaces\\n            k += gapNeeded;\\n            if (extraGap) {\\n                k++;\\n                extraGap--;\\n            }\\n        }\\n        // Update alreadyTaken\\n        alreadyTaken = l;\\n        ans.push_back(curr);\\n        return l;\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int _maxWidth) {\\n        /* Approach:\\n            1. Binary Search -- T.C: O(n * (maxWidth + log n)), S.C: O(n)\\n        */\\n\\n        // Approach 1\\n        alreadyTaken = 0;\\n        N = words.size();\\n        maxWidth = _maxWidth;\\n        preFixLength.assign(N + 1, 0);\\n        // Calculate Prefix Length\\n        for (int i = 1; i <= N; i++) {\\n            preFixLength[i] = preFixLength[i - 1] + words[i - 1].size();\\n        }\\n\\n        vector<string> ans;\\n\\n        int i = 0;\\n        while (i < N) {     // T.C: O(n * (maxWidth + log n))\\n            i = fitWords(i, words, ans);\\n        }\\n        /* Reasoning behind the time complexity:\\n            In the worst case, we are given such words, that our output contains only one word in each line\\n            Complexity of our fitWords() function is O(maxWidth + log (Search Range))\\n            In this case:\\n                i is incremented by 1 and serach space reduces by 1\\n                so the while loop will run \\'N\\' times to call fitWords() function\\n                Time Complexity:\\n                    [maxWidth + log (N)] + [maxWidth + log (N - 1)] + . . . . . [maxWidth + log (2)]\\n                    Which is = N * (maxWidth + log N)\\n        */\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721607,
                "title": "beats-100-full-explaination-tc-o-n-maxwidth",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPartition approach will work as we have to store as many consecutive words possible in a line, with a constraint that every word is separate by atleast one space with another word. \\n\\nSo, for a line to be valid, the constraints come out to be -\\n`totalLengthOfTheWordsInTheLine + totalNumberOfWordsInTheCurrentLine - 1 <= maxWidth`\\nSo for a line to contain 3 words,the sum  of lengths of all the three words and 2 spaces should be less than or equal to maxWidth.\\n\\nAs soon as the constraint is broken or the length of the line becomes greater than maxWidth, we start storing word in a new line.\\n\\n---\\n```\\nFor Example -\\nwords = [\"abc\",\"ab\",\"ab\",\"a\",\"fgabc\"]\\nmaxWidth = 7\\n\\nOutput - \\n\"abc-ab-\"\\n\"ab---a-\"\\n\"fgabc--\"\\n\\nwhere \\'-\\' represent a single space\\n```\\n\\nThe first line contains abc,ab only and not abc,ab,ab because the words need to be separated by atleast one space, so the length of line abc,ab,ab would be `(3 + 2 + 2) + (3-1) = 7 + 2 = 9`, that would excede the maxWidth criteria, so \"ab\" on index 2 goes to a new line.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize line1 with length of `word[0]`. Since it is the only word in the line and the last word should not be followed by a space, the total length of the line1 remains the same.\\nWe iterate over the words array from `i = 1 to n-1`, storing words in a vector `temp`that belongs to same line, checking if the ith word can be added to the current line. We will be taking a separate variable,`prevLen` to store the totalLengthOfTheWords in the current line, and updating it while iterating. The least number of spaces the current line will be having for adding the current word is `lineSpaces = temp.size()`,i.e., `temp.size() - 1` for existing words, and `+ 1` for adding current word, so overall, `temp.size()` spaces.\\n\\nThe condition of being added to the current line being - \\n`prevLen + lineSpaces + curWordLength <= maxWidth`.\\nSo for creating a new line, condition becomes - \\n`prevLen + lineSpaces + curWordLength > maxWidth`\\nAfter a line, `temp`, can no longer hold more words, we add it to the `lines` vector, and store the space the line can have in a `space` vector, as `maxWidth - prevLen`.\\n\\nNote - After iteration, we have to add the last line in the `lines` vector as it won\\'t be added in the iterating loop.\\n\\nAfter storing all the lines and the corresponding number of spaces they can have. We will be iterating over all the lines and converting them into string with spaces, and store in the `ans` vector.\\n\\nWe have two justifications for a line-\\n1. <b>Left Only Justification</b> - For line containing one word, and the last line.\\n2. <b>Left and Right Justification</b> - For all the other lines not mentioned in 1.\\n\\nSo to append spaces, we have three states -\\n1. <b>When the line is the last line, or the line contains only one word -</b>\\nIn this case, we will be adding only one space after every word, except the last word. The remaining spaces will be added after the last word, to make it left justified \\n\\n2. <b>The line which is not the last line, and contains more than one word-</b>\\nIn this case, we will find out the least number of spaces that we can add between two consecutive words by `sp = space[i]/(numberOfWords-1)`, extra space being `spExtra = space[i]%(numberOfWords-1)`.\\nAs to distribute `space[i]` between `numberOfWords` words, even space will be `sp`, and `extraSpace` that is used only `1` time after each word until it becomes `0`. <i>As per the question statement - <b>\\'Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\\'</b></i>\\nSince extra spaces will be less than the total positions where we can add space, i.e., `spExtra < sp`, therefore we will be adding only `1` extra space, if `spExtra` is not already exhausted.\\n\\n# Complexity\\n- <b>Time complexity: $$O(n+n*maxWidth)$$</b>\\n-$$O(n)$$ for storing character in their respective line\\n-$$O(n.maxWidth)$$ for iterating over all lines to store answer.\\nIn worst case, every line contains a single word, so `n` lines, and for each line we iterate over `maxWidth` characters, to append word characters and spaces. So total iteration becomse $$n*maxWidth$$\\n\\n- <b>Space complexity: $$O(n + n*TotalWordLength+TotalWrdLength + maxWidth)$$</b>\\nSince, maximmum number of lines will be `n` in worst case, therefore space utiltized by \\n-`space` vector for storing space will be $$O(n)$$.\\n-Maximum space utilized by `line` vector will be $$O(n*totalWordLength)$$. Since it stores words only.\\n-$$O(TotalWordLength)$$ for `temp` vector.\\n-String `curr` will also have space complexity of $$O(maxWidth)$$, as it will contain maxWidth characters.\\nSo total space complexity will be $$O(n + n*TotalWordLength+TotalWrdLength + maxWidth)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<vector<string>> lines;\\n        vector<int> spaces;\\n\\n        vector<string> temp = {words[0]};\\n        int i = 1, prevLen = words[0].length();\\n        while(i<n){\\n            int curWordLength = words[i].length();\\n            int prevLineSpaces = temp.size();\\n            if(prevLen + prevLineSpaces + curWordLength > maxWidth){\\n                //if cannot add current word to prev line\\n\\n                //adding prev line to ansvector\\n                lines.push_back(temp);\\n                spaces.push_back(maxWidth - prevLen);\\n\\n                //creating new line\\n                prevLen = curWordLength;\\n                temp.clear();\\n                temp.push_back(words[i]);\\n            }\\n            else{\\n                //adding word to current line\\n                prevLen += curWordLength;\\n                temp.push_back(words[i]);\\n            }\\n            i++;\\n        }\\n        //adding last line\\n        lines.push_back(temp);\\n        spaces.push_back(maxWidth-prevLen);\\n\\n        vector<string> ans;\\n        int sz = lines.size();\\n        //generating line string\\n        for(int j = 0;j<sz;++j){\\n            int numberOfWords = lines[j].size();\\n            int sp = spaces[j];\\n            string cur;\\n            //if last line or contains a single character\\n            if(j == sz-1 || numberOfWords==1){\\n                //left only justified\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //not to add space after last character if no extra space is there\\n                    if(sp){\\n                        cur += \\' \\';\\n                        sp--;\\n                    }\\n                }\\n                //padding extra space after last word\\n                if(sp) while(sp--) cur+=\\' \\';\\n            }\\n            else{\\n                //left & right justified\\n                //extra space to be added after first word\\n                int spExtra = sp%(numberOfWords-1);\\n                sp = sp/(numberOfWords-1);\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //adding even space\\n                    if(l!=numberOfWords-1) for(int k=0;k<sp;++k) cur+=\\' \\';\\n                    //adding extra space after first word only\\n                    if(spExtra){\\n                        cur += \\' \\';\\n                        spExtra--;\\n                    }\\n                }\\n            }\\n            ans.push_back(cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nFor Example -\\nwords = [\"abc\",\"ab\",\"ab\",\"a\",\"fgabc\"]\\nmaxWidth = 7\\n\\nOutput - \\n\"abc-ab-\"\\n\"ab---a-\"\\n\"fgabc--\"\\n\\nwhere \\'-\\' represent a single space\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<vector<string>> lines;\\n        vector<int> spaces;\\n\\n        vector<string> temp = {words[0]};\\n        int i = 1, prevLen = words[0].length();\\n        while(i<n){\\n            int curWordLength = words[i].length();\\n            int prevLineSpaces = temp.size();\\n            if(prevLen + prevLineSpaces + curWordLength > maxWidth){\\n                //if cannot add current word to prev line\\n\\n                //adding prev line to ansvector\\n                lines.push_back(temp);\\n                spaces.push_back(maxWidth - prevLen);\\n\\n                //creating new line\\n                prevLen = curWordLength;\\n                temp.clear();\\n                temp.push_back(words[i]);\\n            }\\n            else{\\n                //adding word to current line\\n                prevLen += curWordLength;\\n                temp.push_back(words[i]);\\n            }\\n            i++;\\n        }\\n        //adding last line\\n        lines.push_back(temp);\\n        spaces.push_back(maxWidth-prevLen);\\n\\n        vector<string> ans;\\n        int sz = lines.size();\\n        //generating line string\\n        for(int j = 0;j<sz;++j){\\n            int numberOfWords = lines[j].size();\\n            int sp = spaces[j];\\n            string cur;\\n            //if last line or contains a single character\\n            if(j == sz-1 || numberOfWords==1){\\n                //left only justified\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //not to add space after last character if no extra space is there\\n                    if(sp){\\n                        cur += \\' \\';\\n                        sp--;\\n                    }\\n                }\\n                //padding extra space after last word\\n                if(sp) while(sp--) cur+=\\' \\';\\n            }\\n            else{\\n                //left & right justified\\n                //extra space to be added after first word\\n                int spExtra = sp%(numberOfWords-1);\\n                sp = sp/(numberOfWords-1);\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //adding even space\\n                    if(l!=numberOfWords-1) for(int k=0;k<sp;++k) cur+=\\' \\';\\n                    //adding extra space after first word only\\n                    if(spExtra){\\n                        cur += \\' \\';\\n                        spExtra--;\\n                    }\\n                }\\n            }\\n            ans.push_back(cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033003,
                "title": "c-implementation-easy-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    string get_spaces(int n) {\\n        string spaces = \"\";\\n        for(int i = 0; i < n; i++)\\n            spaces += \" \";\\n        return spaces;\\n    }\\n    \\n    \\n    string justify(vector<string> &words, int mxWidth) {\\n        int len = 0;\\n        for(string word: words) \\n            len += word.length();\\n        \\n        int total = mxWidth - len;\\n        \\n        if(words.size() == 1) \\n            return words[0] + get_spaces(total);\\n        \\n        \\n        int space = total / (words.size()-1);\\n        int rem = total % (words.size()-1);\\n        \\n        string line = words[0];\\n        for(int i = 1; i < words.size(); i++) {\\n            // extra spaces give to leftmost rem words\\n            if(i <= rem)\\n                line += get_spaces(space+1) + words[i];\\n            else \\n                line += get_spaces(space) + words[i];\\n        }\\n        \\n        return line;\\n    }\\n    \\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int curr = 0;\\n        vector<string> tmp;\\n        vector<string> ans;\\n        \\n        for(string word: words) {\\n            if(curr + word.length() <= maxWidth) {\\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            } else {\\n                curr = 0;\\n                string line = justify(tmp, maxWidth);\\n                ans.push_back(line);\\n                tmp.clear();\\n                \\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            }\\n        }\\n        \\n        string line = tmp[0];\\n        for(int i = 1; i < tmp.size(); i++)\\n            line += \" \" + tmp[i];\\n        \\n        // add extra spaces to the end\\n        line += get_spaces(maxWidth-line.length());\\n        ans.push_back(line);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    string get_spaces(int n) {\\n        string spaces = \"\";\\n        for(int i = 0; i < n; i++)\\n            spaces += \" \";\\n        return spaces;\\n    }\\n    \\n    \\n    string justify(vector<string> &words, int mxWidth) {\\n        int len = 0;\\n        for(string word: words) \\n            len += word.length();\\n        \\n        int total = mxWidth - len;\\n        \\n        if(words.size() == 1) \\n            return words[0] + get_spaces(total);\\n        \\n        \\n        int space = total / (words.size()-1);\\n        int rem = total % (words.size()-1);\\n        \\n        string line = words[0];\\n        for(int i = 1; i < words.size(); i++) {\\n            // extra spaces give to leftmost rem words\\n            if(i <= rem)\\n                line += get_spaces(space+1) + words[i];\\n            else \\n                line += get_spaces(space) + words[i];\\n        }\\n        \\n        return line;\\n    }\\n    \\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int curr = 0;\\n        vector<string> tmp;\\n        vector<string> ans;\\n        \\n        for(string word: words) {\\n            if(curr + word.length() <= maxWidth) {\\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            } else {\\n                curr = 0;\\n                string line = justify(tmp, maxWidth);\\n                ans.push_back(line);\\n                tmp.clear();\\n                \\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            }\\n        }\\n        \\n        string line = tmp[0];\\n        for(int i = 1; i < tmp.size(); i++)\\n            line += \" \" + tmp[i];\\n        \\n        // add extra spaces to the end\\n        line += get_spaces(maxWidth-line.length());\\n        ans.push_back(line);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005474,
                "title": "very-clean-and-clear-python-solution-easy-to-understand",
                "content": "Really **not easy**, requiring no algorithm but good coding skills!\\n\\nInitiate a **running line**.\\nInitiate a **running line length**.\\nWrite helper function **format()**\\nWrite helper function **formatLastline()**\\nIn the main function, we **check and collect the words that could put in one line**, and call helper fumction.\\n\\n**Time:** O(n)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        running_line = []\\n        line_length = 0\\n        res = []\\n        for word in words:\\n            if line_length + len(running_line) + len(word) <= maxWidth:\\n                line_length += len(word)\\n                running_line.append(word)\\n            else:\\n                res.append(self._format(running_line, maxWidth))\\n                line_length = len(word)\\n                running_line = [word]\\n        if len(running_line):\\n            res.append(self._formatLast(running_line, maxWidth))\\n        return res\\n\\n    def _format(self, line, maxWidth):\\n        if len(line) == 1:\\n            return line[0] + \" \" * (maxWidth - len(line[0]))\\n        \\n        length = sum([len(word) for word in line])\\n        gaps = len(line) - 1\\n        s = line[0]\\n        for index, word in enumerate(line[1:]):\\n            if index < (maxWidth - length) % gaps:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + \" \" + word\\n            else:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + word\\n        return s\\n        \\n    def _formatLast(self, line, maxWidth):\\n        s = \" \".join(line)\\n        return s + \" \" * (maxWidth - len(s))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        running_line = []\\n        line_length = 0\\n        res = []\\n        for word in words:\\n            if line_length + len(running_line) + len(word) <= maxWidth:\\n                line_length += len(word)\\n                running_line.append(word)\\n            else:\\n                res.append(self._format(running_line, maxWidth))\\n                line_length = len(word)\\n                running_line = [word]\\n        if len(running_line):\\n            res.append(self._formatLast(running_line, maxWidth))\\n        return res\\n\\n    def _format(self, line, maxWidth):\\n        if len(line) == 1:\\n            return line[0] + \" \" * (maxWidth - len(line[0]))\\n        \\n        length = sum([len(word) for word in line])\\n        gaps = len(line) - 1\\n        s = line[0]\\n        for index, word in enumerate(line[1:]):\\n            if index < (maxWidth - length) % gaps:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + \" \" + word\\n            else:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + word\\n        return s\\n        \\n    def _formatLast(self, line, maxWidth):\\n        s = \" \".join(line)\\n        return s + \" \" * (maxWidth - len(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938449,
                "title": "easy-python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Input check\\n        if not len(words):\\n            return []\\n        \\n        result = []\\n        current_line_len, curr_line = 0, []\\n        \\n        for word in words: \\n            # Incase the new word cannot fit the current line,\\n            # add the spaces and create a new entry in final result\\n            if current_line_len + len(word) + len(curr_line) > maxWidth:    \\n                for i in range(maxWidth - current_line_len): \\n                    curr_line[i % (len(curr_line) - 1 or 1) ] += \\' \\'\\n                    \\n                result.append(\\'\\'.join(curr_line))   # Add to result\\n                current_line_len, curr_line = 0, [] # Reset curr_line and len of current line\\n                \\n            current_line_len += len(word)\\n            curr_line.append(word)\\n            \\n        return result + [\\' \\'.join(curr_line).ljust(maxWidth)]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Input check\\n        if not len(words):\\n            return []\\n        \\n        result = []\\n        current_line_len, curr_line = 0, []\\n        \\n        for word in words: \\n            # Incase the new word cannot fit the current line,\\n            # add the spaces and create a new entry in final result\\n            if current_line_len + len(word) + len(curr_line) > maxWidth:    \\n                for i in range(maxWidth - current_line_len): \\n                    curr_line[i % (len(curr_line) - 1 or 1) ] += \\' \\'\\n                    \\n                result.append(\\'\\'.join(curr_line))   # Add to result\\n                current_line_len, curr_line = 0, [] # Reset curr_line and len of current line\\n                \\n            current_line_len += len(word)\\n            curr_line.append(word)\\n            \\n        return result + [\\' \\'.join(curr_line).ljust(maxWidth)]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1895596,
                "title": "python-clean-and-simple",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        lines = self.constructLines(words, maxWidth)\\n        lines = self.addSpaces(lines, maxWidth)\\n        lines = list(map(lambda x : \"\".join(x), lines))\\n        return lines\\n    \\n    def constructLines(self, words, maxWidth):\\n        lines = []\\n        \\n        # Construct words per line\\n        wordLensInPara = list(map(len, words))\\n        i, j = 0, 0\\n        while i < len(words):\\n            while j < len(words):\\n                totalWordLen, numSpaces = sum(wordLensInPara[i:j+1]), (j-i)\\n                width = totalWordLen + numSpaces\\n                if width > maxWidth: break\\n                else: j += 1\\n            lines.append(words[i:j])\\n            i = j\\n        \\n        return lines\\n    \\n    def addSpaces(self, lines, maxWidth):\\n        for line in lines:\\n            numWords = len(line)\\n            lineLen = sum(map(len, line))\\n            numSpaces = maxWidth - lineLen\\n            \\n            # Standard line\\n            if lines.index(line) < len(lines)-1:\\n                if numWords == 1: # One word\\n                    line[0] += \" \" * numSpaces\\n                else: # Multiple words\\n                    numSpacesPerWord, extraSpaces = divmod(numSpaces,numWords-1)\\n                    for i in range(len(line)-1):\\n                        line[i] += \" \" * numSpacesPerWord\\n\\n                        if extraSpaces > 0:\\n                            line[i] += \" \"\\n                            extraSpaces -= 1\\n            # Last line\\n            else:\\n                for i in range(len(line)-1):\\n                    line[i] += \" \"\\n                    numSpaces -= 1\\n                line[-1] += \" \" * numSpaces\\n            \\n        return lines\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        lines = self.constructLines(words, maxWidth)\\n        lines = self.addSpaces(lines, maxWidth)\\n        lines = list(map(lambda x : \"\".join(x), lines))\\n        return lines\\n    \\n    def constructLines(self, words, maxWidth):\\n        lines = []\\n        \\n        # Construct words per line\\n        wordLensInPara = list(map(len, words))\\n        i, j = 0, 0\\n        while i < len(words):\\n            while j < len(words):\\n                totalWordLen, numSpaces = sum(wordLensInPara[i:j+1]), (j-i)\\n                width = totalWordLen + numSpaces\\n                if width > maxWidth: break\\n                else: j += 1\\n            lines.append(words[i:j])\\n            i = j\\n        \\n        return lines\\n    \\n    def addSpaces(self, lines, maxWidth):\\n        for line in lines:\\n            numWords = len(line)\\n            lineLen = sum(map(len, line))\\n            numSpaces = maxWidth - lineLen\\n            \\n            # Standard line\\n            if lines.index(line) < len(lines)-1:\\n                if numWords == 1: # One word\\n                    line[0] += \" \" * numSpaces\\n                else: # Multiple words\\n                    numSpacesPerWord, extraSpaces = divmod(numSpaces,numWords-1)\\n                    for i in range(len(line)-1):\\n                        line[i] += \" \" * numSpacesPerWord\\n\\n                        if extraSpaces > 0:\\n                            line[i] += \" \"\\n                            extraSpaces -= 1\\n            # Last line\\n            else:\\n                for i in range(len(line)-1):\\n                    line[i] += \" \"\\n                    numSpaces -= 1\\n                line[-1] += \" \" * numSpaces\\n            \\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746085,
                "title": "clean-c-code-faster-than-100",
                "content": "class Solution {\\npublic:\\n    \\n    string makeLine(vector<string>&v, int toFill){\\n        string res = \"\";\\n        // One word line\\n        if(v.size() == 1){\\n            res += v[0];\\n            while(toFill--) res += \\' \\';\\n            return res;\\n        }\\n        \\n        //Multiple word line\\n        int space = toFill / (v.size()-1);\\n        int extras = toFill % (v.size()-1);\\n        res += v[0];\\n        for(int i=1;i<v.size();i++){\\n            for(int j=0;j<space;j++) res += \\' \\';\\n            if(extras){\\n                extras --;\\n                res += \\' \\';\\n            }\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    \\n     string makeLastLine(vector<string>&v, int toFill){\\n        string res = v[0];\\n        for(int i=1;i<v.size();i++){\\n            toFill --;\\n            res += \\' \\';\\n            res += v[i];\\n        }\\n        while(toFill --) res += \\' \\';\\n        return res;\\n     }\\n    \\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        vector<string> taken;\\n        int lineLen = 0;\\n        for(auto word: words){\\n            if(lineLen+word.size()+taken.size() > maxWidth){\\n                res.push_back(makeLine(taken, maxWidth-lineLen));\\n                taken.clear();\\n                taken.push_back(word);\\n                lineLen = word.size();\\n            } else{\\n                taken.push_back(word);\\n                lineLen += word.size();\\n            }\\n        }\\n        // Last line\\n        res.push_back(makeLastLine(taken, maxWidth-lineLen));\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    string makeLine(vector<string>&v, int toFill){\\n        string res = \"\";\\n        // One word line\\n        if(v.size() == 1){\\n            res += v[0];\\n            while(toFill--) res += \\' \\';\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1396429,
                "title": "java-life-is-easier-by-using-stringjoiner",
                "content": "The biggest headache for this problem is corner cases with padding space. By using StringJoiner would avoid most of them .\\nAt least allow you focus on the logic but not the stupid missing or extra space here and there . \\n```\\nimport java.util.StringJoiner;\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        // Final result\\n        List<String> result = new ArrayList<>(); \\n        // List of words fit in one line \\n        List<String> line = new ArrayList<>();\\n        \\n        int lineCount = 0; \\n        for (String word : words) {\\n            if ((lineCount + word.length() + line.size() - 1) >= maxWidth) {\\n                 result.add(indent(line, lineCount, maxWidth, false));\\n                 line.clear();\\n                 lineCount = 0; \\n            } \\n            line.add(word);           \\n            lineCount += word.length();\\n        }\\n        result.add(indent(line, lineCount, maxWidth, true));\\n        return result; \\n    }\\n    private String indent(List<String> line, int lineCount, int maxWidth, boolean last) {\\n        StringJoiner sj = new StringJoiner(\" \"); \\n        // Last Line \\n        if (last) {\\n           for (String w : line) {\\n               sj.add(w);\\n           }\\n           int remain = maxWidth - sj.length(); \\n           appendSpace(sj, remain);\\n           return sj.toString(); \\n        }\\n        sj.add(line.get(0));\\n        int spaces = maxWidth - lineCount; \\n        int gapSize = line.size() - 1;\\n        // Only one word , add padding and return ; \\n        if (line.size() == 1) {\\n            appendSpace(sj, spaces);\\n            return sj.toString();             \\n        }\\n        int gap = spaces / gapSize;\\n        // Extra space after average gap \\n        int leftOver = spaces % gapSize; \\n        for (int j = 1; j < line.size(); j++) {\\n            int g = gap ;\\n            if (leftOver > 0) {\\n                g++; \\n                leftOver--;\\n            }\\n            appendSpace(sj, g - 1);\\n            sj.add(line.get(j));\\n        }\\n        return sj.toString(); \\n    }\\n    \\n    private void appendSpace(StringJoiner sj, int count) {\\n           for (int i = 0; i < count ; i++) {\\n               sj.add(\"\");\\n           }        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.StringJoiner;\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        // Final result\\n        List<String> result = new ArrayList<>(); \\n        // List of words fit in one line \\n        List<String> line = new ArrayList<>();\\n        \\n        int lineCount = 0; \\n        for (String word : words) {\\n            if ((lineCount + word.length() + line.size() - 1) >= maxWidth) {\\n                 result.add(indent(line, lineCount, maxWidth, false));\\n                 line.clear();\\n                 lineCount = 0; \\n            } \\n            line.add(word);           \\n            lineCount += word.length();\\n        }\\n        result.add(indent(line, lineCount, maxWidth, true));\\n        return result; \\n    }\\n    private String indent(List<String> line, int lineCount, int maxWidth, boolean last) {\\n        StringJoiner sj = new StringJoiner(\" \"); \\n        // Last Line \\n        if (last) {\\n           for (String w : line) {\\n               sj.add(w);\\n           }\\n           int remain = maxWidth - sj.length(); \\n           appendSpace(sj, remain);\\n           return sj.toString(); \\n        }\\n        sj.add(line.get(0));\\n        int spaces = maxWidth - lineCount; \\n        int gapSize = line.size() - 1;\\n        // Only one word , add padding and return ; \\n        if (line.size() == 1) {\\n            appendSpace(sj, spaces);\\n            return sj.toString();             \\n        }\\n        int gap = spaces / gapSize;\\n        // Extra space after average gap \\n        int leftOver = spaces % gapSize; \\n        for (int j = 1; j < line.size(); j++) {\\n            int g = gap ;\\n            if (leftOver > 0) {\\n                g++; \\n                leftOver--;\\n            }\\n            appendSpace(sj, g - 1);\\n            sj.add(line.get(j));\\n        }\\n        return sj.toString(); \\n    }\\n    \\n    private void appendSpace(StringJoiner sj, int count) {\\n           for (int i = 0; i < count ; i++) {\\n               sj.add(\"\");\\n           }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744200,
                "title": "100-java-this-is-how-normal-programmer-thinks-p",
                "content": "**Inline comments**\\n\\n```\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; ) {\\n            int current_length = 0; // get the current length\\n            ArrayList<String> current = new ArrayList<>(); // make a list of current strings\\n            while (i < words.length && current_length < maxWidth) { // add to the list till the length reaches the maxwidth\\n                if (words[i].length() + current_length <= maxWidth) {\\n                    current.add(words[i]);\\n                    current_length += words[i].length();\\n                    current_length += 1; // add space for each of the words\\n                    i++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            current_length--; // once we have list of words and length, remove the last space\\n            int num_of_words = current.size();\\n            /*\\n            below code has 3 cases\\n            case 1: when we have reached the last words in total list,so the result should be left justified.\\n             */\\n            if (i >= words.length) { // check if i is greater than equal to input list.\\n                // left justify the output.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \");\\n                    }\\n                }\\n                int len = stringBuilder.toString().length();\\n                for (int j = len; j < maxWidth; j++)\\n                    stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            } \\n              /*\\n            below code has 3 cases\\n            case 2: when there are more than one word in the current list.\\n             */\\n            else if (num_of_words > 1) {\\n                int rem = maxWidth - current_length; // get the remaining number of character\\n                // note : current_length already consist one space between words.\\n                int space_between_words = rem / (current.size() - 1); // so the remaining space is remaining length / (number of words)\\n                int extra = rem % (current.size() - 1); // this extra should be left as possible.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \"); // current word space\\n                        for (int k = 0; k < space_between_words; k++) { // add remaing space for each word as per formula\\n                            stringBuilder.append(\" \");\\n                        }\\n                        if (extra > 0) { // extra is added as left as possible, till we have.\\n                            stringBuilder.append(\" \");\\n                            extra--;\\n                        }\\n                    }\\n                }\\n                result.add(stringBuilder.toString());\\n                  /*\\n            below code has 3 cases\\n            case 3:when the current list contains single word\\n            make it left justified\\n             */\\n            } else {\\n                StringBuilder stringBuilder = new StringBuilder();\\n                stringBuilder.append(current.get(0));\\n                for (int j = current.get(0).length(); j < maxWidth; j++) stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            }\\n        }\\n        return result;\\n```",
                "solutionTags": [],
                "code": "```\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; ) {\\n            int current_length = 0; // get the current length\\n            ArrayList<String> current = new ArrayList<>(); // make a list of current strings\\n            while (i < words.length && current_length < maxWidth) { // add to the list till the length reaches the maxwidth\\n                if (words[i].length() + current_length <= maxWidth) {\\n                    current.add(words[i]);\\n                    current_length += words[i].length();\\n                    current_length += 1; // add space for each of the words\\n                    i++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            current_length--; // once we have list of words and length, remove the last space\\n            int num_of_words = current.size();\\n            /*\\n            below code has 3 cases\\n            case 1: when we have reached the last words in total list,so the result should be left justified.\\n             */\\n            if (i >= words.length) { // check if i is greater than equal to input list.\\n                // left justify the output.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \");\\n                    }\\n                }\\n                int len = stringBuilder.toString().length();\\n                for (int j = len; j < maxWidth; j++)\\n                    stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            } \\n              /*\\n            below code has 3 cases\\n            case 2: when there are more than one word in the current list.\\n             */\\n            else if (num_of_words > 1) {\\n                int rem = maxWidth - current_length; // get the remaining number of character\\n                // note : current_length already consist one space between words.\\n                int space_between_words = rem / (current.size() - 1); // so the remaining space is remaining length / (number of words)\\n                int extra = rem % (current.size() - 1); // this extra should be left as possible.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \"); // current word space\\n                        for (int k = 0; k < space_between_words; k++) { // add remaing space for each word as per formula\\n                            stringBuilder.append(\" \");\\n                        }\\n                        if (extra > 0) { // extra is added as left as possible, till we have.\\n                            stringBuilder.append(\" \");\\n                            extra--;\\n                        }\\n                    }\\n                }\\n                result.add(stringBuilder.toString());\\n                  /*\\n            below code has 3 cases\\n            case 3:when the current list contains single word\\n            make it left justified\\n             */\\n            } else {\\n                StringBuilder stringBuilder = new StringBuilder();\\n                stringBuilder.append(current.get(0));\\n                for (int j = current.get(0).length(); j < maxWidth; j++) stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            }\\n        }\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363913,
                "title": "very-simple-and-straightforward-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int curLen = 0;\\n        List<String> curLine = new LinkedList<>(); \\n        for(int i = 0; i < words.length; i++){\\n            if(curLen == 0){\\n                curLen += words[i].length();\\n                curLine.add(words[i]);\\n            }\\n            else if(curLen+1+words[i].length()>maxWidth){\\n                addLine(res, maxWidth, curLine, false);\\n                curLine.clear();\\n                i--;\\n                curLen = 0;\\n            }else{\\n                curLen += words[i].length()+1;\\n                curLine.add(words[i]);                \\n            }            \\n        }\\n        //add last line \\n        addLine(res, maxWidth, curLine, true);\\n        return res;        \\n    }\\n    void addLine(List<String> res, int maxWidth, List<String> curLine, boolean isLastLine){\\n        StringBuilder sb = new StringBuilder();\\n        if(isLastLine||curLine.size()==1){\\n            // left-justified\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0)\\n                    sb.append(\\' \\');\\n                sb.append(curLine.get(i));\\n            }\\n            while(sb.length()<maxWidth)\\n                sb.append(\\' \\');\\n        }else{\\n            //fully-justified\\n            int len = maxWidth;\\n            for(String s: curLine)\\n                len -= s.length();\\n            int j = 0;\\n            j = len % (curLine.size() - 1);\\n            len = len / (curLine.size() - 1);\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0){\\n                    for(int k = 0; k < len; k++)\\n                        sb.append(\\' \\');\\n                    if(j>0){\\n                        sb.append(\\' \\');\\n                        j--;\\n                    }\\n                }\\n                sb.append(curLine.get(i));                \\n            }                       \\n        }\\n        res.add(sb.toString());\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int curLen = 0;\\n        List<String> curLine = new LinkedList<>(); \\n        for(int i = 0; i < words.length; i++){\\n            if(curLen == 0){\\n                curLen += words[i].length();\\n                curLine.add(words[i]);\\n            }\\n            else if(curLen+1+words[i].length()>maxWidth){\\n                addLine(res, maxWidth, curLine, false);\\n                curLine.clear();\\n                i--;\\n                curLen = 0;\\n            }else{\\n                curLen += words[i].length()+1;\\n                curLine.add(words[i]);                \\n            }            \\n        }\\n        //add last line \\n        addLine(res, maxWidth, curLine, true);\\n        return res;        \\n    }\\n    void addLine(List<String> res, int maxWidth, List<String> curLine, boolean isLastLine){\\n        StringBuilder sb = new StringBuilder();\\n        if(isLastLine||curLine.size()==1){\\n            // left-justified\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0)\\n                    sb.append(\\' \\');\\n                sb.append(curLine.get(i));\\n            }\\n            while(sb.length()<maxWidth)\\n                sb.append(\\' \\');\\n        }else{\\n            //fully-justified\\n            int len = maxWidth;\\n            for(String s: curLine)\\n                len -= s.length();\\n            int j = 0;\\n            j = len % (curLine.size() - 1);\\n            len = len / (curLine.size() - 1);\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0){\\n                    for(int k = 0; k < len; k++)\\n                        sb.append(\\' \\');\\n                    if(j>0){\\n                        sb.append(\\' \\');\\n                        j--;\\n                    }\\n                }\\n                sb.append(curLine.get(i));                \\n            }                       \\n        }\\n        res.add(sb.toString());\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954437,
                "title": "brute-force-easy-to-understand-simulation-c-full-explanation-step-by-step",
                "content": "# Intuition\\nThe idea is to analyse the constraints first. On analysis it is well observed that simulating the entire process is time friendly. Therefore we think on designing a justification algorithm for each sentence and then present our answer.\\n\\n# Approach\\nThe approach is pretty straight forward.\\n\\n**Step 1:** Form sentences. \\n1. To do this iterate over all the words and check if words combined together, exceed the max width or not. Once this happens start forming a new sentence. \\n2. There is a catch here. Every word has to be counted with atleast one space for presentation reasons. (Each word must be separated by atleast one space).\\n3. The last word in every sentence can go without the space described above.\\n\\n**Step 2:** Once we have the sentences in the form of words they are going to contain, we now have to calculate the number of spaces we have insert at the end of each word.(excluding the last)\\n1. Note: If number of words in a sentence are \\'N\\', the number of spaces between these words would be \\'N-1\\'.\\n2. Note: Each space should be equal or almost equal (depending on division of total extra space among words).\\n3. For every sentence:\\n   `Total charCount = sum of word sizes`\\n   `Spaces feasible = maxWidth- charCount`\\n4. Space per word (sppw) = total space / (number of words-1)\\n   `sppw = spaces / (sentences[i].size() -1)` \\n\\n**Step 3:** Insert the spaces calculated to each word.\\nHowever this is not enough.\\n\\n**WHAT IF THE SPACES DONT DISTRIBUTE EQUALLY?**\\n1. To handle such a case when the spaces leave a remainder, you would have to iterate over all the words one by one and give them one extra space until the remainder exhausts.\\n2. This would ensure near equal distribution.\\n\\n**Step 3:** Handle Special Cases\\n1. Sentence with only one word\\n   In such a case, all the spaces feasible go after that single word and makes the entire string left aligned.\\n2. The last sentence\\n   According to the question the last sentence should be left aligned, i.e. every word should be spaced by 1, and the remaining spaces should be added to the last.\\n\\n# Complexity\\n- Time complexity:\\nTo calculate the upper bound, lets assume that every sentence has max width, and contains one word only.\\nTherefore, number of character comparisions is given by\\n```\\nNumber of sentences * max width of a sentence\\nNumber of sentences = number of words = 300 (at max).\\nMax width of a sentence = 100\\n```\\n\\nTotal number of character comparisions made= 300 * 100 = 3e4 operations (upper bound).\\n\\n- Space complexity:\\nIn the same way the space required to store the words, in an array of array of strings, would take up 3e4 space (upper bound).\\n\\n\\n# **An upvote would be highly appreaciated if you understand. Happy Learning!**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<vector<string>> sentences;\\n        \\n        int curSize=0;\\n        vector<string> sentence;\\n\\n        // Step 1: Form sentences.\\n        for(auto word: words)\\n        {\\n            curSize+= word.size()+1;\\n            if(curSize> maxWidth+1)\\n            {\\n                sentences.push_back(sentence);\\n                sentence.clear();\\n                sentence.push_back(word);\\n                curSize= word.size()+1;\\n                continue;\\n            }\\n            \\n            sentence.push_back(word);\\n        }\\n        \\n        sentences.push_back(sentence);\\n        \\n        for(int i=0; i<sentences.size(); i++)\\n        {\\n            int m= sentences[i].size();\\n            if(m==1) //Step 3: Case of 1 word sentence\\n            {\\n                // cout<<sentences[i][0]<<endl;\\n                int sz= sentences[i][0].size();\\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][0].push_back(\\' \\');\\n                \\n                // cout<<sentences[i][0].size()<<endl;\\n                continue;\\n            }\\n            \\n            if(i==sentences.size()-1) // Case of last sentence\\n            {\\n                int sz=0;\\n                for(int j=0; j<sentences[i].size()-1; j++) //words\\n                {\\n                    sentences[i][j].push_back(\\' \\');\\n                    sz+= sentences[i][j].size();\\n                }\\n                // cout<<sz<<endl;\\n                sz+= sentences[i][sentences[i].size()-1].size();\\n                // cout<<sz<<endl;\\n                \\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][sentences[i].size()-1].push_back(\\' \\');\\n                \\n                continue;\\n            }\\n            \\n            // Step 2: Calculation of spaces per word\\n            int sz=0;\\n            for(int j=0; j<sentences[i].size(); j++)\\n                sz+= sentences[i][j].size();\\n            \\n            int sp= maxWidth - sz;\\n            int sppw=  sp/(m-1);\\n            int nsz=0;\\n            \\n            for(int j=0; j< sentences[i].size()-1; j++)\\n            {\\n                for(int k=0; k<sppw; k++)\\n                    sentences[i][j].push_back(\\' \\');\\n                \\n                nsz+= sentences[i][j].size();\\n            }\\n            \\n            nsz+= sentences[i][sentences[i].size()-1].size();\\n            \\n            // Handle remainder\\n            for(int j=0, k=0; j<sentences[i].size()&&  k< maxWidth-nsz; k++,j++)\\n            {\\n                sentences[i][j].push_back(\\' \\');\\n            }\\n            \\n        }\\n        \\n        // Form answer in required format\\n        vector<string> ans;\\n        \\n        for(auto s: sentences)\\n        {\\n            string sen;\\n            for(auto w: s)\\n                sen+= w;\\n            ans.push_back(sen);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nNumber of sentences * max width of a sentence\\nNumber of sentences = number of words = 300 (at max).\\nMax width of a sentence = 100\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<vector<string>> sentences;\\n        \\n        int curSize=0;\\n        vector<string> sentence;\\n\\n        // Step 1: Form sentences.\\n        for(auto word: words)\\n        {\\n            curSize+= word.size()+1;\\n            if(curSize> maxWidth+1)\\n            {\\n                sentences.push_back(sentence);\\n                sentence.clear();\\n                sentence.push_back(word);\\n                curSize= word.size()+1;\\n                continue;\\n            }\\n            \\n            sentence.push_back(word);\\n        }\\n        \\n        sentences.push_back(sentence);\\n        \\n        for(int i=0; i<sentences.size(); i++)\\n        {\\n            int m= sentences[i].size();\\n            if(m==1) //Step 3: Case of 1 word sentence\\n            {\\n                // cout<<sentences[i][0]<<endl;\\n                int sz= sentences[i][0].size();\\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][0].push_back(\\' \\');\\n                \\n                // cout<<sentences[i][0].size()<<endl;\\n                continue;\\n            }\\n            \\n            if(i==sentences.size()-1) // Case of last sentence\\n            {\\n                int sz=0;\\n                for(int j=0; j<sentences[i].size()-1; j++) //words\\n                {\\n                    sentences[i][j].push_back(\\' \\');\\n                    sz+= sentences[i][j].size();\\n                }\\n                // cout<<sz<<endl;\\n                sz+= sentences[i][sentences[i].size()-1].size();\\n                // cout<<sz<<endl;\\n                \\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][sentences[i].size()-1].push_back(\\' \\');\\n                \\n                continue;\\n            }\\n            \\n            // Step 2: Calculation of spaces per word\\n            int sz=0;\\n            for(int j=0; j<sentences[i].size(); j++)\\n                sz+= sentences[i][j].size();\\n            \\n            int sp= maxWidth - sz;\\n            int sppw=  sp/(m-1);\\n            int nsz=0;\\n            \\n            for(int j=0; j< sentences[i].size()-1; j++)\\n            {\\n                for(int k=0; k<sppw; k++)\\n                    sentences[i][j].push_back(\\' \\');\\n                \\n                nsz+= sentences[i][j].size();\\n            }\\n            \\n            nsz+= sentences[i][sentences[i].size()-1].size();\\n            \\n            // Handle remainder\\n            for(int j=0, k=0; j<sentences[i].size()&&  k< maxWidth-nsz; k++,j++)\\n            {\\n                sentences[i][j].push_back(\\' \\');\\n            }\\n            \\n        }\\n        \\n        // Form answer in required format\\n        vector<string> ans;\\n        \\n        for(auto s: sentences)\\n        {\\n            string sen;\\n            for(auto w: s)\\n                sen+= w;\\n            ans.push_back(sen);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3668893,
                "title": "beats-92-14",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n    List<string> result = new List<string>();\\n    List<string> currentLine = new List<string>();\\n    int currentLength = 0;\\n\\n    foreach (string word in words)\\n    {\\n        if (currentLength + currentLine.Count + word.Length > maxWidth)\\n        {\\n            int numWords = currentLine.Count;\\n            int numSpaces = maxWidth - currentLength;\\n            string justifiedLine = \"\";\\n\\n            if (numWords == 1)\\n                justifiedLine = currentLine[0] + new string(\\' \\', numSpaces);\\n            else\\n            {\\n                int spacesBetweenWords = numSpaces / (numWords - 1);\\n                int extraSpaces = numSpaces % (numWords - 1);\\n\\n                StringBuilder sb = new StringBuilder();\\n\\n                for (int i = 0; i < numWords - 1; i++)\\n                {\\n                    sb.Append(currentLine[i]);\\n                    sb.Append(new string(\\' \\', spacesBetweenWords));\\n\\n                    if (i < extraSpaces)\\n                    {\\n                        sb.Append(\\' \\');\\n                    }\\n                }\\n\\n                sb.Append(currentLine[numWords - 1]);\\n                justifiedLine = sb.ToString();\\n            }\\n\\n            result.Add(justifiedLine);\\n            currentLine.Clear();\\n            currentLength = 0;\\n        }\\n\\n        currentLine.Add(word);\\n        currentLength += word.Length;\\n    }\\n\\n    string lastLine = string.Join(\" \", currentLine);\\n    lastLine += new string(\\' \\', maxWidth - lastLine.Length);\\n    result.Add(lastLine);\\n\\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n    List<string> result = new List<string>();\\n    List<string> currentLine = new List<string>();\\n    int currentLength = 0;\\n\\n    foreach (string word in words)\\n    {\\n        if (currentLength + currentLine.Count + word.Length > maxWidth)\\n        {\\n            int numWords = currentLine.Count;\\n            int numSpaces = maxWidth - currentLength;\\n            string justifiedLine = \"\";\\n\\n            if (numWords == 1)\\n                justifiedLine = currentLine[0] + new string(\\' \\', numSpaces);\\n            else\\n            {\\n                int spacesBetweenWords = numSpaces / (numWords - 1);\\n                int extraSpaces = numSpaces % (numWords - 1);\\n\\n                StringBuilder sb = new StringBuilder();\\n\\n                for (int i = 0; i < numWords - 1; i++)\\n                {\\n                    sb.Append(currentLine[i]);\\n                    sb.Append(new string(\\' \\', spacesBetweenWords));\\n\\n                    if (i < extraSpaces)\\n                    {\\n                        sb.Append(\\' \\');\\n                    }\\n                }\\n\\n                sb.Append(currentLine[numWords - 1]);\\n                justifiedLine = sb.ToString();\\n            }\\n\\n            result.Add(justifiedLine);\\n            currentLine.Clear();\\n            currentLength = 0;\\n        }\\n\\n        currentLine.Add(word);\\n        currentLength += word.Length;\\n    }\\n\\n    string lastLine = string.Join(\" \", currentLine);\\n    lastLine += new string(\\' \\', maxWidth - lastLine.Length);\\n    result.Add(lastLine);\\n\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180889,
                "title": "68-text-justification-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        i = 0\\n        while i < len(words):\\n            j, total_len = i, 0\\n            while j < len(words) and total_len + len(words[j]) + j - i <= maxWidth:\\n                total_len += len(words[j])\\n                j += 1\\n            if j == len(words):\\n                res.append(\" \".join(words[i:j]) + \" \" * (maxWidth - total_len - (j - i - 1)))\\n            else:\\n                spaces = maxWidth - total_len\\n                slots = j - i - 1\\n                if slots == 0:\\n                    res.append(words[i] + \" \" * spaces)\\n                else:\\n                    spaces_per_slot = spaces // slots\\n                    extra_spaces = spaces % slots\\n                    line = words[i]\\n                    for k in range(i + 1, j):\\n                        line += \" \" * (spaces_per_slot + (1 if extra_spaces > 0 else 0))\\n                        extra_spaces -= 1\\n                        line += words[k]\\n                    res.append(line)\\n            i = j\\n        return res\\n\\n``````\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # list to store the justified lines\\n        justified_lines = []\\n        # list to store the current line of words\\n        line = []\\n        # length of the current line\\n        line_length = 0\\n        # loop through all words\\n        for word in words:\\n            # if adding the current word to the line and a space would exceed the maxWidth\\n            if line_length + len(word) + len(line) > maxWidth:\\n                # calculate the number of spaces needed to be added to the line\\n                spaces = maxWidth - line_length\\n                # distribute the spaces as evenly as possible between the words\\n                for i in range(spaces):\\n                    line[i % (len(line) - 1 or 1)] += \\' \\'\\n                # add the line to the justified_lines list\\n                justified_lines.append(\\'\\'.join(line))\\n                # reset line and line_length for the next line\\n                line = []\\n                line_length = 0\\n            # add the current word to the line\\n            line.append(word)\\n            line_length += len(word)\\n        # handle the last line, which is left-justified\\n        last_line = \\' \\'.join(line)\\n        last_line += \\' \\' * (maxWidth - len(last_line))\\n        justified_lines.append(last_line)\\n        return justified_lines\\n\\n```\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        i = 0\\n        while i < len(words):\\n            j, total_len = i, 0\\n            while j < len(words) and total_len + len(words[j]) + j - i <= maxWidth:\\n                total_len += len(words[j])\\n                j += 1\\n            if j == len(words):\\n                res.append(\" \".join(words[i:j]) + \" \" * (maxWidth - total_len - (j - i - 1)))\\n            else:\\n                spaces = maxWidth - total_len\\n                slots = j - i - 1\\n                if slots == 0:\\n                    res.append(words[i] + \" \" * spaces)\\n                else:\\n                    spaces_per_slot = spaces // slots\\n                    extra_spaces = spaces % slots\\n                    line = words[i]\\n                    for k in range(i + 1, j):\\n                        line += \" \" * (spaces_per_slot + (1 if extra_spaces > 0 else 0))\\n                        extra_spaces -= 1\\n                        line += words[k]\\n                    res.append(line)\\n            i = j\\n        return res\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795688,
                "title": "easy-to-understand-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        if (words == null || words.length == 0 || maxWidth <= 0) {\\n            return new ArrayList<String>();\\n        }\\n\\n        List<String> result = new ArrayList<String>();\\n        List<String> row = new ArrayList<String>();\\n        int index = 0, len = 0;\\n        while (index < words.length) {\\n            String word = words[index];\\n            if ((row.size() == 0 && len + word.length() > maxWidth) \\n                || (row.size() > 0 && len + word.length() + 1 > maxWidth)) {\\n                result.add(formatHelper(row, len, maxWidth, false));\\n                row = new ArrayList<String>();\\n                len = 0;\\n            } else {\\n                row.add(word);\\n                if (len == 0) {\\n                    len += word.length();\\n                } else {\\n                    len += (word.length() + 1);\\n                }\\n                index++;\\n            }\\n        }\\n        if (!row.isEmpty()) {\\n            result.add(formatHelper(row, len, maxWidth, true));\\n        }\\n        return result;\\n    }\\n\\n    private String formatHelper(List<String> row, int len, int maxWidth, boolean isLastRow) {\\n        StringBuilder result = new StringBuilder();\\n        int diff = maxWidth - len;\\n        int interLen = (row.size() > 1) ? (diff / (row.size() - 1)) : diff;\\n        StringBuilder interString = new StringBuilder();\\n        for (int i = 0; i < interLen; i++) {\\n            interString.append(\" \");\\n        }\\n        int largerInterCount = diff - interLen * (row.size() == 1 ? 1 : (row.size() - 1));\\n        for (int i = 0; i < row.size(); i++) {\\n            result.append(row.get(i));\\n            if (isLastRow) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n            } else if (i < row.size() - 1 || row.size() == 1) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n                result.append(interString);\\n                if (largerInterCount-- > 0) {\\n                    result.append(\" \");\\n                }\\n            }\\n        }\\n        if (isLastRow) {\\n            while (result.length() < maxWidth) {\\n                result.append(\" \");\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        if (words == null || words.length == 0 || maxWidth <= 0) {\\n            return new ArrayList<String>();\\n        }\\n\\n        List<String> result = new ArrayList<String>();\\n        List<String> row = new ArrayList<String>();\\n        int index = 0, len = 0;\\n        while (index < words.length) {\\n            String word = words[index];\\n            if ((row.size() == 0 && len + word.length() > maxWidth) \\n                || (row.size() > 0 && len + word.length() + 1 > maxWidth)) {\\n                result.add(formatHelper(row, len, maxWidth, false));\\n                row = new ArrayList<String>();\\n                len = 0;\\n            } else {\\n                row.add(word);\\n                if (len == 0) {\\n                    len += word.length();\\n                } else {\\n                    len += (word.length() + 1);\\n                }\\n                index++;\\n            }\\n        }\\n        if (!row.isEmpty()) {\\n            result.add(formatHelper(row, len, maxWidth, true));\\n        }\\n        return result;\\n    }\\n\\n    private String formatHelper(List<String> row, int len, int maxWidth, boolean isLastRow) {\\n        StringBuilder result = new StringBuilder();\\n        int diff = maxWidth - len;\\n        int interLen = (row.size() > 1) ? (diff / (row.size() - 1)) : diff;\\n        StringBuilder interString = new StringBuilder();\\n        for (int i = 0; i < interLen; i++) {\\n            interString.append(\" \");\\n        }\\n        int largerInterCount = diff - interLen * (row.size() == 1 ? 1 : (row.size() - 1));\\n        for (int i = 0; i < row.size(); i++) {\\n            result.append(row.get(i));\\n            if (isLastRow) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n            } else if (i < row.size() - 1 || row.size() == 1) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n                result.append(interString);\\n                if (largerInterCount-- > 0) {\\n                    result.append(\" \");\\n                }\\n            }\\n        }\\n        if (isLastRow) {\\n            while (result.length() < maxWidth) {\\n                result.append(\" \");\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742430,
                "title": "c-solution-with-inline-comments",
                "content": "**For Details see inline comments in the following code:**\\nm --> Number of words.\\nn --> Total number of characters.\\n**Time Complexity:** O(mn)\\n**Space complexity:**  O(mn)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        \\n        for(int i = 0, w; i < n; i = w) {\\n            // Length of text with 1 space (except at end of a line)              \\n            int len = -1; // last word in a line doesn\\'t require space at end.\\n            // Check how much can be accomodated in a line\\n            for(w = i; w < n && len + words[w].length() + 1 <= maxWidth; w++) {\\n                len += words[w].length() + 1;\\n            }\\n            \\n            string str = words[i];\\n            \\n            // Initially only one space and zero extra spaces.\\n            int space = 1, extra = 0;\\n            if(w != i + 1 && w != words.size()) { // not 1 string, not last line -> ###\\n                // Spaces remaining at end -> (maxWidth - len)\\n                // Slots --> (w - i - 1)\\n                space = (maxWidth - len) / (w - i - 1) + 1;\\n                extra = (maxWidth - len) % (w - i - 1);\\n            }\\n            \\n            // Debug Info: (Uncomment to see)\\n            // cout<<\"w: \"<<w<<\" \";\\n            // cout<<\"len: \"<<len<<\" \";\\n            // cout<<\"space: \"<<space<<\" \";\\n            // cout<<\"extra: \"<<extra<<endl;\\n            \\n            // Adjust spaces remaining in slots \\n            for(int j = i + 1; j < w; ++j) {\\n                for(int s = space; s > 0; s--) str += \\' \\';\\n                // Put extra spaces in left aligned manner as we going left to right\\n                if(extra-- > 0) str += \\' \\';\\n                str += words[j];\\n            }\\n            \\n            // Putting extra spaces for last line -> ###\\n            int strLen = maxWidth - str.length();\\n            while(strLen-- > 0) str += \\' \\';\\n            ans.push_back(str);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        \\n        for(int i = 0, w; i < n; i = w) {\\n            // Length of text with 1 space (except at end of a line)              \\n            int len = -1; // last word in a line doesn\\'t require space at end.\\n            // Check how much can be accomodated in a line\\n            for(w = i; w < n && len + words[w].length() + 1 <= maxWidth; w++) {\\n                len += words[w].length() + 1;\\n            }\\n            \\n            string str = words[i];\\n            \\n            // Initially only one space and zero extra spaces.\\n            int space = 1, extra = 0;\\n            if(w != i + 1 && w != words.size()) { // not 1 string, not last line -> ###\\n                // Spaces remaining at end -> (maxWidth - len)\\n                // Slots --> (w - i - 1)\\n                space = (maxWidth - len) / (w - i - 1) + 1;\\n                extra = (maxWidth - len) % (w - i - 1);\\n            }\\n            \\n            // Debug Info: (Uncomment to see)\\n            // cout<<\"w: \"<<w<<\" \";\\n            // cout<<\"len: \"<<len<<\" \";\\n            // cout<<\"space: \"<<space<<\" \";\\n            // cout<<\"extra: \"<<extra<<endl;\\n            \\n            // Adjust spaces remaining in slots \\n            for(int j = i + 1; j < w; ++j) {\\n                for(int s = space; s > 0; s--) str += \\' \\';\\n                // Put extra spaces in left aligned manner as we going left to right\\n                if(extra-- > 0) str += \\' \\';\\n                str += words[j];\\n            }\\n            \\n            // Putting extra spaces for last line -> ###\\n            int strLen = maxWidth - str.length();\\n            while(strLen-- > 0) str += \\' \\';\\n            ans.push_back(str);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2701534,
                "title": "simle-java-solution",
                "content": "This is my intuitive and somple solution on Java:\\n\\n```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> processedStrings = new ArrayList<>();\\n        int width = 0, wordsCount = 0;\\n\\n        for (int wordIndex = 0; wordIndex < words.length; wordIndex++) {\\n            width += words[wordIndex].length();\\n            wordsCount++;\\n\\n            if (wordIndex == words.length - 1\\n                    || width + words[wordIndex + 1].length() + wordsCount - 1 >= maxWidth) {\\n                int allSpaces = maxWidth - width;\\n                StringBuilder processedString = new StringBuilder();\\n\\n                while (--wordsCount >= 0) {\\n                    processedString.append(words[wordIndex - wordsCount]);\\n                    int spaces = wordIndex == words.length - 1\\n                            ? 1\\n                            : (int) Math.ceil((double) allSpaces / wordsCount);\\n                    processedString.append(\" \".repeat(Math.max(0, Math.min(spaces, allSpaces))));\\n                    allSpaces -= spaces;\\n                }\\n\\n                processedString.append(\" \".repeat(Math.max(0, allSpaces)));\\n                processedStrings.add(processedString.toString());\\n                wordsCount = 0;\\n                width = 0;\\n            }\\n        }\\n\\n        return processedStrings;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> processedStrings = new ArrayList<>();\\n        int width = 0, wordsCount = 0;\\n\\n        for (int wordIndex = 0; wordIndex < words.length; wordIndex++) {\\n            width += words[wordIndex].length();\\n            wordsCount++;\\n\\n            if (wordIndex == words.length - 1\\n                    || width + words[wordIndex + 1].length() + wordsCount - 1 >= maxWidth) {\\n                int allSpaces = maxWidth - width;\\n                StringBuilder processedString = new StringBuilder();\\n\\n                while (--wordsCount >= 0) {\\n                    processedString.append(words[wordIndex - wordsCount]);\\n                    int spaces = wordIndex == words.length - 1\\n                            ? 1\\n                            : (int) Math.ceil((double) allSpaces / wordsCount);\\n                    processedString.append(\" \".repeat(Math.max(0, Math.min(spaces, allSpaces))));\\n                    allSpaces -= spaces;\\n                }\\n\\n                processedString.append(\" \".repeat(Math.max(0, allSpaces)));\\n                processedStrings.add(processedString.toString());\\n                wordsCount = 0;\\n                width = 0;\\n            }\\n        }\\n\\n        return processedStrings;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616085,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] # Collections used to get all the lines.\\n        \\n        i = 0 # Index of the current word\\n        current_width = 0 # Keeps track of the current width we\\'ve processed for a given line.\\n        line = []\\n        \\n        while i < len(words):\\n            word = words[i]\\n            \\n\\t\\t\\t# Verify that the current_width + current word does not exceed the max width.\\n            if (current_width + len(word)) <= maxWidth:\\n                line.append(word)\\n                current_width += len(word) + 1 # Since all words must have a minimum of 1 space, that +1 is for the space\\n                i += 1\\n            else: \\n\\t\\t\\t\\t# We\\'ve reached the point where we can\\'t process any new words. So we process the line seen so far.\\n\\t\\t\\t\\t# Note: We don\\'t increment i here because we want to reprocess it for the next line.\\n                current_line = \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Calculate the total number of spaces we need. In the if statement above, we added +1 for space between words.\\n\\t\\t\\t\\t# Here we\\'re removing all those for easier calculation in the future. That is what the + len(line) is for; 1 space per word.\\n                necessary_spaces = maxWidth - current_width + len(line) \\n                if len(line) == 1: # Edge case where the line only has 1 word.\\n                    current_line += line[0] + \" \" * necessary_spaces # Append all spaces at the end in this instance.\\n                else: # There\\'s more than 1 word in the line so we need to process all of them.\\n                    for j in range(len(line)):\\n                        line_word = line[j]\\n\\t\\t\\t\\t\\t\\t# So between each word we need to distribute spaces evenly. \\n\\t\\t\\t\\t\\t\\t# The intuition here is that, except for the last word, we\\'ll need to calculate how many spaces we need.\\n\\t\\t\\t\\t\\t\\t# Example: if you have these words for a line [\"This\", \"is\", \"an\"] with a maxWidth = 16\\n\\t\\t\\t\\t\\t\\t# there are 3 words and you need to divide it between 2 spaces: \"this\" and \"is\" and \"is\" and \"an\" so that means\\n\\t\\t\\t\\t\\t\\t# you need 8 spaces evenly. We use remaining_words below to calculate the required_spaces below using the logic seen below.\\n\\t\\t\\t\\t\\t\\t# For the last word in a line, we don\\'t need any spaces so it is always 0.\\n\\t\\t\\t\\t\\t\\t# We use the ceil function here because if maxWidth is odd, then we have to distribute to the left side first (or greedily).\\n                        remaining_words = len(line) - (j + 1)\\n                        required_spaces = ceil(necessary_spaces / remaining_words) if remaining_words else 0\\n                        current_line += line_word + \" \" * required_spaces\\n                        necessary_spaces -= required_spaces # Subtract from necessary spaces. In the example above it would take 8 -> 4.\\n\\t\\t\\t\\t\\t\\t\\n                lines.append(current_line) # Add the result of the current line.\\n                line = []\\n                current_width = 0\\n\\n\\t\\t# It\\'s possible that we have processed all the words, but have some left over in the line. So we\\'ll add the remainder.\\n\\t\\t# Based on the problem description we want to only add a space between each word here and then add any remaining\\n\\t\\t# spaces at the end.\\n        if line: \\n            necessary_spaces = maxWidth - current_width + 1\\n            current_line = \\' \\'.join(line) + \" \" * necessary_spaces\\n            lines.append(current_line)\\n        return lines\\n```\\n\\nSome optimizations exist. I\\'m using string concatenation for the current line, but appending to the list may be preferred,.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] # Collections used to get all the lines.\\n        \\n        i = 0 # Index of the current word\\n        current_width = 0 # Keeps track of the current width we\\'ve processed for a given line.\\n        line = []\\n        \\n        while i < len(words):\\n            word = words[i]\\n            \\n\\t\\t\\t# Verify that the current_width + current word does not exceed the max width.\\n            if (current_width + len(word)) <= maxWidth:\\n                line.append(word)\\n                current_width += len(word) + 1 # Since all words must have a minimum of 1 space, that +1 is for the space\\n                i += 1\\n            else: \\n\\t\\t\\t\\t# We\\'ve reached the point where we can\\'t process any new words. So we process the line seen so far.\\n\\t\\t\\t\\t# Note: We don\\'t increment i here because we want to reprocess it for the next line.\\n                current_line = \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Calculate the total number of spaces we need. In the if statement above, we added +1 for space between words.\\n\\t\\t\\t\\t# Here we\\'re removing all those for easier calculation in the future. That is what the + len(line) is for; 1 space per word.\\n                necessary_spaces = maxWidth - current_width + len(line) \\n                if len(line) == 1: # Edge case where the line only has 1 word.\\n                    current_line += line[0] + \" \" * necessary_spaces # Append all spaces at the end in this instance.\\n                else: # There\\'s more than 1 word in the line so we need to process all of them.\\n                    for j in range(len(line)):\\n                        line_word = line[j]\\n\\t\\t\\t\\t\\t\\t# So between each word we need to distribute spaces evenly. \\n\\t\\t\\t\\t\\t\\t# The intuition here is that, except for the last word, we\\'ll need to calculate how many spaces we need.\\n\\t\\t\\t\\t\\t\\t# Example: if you have these words for a line [\"This\", \"is\", \"an\"] with a maxWidth = 16\\n\\t\\t\\t\\t\\t\\t# there are 3 words and you need to divide it between 2 spaces: \"this\" and \"is\" and \"is\" and \"an\" so that means\\n\\t\\t\\t\\t\\t\\t# you need 8 spaces evenly. We use remaining_words below to calculate the required_spaces below using the logic seen below.\\n\\t\\t\\t\\t\\t\\t# For the last word in a line, we don\\'t need any spaces so it is always 0.\\n\\t\\t\\t\\t\\t\\t# We use the ceil function here because if maxWidth is odd, then we have to distribute to the left side first (or greedily).\\n                        remaining_words = len(line) - (j + 1)\\n                        required_spaces = ceil(necessary_spaces / remaining_words) if remaining_words else 0\\n                        current_line += line_word + \" \" * required_spaces\\n                        necessary_spaces -= required_spaces # Subtract from necessary spaces. In the example above it would take 8 -> 4.\\n\\t\\t\\t\\t\\t\\t\\n                lines.append(current_line) # Add the result of the current line.\\n                line = []\\n                current_width = 0\\n\\n\\t\\t# It\\'s possible that we have processed all the words, but have some left over in the line. So we\\'ll add the remainder.\\n\\t\\t# Based on the problem description we want to only add a space between each word here and then add any remaining\\n\\t\\t# spaces at the end.\\n        if line: \\n            necessary_spaces = maxWidth - current_width + 1\\n            current_line = \\' \\'.join(line) + \" \" * necessary_spaces\\n            lines.append(current_line)\\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564093,
                "title": "easy-to-understand-java-greedy-solution",
                "content": "I am going solve this problem using greedy approach.\\n\\nThe greedy approach involves having two pointers \"i\" and \"j\". We move our \"j\" pointer forward until we get to a point where the words in the line go over our \"maxWidth\" parameter. Once that occurs, we now know all of the words that are going to be inside of the line.\\n\\nNext, we will count the number of words we have in the line. If we have a single word OR we are on the last line, then we will be left justifying the line, otherwise we middle justify. To left justify a line, we take the difference between the total amount of word characters we have and our \"maxWidth\" and this will tell us how many spaces there needs to be inside of the line.\\nThere should only be a single space between each word, but the last word will have the rest of the unused spaces to the very right of it, causing the line to left justify properly. In order to middle justify, we take the the number of spaces needed and the number of sections of spaces required. To get the section number, we do \"j\" - \"i\" - 1. Then divide our spaces with the section number which gives us a number to evenly distribute the spaces in between each word in the line. If we have extra spaces, the spaces will be added to the left-most words from left to right.\\n\\nThe time and space complexity of our solution is going to be O(lines * maxWidth). We must iterate, for each potential line, to the \"maxWidth\" since the spaces will be repeated. Under the hood, the \"repeat\" function is just running a for loop duplicating the character.\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int n = words.length;\\n        int i=0,j,lineLength;\\n        while(i<n){\\n            j=i+1;\\n            lineLength=words[i].length();\\n          while(j<n&&(lineLength+words[j].length()+(j-i-1)<maxWidth))\\n            {\\n              lineLength+=words[j].length();\\n              j++;\\n            }\\n          int diff =maxWidth-lineLength;\\n          int noOfWords=j-i;\\n            if(noOfWords==1||j>=n)\\n                result.add(leftJustify(diff,noOfWords,words,i,j));\\n            else\\n                result.add(middleJustify(diff,noOfWords,words,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    public static String leftJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n        StringBuilder  leftJustifyAns = new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++){\\n           leftJustifyAns.append(\" \"+words[k]);\\n        }\\n       leftJustifyAns.append(\" \".repeat(spacesOnRight));\\n        return  leftJustifyAns.toString();\\n    }\\n    public static String middleJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n         StringBuilder  middleJustifyAns = new StringBuilder(words[i]);\\n       \\n        int spacesNeeded= j-i-1;\\n        int spaces =diff/spacesNeeded;\\n        int extraSpaces = diff%spaces;\\n        for(int k=i+1;k<j;++k){\\n            int spacesToApply=spaces+(extraSpaces-- > 0 ? 1 : 0);\\n            middleJustifyAns.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return  middleJustifyAns.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int n = words.length;\\n        int i=0,j,lineLength;\\n        while(i<n){\\n            j=i+1;\\n            lineLength=words[i].length();\\n          while(j<n&&(lineLength+words[j].length()+(j-i-1)<maxWidth))\\n            {\\n              lineLength+=words[j].length();\\n              j++;\\n            }\\n          int diff =maxWidth-lineLength;\\n          int noOfWords=j-i;\\n            if(noOfWords==1||j>=n)\\n                result.add(leftJustify(diff,noOfWords,words,i,j));\\n            else\\n                result.add(middleJustify(diff,noOfWords,words,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    public static String leftJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n        StringBuilder  leftJustifyAns = new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++){\\n           leftJustifyAns.append(\" \"+words[k]);\\n        }\\n       leftJustifyAns.append(\" \".repeat(spacesOnRight));\\n        return  leftJustifyAns.toString();\\n    }\\n    public static String middleJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n         StringBuilder  middleJustifyAns = new StringBuilder(words[i]);\\n       \\n        int spacesNeeded= j-i-1;\\n        int spaces =diff/spacesNeeded;\\n        int extraSpaces = diff%spaces;\\n        for(int k=i+1;k<j;++k){\\n            int spacesToApply=spaces+(extraSpaces-- > 0 ? 1 : 0);\\n            middleJustifyAns.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return  middleJustifyAns.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418813,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Simulation***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int max_width) {\\n        \\n        int n = words.size();\\n        \\n        vector<string> res;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            int start = i;\\n            \\n            // total characters keeps track of count of included characters\\n            \\n            int total_characters = 0;\\n            \\n            // count_words keeps track of no. of included words\\n            \\n            int count_words = 0;\\n            \\n            // include the words \\n            \\n            while(i < n && total_characters + count_words + words[i].size() <= max_width)\\n            {\\n                total_characters += words[i].size();\\n                \\n                count_words++;\\n                \\n                i++;\\n            }\\n            \\n            // calculate the no. of spaces we have to insert\\n           \\n            int total_spaces = max_width - total_characters;\\n            \\n            // if no. of words included = 1, then provide all the spaces after the word\\n            \\n            if(count_words == 1)\\n            {\\n                string temp_res = \"\";\\n                \\n                // append the word\\n                \\n                temp_res += words[start];\\n                \\n                // now append the spaces\\n                \\n                string space(total_spaces, \\' \\');\\n                \\n                temp_res += space;\\n                \\n                res.push_back(temp_res);\\n                \\n                continue;\\n            }\\n            \\n            // if no. of word is more than 1\\n            \\n            // 1st provide equal spaces between words, then distribute the remaining spaces \\n            \\n            // no. of places where space will be provided is = total words - 1\\n            \\n            int equal_spaces = total_spaces / (count_words - 1);\\n            \\n            int rem_spaces = total_spaces % (count_words - 1);\\n            \\n            // create a spaces array, which will store the no. of spaces provided between words from left side\\n            \\n            vector<int> spaces(count_words - 1, equal_spaces);\\n            \\n            // distribute the rem spaces from left to right\\n            \\n            int j = 0;\\n            \\n            while(rem_spaces)\\n            {\\n                spaces[j++] += 1;\\n                \\n                rem_spaces--;\\n            }  \\n            \\n            // j will point to the index of spaces array\\n            \\n            j = 0;\\n            \\n            string temp_res = \"\";\\n            \\n            // 1st case, if the text is not in the last line\\n            \\n            if(i < n)\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide the spaces\\n                    \\n                    if(j < spaces.size())\\n                    {\\n                        string space(spaces[j++], \\' \\');\\n                        \\n                        temp_res += space;\\n                    } \\n                }\\n            }\\n            \\n            // second case if the text is in the last line\\n            \\n            else\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide spaces\\n                    \\n                    temp_res += \\' \\';\\n                    \\n                    // decrement the spaces\\n                    \\n                    total_spaces--;\\n                }\\n                \\n                // if the total_spaces <= 0, then pop the last extra space\\n                \\n                if(total_spaces <= 0)\\n                {\\n                    temp_res.pop_back();\\n                }\\n                \\n                // otherwise push the spaces into temp_res\\n                \\n                else\\n                {\\n                    string space(total_spaces, \\' \\');\\n                    \\n                    temp_res += space;\\n                } \\n            }\\n            \\n            // push the temp_res into res array\\n            \\n            res.push_back(temp_res);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int max_width) {\\n        \\n        int n = words.size();\\n        \\n        vector<string> res;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            int start = i;\\n            \\n            // total characters keeps track of count of included characters\\n            \\n            int total_characters = 0;\\n            \\n            // count_words keeps track of no. of included words\\n            \\n            int count_words = 0;\\n            \\n            // include the words \\n            \\n            while(i < n && total_characters + count_words + words[i].size() <= max_width)\\n            {\\n                total_characters += words[i].size();\\n                \\n                count_words++;\\n                \\n                i++;\\n            }\\n            \\n            // calculate the no. of spaces we have to insert\\n           \\n            int total_spaces = max_width - total_characters;\\n            \\n            // if no. of words included = 1, then provide all the spaces after the word\\n            \\n            if(count_words == 1)\\n            {\\n                string temp_res = \"\";\\n                \\n                // append the word\\n                \\n                temp_res += words[start];\\n                \\n                // now append the spaces\\n                \\n                string space(total_spaces, \\' \\');\\n                \\n                temp_res += space;\\n                \\n                res.push_back(temp_res);\\n                \\n                continue;\\n            }\\n            \\n            // if no. of word is more than 1\\n            \\n            // 1st provide equal spaces between words, then distribute the remaining spaces \\n            \\n            // no. of places where space will be provided is = total words - 1\\n            \\n            int equal_spaces = total_spaces / (count_words - 1);\\n            \\n            int rem_spaces = total_spaces % (count_words - 1);\\n            \\n            // create a spaces array, which will store the no. of spaces provided between words from left side\\n            \\n            vector<int> spaces(count_words - 1, equal_spaces);\\n            \\n            // distribute the rem spaces from left to right\\n            \\n            int j = 0;\\n            \\n            while(rem_spaces)\\n            {\\n                spaces[j++] += 1;\\n                \\n                rem_spaces--;\\n            }  \\n            \\n            // j will point to the index of spaces array\\n            \\n            j = 0;\\n            \\n            string temp_res = \"\";\\n            \\n            // 1st case, if the text is not in the last line\\n            \\n            if(i < n)\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide the spaces\\n                    \\n                    if(j < spaces.size())\\n                    {\\n                        string space(spaces[j++], \\' \\');\\n                        \\n                        temp_res += space;\\n                    } \\n                }\\n            }\\n            \\n            // second case if the text is in the last line\\n            \\n            else\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide spaces\\n                    \\n                    temp_res += \\' \\';\\n                    \\n                    // decrement the spaces\\n                    \\n                    total_spaces--;\\n                }\\n                \\n                // if the total_spaces <= 0, then pop the last extra space\\n                \\n                if(total_spaces <= 0)\\n                {\\n                    temp_res.pop_back();\\n                }\\n                \\n                // otherwise push the spaces into temp_res\\n                \\n                else\\n                {\\n                    string space(total_spaces, \\' \\');\\n                    \\n                    temp_res += space;\\n                } \\n            }\\n            \\n            // push the temp_res into res array\\n            \\n            res.push_back(temp_res);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338338,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int L) {\\n         vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int L) {\\n         vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192845,
                "title": "java-solution-with-o-n-time-o-1-space-complexity",
                "content": "```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n\\n        for(int i=0; i<words.length; i++) {\\n            StringBuilder line = new StringBuilder();\\n            int len = 0;\\n            int wlen =0;\\n            int start=i;\\n            int end = i;\\n            while(end<words.length && len + words[end].length() <= maxWidth) {\\n                len += words[end].length()+1;\\n                wlen += words[end].length();\\n                end++;\\n            }\\n            int gaps = end - start - 1;\\n            int padding = end == words.length ? gaps : maxWidth-wlen;\\n\\n            int spacing = gaps == 0 ? 1 : padding / gaps;\\n            int extraSpace = gaps != 0 ? padding % gaps : 0;\\n            for(int j=start; j<end; j++) {\\n                line.append(words[j]);\\n                if(j!= end-1) {\\n                    line.append(\" \".repeat(spacing));\\n                }\\n                if(extraSpace>0) {\\n                    line.append(\" \");\\n                    extraSpace--;\\n                }\\n            }\\n            while(line.length() < maxWidth) {\\n                line.append(\" \");\\n            }\\n            i = end-1;\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n\\n        for(int i=0; i<words.length; i++) {\\n            StringBuilder line = new StringBuilder();\\n            int len = 0;\\n            int wlen =0;\\n            int start=i;\\n            int end = i;\\n            while(end<words.length && len + words[end].length() <= maxWidth) {\\n                len += words[end].length()+1;\\n                wlen += words[end].length();\\n                end++;\\n            }\\n            int gaps = end - start - 1;\\n            int padding = end == words.length ? gaps : maxWidth-wlen;\\n\\n            int spacing = gaps == 0 ? 1 : padding / gaps;\\n            int extraSpace = gaps != 0 ? padding % gaps : 0;\\n            for(int j=start; j<end; j++) {\\n                line.append(words[j]);\\n                if(j!= end-1) {\\n                    line.append(\" \".repeat(spacing));\\n                }\\n                if(extraSpace>0) {\\n                    line.append(\" \");\\n                    extraSpace--;\\n                }\\n            }\\n            while(line.length() < maxWidth) {\\n                line.append(\" \");\\n            }\\n            i = end-1;\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176270,
                "title": "javascript-simple-commented-iterative-solution",
                "content": "Based on [this solution](https://leetcode.com/problems/text-justification/discuss/446139/Well-commented-JavaScript-solution)\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\n**Intuition**\\n\\nAs we iterate through the words to form a line, we need to keep track of two things:\\n\\n1) How much space is left in that line\\n2) The words we\\'ve used so far in the line\\n\\nFor the space left, we can start with the `maxWidth` and decrease it by the length of any newly added word and the space needed to separate it from the previous word.  We can use an array to keep track of the words added so far to the line and perform a simple join operation later on to construct the line with a space between each word.  If a new word would cause the line to exceed the `maxWidth`, we can justify the existing line and start a new line with that word.\\n\\nThe tricky part comes from figuring out how to justify a line.  If a line only has a single word, it\\'s treated like the final line in which the word is left justified and any remaining space is added to the end.  If there\\'s more than one word, we\\'ll need to iteratively add the space remaining to each letter at a time which can be accomplished with a while loop that keeps track of which index in the array of words we should be on in each iteration.\\n\\nAfter we exit the for loop, we\\'ve finished checking each word, but if the line array still has words in it, we treat it as the final line in which everything needs to be left justified and whatever is left is filled with trailing spaces.  We simply join the words with an empty space and add on the difference between `maxWidth` and the length of the words + the spaces between them.\\n\\n```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let line = [words[0]];\\n\\t// spaceLeft will keep track of the trailing space left after\\n\\t// accounting for both the length of the words and the spaces between them\\n    let spaceLeft = maxWidth - words[0].length;\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        // Only add a new word to the line if\\n        // there\\'s enough space for it and the \\n        // space before it.\\n        const word = words[i];\\n        if (spaceLeft >= word.length + 1) {\\n            line.push(word);\\n            spaceLeft -= (word.length + 1);\\n        } else {\\n\\t\\t\\t// There\\'s not enough space left for the word\\n\\t\\t\\t// and the space before it.  Justify the existing\\n\\t\\t\\t// line and start a new line with the word.\\n            res.push(justifyLine(line, spaceLeft));\\n            line = [word];\\n            spaceLeft = maxWidth - word.length;\\n        }\\n    }\\n    \\n    // We\\'ve added the final word but there\\'s still space \\n    // left. In this case, we justify the line left and add\\n    // all the left over space to the end of the line.\\n    if (line.length) {\\n        let lastLine = line.join(\\' \\');\\n        lastLine += \\' \\'.repeat(maxWidth - lastLine.length);\\n        res.push(lastLine);\\n    }\\n    \\n    return res;\\n};\\n\\nconst justifyLine = (line, spaceLeft) => {\\n    // Remember, if there\\'s only a single word, it\\'s treated\\n\\t// as being left justified so all the spaces are added to the end\\n\\tif (line.length === 1) {\\n        return line[0] + \\' \\'.repeat(spaceLeft);\\n    }\\n    \\n    // The total amount of spacing will be the spaces\\n    // between words and the space left. Since we can let\\n    // the join operation take care of the spaces between\\n    // words, we only need to add the space left.\\n    let i = 0;\\n    while (spaceLeft > 0) {\\n        line[i] += \\' \\';\\n        // We don\\'t want to add a space to the final word\\n        // so when we reach it, we loop back to the start\\n        i = (i + 1) % (line.length - 1);\\n        spaceLeft--;\\n    }\\n    \\n    return line.join(\\' \\');\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9862f77b-4ef5-4cba-9de3-a64aeb7ef0d1_1655759410.4639826.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let line = [words[0]];\\n\\t// spaceLeft will keep track of the trailing space left after\\n\\t// accounting for both the length of the words and the spaces between them\\n    let spaceLeft = maxWidth - words[0].length;\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        // Only add a new word to the line if\\n        // there\\'s enough space for it and the \\n        // space before it.\\n        const word = words[i];\\n        if (spaceLeft >= word.length + 1) {\\n            line.push(word);\\n            spaceLeft -= (word.length + 1);\\n        } else {\\n\\t\\t\\t// There\\'s not enough space left for the word\\n\\t\\t\\t// and the space before it.  Justify the existing\\n\\t\\t\\t// line and start a new line with the word.\\n            res.push(justifyLine(line, spaceLeft));\\n            line = [word];\\n            spaceLeft = maxWidth - word.length;\\n        }\\n    }\\n    \\n    // We\\'ve added the final word but there\\'s still space \\n    // left. In this case, we justify the line left and add\\n    // all the left over space to the end of the line.\\n    if (line.length) {\\n        let lastLine = line.join(\\' \\');\\n        lastLine += \\' \\'.repeat(maxWidth - lastLine.length);\\n        res.push(lastLine);\\n    }\\n    \\n    return res;\\n};\\n\\nconst justifyLine = (line, spaceLeft) => {\\n    // Remember, if there\\'s only a single word, it\\'s treated\\n\\t// as being left justified so all the spaces are added to the end\\n\\tif (line.length === 1) {\\n        return line[0] + \\' \\'.repeat(spaceLeft);\\n    }\\n    \\n    // The total amount of spacing will be the spaces\\n    // between words and the space left. Since we can let\\n    // the join operation take care of the spaces between\\n    // words, we only need to add the space left.\\n    let i = 0;\\n    while (spaceLeft > 0) {\\n        line[i] += \\' \\';\\n        // We don\\'t want to add a space to the final word\\n        // so when we reach it, we loop back to the start\\n        i = (i + 1) % (line.length - 1);\\n        spaceLeft--;\\n    }\\n    \\n    return line.join(\\' \\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033072,
                "title": "python-easy-solution-explanation-faster-than-92-03-o-n",
                "content": "\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:    \\n        justified = []\\n        currRow = [] # the current row of strings that fit in maxWidth accounting for additional spaces\\n\\t\\t\\n        for i in range(len(words)):\\n            space = maxWidth # track space available\\n            space_occupied = 0 # track space taken\\n            for j in range(len(currRow)):\\n                wordLength = len(currRow[j])\\n                space_occupied += wordLength\\n                space -= wordLength\\n            \\n            # adjust for the spaces needed for each word which is the number of words - 1\\n            space -= len(currRow) - 1\\n            \\n            # if there is still space for another word and a space\\n            # append the word to the current row\\n            if space >= len(words[i]) + 1:\\n                currRow.append(words[i])\\n                \\n            # if not, append the justified row and assign the word the current row as the first  and only element\\n            else:\\n                row = self.justifyRow(currRow, maxWidth, space_occupied)\\n                justified.append(row)\\n                currRow = [words[i]]\\n               \\n\\t\\t# append the last row justifying it left\\n        if len(currRow) > 0:\\n            last = \"\"\\n            for i in range(len(currRow)):\\n                last += currRow[i] + \" \" if len(last) + len(currRow[i]) < maxWidth else currRow[i]\\n            justified.append(last.ljust(maxWidth))\\n            \\n        return justified\\n                \\n    # justifies the row given the row, max width, and the space occupied\\n    def justifyRow(self, row: List[str], maxWidth: int, space_occupied: int) -> str:\\n        length = len(row)\\n\\t\\t# return left justified if it is the only word in the row\\n        if length == 1:\\n            return row[0].ljust(maxWidth)\\n        else:\\n            justifiedRow = \"\"\\n            space_avail = maxWidth - space_occupied\\n            additional = space_avail % (length - 1)  # number of additional spaces needed for unevenness\\n            space_between = space_avail // (length - 1)  # the base number of spaces in between each word\\n            for i in range(length):\\n                justLen = len(row[i]) + space_between  # number of spaces for each word without additional\\n                # if there are additional spaces left, append it to the current word\\n\\t\\t\\t\\tif additional > 0:\\n                    justifiedRow += row[i].ljust(justLen + 1)\\n                    additional -= 1\\n\\t\\t\\t\\t# since all words and their spaces in between are accounted for, append the last word\\n                elif i == length - 1:\\n                    justifiedRow += row[i]\\n\\t\\t\\t\\t# everything else needs to add the space between\\n                else:\\n                    justifiedRow += row[i].ljust(justLen)\\n            \\n            return justifiedRow",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:    \\n        justified = []\\n        currRow = [] # the current row of strings that fit in maxWidth accounting for additional spaces\\n\\t\\t\\n        for i in range(len(words)):\\n            space = maxWidth # track space available\\n            space_occupied = 0 # track space taken\\n            for j in range(len(currRow)):\\n                wordLength = len(currRow[j])\\n                space_occupied += wordLength\\n                space -= wordLength\\n            \\n            # adjust for the spaces needed for each word which is the number of words - 1\\n            space -= len(currRow) - 1\\n            \\n            # if there is still space for another word and a space\\n            # append the word to the current row\\n            if space >= len(words[i]) + 1:\\n                currRow.append(words[i])\\n                \\n            # if not, append the justified row and assign the word the current row as the first  and only element\\n            else:\\n                row = self.justifyRow(currRow, maxWidth, space_occupied)\\n                justified.append(row)\\n                currRow = [words[i]]\\n               \\n\\t\\t# append the last row justifying it left\\n        if len(currRow) > 0:\\n            last = \"\"\\n            for i in range(len(currRow)):\\n                last += currRow[i] + \" \" if len(last) + len(currRow[i]) < maxWidth else currRow[i]\\n            justified.append(last.ljust(maxWidth))\\n            \\n        return justified\\n                \\n    # justifies the row given the row, max width, and the space occupied\\n    def justifyRow(self, row: List[str], maxWidth: int, space_occupied: int) -> str:\\n        length = len(row)\\n\\t\\t# return left justified if it is the only word in the row\\n        if length == 1:\\n            return row[0].ljust(maxWidth)\\n        else:\\n            justifiedRow = \"\"\\n            space_avail = maxWidth - space_occupied\\n            additional = space_avail % (length - 1)  # number of additional spaces needed for unevenness\\n            space_between = space_avail // (length - 1)  # the base number of spaces in between each word\\n            for i in range(length):\\n                justLen = len(row[i]) + space_between  # number of spaces for each word without additional\\n                # if there are additional spaces left, append it to the current word\\n\\t\\t\\t\\tif additional > 0:\\n                    justifiedRow += row[i].ljust(justLen + 1)\\n                    additional -= 1\\n\\t\\t\\t\\t# since all words and their spaces in between are accounted for, append the last word\\n                elif i == length - 1:\\n                    justifiedRow += row[i]\\n\\t\\t\\t\\t# everything else needs to add the space between\\n                else:\\n                    justifiedRow += row[i].ljust(justLen)\\n            \\n            return justifiedRow",
                "codeTag": "Python3"
            },
            {
                "id": 2023640,
                "title": "simple-java-solution-with-detailed-explanation",
                "content": "Break this problem into two parts.\\n1. Separate the words for each line\\n2. Format each line by applying text alignment (Either middle alignment or left alignment)\\n\\n# Now Lets see how can we separate words from the input per line.\\nSuppose our input looks like below\\n**Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16**\\nThe output will be like below\\n**\"This    is    an\",\\n\"example  of text\",\\n\"justification.  \"**\\n\\nSo for each line we may have multiple words(String). So lets declare a List which items is aslo a list to store our word. Again the end result will be just a plain string list. Lets define also\\n```\\nList<List<String>> lines = new ArrayList<>();\\nList<String> result = new ArrayList<>();\\n```\\n\\nNow how we are going to pick word for a line? Suppose you have a word and a line. You can place this word in that line if after adding the word total size of this line (Total character) will not increase the maxWidth. So suppose you picked that word. Now for the next word you need to know how many remaining characters you have. So we need to track the remaining characters per line. Initially remaining characters will be maxWidth. So inside a map we the key will be line index and value will be the remaining characters.\\n\\nLets declare the map as well as insert initial value for the lines and remaining characters for that line like below\\n```\\nint currentLine = 0;\\nlines.add(new ArrayList<String>());\\ncharMap.put(currentLine, maxWidth);\\n```\\n\\nNow we have the initial setup. In which line we are adding the next word will be determined by **currentLine** variable. Iniially it is 0 as we are filling from the first line (index 0).\\n\\nNow we loop through all the words and try to put those words in the line. \\n```\\nfor (String word : words) {\\n     int remainingChar = charMap.get(currentLine);\\n     if (word.length() <= remainingChar) {\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      } else {\\n         currentLine++;\\n         lines.add(new ArrayList<String>());\\n         charMap.put(currentLine, maxWidth);\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      }\\n}\\n```\\n\\nThats it. So what we did? Initially currentLine = 0 and at first we inserted maxWidth for the 0 in the **charMap**. So remainingChar is 16 here. Now we are checking if **current word <= remainingChar** . If it is we will add this word in the line by calling the function addWordToLine. \\n\\nIf not that means we need a new line. Right? So we are incrementing the currentLine number adding a new ArrayList in the lines as well as remainingCharacter for that line. So we have a new line setup. Now we can call addWordToLine() function to add the word in the line.\\n\\n**Now lets look what is happening inside addWordToLine function.**\\n\\n```\\n public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }\\n```\\n\\nAs this function called, we know that we can add the word. So added the word in the first line. As we added the word we need to subtract the word length from the remainingChar. So we did that in the second line.\\n\\nNow we have a very crucial trick here. After adding a word it may cover the maxLength. Its ok. But if we have more space left then a new word can come in this line next. So between two words we must seprate them by a space. Right? So if for this line if we have space left we will consider a space. Hence, we subtracted 1 from the remainingChar. (This is important. If you find difficult read this paragraph and rethink multiple times.) \\n\\nSo we have separated all the words based on lines. Now we need to format those line to generate the output.\\n\\n# Lets see how can we format the lines?\\n```\\n public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n```\\n\\nSimple function. Right? Now think when you will do left justification and when midddle justification? If a line contains only one word it will be left justified or left aligned. Also if a line is the last line it will be left justified. So we did this here. For the alignment we passing the line and maxWidth to two separate function **makeLeftAligned** and **makeMiddleAligned**\\n\\n**Now first see what is happening inside makeLeftAligned function**\\nPreviously in a line list we just added the string but did not added any spaces. Now we have to add spaces between word as well as space in the end if required.\\n\\n```\\n ublic String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n```\\n\\nI think you understand what I did. First we called a function **getCharacterCount** which just return the total word. You can optmize here. You can calculate this while adding word in the line in the first method. However, I did like this to keep my code clean. Here is the getCharacterCount function\\n\\n```\\n private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```\\n\\nSo we first get the actual character count. Then we subtracted it from maxWidth to get the remainingCharacter. This we need to fill with spacea. So for each character we are adding a space and we decrementing the remainingPos variable. So we added one space between words. But we may have remaining position in the end. So we fill those position with space inside while loop.\\n\\n**Now see what we did inside makeMiddleAligned function?**\\n\\n```\\n public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n```\\n\\nFirst calculated the remainingChar which we need to fillup. In case of middle alignment it is littlle bit tricky. We need to add spaces between words. So we could not add space after last word. Now how can we know how many space we need to add after each word? Again remainingChar can be odd number. So how we are going to distribute those spaces?\\n\\nDon\\'t worry. Space after each word will be\\nint spaces = Ceil(remainingChar / (wordCountPerLine - i - 1))\\nWhy we are doing that? If we have 3 word we are putting the spaces before two words or we can say after two words. So thats why -1. Now why -i? Suppose we have 5 remainingChar and wordCountPerLine = 3.\\nSo after adding 1 word to stringbuilder it will go inside if and i = 0 so\\nspaces = Ceil(5 / ( 3 - 0 - 1) )\\nspaces = Ceil (5 / 2)\\nspaces = 3\\n\\nSo after the first word it will put three spaces and we subtract this from remainChar as it has been full filled with spaces.\\nremainChar = 5 - 3 = 2\\nNow when i = 1 means adding another word what will happen?\\nspaces = Ceil (2 / (3 - 1 - 1))\\nspaces = Ceil (2 / 1)\\nspaces = 2\\n\\nSo we need to give 2 spaces. After that remainingChar will be 0. \\n\\nNow we can return the result. Lets look the whole code at once\\n\\n```\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> lines = new ArrayList<>();\\n        List<String> result = new ArrayList<>();\\n        Map<Integer, Integer> charMap = new HashMap<>();\\n        int currentLine = 0;\\n        \\n        lines.add(new ArrayList<String>());\\n        charMap.put(currentLine, maxWidth);\\n        \\n        for (String word : words) {\\n            int remainingChar = charMap.get(currentLine);\\n            if (word.length() <= remainingChar) {\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            } else {\\n                currentLine++;\\n                lines.add(new ArrayList<String>());\\n                charMap.put(currentLine, maxWidth);\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            }\\n        }\\n            \\n        formatLines(lines, result, maxWidth);\\n        return result;\\n    }\\n    \\n    public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }              \\n    \\n    public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n    \\n    public String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```\\n\\nIt looks large. But if you break down the problem multiple steps you can unit test each and every function and can check your logic. \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nList<List<String>> lines = new ArrayList<>();\\nList<String> result = new ArrayList<>();\\n```\n```\\nint currentLine = 0;\\nlines.add(new ArrayList<String>());\\ncharMap.put(currentLine, maxWidth);\\n```\n```\\nfor (String word : words) {\\n     int remainingChar = charMap.get(currentLine);\\n     if (word.length() <= remainingChar) {\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      } else {\\n         currentLine++;\\n         lines.add(new ArrayList<String>());\\n         charMap.put(currentLine, maxWidth);\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      }\\n}\\n```\n```\\n public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }\\n```\n```\\n public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n```\n```\\n ublic String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n```\n```\\n private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```\n```\\n public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n```\n```\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> lines = new ArrayList<>();\\n        List<String> result = new ArrayList<>();\\n        Map<Integer, Integer> charMap = new HashMap<>();\\n        int currentLine = 0;\\n        \\n        lines.add(new ArrayList<String>());\\n        charMap.put(currentLine, maxWidth);\\n        \\n        for (String word : words) {\\n            int remainingChar = charMap.get(currentLine);\\n            if (word.length() <= remainingChar) {\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            } else {\\n                currentLine++;\\n                lines.add(new ArrayList<String>());\\n                charMap.put(currentLine, maxWidth);\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            }\\n        }\\n            \\n        formatLines(lines, result, maxWidth);\\n        return result;\\n    }\\n    \\n    public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }              \\n    \\n    public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n    \\n    public String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640627,
                "title": "java-much-more-readable-clean-1ms-solution-with-inline-comments",
                "content": "```\\n  public List<String> fullJustify(String[] words, int maxWidth) {\\n    var result = new ArrayList<String>();\\n    // Trick: Use queue and poll, cleaner way to collect & process words. No messy cursors\\n    // No need to renew too, naturally polled empty\\n    var wordList = new LinkedList<String>();\\n    var textWidth = 0;\\n\\n    for (int i = 0; i < words.length; ) {\\n      // Need minimum 1 whitespace btw words!\\n      // Trick: Use wordsToAdd.size to account for whitespaces, instead of +1 to width!\\n      // Naturally excludes last word\\'s, doesn\\'t include curr count.\\n      if (textWidth + words[i].length() + wordList.size() <= maxWidth) {\\n        textWidth += words[i].length();\\n        wordList.add(words[i]);\\n        i++;\\n        continue;\\n      }\\n\\n      var spacesInbtw = (maxWidth - textWidth) / Math.max(1, wordList.size() - 1);\\n      var extraSpaces = (maxWidth - textWidth) % Math.max(1, wordList.size() - 1);\\n\\n      var line = generateLine(wordList, maxWidth, spacesInbtw, extraSpaces--);\\n      result.add(line);\\n      textWidth = 0;\\n    }\\n\\n    var line = generateLine(wordList, maxWidth, 1, 0);\\n    result.add(line);\\n\\n    return result;\\n  }\\n\\n  private String generateLine(LinkedList<String> wordsToAdd, int maxWidth, int spacesBtw, int extraSpaces) {\\n    var line = new StringBuffer();\\n    var spaces = addSpaces(spacesBtw);\\n    while (wordsToAdd.size() > 0) {\\n      line.append(wordsToAdd.poll())\\n        .append(spaces)\\n        .append(extraSpaces-- > 0 ? \" \" : \"\");\\n    }\\n    // For filling last line\\n    line.append(addSpaces(maxWidth - line.length()));\\n    return line.substring(0, maxWidth);\\n  }\\n\\n  private String addSpaces(int spaceWidth) {\\n    var spaces = new StringBuffer();\\n    while (spaceWidth-- > 0) {\\n      spaces.append(\" \");\\n    }\\n    return spaces.toString();\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public List<String> fullJustify(String[] words, int maxWidth) {\\n    var result = new ArrayList<String>();\\n    // Trick: Use queue and poll, cleaner way to collect & process words. No messy cursors\\n    // No need to renew too, naturally polled empty\\n    var wordList = new LinkedList<String>();\\n    var textWidth = 0;\\n\\n    for (int i = 0; i < words.length; ) {\\n      // Need minimum 1 whitespace btw words!\\n      // Trick: Use wordsToAdd.size to account for whitespaces, instead of +1 to width!\\n      // Naturally excludes last word\\'s, doesn\\'t include curr count.\\n      if (textWidth + words[i].length() + wordList.size() <= maxWidth) {\\n        textWidth += words[i].length();\\n        wordList.add(words[i]);\\n        i++;\\n        continue;\\n      }\\n\\n      var spacesInbtw = (maxWidth - textWidth) / Math.max(1, wordList.size() - 1);\\n      var extraSpaces = (maxWidth - textWidth) % Math.max(1, wordList.size() - 1);\\n\\n      var line = generateLine(wordList, maxWidth, spacesInbtw, extraSpaces--);\\n      result.add(line);\\n      textWidth = 0;\\n    }\\n\\n    var line = generateLine(wordList, maxWidth, 1, 0);\\n    result.add(line);\\n\\n    return result;\\n  }\\n\\n  private String generateLine(LinkedList<String> wordsToAdd, int maxWidth, int spacesBtw, int extraSpaces) {\\n    var line = new StringBuffer();\\n    var spaces = addSpaces(spacesBtw);\\n    while (wordsToAdd.size() > 0) {\\n      line.append(wordsToAdd.poll())\\n        .append(spaces)\\n        .append(extraSpaces-- > 0 ? \" \" : \"\");\\n    }\\n    // For filling last line\\n    line.append(addSpaces(maxWidth - line.length()));\\n    return line.substring(0, maxWidth);\\n  }\\n\\n  private String addSpaces(int spaceWidth) {\\n    var spaces = new StringBuffer();\\n    while (spaceWidth-- > 0) {\\n      spaces.append(\" \");\\n    }\\n    return spaces.toString();\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518515,
                "title": "c-90-speed",
                "content": "I never see .NET code on here so here is my C# version. I tried to break out the functions to make it easier to read.\\n\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> retval = new List<string>();\\n        \\n        List<string> lwords = new List<string>();\\n        int sublen = 0;\\n        int words_len = 0;\\n        foreach(string word in words){\\n            sublen += word.Length + 1;\\n            //\\'+1\\' is for the space added above\\n            if(sublen > maxWidth + 1){ \\n                string line = BuildLine(lwords, maxWidth, words_len);\\n                retval.Add(line);\\n                lwords.Clear();\\n                //Remember to add back in the current word\\n                sublen = word.Length + 1;\\n                words_len = 0;\\n            }\\n            lwords.Add(word);     \\n            words_len += word.Length;       \\n        }\\n        \\n        //Do any remaining words\\n        if(lwords.Count() > 0 ){\\n            string line = \"\";\\n            foreach(string word in lwords){\\n                line += $\"{word} \";\\n            }\\n            //NOTE: \\'Trim()\\' is to remove the space on the last word\\n            line = line.Trim().PadRight(maxWidth);\\n            retval.Add(line);\\n        }\\n        \\n        return retval;\\n    }\\n    \\n    private string BuildLine(List<string> words, int maxWidth, int words_len){\\n        int word_count = words.Count();\\n        int spaces = maxWidth - words_len;\\n        \\n        //Special Cases: Handle a single or double word\\n        if(word_count == 1){\\n            return words[0].PadRight(maxWidth);\\n        }else if (word_count == 2){\\n            return words[0] + \"\".PadRight(spaces) + words[1];\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //Number of space blocks\\n        int num_of_spaces = word_count - 1;\\n        //spaces per space block\\n        int spaces_per_word = spaces / num_of_spaces;\\n        //Extra spaces\\n        int extra = spaces % num_of_spaces;\\n        \\n        for(int i = 0; i < word_count; i++){\\n            string word = words[i];\\n            sb.Append(word);\\n            //Append spaces except for the last word\\n            if( i != word_count - 1)\\n                sb.Append(\\' \\',spaces_per_word);\\n            //Check for extra spaces\\n            if( extra > 0 ){\\n                sb.Append(\\' \\',1);\\n                extra--;\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> retval = new List<string>();\\n        \\n        List<string> lwords = new List<string>();\\n        int sublen = 0;\\n        int words_len = 0;\\n        foreach(string word in words){\\n            sublen += word.Length + 1;\\n            //\\'+1\\' is for the space added above\\n            if(sublen > maxWidth + 1){ \\n                string line = BuildLine(lwords, maxWidth, words_len);\\n                retval.Add(line);\\n                lwords.Clear();\\n                //Remember to add back in the current word\\n                sublen = word.Length + 1;\\n                words_len = 0;\\n            }\\n            lwords.Add(word);     \\n            words_len += word.Length;       \\n        }\\n        \\n        //Do any remaining words\\n        if(lwords.Count() > 0 ){\\n            string line = \"\";\\n            foreach(string word in lwords){\\n                line += $\"{word} \";\\n            }\\n            //NOTE: \\'Trim()\\' is to remove the space on the last word\\n            line = line.Trim().PadRight(maxWidth);\\n            retval.Add(line);\\n        }\\n        \\n        return retval;\\n    }\\n    \\n    private string BuildLine(List<string> words, int maxWidth, int words_len){\\n        int word_count = words.Count();\\n        int spaces = maxWidth - words_len;\\n        \\n        //Special Cases: Handle a single or double word\\n        if(word_count == 1){\\n            return words[0].PadRight(maxWidth);\\n        }else if (word_count == 2){\\n            return words[0] + \"\".PadRight(spaces) + words[1];\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //Number of space blocks\\n        int num_of_spaces = word_count - 1;\\n        //spaces per space block\\n        int spaces_per_word = spaces / num_of_spaces;\\n        //Extra spaces\\n        int extra = spaces % num_of_spaces;\\n        \\n        for(int i = 0; i < word_count; i++){\\n            string word = words[i];\\n            sb.Append(word);\\n            //Append spaces except for the last word\\n            if( i != word_count - 1)\\n                sb.Append(\\' \\',spaces_per_word);\\n            //Check for extra spaces\\n            if( extra > 0 ){\\n                sb.Append(\\' \\',1);\\n                extra--;\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456052,
                "title": "python-3-easy-implementation",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        bucket = []\\n        \\n        ans = []\\n        \\n        count = 0\\n        \\n        for word in words:\\n\\t\\t\\t#Keep track of total length so far including 1 space per word\\n            if count + len(bucket) + len(word) > maxWidth:\\n\\t\\t\\t\\t#Calculate total spaces needed\\n                spaces = maxWidth - count\\n                i = 0\\n\\t\\t\\t\\t#Distribute spaces evenly in all words except the last\\n                while spaces > 0:\\n                    bucket[i] += \\' \\'\\n                    if len(bucket) > 1:\\n                        i =  ( i + 1 ) % ( len( bucket ) - 1 )\\n                    spaces -= 1\\n                ans .append(\\'\\'.join(bucket))\\n                bucket, count = [], 0\\n            bucket.append(word)\\n            count += len(word)\\n        \\n        #Last line should be left justifies, so append normally\\n        ans.append(\\' \\'.join(bucket))\\n\\t\\t#Add additional spaces in the end\\n\\t\\tspaces = maxWidth - count - (len(bucket)-1)\\n        ans[-1] += \\' \\'*spaces\\n        \\n\\t\\t#Voila you get the ans in O(n) time\\n        return (ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        bucket = []\\n        \\n        ans = []\\n        \\n        count = 0\\n        \\n        for word in words:\\n\\t\\t\\t#Keep track of total length so far including 1 space per word\\n            if count + len(bucket) + len(word) > maxWidth:\\n\\t\\t\\t\\t#Calculate total spaces needed\\n                spaces = maxWidth - count\\n                i = 0\\n\\t\\t\\t\\t#Distribute spaces evenly in all words except the last\\n                while spaces > 0:\\n                    bucket[i] += \\' \\'\\n                    if len(bucket) > 1:\\n                        i =  ( i + 1 ) % ( len( bucket ) - 1 )\\n                    spaces -= 1\\n                ans .append(\\'\\'.join(bucket))\\n                bucket, count = [], 0\\n            bucket.append(word)\\n            count += len(word)\\n        \\n        #Last line should be left justifies, so append normally\\n        ans.append(\\' \\'.join(bucket))\\n\\t\\t#Add additional spaces in the end\\n\\t\\tspaces = maxWidth - count - (len(bucket)-1)\\n        ans[-1] += \\' \\'*spaces\\n        \\n\\t\\t#Voila you get the ans in O(n) time\\n        return (ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184405,
                "title": "java-20-lines-100",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> output= new ArrayList<>();\\n        int n= words.length;\\n        for(int i= 0, k= 1; i<n; i+= k, k= 1){\\n            // calculate k == how many words we can fit in this line (always at least one) with minimum gap of 1 space\\n\\t\\t\\t// and len == what is the total length of these words (then reduced by number of gaps k-1 before passing into printJustified)\\n\\t\\t\\tint len= words[i].length();\\n            for(int j= i+1, nextLen; j<n; j++, k++, len= nextLen)\\n                if((nextLen= len+1 + words[j].length()) > maxWidth) break;\\n\\t\\t\\t// justify left if there is only one word in the line or if it is the last line\\n            output.add(printJustified(words, maxWidth, i, k, len-k+1, k==1 || i+k == n));\\n        }\\n        return output;\\n    }\\n\\n    // i: first word, k: word count, len: line length (no spaces), left: left-justified otherwise full\\n    private String printJustified(String[] words, int maxWidth, int i, int k, int len, boolean left){\\n        int gapLen= left?1:(maxWidth-len)/(k-1), longGaps= left?0:(maxWidth-len)%(k-1);\\n        String gap= \" \".repeat(gapLen), longGap= \" \".repeat(gapLen+1);\\n        StringBuilder line= new StringBuilder(words[i]);\\n        for(int j=1; j<k; j++)\\n            line.append(j<=longGaps?longGap:gap).append(words[i+j]);\\n        if(left) line.append(\" \".repeat(maxWidth-line.length()));\\n        return line.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> output= new ArrayList<>();\\n        int n= words.length;\\n        for(int i= 0, k= 1; i<n; i+= k, k= 1){\\n            // calculate k == how many words we can fit in this line (always at least one) with minimum gap of 1 space\\n\\t\\t\\t// and len == what is the total length of these words (then reduced by number of gaps k-1 before passing into printJustified)\\n\\t\\t\\tint len= words[i].length();\\n            for(int j= i+1, nextLen; j<n; j++, k++, len= nextLen)\\n                if((nextLen= len+1 + words[j].length()) > maxWidth) break;\\n\\t\\t\\t// justify left if there is only one word in the line or if it is the last line\\n            output.add(printJustified(words, maxWidth, i, k, len-k+1, k==1 || i+k == n));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 997123,
                "title": "python-3-99-faster",
                "content": "```\\ndef fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        cur,st,i,ans=len(words[0]),0,1,[]\\n        while i<len(words):\\n            while i<len(words) and  cur+len(words[i])+1<=maxWidth:\\n                cur+=len(words[i])+1\\n                i+=1\\n            if i==len(words):\\n                tmp=\"\"\\n                for x in range(st,i):\\n                    tmp+=words[x]+\" \"\\n                if len(tmp)>maxWidth:\\n                    ans.append(tmp[:maxWidth])\\n                else:\\n                    ans.append(tmp+\" \"*(maxWidth-len(tmp)))\\n                return ans\\n            else:\\n                if i-st==1:\\n                    ans.append(words[st]+\" \"*(maxWidth-len(words[st])))\\n                else:\\n                    gap=i-st-1\\n                    sp=maxWidth-sum(map(len,words[st:i]))\\n                    nor=sp//gap\\n                    mor=sp%gap\\n                    tmp=\"\"\\n                    for x in range(mor):\\n                        tmp+=words[st+x]+\" \"*(nor+1)\\n                    for x in range(mor,gap):\\n                        tmp+=words[st+x]+\" \"*nor\\n                    tmp+=words[st+gap]\\n                    ans.append(tmp)\\n            st=i\\n            cur=len(words[st])\\n            i+=1\\n        if i==len(words):\\n            ans.append(words[i-1]+\" \"*(maxWidth-len(words[st])))\\n            return ans\\n\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        cur,st,i,ans=len(words[0]),0,1,[]\\n        while i<len(words):\\n            while i<len(words) and  cur+len(words[i])+1<=maxWidth:\\n                cur+=len(words[i])+1\\n                i+=1\\n            if i==len(words):\\n                tmp=\"\"\\n                for x in range(st,i):\\n                    tmp+=words[x]+\" \"\\n                if len(tmp)>maxWidth:\\n                    ans.append(tmp[:maxWidth])\\n                else:\\n                    ans.append(tmp+\" \"*(maxWidth-len(tmp)))\\n                return ans\\n            else:\\n                if i-st==1:\\n                    ans.append(words[st]+\" \"*(maxWidth-len(words[st])))\\n                else:\\n                    gap=i-st-1\\n                    sp=maxWidth-sum(map(len,words[st:i]))\\n                    nor=sp//gap\\n                    mor=sp%gap\\n                    tmp=\"\"\\n                    for x in range(mor):\\n                        tmp+=words[st+x]+\" \"*(nor+1)\\n                    for x in range(mor,gap):\\n                        tmp+=words[st+x]+\" \"*nor\\n                    tmp+=words[st+gap]\\n                    ans.append(tmp)\\n            st=i\\n            cur=len(words[st])\\n            i+=1\\n        if i==len(words):\\n            ans.append(words[i-1]+\" \"*(maxWidth-len(words[st])))\\n            return ans\\n\\t\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 748432,
                "title": "java-solution",
                "content": "I followed video here to understand, easy to do it afterwards.\\nhttps://www.youtube.com/watch?v=TePHubQTgQ8\\n```\\nclass Solution {\\n        public List<String> fullJustify(String[] words, int maxWidth) {\\n            if(words.length==0 || maxWidth==0) return new ArrayList<>();\\n            int index = 0;\\n            int last = 0;\\n            int n = words.length;\\n\\n            List<String> res = new ArrayList<>();\\n\\n            while(index < n){\\n                int totalChars = words[index].length();\\n                int gaps = 0;\\n                last = index+1;\\n                while(last < n && (totalChars +1+ words[last].length()) <= maxWidth){\\n                    totalChars += (1 + words[last].length());\\n                    last ++;\\n                }\\n                StringBuilder sb = new StringBuilder(\"\");\\n                gaps = last - index - 1;\\n                if(last == n || gaps ==0){\\n                    for(int i=index;i<last;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n                    }\\n                    sb.delete(sb.length()-1,sb.length());\\n                    for(int i=0;i<maxWidth - totalChars;i++){\\n                        sb.append(\" \");\\n                    }\\n                }else{\\n                    int spaces = (maxWidth - totalChars)/( gaps);\\n                    int extra = (maxWidth-totalChars) % (gaps);\\n                    for(int i=index;i<last-1;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n\\n                        for(int j=0;j<spaces + (i-index<extra?1:0);j++){\\n                            sb.append(\" \");\\n                        }\\n                    }\\n                    sb.append(words[last-1]);\\n                }\\n                res.add(sb.toString());\\n                index = last;\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public List<String> fullJustify(String[] words, int maxWidth) {\\n            if(words.length==0 || maxWidth==0) return new ArrayList<>();\\n            int index = 0;\\n            int last = 0;\\n            int n = words.length;\\n\\n            List<String> res = new ArrayList<>();\\n\\n            while(index < n){\\n                int totalChars = words[index].length();\\n                int gaps = 0;\\n                last = index+1;\\n                while(last < n && (totalChars +1+ words[last].length()) <= maxWidth){\\n                    totalChars += (1 + words[last].length());\\n                    last ++;\\n                }\\n                StringBuilder sb = new StringBuilder(\"\");\\n                gaps = last - index - 1;\\n                if(last == n || gaps ==0){\\n                    for(int i=index;i<last;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n                    }\\n                    sb.delete(sb.length()-1,sb.length());\\n                    for(int i=0;i<maxWidth - totalChars;i++){\\n                        sb.append(\" \");\\n                    }\\n                }else{\\n                    int spaces = (maxWidth - totalChars)/( gaps);\\n                    int extra = (maxWidth-totalChars) % (gaps);\\n                    for(int i=index;i<last-1;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n\\n                        for(int j=0;j<spaces + (i-index<extra?1:0);j++){\\n                            sb.append(\" \");\\n                        }\\n                    }\\n                    sb.append(words[last-1]);\\n                }\\n                res.add(sb.toString());\\n                index = last;\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481553,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string>results;\\n        vector<string>vec;\\n        string str;\\n        int length = 0;\\n        \\n        for(int i=0; i<words.size(); i++)\\n        {\\n            int total_length = words[i].size() + length + vec.size();\\n            if(total_length <= maxWidth) //Can the word fit in the line\\n            {\\n                vec.push_back(words[i]);\\n                length += words[i].length();\\n            }\\n            else//vec is full. No more words fit in a line\\n            {\\n                if(vec.size() == 1)\\n                {\\n                    str = vec[0];\\n                    str.append(maxWidth - str.size(), \\' \\');\\n                    results.push_back(str);\\n                }\\n                else if(vec.size() > 1)\\n                {\\n                    int divide = (maxWidth - length) / (vec.size()-1);\\n                    int mod = (maxWidth - length) % (vec.size() - 1);\\n                    \\n                    str = vec[0];\\n                    \\n                    for(int j = 1; j<vec.size(); j++)\\n                    {\\n                        if(j <= mod)\\n                        {\\n                            str.append(divide+1, \\' \\');\\n                        }\\n                        else\\n                        {\\n                            str.append(divide, \\' \\');\\n                        }\\n                        str += vec[j];\\n                    }\\n                    results.push_back(str);\\n                }\\n                vec.clear();\\n                vec.push_back(words[i]);\\n                length = words[i].size();\\n            }\\n        }\\n        \\n        str = vec[0];\\n        for (int j = 1; j < vec.size(); ++j) str += \\' \\' + vec[j];\\n\\t    str.append(maxWidth - str.size(), \\' \\');\\n\\t    results.push_back(str);\\n\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string>results;\\n        vector<string>vec;\\n        string str;\\n        int length = 0;\\n        \\n        for(int i=0; i<words.size(); i++)\\n        {\\n            int total_length = words[i].size() + length + vec.size();\\n            if(total_length <= maxWidth) //Can the word fit in the line\\n            {\\n                vec.push_back(words[i]);\\n                length += words[i].length();\\n            }\\n            else//vec is full. No more words fit in a line\\n            {\\n                if(vec.size() == 1)\\n                {\\n                    str = vec[0];\\n                    str.append(maxWidth - str.size(), \\' \\');\\n                    results.push_back(str);\\n                }\\n                else if(vec.size() > 1)\\n                {\\n                    int divide = (maxWidth - length) / (vec.size()-1);\\n                    int mod = (maxWidth - length) % (vec.size() - 1);\\n                    \\n                    str = vec[0];\\n                    \\n                    for(int j = 1; j<vec.size(); j++)\\n                    {\\n                        if(j <= mod)\\n                        {\\n                            str.append(divide+1, \\' \\');\\n                        }\\n                        else\\n                        {\\n                            str.append(divide, \\' \\');\\n                        }\\n                        str += vec[j];\\n                    }\\n                    results.push_back(str);\\n                }\\n                vec.clear();\\n                vec.push_back(words[i]);\\n                length = words[i].size();\\n            }\\n        }\\n        \\n        str = vec[0];\\n        for (int j = 1; j < vec.size(); ++j) str += \\' \\' + vec[j];\\n\\t    str.append(maxWidth - str.size(), \\' \\');\\n\\t    results.push_back(str);\\n\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313566,
                "title": "c-85-beaten-brute-force-beatings-iterative-solution-o-n-some-clever-tricks",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string> aResult;\\n        \\n        int aLineStart = 0;\\n        int aSeek = 0;\\n        \\n        char aBuff[maxWidth + 1];\\n        aBuff[maxWidth] = 0;\\n        \\n        for (aLineStart=0;aLineStart<words.size();aLineStart=aSeek) {\\n            \\n            int aWidth = 0;\\n            for (aSeek=aLineStart;aSeek<words.size() && aWidth + words[aSeek].size() + (aSeek - aLineStart) <= maxWidth;aSeek++) {\\n                aWidth += words[aSeek].size();\\n            }\\n            \\n            int aSpacing = 1;\\n            int aExtra = 0;\\n            if ((aSeek - aLineStart) > 1 && aSeek < words.size()) {\\n                aSpacing = (maxWidth - aWidth) / (aSeek - aLineStart - 1);\\n                aExtra   = (maxWidth - aWidth) % (aSeek - aLineStart - 1);\\n            }\\n            \\n            int aPaste = 0;\\n            for (int i=aLineStart;i<aSeek;i++) {\\n                for (int k=0;k<words[i].size();k++) {\\n                    aBuff[aPaste++] = words[i][k];\\n                }\\n                if (i < (aSeek - 1)) {\\n                    for (int k=0;k<aSpacing;k++) { aBuff[aPaste++] = \\' \\'; }\\n                    if (aExtra-- > 0) { aBuff[aPaste++] = \\' \\'; }\\n                }\\n            }\\n            \\n            while (aPaste < maxWidth) { aBuff[aPaste++] = \\' \\'; }\\n            \\n            aResult.push_back(string(aBuff));\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nKaboom, baby. I thought I could squeak out extra speed with the static buffer. Doesn\\'t seem to beat the top 20%.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string> aResult;\\n        \\n        int aLineStart = 0;\\n        int aSeek = 0;\\n        \\n        char aBuff[maxWidth + 1];\\n        aBuff[maxWidth] = 0;\\n        \\n        for (aLineStart=0;aLineStart<words.size();aLineStart=aSeek) {\\n            \\n            int aWidth = 0;\\n            for (aSeek=aLineStart;aSeek<words.size() && aWidth + words[aSeek].size() + (aSeek - aLineStart) <= maxWidth;aSeek++) {\\n                aWidth += words[aSeek].size();\\n            }\\n            \\n            int aSpacing = 1;\\n            int aExtra = 0;\\n            if ((aSeek - aLineStart) > 1 && aSeek < words.size()) {\\n                aSpacing = (maxWidth - aWidth) / (aSeek - aLineStart - 1);\\n                aExtra   = (maxWidth - aWidth) % (aSeek - aLineStart - 1);\\n            }\\n            \\n            int aPaste = 0;\\n            for (int i=aLineStart;i<aSeek;i++) {\\n                for (int k=0;k<words[i].size();k++) {\\n                    aBuff[aPaste++] = words[i][k];\\n                }\\n                if (i < (aSeek - 1)) {\\n                    for (int k=0;k<aSpacing;k++) { aBuff[aPaste++] = \\' \\'; }\\n                    if (aExtra-- > 0) { aBuff[aPaste++] = \\' \\'; }\\n                }\\n            }\\n            \\n            while (aPaste < maxWidth) { aBuff[aPaste++] = \\' \\'; }\\n            \\n            aResult.push_back(string(aBuff));\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242607,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(n)`, where `n` is the total number of characters in the text.\\n\\n```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        line = []\\n        word_count = 0\\n        char_count = 0\\n        res = []\\n        for word in words:\\n            length = char_count+1+len(word)\\n            if length > maxWidth:\\n                space_left = maxWidth - char_count\\n                if word_count == 1:\\n                    string = line[0]+\" \"*(maxWidth-len(line[0]))\\n                    res.append(string)\\n                    line = [word]\\n                    char_count = len(word)\\n                else:\\n                    q, r = divmod(space_left, word_count-1)\\n                    front = (\" \"*(q+2)).join(line[:r+1])\\n                    end = (\" \"*(q+1)).join(line[r+1:])\\n                    string = front+\" \"*(q+1)+end\\n                    if string:\\n                        res.append(string)\\n                    line = [word]\\n                    word_count = 1\\n                    char_count = len(word)\\n            else:\\n                if line:\\n                    char_count += len(word)+1\\n                else:\\n                    char_count += len(word)\\n                line.append(word)\\n                word_count += 1\\n        if line:\\n            line = \" \".join(line)\\n            line += \" \"*(maxWidth-len(line))\\n            res.append(line)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        line = []\\n        word_count = 0\\n        char_count = 0\\n        res = []\\n        for word in words:\\n            length = char_count+1+len(word)\\n            if length > maxWidth:\\n                space_left = maxWidth - char_count\\n                if word_count == 1:\\n                    string = line[0]+\" \"*(maxWidth-len(line[0]))\\n                    res.append(string)\\n                    line = [word]\\n                    char_count = len(word)\\n                else:\\n                    q, r = divmod(space_left, word_count-1)\\n                    front = (\" \"*(q+2)).join(line[:r+1])\\n                    end = (\" \"*(q+1)).join(line[r+1:])\\n                    string = front+\" \"*(q+1)+end\\n                    if string:\\n                        res.append(string)\\n                    line = [word]\\n                    word_count = 1\\n                    char_count = len(word)\\n            else:\\n                if line:\\n                    char_count += len(word)+1\\n                else:\\n                    char_count += len(word)\\n                line.append(word)\\n                word_count += 1\\n        if line:\\n            line = \" \".join(line)\\n            line += \" \"*(maxWidth-len(line))\\n            res.append(line)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213677,
                "title": "verbose-python-solution",
                "content": "```python\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        i, l = 0, len(words)\\n        output = []\\n        \\n        while i < l:\\n            j, line_words, line, rem_width = i, [], \\'\\', maxWidth\\n\\n            # if only the word can fit in the line, no remaining cols\\n            if len(words[i]) == maxWidth:\\n                i+= 1\\n                output.append(words[i-1])\\n                continue\\n\\n            # calculate remaining width after fitting words on line\\n            while i < len(words) and len(words[i]) +1 <= rem_width:\\n                # ignore first word but add spaces to rest\\n                if len(line_words) > 0: rem_width -=1\\n                rem_width -= len(words[i])\\n                line_words.append(words[i])\\n                i+=1\\n\\n            # left justify if no extra spaces or words\\n            if i == len(words) or rem_width == 0 or len(line_words) == 1:\\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    line += \\' \\'\\n                    line += words[j]\\n                    j+= 1\\n                while rem_width > 0:\\n                    line += \\' \\'\\n                    rem_width -= 1\\n                output.append(line)\\n                continue\\n\\n            # if there are leftover spaces after fitting words    \\n            if rem_width > 0:\\n                num_spaces = rem_width //(len(line_words) -1) + 1\\n                extra_spaces = rem_width % (len(line_words) -1)\\n                \\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    k = num_spaces\\n                    while k > 0:\\n                        line += \\' \\'\\n                        k-=1\\n                    if extra_spaces > 0:\\n                        extra_spaces -= 1\\n                        line += \\' \\'\\n                    line += words[j]\\n                    j+=1\\n                output.append(line)\\n                continue\\n            \\n            \\n        return output\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        i, l = 0, len(words)\\n        output = []\\n        \\n        while i < l:\\n            j, line_words, line, rem_width = i, [], \\'\\', maxWidth\\n\\n            # if only the word can fit in the line, no remaining cols\\n            if len(words[i]) == maxWidth:\\n                i+= 1\\n                output.append(words[i-1])\\n                continue\\n\\n            # calculate remaining width after fitting words on line\\n            while i < len(words) and len(words[i]) +1 <= rem_width:\\n                # ignore first word but add spaces to rest\\n                if len(line_words) > 0: rem_width -=1\\n                rem_width -= len(words[i])\\n                line_words.append(words[i])\\n                i+=1\\n\\n            # left justify if no extra spaces or words\\n            if i == len(words) or rem_width == 0 or len(line_words) == 1:\\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    line += \\' \\'\\n                    line += words[j]\\n                    j+= 1\\n                while rem_width > 0:\\n                    line += \\' \\'\\n                    rem_width -= 1\\n                output.append(line)\\n                continue\\n\\n            # if there are leftover spaces after fitting words    \\n            if rem_width > 0:\\n                num_spaces = rem_width //(len(line_words) -1) + 1\\n                extra_spaces = rem_width % (len(line_words) -1)\\n                \\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    k = num_spaces\\n                    while k > 0:\\n                        line += \\' \\'\\n                        k-=1\\n                    if extra_spaces > 0:\\n                        extra_spaces -= 1\\n                        line += \\' \\'\\n                    line += words[j]\\n                    j+=1\\n                output.append(line)\\n                continue\\n            \\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197996,
                "title": "javascript-90-with-comments",
                "content": "I was asked this in an Uber interview...Perfect justify logic was complicated...I adapted the algorithm from \\n\\nhttps://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines.\\n\\n...as the author says...the justification explanation is a complicated way to just say round robin distribution...\\n\\n```\\n// You should pack your words in a greedy approach; \\n// that is, pack as many words as you can in each line. \\n// Pad extra spaces \\' \\' when necessary so that each line \\n// has exactly maxWidth characters.\\nvar createLines = function(words, maxWidth) {\\n    let lines = [];\\n    \\n    let p = 0;\\n    \\n    while(p < words.length) {\\n        let line = [];\\n        \\n        while(p < words.length) {\\n            let peek = words[p];\\n            let peeklen = [...line, peek].join(\\' \\').length;\\n\\n            if(peeklen <= maxWidth) {\\n                line.push(peek);\\n                \\n                p++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        lines.push(line);\\n    }\\n    \\n    return lines;\\n};\\n\\nvar justifyLines = function(lines, maxWidth) {\\n    const justified = [];\\n    \\n    const push = (line, space) => {\\n        let text = line.join(space);\\n       \\n        let extra = \\' \\'.repeat(maxWidth-text.length);\\n        \\n        justified.push(text + extra);\\n    };\\n    \\n    for(let l = 0; l < lines.length -1; l++) {\\n        const line = lines[l];\\n        \\n        let spaces = (maxWidth - line.join(\\'\\').length);\\n        \\n\\t\\t// Extra spaces between words should be distributed as evenly as possible. \\n\\t\\t// If the number of spaces on a line do not divide evenly between words, \\n\\t\\t// the empty slots on the left will be assigned more spaces than the slots on the right.\\n        for(let i = 0; i < spaces; i++) {\\n            const index = i%((line.length-1) || 1);\\n\\n            line[index] += \\' \\';\\n        }\\n        \\n        push(line, \\'\\');\\n    };\\n    \\n\\t// For the last line of text, it should be left justified \\n\\t// and no extra space is inserted between words.\\n    push(lines[lines.length-1],  \\' \\');\\n    \\n    return justified;\\n}\\n\\nvar fullJustify = function(words, maxWidth) {\\n    let lines = createLines(words, maxWidth);\\n    \\n    lines = justifyLines(lines, maxWidth);\\n    \\n    return lines;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// You should pack your words in a greedy approach; \\n// that is, pack as many words as you can in each line. \\n// Pad extra spaces \\' \\' when necessary so that each line \\n// has exactly maxWidth characters.\\nvar createLines = function(words, maxWidth) {\\n    let lines = [];\\n    \\n    let p = 0;\\n    \\n    while(p < words.length) {\\n        let line = [];\\n        \\n        while(p < words.length) {\\n            let peek = words[p];\\n            let peeklen = [...line, peek].join(\\' \\').length;\\n\\n            if(peeklen <= maxWidth) {\\n                line.push(peek);\\n                \\n                p++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        lines.push(line);\\n    }\\n    \\n    return lines;\\n};\\n\\nvar justifyLines = function(lines, maxWidth) {\\n    const justified = [];\\n    \\n    const push = (line, space) => {\\n        let text = line.join(space);\\n       \\n        let extra = \\' \\'.repeat(maxWidth-text.length);\\n        \\n        justified.push(text + extra);\\n    };\\n    \\n    for(let l = 0; l < lines.length -1; l++) {\\n        const line = lines[l];\\n        \\n        let spaces = (maxWidth - line.join(\\'\\').length);\\n        \\n\\t\\t// Extra spaces between words should be distributed as evenly as possible. \\n\\t\\t// If the number of spaces on a line do not divide evenly between words, \\n\\t\\t// the empty slots on the left will be assigned more spaces than the slots on the right.\\n        for(let i = 0; i < spaces; i++) {\\n            const index = i%((line.length-1) || 1);\\n\\n            line[index] += \\' \\';\\n        }\\n        \\n        push(line, \\'\\');\\n    };\\n    \\n\\t// For the last line of text, it should be left justified \\n\\t// and no extra space is inserted between words.\\n    push(lines[lines.length-1],  \\' \\');\\n    \\n    return justified;\\n}\\n\\nvar fullJustify = function(words, maxWidth) {\\n    let lines = createLines(words, maxWidth);\\n    \\n    lines = justifyLines(lines, maxWidth);\\n    \\n    return lines;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24952,
                "title": "recursive-python-solution-with-detailed-comments",
                "content": "    import math\\n\\n    def fullJustify(self, words, maxWidth):\\n        \\n        # Handle corner cases\\n        \\n        n = len(words)\\n        if n == 0:\\n            return words\\n        if words[0] == \"\":\\n            return [\" \" * maxWidth]\\n            \\n        # Greedily put words in words_line until full\\n            \\n        words_line = [words[0]]\\n        i, len_words, len_spaces = 1, len(words[0]), 0\\n        while i < len(words) and len_spaces + len_words <= maxWidth:\\n            words_line.append(words[i])\\n            len_words += len(words[i])\\n            len_spaces += 1\\n            i += 1\\n        \\n        # Remove last word if went beyond maxWidth\\n        \\n        if len_spaces + len_words > maxWidth:\\n            a = words_line.pop()\\n            len_words -= len(a)\\n            len_spaces -= 1\\n        \\n        # Need to fill slots with spaces\\n        \\n        slots = len(words_line) - 1 if len(words_line) > 1 else 1\\n        spaces = maxWidth - len_words\\n        padding = []\\n        \\n        # Fill padding between words depending on the case\\n        \\n        spaces_, slots_ = spaces, slots\\n        while spaces_ % slots_ != 0:\\n            sp = int(math.ceil(spaces_/float(slots_)))\\n            padding += [sp]\\n            spaces_ -= sp\\n            slots_ -= 1\\n        padding += [int(spaces_ // slots_)] * slots_\\n\\n        # Last line, padding is different\\n\\n        if len(words[len(words_line):]) == 0:\\n            padding = [1] * (len(words_line) - 1) + [spaces - (len(words_line) - 1)]\\n            \\n        # Construct line\\n        \\n        i, line = 0, \"\"\\n        for word in words_line:\\n            line += word\\n            if i < len(padding):\\n                line += \" \" * padding[i]\\n            i += 1\\n            \\n        # Recursive call on rest of phrase\\n\\n        further_lines = self.fullJustify(words[len(words_line):], maxWidth)\\n        return [line] + further_lines",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "    import math\\n\\n    def fullJustify(self, words, maxWidth):\\n        \\n        # Handle corner cases\\n        \\n        n = len(words)\\n        if n == 0:\\n            return words\\n        if words[0] == \"\":\\n            return [\" \" * maxWidth]\\n            \\n        # Greedily put words in words_line until full\\n            \\n        words_line = [words[0]]\\n        i, len_words, len_spaces = 1, len(words[0]), 0\\n        while i < len(words) and len_spaces + len_words <= maxWidth:\\n            words_line.append(words[i])\\n            len_words += len(words[i])\\n            len_spaces += 1\\n            i += 1\\n        \\n        # Remove last word if went beyond maxWidth\\n        \\n        if len_spaces + len_words > maxWidth:\\n            a = words_line.pop()\\n            len_words -= len(a)\\n            len_spaces -= 1\\n        \\n        # Need to fill slots with spaces\\n        \\n        slots = len(words_line) - 1 if len(words_line) > 1 else 1\\n        spaces = maxWidth - len_words\\n        padding = []\\n        \\n        # Fill padding between words depending on the case\\n        \\n        spaces_, slots_ = spaces, slots\\n        while spaces_ % slots_ != 0:\\n            sp = int(math.ceil(spaces_/float(slots_)))\\n            padding += [sp]\\n            spaces_ -= sp\\n            slots_ -= 1\\n        padding += [int(spaces_ // slots_)] * slots_\\n\\n        # Last line, padding is different\\n\\n        if len(words[len(words_line):]) == 0:\\n            padding = [1] * (len(words_line) - 1) + [spaces - (len(words_line) - 1)]\\n            \\n        # Construct line\\n        \\n        i, line = 0, \"\"\\n        for word in words_line:\\n            line += word\\n            if i < len(padding):\\n                line += \" \" * padding[i]\\n            i += 1\\n            \\n        # Recursive call on rest of phrase\\n\\n        further_lines = self.fullJustify(words[len(words_line):], maxWidth)\\n        return [line] + further_lines",
                "codeTag": "Python3"
            },
            {
                "id": 24975,
                "title": "c-solution-with-comments",
                "content": "    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n          int idx = 0;\\n          vector<string> ret;\\n          while (idx < words.size()) {\\n            // get the current line\\n            int end = idx;\\n            int total = 0;\\n            vector<string> line;\\n            while (end < words.size() \\\\\\n        \\t   && total+line.size()+words[end].length() <= maxWidth) {\\n              line.push_back(words[end]);\\n              total += words[end].length();\\n              end ++;\\n            }\\n            // the last line or just a single word -> left alignment\\n            // just pad the end with spaces\\n            string l = words[idx];\\n            if (end == words.size() || line.size()==1) {      \\n              for (int i = idx+1; i < end; i ++)\\n                l += \" \" + words[i];\\n              l += string(maxWidth-(total+line.size()-1), ' ');\\n            }\\n            // distribute the spaces evenly\\n            else {\\n              int space_len = maxWidth - total;\\n              int left = space_len % (line.size()-1);\\n              int base = space_len / (line.size()-1);\\n              int cnt = 0;\\n              for (int i = idx+1; i < end; i ++) {\\n                l += string(base, ' ');\\n                // add extra\\n                if (cnt < left) {\\n                  l += \" \";\\n                  cnt ++;\\n                }\\n                l += words[i];\\n              }\\n            }\\n            ret.push_back(l);\\n            idx = end;\\n          }\\n          return ret;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n          int idx = 0;\\n          vector<string> ret;\\n          while (idx < words.size()) {\\n            // get the current line\\n            int end = idx;\\n            int total = 0;\\n            vector<string> line;\\n            while (end < words.size() \\\\\\n        \\t   && total+line.size()+words[end].length() <= maxWidth) {\\n              line.push_back(words[end]);\\n              total += words[end].length();\\n              end ++;\\n            }\\n            // the last line or just a single word -> left alignment\\n            // just pad the end with spaces\\n            string l = words[idx];\\n            if (end == words.size() || line.size()==1) {      \\n              for (int i = idx+1; i < end; i ++)\\n                l += \" \" + words[i];\\n              l += string(maxWidth-(total+line.size()-1), ' ');\\n            }\\n            // distribute the spaces evenly\\n            else {\\n              int space_len = maxWidth - total;\\n              int left = space_len % (line.size()-1);\\n              int base = space_len / (line.size()-1);\\n              int cnt = 0;\\n              for (int i = idx+1; i < end; i ++) {\\n                l += string(base, ' ');\\n                // add extra\\n                if (cnt < left) {\\n                  l += \" \";\\n                  cnt ++;\\n                }\\n                l += words[i];\\n              }\\n            }\\n            ret.push_back(l);\\n            idx = end;\\n          }\\n          return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4050577,
                "title": "text-justification-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955510,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\niterate through the input words and form lines that fit within the maximum width.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe main logic is within the fullJustify function. It iterates through the input words and forms lines that fit within the maximum width. It then uses the addSpaces function to create the justified lines.\\n\\nThe condition for the last line is checked using the isLastLine boolean flag.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(M), M-No of input characteres in a stream\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addSpaces(vector<string>& words, int maxWidth, int i, int j, bool isLast) {\\n        string result = words[i];\\n        if (i == j || isLast) {  // For a single-word line or last line\\n            for (int k = i + 1; k <= j; ++k) {\\n                result += \" \" + words[k];\\n            }\\n            result += string(maxWidth - result.length(), \\' \\');\\n            return result;\\n        }\\n\\n        int totalSpaces = maxWidth - accumulate(words.begin() + i, words.begin() + j + 1, 0, [](int len, const string& word) { return len + word.length(); });\\n        int slots = j - i;  // Number of slots between words\\n        int spacesBetweenWords = totalSpaces / slots;\\n        int extraSpaces = totalSpaces % slots;\\n\\n        for (int k = i + 1; k <= j; ++k) {\\n            int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n            result += string(spaces, \\' \\') + words[k];\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0, n = words.size();\\n\\n        while (i < n) {\\n            int j = i, lineLength = 0;\\n            while (j < n && lineLength + words[j].length() + (j - i) <= maxWidth) {\\n                lineLength += words[j].length();\\n                j++;\\n            }\\n\\n            bool isLastLine = (j == n);\\n            result.push_back(addSpaces(words, maxWidth, i, j - 1, isLastLine));\\n\\n            i = j;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addSpaces(vector<string>& words, int maxWidth, int i, int j, bool isLast) {\\n        string result = words[i];\\n        if (i == j || isLast) {  // For a single-word line or last line\\n            for (int k = i + 1; k <= j; ++k) {\\n                result += \" \" + words[k];\\n            }\\n            result += string(maxWidth - result.length(), \\' \\');\\n            return result;\\n        }\\n\\n        int totalSpaces = maxWidth - accumulate(words.begin() + i, words.begin() + j + 1, 0, [](int len, const string& word) { return len + word.length(); });\\n        int slots = j - i;  // Number of slots between words\\n        int spacesBetweenWords = totalSpaces / slots;\\n        int extraSpaces = totalSpaces % slots;\\n\\n        for (int k = i + 1; k <= j; ++k) {\\n            int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n            result += string(spaces, \\' \\') + words[k];\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0, n = words.size();\\n\\n        while (i < n) {\\n            int j = i, lineLength = 0;\\n            while (j < n && lineLength + words[j].length() + (j - i) <= maxWidth) {\\n                lineLength += words[j].length();\\n                j++;\\n            }\\n\\n            bool isLastLine = (j == n);\\n            result.push_back(addSpaces(words, maxWidth, i, j - 1, isLastLine));\\n\\n            i = j;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954019,
                "title": "easy-ad-hoc-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        vector<string> ans;\\n        int i = 0, j = 0;\\n        while (i < words.size())\\n        {\\n            int charCnt = words[i].length(), spaceCnt = 0;\\n            j = i + 1;\\n            while (j < words.size() && charCnt + spaceCnt + 1 + words[j].length() <= maxWidth)\\n            {\\n                charCnt += words[j].length();\\n                spaceCnt++;\\n                j++;\\n            }\\n            int rem = maxWidth - charCnt;\\n            int equalDistribute = (spaceCnt == 0) ? 0 : rem / spaceCnt;\\n            int extraDistribute = (spaceCnt == 0) ? 0 : rem % spaceCnt;\\n            if (j == words.size())\\n            {\\n                equalDistribute = 1;\\n                extraDistribute = 0;\\n            }\\n            string s;\\n            for (int k = i; k < j; ++k)\\n            {\\n                s += words[k];\\n                if (k == j - 1)\\n                    break;\\n                for (int p = 0; p < equalDistribute; ++p)\\n                {\\n                    s.push_back(\\' \\');\\n                }\\n                if (extraDistribute > 0)\\n                {\\n                    s.push_back(\\' \\');\\n                    extraDistribute--;\\n                }\\n            }\\n            while (s.length() < maxWidth)\\n            {\\n                s.push_back(\\' \\');\\n            }\\n            ans.push_back(s);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        vector<string> ans;\\n        int i = 0, j = 0;\\n        while (i < words.size())\\n        {\\n            int charCnt = words[i].length(), spaceCnt = 0;\\n            j = i + 1;\\n            while (j < words.size() && charCnt + spaceCnt + 1 + words[j].length() <= maxWidth)\\n            {\\n                charCnt += words[j].length();\\n                spaceCnt++;\\n                j++;\\n            }\\n            int rem = maxWidth - charCnt;\\n            int equalDistribute = (spaceCnt == 0) ? 0 : rem / spaceCnt;\\n            int extraDistribute = (spaceCnt == 0) ? 0 : rem % spaceCnt;\\n            if (j == words.size())\\n            {\\n                equalDistribute = 1;\\n                extraDistribute = 0;\\n            }\\n            string s;\\n            for (int k = i; k < j; ++k)\\n            {\\n                s += words[k];\\n                if (k == j - 1)\\n                    break;\\n                for (int p = 0; p < equalDistribute; ++p)\\n                {\\n                    s.push_back(\\' \\');\\n                }\\n                if (extraDistribute > 0)\\n                {\\n                    s.push_back(\\' \\');\\n                    extraDistribute--;\\n                }\\n            }\\n            while (s.length() < maxWidth)\\n            {\\n                s.push_back(\\' \\');\\n            }\\n            ans.push_back(s);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954009,
                "title": "optimal-text-justification-a-deep-dive-into-greedy-line-formatting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this post, we will tackle the \"Text Justification\" problem, where we are given an array of words and a maximum width, and we need to format the text such that each line has exactly the specified width and is fully justified. We\\'ll discuss the intuition behind the solution, step-by-step approach to solve the problem, the provided code solution, as well as the time and space complexity analysis.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo tackle this problem, we\\'ll use a greedy approach. We will iterate through the `words` array and try to pack as many words as possible in each line while adhering to the `maxWidth` constraint. We\\'ll maintain a begin pointer to track the start of the current line, a `len` variable to track the length of words in the current line, and iterate through the words.\\n\\nWhenever adding a new word to the current line would exceed the `maxWidth`, we will finalize the current line by calling a helper function `connect()`. This function will construct the line by adding the words and the appropriate number of spaces between them. If it\\'s the last line, we\\'ll add only single spaces between words.\\n\\nFinally, we\\'ll handle the last line separately, ensuring it\\'s left-justified with no extra spaces added.\\n\\n# Complexity\\n- Time Complexity:\\nThe time complexity of this solution is O(N), where N is the number of words in the input array. We iterate through the words once to construct the lines, and the connect function runs in constant time since it\\'s processing a fixed number of words.\\n\\n- Space Complexity:\\nThe space complexity is also O(N), as we are using additional space to store the output lines.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953512,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition and approach dicussed in detail in video solution\\nhttps://youtu.be/hLXrrg-cd98\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int left = 0;\\n        std::vector<string> answer;\\n        while (left < words.size()) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.push_back(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\nprivate:\\n\\n    int getRightPtr(int left, vector<string>& words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.size() && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    string justify(int left, int right, vector<string>& words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        bool isLastLine = right == words.size() - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        string space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        string answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.size() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.size() && answer[leftPtr]  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer[rightPtr] == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substr(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    string addRemSpaces(string answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + string(maxWidth - answer.length(), \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, vector<string>& words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    string findSpaceSeq(int count) {\\n        return std::string(count, \\' \\');\\n    }\\n    \\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n    int left = 0;\\n        List<String> answer = new ArrayList<>();\\n        while (left < words.length) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\n    int getRightPtr(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        boolean isLastLine = right == words.length - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        String space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        String answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.length() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.length() && answer.charAt(leftPtr)  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer.charAt(rightPtr) == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substring(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    String addRemSpaces(String answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + new String(new char[maxWidth - answer.length()]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, String[] words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    String findSpaceSeq(int count) {\\n        return new String(new char[count]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int left = 0;\\n        std::vector<string> answer;\\n        while (left < words.size()) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.push_back(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\nprivate:\\n\\n    int getRightPtr(int left, vector<string>& words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.size() && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    string justify(int left, int right, vector<string>& words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        bool isLastLine = right == words.size() - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        string space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        string answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.size() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.size() && answer[leftPtr]  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer[rightPtr] == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substr(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    string addRemSpaces(string answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + string(maxWidth - answer.length(), \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, vector<string>& words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    string findSpaceSeq(int count) {\\n        return std::string(count, \\' \\');\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n    int left = 0;\\n        List<String> answer = new ArrayList<>();\\n        while (left < words.length) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\n    int getRightPtr(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        boolean isLastLine = right == words.length - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        String space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        String answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.length() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.length() && answer.charAt(leftPtr)  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer.charAt(rightPtr) == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substring(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    String addRemSpaces(String answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + new String(new char[maxWidth - answer.length()]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, String[] words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    String findSpaceSeq(int count) {\\n        return new String(new char[count]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953504,
                "title": "simple-c-solution",
                "content": "# Intuition\\nAdd as many words to a line while it is <= maxWidth\\nJustify by then adding spaces until that line == maxWidth\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n\\t\\tList<string> result = new List<string>();\\n\\t\\tList<string> temp = new List<string>();\\n\\t\\tstring line = string.Empty;\\n\\t\\tforeach (string word in words)\\n\\t\\t{\\n\\t\\t\\tif (temp.Count + word.Length + temp.Sum(x => x.Length) <= maxWidth)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.Add(word);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Justify\\n\\t\\t\\t\\tresult.Add(Justify(temp, maxWidth));\\n\\t\\t\\t\\ttemp = new List<string>() { word };\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (temp.Count > 0)\\n\\t\\t{\\n\\t\\t\\tresult.Add(string.Join(\" \", temp).PadRight(maxWidth));\\n\\t\\t}\\n\\t\\treturn result.ToArray();\\n    }\\n\\n\\tpublic string Justify(List<string> words, int maxWidth)\\n\\t{\\n\\t\\tif (words.Count == 1)\\n\\t\\t{\\n\\t\\t\\treturn words[0].PadRight(maxWidth);\\n\\t\\t}\\n        while (words.Sum(x => x.Length) < maxWidth)\\n        {\\n            // We can\\'t justify last word\\n            for (int i = 0; i < words.Count - 1; i++)\\n            {\\n                words[i] = words[i] + \" \";\\n                if (words.Sum(x => x.Length) == maxWidth)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\t\\treturn string.Join(\"\", words);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n\\t\\tList<string> result = new List<string>();\\n\\t\\tList<string> temp = new List<string>();\\n\\t\\tstring line = string.Empty;\\n\\t\\tforeach (string word in words)\\n\\t\\t{\\n\\t\\t\\tif (temp.Count + word.Length + temp.Sum(x => x.Length) <= maxWidth)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.Add(word);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Justify\\n\\t\\t\\t\\tresult.Add(Justify(temp, maxWidth));\\n\\t\\t\\t\\ttemp = new List<string>() { word };\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (temp.Count > 0)\\n\\t\\t{\\n\\t\\t\\tresult.Add(string.Join(\" \", temp).PadRight(maxWidth));\\n\\t\\t}\\n\\t\\treturn result.ToArray();\\n    }\\n\\n\\tpublic string Justify(List<string> words, int maxWidth)\\n\\t{\\n\\t\\tif (words.Count == 1)\\n\\t\\t{\\n\\t\\t\\treturn words[0].PadRight(maxWidth);\\n\\t\\t}\\n        while (words.Sum(x => x.Length) < maxWidth)\\n        {\\n            // We can\\'t justify last word\\n            for (int i = 0; i < words.Count - 1; i++)\\n            {\\n                words[i] = words[i] + \" \";\\n                if (words.Sum(x => x.Length) == maxWidth)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\t\\treturn string.Join(\"\", words);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953142,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nWe have a task of justifying a list of words into lines of equal width while adhering to a specified maximum width. So we iterate through the words, progressively building lines and calculating the total length of characters in the current line. When the addition of a new word would exceed the maximum width, we distribute spaces evenly between words to achieve the target width. The last line is handled separately, being left-aligned with extra spaces added to the right.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n- So we iterate through each word in the words vector. We check if adding the current word to the current line would exceed the maxWidth limit. If it does, we enter a block to format and justify the current line. We distribute spaces evenly between words to achieve the desired line width, with the exception of the last line which is left-aligned.\\n\\n- After formatting the current line, it is added to the result vector, and the current vector is cleared along with resetting numLen to 0.\\n\\n- If the current word can be added to the current line without exceeding the maxWidth, the word is added to the current vector, and its length is added to numLen.\\n\\n- Once all words have been processed, we handle the last line by concatenating the words with single spaces between them, and then adding extra spaces to the right to achieve the maxWidth.\\n\\n- The last line is added to the result vector, and the final result vector containing justified lines is returned.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> current;\\n        int numLen=0;\\n        for(string word:words){\\n            if(word.size()+current.size()+numLen>maxWidth){\\n                for(int i=0;i<maxWidth-numLen;i++){\\n                    current[i%(current.size()-1?current.size()-1:1)]+=\\' \\';\\n                }\\n                result.push_back(\"\");\\n                for(string s:current) result.back()+=s;\\n                current.clear();\\n                numLen=0;\\n            }\\n            current.push_back(word);\\n            numLen+=word.size();\\n        }\\n        string lastLine=\"\";\\n        for(string s:current) lastLine+=s+\\' \\';\\n        lastLine=lastLine.substr(0,lastLine.size()-1);\\n        while(lastLine.size()<maxWidth) lastLine+=\\' \\';\\n        result.push_back(lastLine);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> current;\\n        int numLen=0;\\n        for(string word:words){\\n            if(word.size()+current.size()+numLen>maxWidth){\\n                for(int i=0;i<maxWidth-numLen;i++){\\n                    current[i%(current.size()-1?current.size()-1:1)]+=\\' \\';\\n                }\\n                result.push_back(\"\");\\n                for(string s:current) result.back()+=s;\\n                current.clear();\\n                numLen=0;\\n            }\\n            current.push_back(word);\\n            numLen+=word.size();\\n        }\\n        string lastLine=\"\";\\n        for(string s:current) lastLine+=s+\\' \\';\\n        lastLine=lastLine.substr(0,lastLine.size()-1);\\n        while(lastLine.size()<maxWidth) lastLine+=\\' \\';\\n        result.push_back(lastLine);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952495,
                "title": "c-easy-solution-faster-than-100-excellent-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // Intution\\n        // The idea in here is really very simple. What we will do is we will maintain the spaces required for the words in the temporary vector and also the number of characters in the current word. If we found that the total lenght is greater than or equal to maximum length then we will perform the operation.\\n\\n        int spacesReq;\\n        int currLen = 0;\\n\\n        vector<string> temp;\\n        vector<string> result;\\n\\n        for(auto &word : words){\\n            int wordLen = word.size();\\n            spacesReq = temp.size();\\n            if(currLen + wordLen + spacesReq > maxWidth){\\n                string answer = \"\";\\n                int spaces = maxWidth - currLen;\\n                if(temp.size() == 1){\\n                    answer = temp[0];\\n                    while(spaces --> 0) answer += \" \";\\n                    result.push_back(answer);\\n                }\\n                else{\\n                    int spaceBetween = spaces / (temp.size() - 1);\\n                    int extraSpaces = maxWidth - currLen - spaceBetween * (temp.size() - 1);\\n                    answer = temp[0];\\n                    string bet = \"\";\\n                    while(spaceBetween --> 0) bet += \" \";\\n                    for(int i = 1 ; i < temp.size() ; i++){\\n                        answer += bet;\\n                        if(extraSpaces > 0){\\n                            answer += \" \";\\n                            extraSpaces -= 1;\\n                        }\\n                        answer += temp[i];\\n                    }\\n                    result.push_back(answer);\\n                }\\n                temp.clear();\\n                currLen = wordLen;\\n                temp.push_back(word);\\n            }\\n            else{\\n                currLen += wordLen;\\n                temp.push_back(word);\\n            }\\n        }\\n\\n        if(temp.size() >= 1){\\n            string answer = temp[0];\\n            for(int i = 1 ; i < temp.size() ; i++){\\n                answer += \" \" + temp[i];\\n            }\\n            while(answer.size() < maxWidth) answer += \" \";\\n            result.push_back(answer);\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // Intution\\n        // The idea in here is really very simple. What we will do is we will maintain the spaces required for the words in the temporary vector and also the number of characters in the current word. If we found that the total lenght is greater than or equal to maximum length then we will perform the operation.\\n\\n        int spacesReq;\\n        int currLen = 0;\\n\\n        vector<string> temp;\\n        vector<string> result;\\n\\n        for(auto &word : words){\\n            int wordLen = word.size();\\n            spacesReq = temp.size();\\n            if(currLen + wordLen + spacesReq > maxWidth){\\n                string answer = \"\";\\n                int spaces = maxWidth - currLen;\\n                if(temp.size() == 1){\\n                    answer = temp[0];\\n                    while(spaces --> 0) answer += \" \";\\n                    result.push_back(answer);\\n                }\\n                else{\\n                    int spaceBetween = spaces / (temp.size() - 1);\\n                    int extraSpaces = maxWidth - currLen - spaceBetween * (temp.size() - 1);\\n                    answer = temp[0];\\n                    string bet = \"\";\\n                    while(spaceBetween --> 0) bet += \" \";\\n                    for(int i = 1 ; i < temp.size() ; i++){\\n                        answer += bet;\\n                        if(extraSpaces > 0){\\n                            answer += \" \";\\n                            extraSpaces -= 1;\\n                        }\\n                        answer += temp[i];\\n                    }\\n                    result.push_back(answer);\\n                }\\n                temp.clear();\\n                currLen = wordLen;\\n                temp.push_back(word);\\n            }\\n            else{\\n                currLen += wordLen;\\n                temp.push_back(word);\\n            }\\n        }\\n\\n        if(temp.size() >= 1){\\n            string answer = temp[0];\\n            for(int i = 1 ; i < temp.size() ; i++){\\n                answer += \" \" + temp[i];\\n            }\\n            while(answer.size() < maxWidth) answer += \" \";\\n            result.push_back(answer);\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952371,
                "title": "c-solution-for-text-justification-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to format a given list of words into lines of a given maximum width while adhering to the specified rules for justification. The key intuition is to process the words one by one, adding them to the current line as long as they fit within the maxWidth. If the current line is not full, we distribute extra spaces between the words to achieve full justification. When a line is full, we move on to the next line. We repeat this process until all words are processed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty list to store the resulting lines.\\n1. Loop through the words array, processing each word and building lines.\\n1. For each line, calculate the number of words that can fit in the line without exceeding maxWidth.\\n1. Calculate the total spaces needed to achieve full justification for the words in the line.\\n1. Depending on whether it\\'s the last line or there\\'s only one word in the line, handle left justification.\\n1. For other lines, calculate the spaces between words and distribute them evenly.\\n1. Add the constructed line to the result list.\\n1. Move the word index to the next word that was not included in the current line.\\n1. Return the list of formatted lines.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is O(n), where n is the number of words in the input array. We iterate through each word once, and for each word, we perform constant time operations like calculating lengths and spaces.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n + m), where n is the number of words in the input array and m is the length of the longest word. We store the formatted lines in a list, which takes O(n) space. Additionally, we use StringBuilder to construct the lines, which might require up to O(m) space for each line during the construction process.\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = GetEndIndex(words, startIndex, maxWidth);\\n            int spaceCount = endIndex - startIndex;\\n\\n            StringBuilder line = new StringBuilder();\\n\\n            if (spaceCount == 0 || endIndex == words.Length - 1) {\\n                // Left-justify the last line or lines with only one word.\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        line.Append(\\' \\');\\n                    }\\n                }\\n                line.Append(\\' \\', maxWidth - line.Length);\\n            } else {\\n                int totalSpaces = maxWidth - CalculateWordLength(words, startIndex, endIndex);\\n                int spacesBetweenWords = totalSpaces / spaceCount;\\n                int extraSpaces = totalSpaces % spaceCount;\\n\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        int spaces = spacesBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                        line.Append(\\' \\', spaces);\\n                        extraSpaces--;\\n                    }\\n                }\\n            }\\n\\n            result.Add(line.ToString());\\n            startIndex = endIndex + 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int GetEndIndex(string[] words, int startIndex, int maxWidth) {\\n        int endIndex = startIndex;\\n        int lineLength = words[startIndex].Length;\\n\\n        while (endIndex + 1 < words.Length && lineLength + words[endIndex + 1].Length + 1 <= maxWidth) {\\n            endIndex++;\\n            lineLength += words[endIndex].Length + 1;\\n        }\\n\\n        return endIndex;\\n    }\\n\\n    private int CalculateWordLength(string[] words, int startIndex, int endIndex) {\\n        int length = 0;\\n        for (int i = startIndex; i <= endIndex; i++) {\\n            length += words[i].Length;\\n        }\\n        return length;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = GetEndIndex(words, startIndex, maxWidth);\\n            int spaceCount = endIndex - startIndex;\\n\\n            StringBuilder line = new StringBuilder();\\n\\n            if (spaceCount == 0 || endIndex == words.Length - 1) {\\n                // Left-justify the last line or lines with only one word.\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        line.Append(\\' \\');\\n                    }\\n                }\\n                line.Append(\\' \\', maxWidth - line.Length);\\n            } else {\\n                int totalSpaces = maxWidth - CalculateWordLength(words, startIndex, endIndex);\\n                int spacesBetweenWords = totalSpaces / spaceCount;\\n                int extraSpaces = totalSpaces % spaceCount;\\n\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        int spaces = spacesBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                        line.Append(\\' \\', spaces);\\n                        extraSpaces--;\\n                    }\\n                }\\n            }\\n\\n            result.Add(line.ToString());\\n            startIndex = endIndex + 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int GetEndIndex(string[] words, int startIndex, int maxWidth) {\\n        int endIndex = startIndex;\\n        int lineLength = words[startIndex].Length;\\n\\n        while (endIndex + 1 < words.Length && lineLength + words[endIndex + 1].Length + 1 <= maxWidth) {\\n            endIndex++;\\n            lineLength += words[endIndex].Length + 1;\\n        }\\n\\n        return endIndex;\\n    }\\n\\n    private int CalculateWordLength(string[] words, int startIndex, int endIndex) {\\n        int length = 0;\\n        for (int i = startIndex; i <= endIndex; i++) {\\n            length += words[i].Length;\\n        }\\n        return length;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952286,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952236,
                "title": "0ms-o-n-most-efficient-solution-simplest-code-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem, despite marked hard, is actually a simple one. It requires no algorithm skills but edge case handlings. The key is to simply keep your code simple and readable, so that you know the edge cases are properly covered.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first scan words, do some arithmetics to find width and decide a line, then we pack a line, in simple iterations.\\n```\\nint width = words[start].size();\\nint end = start + 1;\\nwhile (end < words.size()) {\\n  int new_width = width + words[end].size() + 1;\\n  if (new_width > maxWidth) {\\n    break;\\n  }\\n  width = new_width;\\n  ++end;\\n}\\n// Now we pack words[start, end) into a line.\\n```\\nNothing is tricky here except to remember the `+1` for each extra words.\\n\\nThen we pack `words[start, end)` into a single text line, with spaces properly distributed.\\nBy default each gap between words have one space, but in order to (also) right justify the text line we need to add extra spaces. And we might also need to add one more extra space for some gaps in the left. These can all be calculated using simple arithmetics.\\nMake sure to compute `extra_space_per_gap` and `one_more_space_gaps` **outside the inner loop** as a good habit for performance and readability.\\n```\\nint count = end - start;\\nstring& line = text.emplace_back();\\nline.append(words[start]);\\n\\nint extra_space_per_gap = 0;\\nint one_more_space_gaps = 0;\\nif (count > 1 && end < words.size()) {  // Not last line or single word line.\\n  int gap = count - 1;\\n  int extra_space = maxWidth - width;\\n  extra_space_per_gap = extra_space / gap;\\n  one_more_space_gaps = extra_space % gap;\\n}\\nfor (int i = 1; i < count; ++i) {\\n  int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n  line.resize(line.size() + space_count, \\' \\');\\n  line.append(words[start + i]);\\n}\\nline.resize(maxWidth, \\' \\');\\n```\\nNote that we need to handle last line differently.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$ Where $N$ is the size of the input data. More specifically $N$ is the sum of the lengths of all the `words`.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int start = 0;\\n    vector<string> text;\\n    while (start < words.size()) {\\n      int width = words[start].size();\\n      int end = start + 1;\\n      while (end < words.size()) {\\n        int new_width = width + words[end].size() + 1;\\n        if (new_width > maxWidth) {\\n          break;\\n        }\\n        width = new_width;\\n        ++end;\\n      }\\n      // Now we pack words[start, end) into a line.\\n      int count = end - start;\\n      string& line = text.emplace_back();\\n      line.append(words[start]);\\n\\n      int extra_space_per_gap = 0;\\n      int one_more_space_gaps = 0;\\n      if (count > 1 && end < words.size()) {  // Not last line or single word line.\\n        int gap = count - 1;\\n        int extra_space = maxWidth - width;\\n        extra_space_per_gap = extra_space / gap;\\n        one_more_space_gaps = extra_space % gap;\\n      }\\n      for (int i = 1; i < count; ++i) {\\n        int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n        line.resize(line.size() + space_count, \\' \\');\\n        line.append(words[start + i]);\\n      }\\n      line.resize(maxWidth, \\' \\');\\n      start = end;\\n    }\\n    return text;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nint width = words[start].size();\\nint end = start + 1;\\nwhile (end < words.size()) {\\n  int new_width = width + words[end].size() + 1;\\n  if (new_width > maxWidth) {\\n    break;\\n  }\\n  width = new_width;\\n  ++end;\\n}\\n// Now we pack words[start, end) into a line.\\n```\n```\\nint count = end - start;\\nstring& line = text.emplace_back();\\nline.append(words[start]);\\n\\nint extra_space_per_gap = 0;\\nint one_more_space_gaps = 0;\\nif (count > 1 && end < words.size()) {  // Not last line or single word line.\\n  int gap = count - 1;\\n  int extra_space = maxWidth - width;\\n  extra_space_per_gap = extra_space / gap;\\n  one_more_space_gaps = extra_space % gap;\\n}\\nfor (int i = 1; i < count; ++i) {\\n  int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n  line.resize(line.size() + space_count, \\' \\');\\n  line.append(words[start + i]);\\n}\\nline.resize(maxWidth, \\' \\');\\n```\n```\\nclass Solution {\\npublic:\\n  vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int start = 0;\\n    vector<string> text;\\n    while (start < words.size()) {\\n      int width = words[start].size();\\n      int end = start + 1;\\n      while (end < words.size()) {\\n        int new_width = width + words[end].size() + 1;\\n        if (new_width > maxWidth) {\\n          break;\\n        }\\n        width = new_width;\\n        ++end;\\n      }\\n      // Now we pack words[start, end) into a line.\\n      int count = end - start;\\n      string& line = text.emplace_back();\\n      line.append(words[start]);\\n\\n      int extra_space_per_gap = 0;\\n      int one_more_space_gaps = 0;\\n      if (count > 1 && end < words.size()) {  // Not last line or single word line.\\n        int gap = count - 1;\\n        int extra_space = maxWidth - width;\\n        extra_space_per_gap = extra_space / gap;\\n        one_more_space_gaps = extra_space % gap;\\n      }\\n      for (int i = 1; i < count; ++i) {\\n        int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n        line.resize(line.size() + space_count, \\' \\');\\n        line.append(words[start + i]);\\n      }\\n      line.resize(maxWidth, \\' \\');\\n      start = end;\\n    }\\n    return text;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952203,
                "title": "c-easy-solution-100-o-n",
                "content": "#### Approach:\\nI will break the question into 2 sub questions: \\n1. First part is finding which how many words I can include in my current line. I would just be finding be the words not adding them in the line now, I will add the words in the line in second part.\\n2.  Second part is adding words in the line and also justifying the line at the same time.\\n3. Repeating the 1st and 2nd part for every line till every word is added in some line.\\n\\n#### Points to Note: \\n1. I will **not** make the line first and then justify it.\\n2. While updating current length of line I am adding 1+words[i].size() (except when current length is 0 where I add words[i[.size()).\\n\\tThis extra plus 1 is kept because every word in a line must have atleast 1 space between them.\\n3. Say there are m words in line for justifying the line and *left* is the amount of extra space in line. \\n\\tSo in total there will m-1 number of gaps in the line , so *left* number of spaces needs to be added in the line for justifying. \\n\\tIn the 1st (left%(m-1) ) gaps there will be *((left/gap)+1)* extra spaces and in the remaining spaces there will be *(left/gap)* extra spaces.\\n4. In case there is only a single word in line or it is the last line then all the extra spaces needs to be added at the end of the line.\\n5. Try to use words[i].size() instead of words[i].length to find out size of word. The .size() method runs in O(1) time while the .length() runs in O(n) time.\\n\\n\\n#### Code:\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n\\t\\tint k=maxWidth;\\n        string temp=\"\";\\n        int n=words.size();\\n        \\n        vector<string> ans;\\n        \\n        int i=0;\\n        int currsize=0;\\n        int prev=0;\\n        \\n        while(i<n){\\n            \\n            \\n            \\n            int curr=words[i].size();\\n            i++;\\n            \\n            while(i<n and (curr+words[i].size()+1)<=k){\\n                curr+=(words[i].size()+1);\\n                i++;\\n            }\\n            \\n            string temp=\"\";\\n            ans.push_back(temp);\\n            int m=i-prev;\\n            \\n            if(i==n or m==1){\\n                \\n                for(int j=prev;j<i;j++){\\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                }\\n                \\n                int z=ans[currsize].size();\\n                while(z<k){\\n                    ans[currsize]+=\\' \\';\\n                    z++;\\n                }\\n                \\n            }else{\\n                \\n                int gap=m-1;\\n                int left=k-curr;\\n                \\n                int a=left/gap;\\n                \\n                int x=(gap-(left%gap)) ; // gaps with \\'a\\' no. of spaces\\n                int y=left%gap ; // gaps with \\'a+1\\' no. of spaces\\n                \\n                \\n                for(int j=prev;j<i;j++){\\n                    \\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                    \\n                    if(x>0 or y>0){\\n                        for(int t=0;t<a;t++){\\n                            ans[currsize]+=\\' \\';\\n                        }\\n                    }\\n                    \\n                    if(y>0){\\n                        ans[currsize]+=\\' \\';\\n                        y--;\\n                    }else{\\n                        x--;\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currsize++;\\n            prev=i;\\n            \\n        }\\n        \\n        \\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n\\t\\tint k=maxWidth;\\n        string temp=\"\";\\n        int n=words.size();\\n        \\n        vector<string> ans;\\n        \\n        int i=0;\\n        int currsize=0;\\n        int prev=0;\\n        \\n        while(i<n){\\n            \\n            \\n            \\n            int curr=words[i].size();\\n            i++;\\n            \\n            while(i<n and (curr+words[i].size()+1)<=k){\\n                curr+=(words[i].size()+1);\\n                i++;\\n            }\\n            \\n            string temp=\"\";\\n            ans.push_back(temp);\\n            int m=i-prev;\\n            \\n            if(i==n or m==1){\\n                \\n                for(int j=prev;j<i;j++){\\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                }\\n                \\n                int z=ans[currsize].size();\\n                while(z<k){\\n                    ans[currsize]+=\\' \\';\\n                    z++;\\n                }\\n                \\n            }else{\\n                \\n                int gap=m-1;\\n                int left=k-curr;\\n                \\n                int a=left/gap;\\n                \\n                int x=(gap-(left%gap)) ; // gaps with \\'a\\' no. of spaces\\n                int y=left%gap ; // gaps with \\'a+1\\' no. of spaces\\n                \\n                \\n                for(int j=prev;j<i;j++){\\n                    \\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                    \\n                    if(x>0 or y>0){\\n                        for(int t=0;t<a;t++){\\n                            ans[currsize]+=\\' \\';\\n                        }\\n                    }\\n                    \\n                    if(y>0){\\n                        ans[currsize]+=\\' \\';\\n                        y--;\\n                    }else{\\n                        x--;\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currsize++;\\n            prev=i;\\n            \\n        }\\n        \\n        \\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952174,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        n=len(words)\\n        ans=[]\\n        i=0\\n        while i<n:\\n            temp=[]\\n            seen=0\\n            cur=\"\"\\n            while i<n and seen+len(words[i])+len(temp)<=maxWidth:\\n                temp.append(words[i])\\n                seen+=len(words[i])\\n                i+=1\\n\\n            m=len(temp)\\n            if (m-1)!=0 and i!=n:\\n                q,r=divmod(maxWidth-seen,(m-1))\\n                sp=[q+(1 if j<r else 0) for j in range(m-1)]\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'*sp[j]\\n                cur+=temp[-1]\\n\\n            else:\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'\\n                cur+=temp[-1]\\n                cur+=\\' \\'*(maxWidth-len(cur))\\n\\n            ans.append(cur)\\n        return ans                        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        n=len(words)\\n        ans=[]\\n        i=0\\n        while i<n:\\n            temp=[]\\n            seen=0\\n            cur=\"\"\\n            while i<n and seen+len(words[i])+len(temp)<=maxWidth:\\n                temp.append(words[i])\\n                seen+=len(words[i])\\n                i+=1\\n\\n            m=len(temp)\\n            if (m-1)!=0 and i!=n:\\n                q,r=divmod(maxWidth-seen,(m-1))\\n                sp=[q+(1 if j<r else 0) for j in range(m-1)]\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'*sp[j]\\n                cur+=temp[-1]\\n\\n            else:\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'\\n                cur+=temp[-1]\\n                cur+=\\' \\'*(maxWidth-len(cur))\\n\\n            ans.append(cur)\\n        return ans                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771390,
                "title": "text-justification-o-n-javascript-memory-87-99-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nvar fullJustify = function (words, maxWidth) {\\n  const builtArray = [];\\n  let tempArray = [];\\n  let tempLen = 0;\\n\\n  const createSpaceOfGivenSize = size => {\\n    let space = ``;\\n    for (let index = 0; index < size; index++) {\\n      space += ` `;\\n    }\\n    return space;\\n  };\\n\\n  //pack your words in a greedy approach; that is, pack as many words as you can in each line\\n  for (let index = 0; index < words.length; index++) {\\n    if (tempLen + tempArray.length + words[index].length <= maxWidth) {\\n      tempArray.push (words[index]);\\n      tempLen += words[index].length;\\n    } else {\\n      builtArray.push ({\\n        array: tempArray,\\n        size: tempLen,\\n      });\\n      tempArray = [words[index]];\\n      tempLen = words[index].length;\\n      continue;\\n    }\\n  }\\n\\n  //for last iteration\\n  builtArray.push ({\\n    array: tempArray,\\n    size: tempLen,\\n  });\\n  const output = [];\\n  for (let index = 0; index < builtArray.length; index++) {\\n    let {array, size} = builtArray[index];\\n    const totalWord = array.length;\\n    const totalRequiredSpace = maxWidth - size;\\n    if (index === builtArray.length - 1) {\\n      // because the last line must be left-justified instead of fully-justified.\\n      const str =\\n        array.join (` `) +\\n        createSpaceOfGivenSize (totalRequiredSpace - (array.length - 1));\\n      output.push (str);\\n    } else {\\n      let extraSpace = totalRequiredSpace % (totalWord - 1);\\n      //If the number of spaces on a line does not divide evenly between words,\\n      if (extraSpace) {\\n        const spaces = [];\\n        //Extra spaces between words should be distributed as evenly as possible.\\n        let spacePerWord = (totalRequiredSpace - extraSpace) / (totalWord - 1);\\n        for (let index = 0; index < totalWord - 1; index++) {\\n          spaces.push (createSpaceOfGivenSize (spacePerWord));\\n        }\\n        let tempTotalWord = totalWord - 1 - 1;\\n        // the empty slots on the left will be assigned more spaces than the slots on the right.\\n        while (extraSpace) {\\n          const temp = extraSpace % tempTotalWord;\\n          spacePerWord = parseInt (extraSpace / tempTotalWord);\\n          for (let index = 0; index < tempTotalWord; index++) {\\n            spaces[index] += createSpaceOfGivenSize (spacePerWord);\\n          }\\n          tempTotalWord -= 1;\\n          extraSpace = temp;\\n        }\\n        let tempString = ``;\\n        for (let index = 0; index < totalWord; index++) {\\n          //Each line has exactly maxWidth characters.\\n          if (spaces[index]) {\\n            tempString += array[index] + spaces[index] || ``;\\n          } else {\\n            tempString += array[index];\\n          }\\n        }\\n        output.push (tempString);\\n      } else {\\n        //If the number of spaces on a line divide evenly between words,\\n        if (totalWord - 1) {\\n          output.push (\\n            array.join (\\n              createSpaceOfGivenSize (totalRequiredSpace / (totalWord - 1))\\n            )\\n          );\\n        } else {\\n          output.push (array[0] + createSpaceOfGivenSize (totalRequiredSpace));\\n        }\\n      }\\n    }\\n  }\\n  return output;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/dee00410-e5ae-4791-a47c-9d22b55f5f1b_1689480610.4518938.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fullJustify = function (words, maxWidth) {\\n  const builtArray = [];\\n  let tempArray = [];\\n  let tempLen = 0;\\n\\n  const createSpaceOfGivenSize = size => {\\n    let space = ``;\\n    for (let index = 0; index < size; index++) {\\n      space += ` `;\\n    }\\n    return space;\\n  };\\n\\n  //pack your words in a greedy approach; that is, pack as many words as you can in each line\\n  for (let index = 0; index < words.length; index++) {\\n    if (tempLen + tempArray.length + words[index].length <= maxWidth) {\\n      tempArray.push (words[index]);\\n      tempLen += words[index].length;\\n    } else {\\n      builtArray.push ({\\n        array: tempArray,\\n        size: tempLen,\\n      });\\n      tempArray = [words[index]];\\n      tempLen = words[index].length;\\n      continue;\\n    }\\n  }\\n\\n  //for last iteration\\n  builtArray.push ({\\n    array: tempArray,\\n    size: tempLen,\\n  });\\n  const output = [];\\n  for (let index = 0; index < builtArray.length; index++) {\\n    let {array, size} = builtArray[index];\\n    const totalWord = array.length;\\n    const totalRequiredSpace = maxWidth - size;\\n    if (index === builtArray.length - 1) {\\n      // because the last line must be left-justified instead of fully-justified.\\n      const str =\\n        array.join (` `) +\\n        createSpaceOfGivenSize (totalRequiredSpace - (array.length - 1));\\n      output.push (str);\\n    } else {\\n      let extraSpace = totalRequiredSpace % (totalWord - 1);\\n      //If the number of spaces on a line does not divide evenly between words,\\n      if (extraSpace) {\\n        const spaces = [];\\n        //Extra spaces between words should be distributed as evenly as possible.\\n        let spacePerWord = (totalRequiredSpace - extraSpace) / (totalWord - 1);\\n        for (let index = 0; index < totalWord - 1; index++) {\\n          spaces.push (createSpaceOfGivenSize (spacePerWord));\\n        }\\n        let tempTotalWord = totalWord - 1 - 1;\\n        // the empty slots on the left will be assigned more spaces than the slots on the right.\\n        while (extraSpace) {\\n          const temp = extraSpace % tempTotalWord;\\n          spacePerWord = parseInt (extraSpace / tempTotalWord);\\n          for (let index = 0; index < tempTotalWord; index++) {\\n            spaces[index] += createSpaceOfGivenSize (spacePerWord);\\n          }\\n          tempTotalWord -= 1;\\n          extraSpace = temp;\\n        }\\n        let tempString = ``;\\n        for (let index = 0; index < totalWord; index++) {\\n          //Each line has exactly maxWidth characters.\\n          if (spaces[index]) {\\n            tempString += array[index] + spaces[index] || ``;\\n          } else {\\n            tempString += array[index];\\n          }\\n        }\\n        output.push (tempString);\\n      } else {\\n        //If the number of spaces on a line divide evenly between words,\\n        if (totalWord - 1) {\\n          output.push (\\n            array.join (\\n              createSpaceOfGivenSize (totalRequiredSpace / (totalWord - 1))\\n            )\\n          );\\n        } else {\\n          output.push (array[0] + createSpaceOfGivenSize (totalRequiredSpace));\\n        }\\n      }\\n    }\\n  }\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3631796,
                "title": "solution-in-java-python",
                "content": "## Just follow through the code and you will be good to go.\\n---\\n# Code\\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> line = new ArrayList<>();\\n        int ctr = 0;\\n        int width = 0;\\n        while(ctr<words.length)\\n        {\\n            String word = words[ctr];\\n            if(word.length()+width<=maxWidth)\\n            {\\n                line.add(word);\\n                width+=word.length()+1;\\n                ctr++;\\n            }\\n            else\\n            {\\n                int spaces = maxWidth-width+line.size();\\n                int j = 0;\\n                int k = 0;\\n                while(k < spaces)\\n                {\\n                    if(j>=line.size()-1)\\n                    {\\n                        j = 0;\\n                    }\\n                    line.set(j,line.get(j)+\" \");\\n                    k++;\\n                    j++;\\n                }\\n                String temp = \"\";\\n                for(String str: line)\\n                {\\n                    temp+=str;\\n                }\\n                result.add(temp);\\n                line.clear();\\n                width = 0;\\n            }\\n        }\\n        for(int i = 0;i<line.size()-1;i++)\\n        {\\n            line.set(i,line.get(i)+\" \");\\n        }\\n        for(int x = 0;x<maxWidth-width+1;x++)\\n        {\\n            line.set(line.size()-1,line.get(line.size()-1)+\" \");\\n        }\\n        String temp = \"\";\\n        for(String str: line)\\n        {\\n            temp+=str;\\n        }\\n        result.add(temp);\\n        return result;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []\\n        width = 0 \\n        i = 0\\n        while i<len(words):\\n            word = words[i]\\n            if width+len(word)<=maxWidth:\\n                line.append(word)\\n                width+=len(word)+1\\n                i+=1\\n            else:\\n                spaces = maxWidth-width+len(line)\\n                j = 0\\n                s = 0\\n                while s<spaces:\\n                    if j>=len(line)-1:\\n                        j=0\\n                    line[j]+=\" \"\\n                    s+=1\\n                    j+=1\\n                result.append(\"\".join(line))\\n                line = []\\n                width = 0\\n        for word in range(len(line)-1):\\n            line[word]+=\" \"\\n        line[-1]+=\" \" * (maxWidth-width+1)\\n        result.append(\"\".join(line))\\n        return result\\n\\n\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.\\uD83D\\uDC4D*\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> line = new ArrayList<>();\\n        int ctr = 0;\\n        int width = 0;\\n        while(ctr<words.length)\\n        {\\n            String word = words[ctr];\\n            if(word.length()+width<=maxWidth)\\n            {\\n                line.add(word);\\n                width+=word.length()+1;\\n                ctr++;\\n            }\\n            else\\n            {\\n                int spaces = maxWidth-width+line.size();\\n                int j = 0;\\n                int k = 0;\\n                while(k < spaces)\\n                {\\n                    if(j>=line.size()-1)\\n                    {\\n                        j = 0;\\n                    }\\n                    line.set(j,line.get(j)+\" \");\\n                    k++;\\n                    j++;\\n                }\\n                String temp = \"\";\\n                for(String str: line)\\n                {\\n                    temp+=str;\\n                }\\n                result.add(temp);\\n                line.clear();\\n                width = 0;\\n            }\\n        }\\n        for(int i = 0;i<line.size()-1;i++)\\n        {\\n            line.set(i,line.get(i)+\" \");\\n        }\\n        for(int x = 0;x<maxWidth-width+1;x++)\\n        {\\n            line.set(line.size()-1,line.get(line.size()-1)+\" \");\\n        }\\n        String temp = \"\";\\n        for(String str: line)\\n        {\\n            temp+=str;\\n        }\\n        result.add(temp);\\n        return result;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []\\n        width = 0 \\n        i = 0\\n        while i<len(words):\\n            word = words[i]\\n            if width+len(word)<=maxWidth:\\n                line.append(word)\\n                width+=len(word)+1\\n                i+=1\\n            else:\\n                spaces = maxWidth-width+len(line)\\n                j = 0\\n                s = 0\\n                while s<spaces:\\n                    if j>=len(line)-1:\\n                        j=0\\n                    line[j]+=\" \"\\n                    s+=1\\n                    j+=1\\n                result.append(\"\".join(line))\\n                line = []\\n                width = 0\\n        for word in range(len(line)-1):\\n            line[word]+=\" \"\\n        line[-1]+=\" \" * (maxWidth-width+1)\\n        result.append(\"\".join(line))\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525236,
                "title": "pure-c",
                "content": "# Implemented:\\n```\\n1. cJust()        - Center justify\\n2. lJust()        - Left justify for last string\\n3. countStrings() - Strings counter for accurate mem alloc\\n```\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth);\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr);\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr);\\n\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize)\\n{\\n    *returnSize = countStrings(words, wordsSize, maxWidth);     // Get Number Of Justified Strings\\n    int currStr = 0;                                            // Current Result String Index\\n    const char **strings = calloc(sizeof(char *), *returnSize); // Mem Alloc\\n    for(int i = 0; i < *returnSize; i++)                        // Mem Alloc\\n        strings[i] = calloc(sizeof(char), ( maxWidth + 1 ) );   // Mem Alloc\\n\\n    char ** tail     = &words[0]; // Tail of Accumulated Words\\n    char ** head     = tail;      // Head of Accumulated Words\\n    char ** lastWord = &words[wordsSize-1];\\n    int len = strlen(*head);   // Init len with first word length value\\n\\n    for ( head; ; head++ )  // Iterate Each Word\\n    {\\n        if ( head == lastWord ) { // If Last Word - Justify Accumulated Words and Break\\n            lJust(tail, head - tail + 1, maxWidth, strings[currStr]);\\n            break;\\n        }\\n        \\n        const int  nextWordLen = strlen(*(head + 1));\\n        const int  nextLen     = len + 1 + nextWordLen; // Accumulate String length. +1 space \\n        const bool lenExceeded = nextLen > maxWidth;  \\n\\n        if ( lenExceeded ) {\\n            cJust(tail, head - tail + 1, maxWidth, maxWidth - len, strings[currStr++]); // Justify String\\n            tail = head + 1; // Set New Tail\\n        }\\n\\n        len  = lenExceeded ?  nextWordLen : nextLen;  // Accumulate Length or Reset\\n    }\\n    return strings;\\n}\\n\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth)\\n{\\n    int counter = 0; // Strings Counter\\n    int len = strlen(words[0]); // Init Len With First Word Length Value\\n\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        if ( isLastWord ) { // If Last Word - Increase Counter And Break\\n            ++counter;\\n            break;\\n        }\\n        int nextWordLen = strlen(words[i + 1]); // Get Next Word Length\\n        int nextLen = len + 1 + nextWordLen;    // Get Summary Length Including Next Word And Spaces Between\\n\\n        if (nextLen > maxWidth) { // If Length Oversized - Increase Counter\\n            ++counter;\\n        }\\n        len = nextLen > maxWidth ? nextWordLen : nextLen;  // Update Summary Length\\n    }\\n    return counter;\\n}\\n\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr)\\n{\\n    int n = 0; // Index For jStr\\n    const int gaps = wordsSize == 1 ? 1 : wordsSize - 1; // Total Space Gaps\\n    int spaces = wordsSize-1 + extraSpaces; // Total Spaces To Insert\\n\\n    for( int i = 0; i<wordsSize; i++) // Iterate Each Word\\n    {\\n        while(*words[i]) {\\n            jStr[n++] = *(words[i]++); // Copy Aa Word To Result String\\n        }\\n        if ( n < maxWidth ) {            \\n            int nSp = spaces / ( gaps - i ) + ( spaces % ( gaps - i ) ? 1 : 0 ); // Calc Number Of Spaces To Insert\\n            spaces -= nSp;\\n            while(nSp--) { // Append Spaces After Word\\n                jStr[n++] = \\' \\';\\n            }\\n        }\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr)\\n{\\n    int n = 0;\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        while(*words[i]) { // Copy Aa Word To Result String\\n            jStr[n++] = *(words[i]++);\\n        }\\n        if ( isLastWord ) { // Last Word - Break\\n            break;\\n        }\\n        jStr[n++] = \\' \\'; // +1 Space\\n    }\\n    while ( n < maxWidth ) { // Fill The End With Spaces\\n        jStr[n++] = \\' \\';\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. cJust()        - Center justify\\n2. lJust()        - Left justify for last string\\n3. countStrings() - Strings counter for accurate mem alloc\\n```\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth);\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr);\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr);\\n\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize)\\n{\\n    *returnSize = countStrings(words, wordsSize, maxWidth);     // Get Number Of Justified Strings\\n    int currStr = 0;                                            // Current Result String Index\\n    const char **strings = calloc(sizeof(char *), *returnSize); // Mem Alloc\\n    for(int i = 0; i < *returnSize; i++)                        // Mem Alloc\\n        strings[i] = calloc(sizeof(char), ( maxWidth + 1 ) );   // Mem Alloc\\n\\n    char ** tail     = &words[0]; // Tail of Accumulated Words\\n    char ** head     = tail;      // Head of Accumulated Words\\n    char ** lastWord = &words[wordsSize-1];\\n    int len = strlen(*head);   // Init len with first word length value\\n\\n    for ( head; ; head++ )  // Iterate Each Word\\n    {\\n        if ( head == lastWord ) { // If Last Word - Justify Accumulated Words and Break\\n            lJust(tail, head - tail + 1, maxWidth, strings[currStr]);\\n            break;\\n        }\\n        \\n        const int  nextWordLen = strlen(*(head + 1));\\n        const int  nextLen     = len + 1 + nextWordLen; // Accumulate String length. +1 space \\n        const bool lenExceeded = nextLen > maxWidth;  \\n\\n        if ( lenExceeded ) {\\n            cJust(tail, head - tail + 1, maxWidth, maxWidth - len, strings[currStr++]); // Justify String\\n            tail = head + 1; // Set New Tail\\n        }\\n\\n        len  = lenExceeded ?  nextWordLen : nextLen;  // Accumulate Length or Reset\\n    }\\n    return strings;\\n}\\n\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth)\\n{\\n    int counter = 0; // Strings Counter\\n    int len = strlen(words[0]); // Init Len With First Word Length Value\\n\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        if ( isLastWord ) { // If Last Word - Increase Counter And Break\\n            ++counter;\\n            break;\\n        }\\n        int nextWordLen = strlen(words[i + 1]); // Get Next Word Length\\n        int nextLen = len + 1 + nextWordLen;    // Get Summary Length Including Next Word And Spaces Between\\n\\n        if (nextLen > maxWidth) { // If Length Oversized - Increase Counter\\n            ++counter;\\n        }\\n        len = nextLen > maxWidth ? nextWordLen : nextLen;  // Update Summary Length\\n    }\\n    return counter;\\n}\\n\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr)\\n{\\n    int n = 0; // Index For jStr\\n    const int gaps = wordsSize == 1 ? 1 : wordsSize - 1; // Total Space Gaps\\n    int spaces = wordsSize-1 + extraSpaces; // Total Spaces To Insert\\n\\n    for( int i = 0; i<wordsSize; i++) // Iterate Each Word\\n    {\\n        while(*words[i]) {\\n            jStr[n++] = *(words[i]++); // Copy Aa Word To Result String\\n        }\\n        if ( n < maxWidth ) {            \\n            int nSp = spaces / ( gaps - i ) + ( spaces % ( gaps - i ) ? 1 : 0 ); // Calc Number Of Spaces To Insert\\n            spaces -= nSp;\\n            while(nSp--) { // Append Spaces After Word\\n                jStr[n++] = \\' \\';\\n            }\\n        }\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr)\\n{\\n    int n = 0;\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        while(*words[i]) { // Copy Aa Word To Result String\\n            jStr[n++] = *(words[i]++);\\n        }\\n        if ( isLastWord ) { // Last Word - Break\\n            break;\\n        }\\n        jStr[n++] = \\' \\'; // +1 Space\\n    }\\n    while ( n < maxWidth ) { // Fill The End With Spaces\\n        jStr[n++] = \\' \\';\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481581,
                "title": "c-100-fast-30-lines-comments-added",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<string> answer;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // Step 1: find out how many words can fit on line with one space between words\\n            int begin = i, lineSize = words[i].size();\\n            while (i + 1 < n && words[i + 1].size() + lineSize + 1 <= maxWidth) {\\n                lineSize += words[++i].size() + 1; // +1 for space between prev and cur words\\n            }\\n            \\n            // Step 2: determine space size (round-robin distribution)\\n            int numWords = i - begin + 1, spaceSize = 1, numExtraSpaces = 0;\\n            if (numWords > 1 && i < n - 1) { // if greater than one word in line and this isn\\'t the last line\\n                int remaining = maxWidth - lineSize;\\n                spaceSize = remaining / (numWords - 1) + 1; // +1 since lineSize already includes 1 space betweeen words\\n                numExtraSpaces = remaining % (numWords - 1);\\n            }\\n            \\n            // Step 3: create line\\n            string line = words[begin];\\n            for (int j = 1; j < numWords; ++j) {\\n                // add space between prev and cur words\\n                line.append(spaceSize, \\' \\');\\n                if (j <= numExtraSpaces) {\\n                    line.push_back(\\' \\');\\n                }\\n                line += words[begin + j];\\n            }\\n            if (line.size() < maxWidth) { // add right padding\\n                line.append(maxWidth - line.size(), \\' \\');\\n            }\\n            \\n            answer.emplace_back(line);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\n![upvote2.jpg](https://assets.leetcode.com/users/images/a531facd-2a18-429a-9d39-94d46cddaf4b_1689310705.582009.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<string> answer;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // Step 1: find out how many words can fit on line with one space between words\\n            int begin = i, lineSize = words[i].size();\\n            while (i + 1 < n && words[i + 1].size() + lineSize + 1 <= maxWidth) {\\n                lineSize += words[++i].size() + 1; // +1 for space between prev and cur words\\n            }\\n            \\n            // Step 2: determine space size (round-robin distribution)\\n            int numWords = i - begin + 1, spaceSize = 1, numExtraSpaces = 0;\\n            if (numWords > 1 && i < n - 1) { // if greater than one word in line and this isn\\'t the last line\\n                int remaining = maxWidth - lineSize;\\n                spaceSize = remaining / (numWords - 1) + 1; // +1 since lineSize already includes 1 space betweeen words\\n                numExtraSpaces = remaining % (numWords - 1);\\n            }\\n            \\n            // Step 3: create line\\n            string line = words[begin];\\n            for (int j = 1; j < numWords; ++j) {\\n                // add space between prev and cur words\\n                line.append(spaceSize, \\' \\');\\n                if (j <= numExtraSpaces) {\\n                    line.push_back(\\' \\');\\n                }\\n                line += words[begin + j];\\n            }\\n            if (line.size() < maxWidth) { // add right padding\\n                line.append(maxWidth - line.size(), \\' \\');\\n            }\\n            \\n            answer.emplace_back(line);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907088,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }\\n            bool isLast = (end == words.size());\\n            res.push_back(justify(words, start, end, maxWidth - total, isLast));\\n            start = end;\\n        }\\n        return res;\\n    }\\n    \\n    string justify(const vector<string>& words, int start, int end, int space, bool isLast) {\\n        string line;\\n        if (!isLast) {\\n            // eg: \"Science  is  what we\" maxwidth = 20\\n            // characters: 7 + 2 + 4 + 2 = 15\\n            // left = 20 - 15 = 5\\n            // 5/3 => 5 % 3 != 0? => space 1 = 5/3 + 1 = 2\\n            // 3/2 -> 3 % 2 != 0? => space 2 = 3/2 + 1 = 2\\n            // 1 => space 3 = 1\\n\\t\\t\\tint count = end - start - 1;  // number of space slots = number of words - 1\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (count > 0) {\\n                    int cur = space % count != 0? space/count + 1: space/count;\\n                    line.insert(line.end(), cur, \\' \\');\\n                    space -= cur;\\n                    --count;\\n                }\\n            }\\n        } else {\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (space-- > 0) line.push_back(\\' \\');\\n            }\\n\\n        }\\n        if (space > 0) line.insert(line.end(), space, \\' \\');\\n        return line;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2853652,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\npublic class Solution {\\n\\n    private class LineData {\\n\\n        int startIndexWords;\\n        int endIndexWords;\\n        int textLength;\\n        int singleSapcesBetweenWordsLength;\\n\\n        LineData(int index, String[] words) {\\n            if (index < words.length) {\\n                startIndexWords = index;\\n                endIndexWords = index;\\n                textLength = words[index].length();\\n                singleSapcesBetweenWordsLength = 0;\\n            }\\n        }\\n    }\\n\\n    private static final int SINGLE_SPACE = 1;\\n    private LineData lineData;\\n    private int maxWidth;\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        this.maxWidth = maxWidth;\\n        lineData = new LineData(0, words);\\n        List<String> fullyJustifiedText = new ArrayList<>();\\n\\n        for (int i = 1; i < words.length; ++i) {\\n\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n                continue;\\n            }\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = new LineData(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = new LineData(i, words);\\n        }\\n\\n        if (lineData.textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\n    private void createLine(List<String> fullyJustifiedText, String[] words, boolean isLastLine) {\\n\\n        int totalSpaceInLine = maxWidth - lineData.textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData.endIndexWords - lineData.startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        StringBuilder line = new StringBuilder();\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData.startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.add(line.toString());\\n            return;\\n        }\\n\\n        while (lineData.startIndexWords < lineData.endIndexWords) {\\n            line.append(words[lineData.startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData.startIndexWords;\\n        }\\n        line.append(words[lineData.endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.add(line.toString());\\n    }\\n\\n    private void appendSpaceToLine(int spacesToAppend, StringBuilder line) {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function (words, maxWidth) {\\n    const SINGLE_SPACE = 1;\\n    this.maxWidth = maxWidth;\\n    this.lineData = new LineData(0, words);\\n    const fullyJustifiedText = [];\\n\\n    for (let i = 1; i < words.length; ++i) {\\n\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length < maxWidth) {\\n            this.lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n            continue;\\n        }\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length === maxWidth) {\\n            lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n\\n            createLine(fullyJustifiedText, words, false);\\n            this.lineData = new LineData(++i, words);\\n            continue;\\n        }\\n        createLine(fullyJustifiedText, words, false);\\n        this.lineData = new LineData(i, words);\\n    }\\n\\n    if (this.lineData.textLength > 0) {\\n        createLine(fullyJustifiedText, words, true);\\n    }\\n    return fullyJustifiedText;\\n};\\n\\nclass LineData {\\n\\n    startIndexWords = 0;\\n    endIndexWords = 0;\\n    textLength = 0;\\n    singleSapcesBetweenWordsLength = 0;\\n\\n    /**\\n     * @param {number} index\\n     * @param {string[]} words\\n     */\\n    constructor(index, words) {\\n        if (index < words.length) {\\n            this.startIndexWords = index;\\n            this.endIndexWords = index;\\n            this.textLength = words[index].length;\\n            this.singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n}\\n\\n/**\\n * @param {string[]} fullyJustifiedText\\n * @param {string[]} words \\n * @param {boolean} isLastLine\\n * @return {void}\\n */\\nfunction createLine(fullyJustifiedText, words, isLastLine) {\\n\\n    let totalSpaceInLine = this.maxWidth - this.lineData.textLength;\\n    let spaceBetweenWordsWithoutRemainder = 0;\\n    let totalSpaceRemainder = 0;\\n    let spaceAfterLastWordInLastLine = 0;\\n    let numberOfWords = this.lineData.endIndexWords - this.lineData.startIndexWords + 1;\\n\\n    if (!isLastLine) {\\n        spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? Math.floor(totalSpaceInLine / (numberOfWords - 1)) : totalSpaceInLine;\\n        totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n    } else {\\n        spaceBetweenWordsWithoutRemainder = 1;\\n        spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n    }\\n\\n    let line = [];\\n\\n    if (numberOfWords === 1 && !isLastLine) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n        fullyJustifiedText.push(line.join(\\'\\'));\\n        return;\\n    }\\n\\n    while (this.lineData.startIndexWords < this.lineData.endIndexWords) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        let spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n        appendSpaceToLine(spaceBetweenWords, line);\\n        ++this.lineData.startIndexWords;\\n    }\\n    line.push(words[this.lineData.endIndexWords]);\\n    appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n    fullyJustifiedText.push(line.join(\\'\\'));\\n}\\n\\n/**\\n * @param {number} spacesToAppend\\n * @param {string[]} line \\n * @return {void}\\n */\\nfunction appendSpaceToLine(spacesToAppend, line) {\\n    while (spacesToAppend-- > 0) {\\n        line.push(\" \");\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <string>\\n#include <memory>\\n#include <vector>\\nusing namespace std;\\n\\nstruct LineData {\\n    int startIndexWords = 0;\\n    int endIndexWords = 0;\\n    int textLength = 0;\\n    int singleSapcesBetweenWordsLength = 0;\\n\\n    LineData() = default;\\n\\n    LineData(int index, const vector<string>& words) {\\n        if (index < words.size()) {\\n            startIndexWords = index;\\n            endIndexWords = index;\\n            textLength = words[index].length();\\n            singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\n    inline static const int SINGLE_SPACE = 1;\\n    unique_ptr<LineData> lineData;\\n    size_t maxWidth;\\n\\npublic:\\n    vector<string> fullJustify(const vector<string>& words, int maxWidth) {\\n        this->maxWidth = maxWidth;\\n        lineData = make_unique<LineData>(0, words);\\n        vector<string> fullyJustifiedText;\\n\\n        for (int i = 1; i < words.size(); ++i) {\\n\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n                continue;\\n            }\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = make_unique<LineData>(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = make_unique<LineData>(i, words);\\n        }\\n\\n        if (lineData->textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\nprivate:\\n    void createLine(vector<string>& fullyJustifiedText, const vector<string>& words, bool isLastLine) const {\\n\\n        int totalSpaceInLine = maxWidth - lineData->textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData->endIndexWords - lineData->startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        string line;\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData->startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.push_back(line);\\n            return;\\n        }\\n\\n        while (lineData->startIndexWords < lineData->endIndexWords) {\\n            line.append(words[lineData->startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData->startIndexWords;\\n        }\\n        line.append(words[lineData->endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.push_back(line);\\n    }\\n\\n    void appendSpaceToLine(int spacesToAppend, string& line) const {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\npublic class Solution {\\n\\n    private class LineData {\\n\\n        int startIndexWords;\\n        int endIndexWords;\\n        int textLength;\\n        int singleSapcesBetweenWordsLength;\\n\\n        LineData(int index, String[] words) {\\n            if (index < words.length) {\\n                startIndexWords = index;\\n                endIndexWords = index;\\n                textLength = words[index].length();\\n                singleSapcesBetweenWordsLength = 0;\\n            }\\n        }\\n    }\\n\\n    private static final int SINGLE_SPACE = 1;\\n    private LineData lineData;\\n    private int maxWidth;\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        this.maxWidth = maxWidth;\\n        lineData = new LineData(0, words);\\n        List<String> fullyJustifiedText = new ArrayList<>();\\n\\n        for (int i = 1; i < words.length; ++i) {\\n\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n                continue;\\n            }\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = new LineData(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = new LineData(i, words);\\n        }\\n\\n        if (lineData.textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\n    private void createLine(List<String> fullyJustifiedText, String[] words, boolean isLastLine) {\\n\\n        int totalSpaceInLine = maxWidth - lineData.textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData.endIndexWords - lineData.startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        StringBuilder line = new StringBuilder();\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData.startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.add(line.toString());\\n            return;\\n        }\\n\\n        while (lineData.startIndexWords < lineData.endIndexWords) {\\n            line.append(words[lineData.startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData.startIndexWords;\\n        }\\n        line.append(words[lineData.endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.add(line.toString());\\n    }\\n\\n    private void appendSpaceToLine(int spacesToAppend, StringBuilder line) {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function (words, maxWidth) {\\n    const SINGLE_SPACE = 1;\\n    this.maxWidth = maxWidth;\\n    this.lineData = new LineData(0, words);\\n    const fullyJustifiedText = [];\\n\\n    for (let i = 1; i < words.length; ++i) {\\n\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length < maxWidth) {\\n            this.lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n            continue;\\n        }\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length === maxWidth) {\\n            lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n\\n            createLine(fullyJustifiedText, words, false);\\n            this.lineData = new LineData(++i, words);\\n            continue;\\n        }\\n        createLine(fullyJustifiedText, words, false);\\n        this.lineData = new LineData(i, words);\\n    }\\n\\n    if (this.lineData.textLength > 0) {\\n        createLine(fullyJustifiedText, words, true);\\n    }\\n    return fullyJustifiedText;\\n};\\n\\nclass LineData {\\n\\n    startIndexWords = 0;\\n    endIndexWords = 0;\\n    textLength = 0;\\n    singleSapcesBetweenWordsLength = 0;\\n\\n    /**\\n     * @param {number} index\\n     * @param {string[]} words\\n     */\\n    constructor(index, words) {\\n        if (index < words.length) {\\n            this.startIndexWords = index;\\n            this.endIndexWords = index;\\n            this.textLength = words[index].length;\\n            this.singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n}\\n\\n/**\\n * @param {string[]} fullyJustifiedText\\n * @param {string[]} words \\n * @param {boolean} isLastLine\\n * @return {void}\\n */\\nfunction createLine(fullyJustifiedText, words, isLastLine) {\\n\\n    let totalSpaceInLine = this.maxWidth - this.lineData.textLength;\\n    let spaceBetweenWordsWithoutRemainder = 0;\\n    let totalSpaceRemainder = 0;\\n    let spaceAfterLastWordInLastLine = 0;\\n    let numberOfWords = this.lineData.endIndexWords - this.lineData.startIndexWords + 1;\\n\\n    if (!isLastLine) {\\n        spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? Math.floor(totalSpaceInLine / (numberOfWords - 1)) : totalSpaceInLine;\\n        totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n    } else {\\n        spaceBetweenWordsWithoutRemainder = 1;\\n        spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n    }\\n\\n    let line = [];\\n\\n    if (numberOfWords === 1 && !isLastLine) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n        fullyJustifiedText.push(line.join(\\'\\'));\\n        return;\\n    }\\n\\n    while (this.lineData.startIndexWords < this.lineData.endIndexWords) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        let spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n        appendSpaceToLine(spaceBetweenWords, line);\\n        ++this.lineData.startIndexWords;\\n    }\\n    line.push(words[this.lineData.endIndexWords]);\\n    appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n    fullyJustifiedText.push(line.join(\\'\\'));\\n}\\n\\n/**\\n * @param {number} spacesToAppend\\n * @param {string[]} line \\n * @return {void}\\n */\\nfunction appendSpaceToLine(spacesToAppend, line) {\\n    while (spacesToAppend-- > 0) {\\n        line.push(\" \");\\n    }\\n}\\n```\n```\\n#include <string>\\n#include <memory>\\n#include <vector>\\nusing namespace std;\\n\\nstruct LineData {\\n    int startIndexWords = 0;\\n    int endIndexWords = 0;\\n    int textLength = 0;\\n    int singleSapcesBetweenWordsLength = 0;\\n\\n    LineData() = default;\\n\\n    LineData(int index, const vector<string>& words) {\\n        if (index < words.size()) {\\n            startIndexWords = index;\\n            endIndexWords = index;\\n            textLength = words[index].length();\\n            singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\n    inline static const int SINGLE_SPACE = 1;\\n    unique_ptr<LineData> lineData;\\n    size_t maxWidth;\\n\\npublic:\\n    vector<string> fullJustify(const vector<string>& words, int maxWidth) {\\n        this->maxWidth = maxWidth;\\n        lineData = make_unique<LineData>(0, words);\\n        vector<string> fullyJustifiedText;\\n\\n        for (int i = 1; i < words.size(); ++i) {\\n\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n                continue;\\n            }\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = make_unique<LineData>(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = make_unique<LineData>(i, words);\\n        }\\n\\n        if (lineData->textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\nprivate:\\n    void createLine(vector<string>& fullyJustifiedText, const vector<string>& words, bool isLastLine) const {\\n\\n        int totalSpaceInLine = maxWidth - lineData->textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData->endIndexWords - lineData->startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        string line;\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData->startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.push_back(line);\\n            return;\\n        }\\n\\n        while (lineData->startIndexWords < lineData->endIndexWords) {\\n            line.append(words[lineData->startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData->startIndexWords;\\n        }\\n        line.append(words[lineData->endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.push_back(line);\\n    }\\n\\n    void appendSpaceToLine(int spacesToAppend, string& line) const {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2526012,
                "title": "c-fast-and-brief-solution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        for (int i = 0, j;i < words.size();) {\\n            int len = -1; // remove the first space\\n            for (j = i;j < words.size() && len + words[j].length() + 1 <= maxWidth;j++) {\\n                len += (words[j].length() + 1); // add the space and the word\\n            }\\n            string line = words[i++]; // get the first word\\n            int num_words = j - i; // number of words\\n            int num_space = maxWidth - len; // number of spaces (exclude the single space above)\\n            int extra = (num_words > 0) ? num_space%num_words : 0; // extra spaces\\n            for (;i < j;i++) {\\n                int space = (j == words.size()) ? 0 : // if last line, no space needed\\n                    (num_space/num_words + (extra-- > 0)); // else append average, then the extra\\n                line += string(space+1, \\' \\') + words[i];\\n            }\\n            line += string(maxWidth - line.length(), \\' \\'); // add the remaining\\n            output.push_back(line);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        for (int i = 0, j;i < words.size();) {\\n            int len = -1; // remove the first space\\n            for (j = i;j < words.size() && len + words[j].length() + 1 <= maxWidth;j++) {\\n                len += (words[j].length() + 1); // add the space and the word\\n            }\\n            string line = words[i++]; // get the first word\\n            int num_words = j - i; // number of words\\n            int num_space = maxWidth - len; // number of spaces (exclude the single space above)\\n            int extra = (num_words > 0) ? num_space%num_words : 0; // extra spaces\\n            for (;i < j;i++) {\\n                int space = (j == words.size()) ? 0 : // if last line, no space needed\\n                    (num_space/num_words + (extra-- > 0)); // else append average, then the extra\\n                line += string(space+1, \\' \\') + words[i];\\n            }\\n            line += string(maxWidth - line.length(), \\' \\'); // add the remaining\\n            output.push_back(line);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468109,
                "title": "easy-to-understand-python-solution-by-intution",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Initilize three varaibles as we form line-by-line\\n        current_line_length = 0\\n        current_line_words = []\\n        ans = []\\n        for word in words: #-----> O(n)\\n            word_length = len(word)\\n            \"\"\"For each word, we consider the space after that word also\\n                We check if current line length exceeds the maxiWidth if this word is added or not\"\"\"\\n            if current_line_length+word_length+1 <= maxWidth or (current_line_length+word_length == maxWidth):\\n                \"\"\"\\n                Append the word to current line words\\n                \"\"\"\\n                current_line_words.append(word)\\n                current_line_length += word_length+1\\n            else:\\n                if len(current_line_words) == 1:\\n                    \"\"\"\\n                    If there is only word for this line, that word should be left-justified\\n                    \"\"\"\\n                    characters = len(current_line_words[0])\\n                    spaces = maxWidth-characters\\n                    ans.append(\"\".join(current_line_words+([\\' \\']*spaces)))\\n                else:\\n                    \"\"\"\\n                    If there are multiple words for this line\\n                    \"\"\"\\n                    characters = current_line_length-len(current_line_words)\\n                    spaces = maxWidth-characters\\n                    distribution_spaces = spaces//(len(current_line_words)-1)\\n                    if not spaces%(len(current_line_words)-1):\\n                        \"\"\"\\n                        If the spaces divide evenly between words\\n                        \"\"\"\\n                        spaces = \"\".join([\\' \\']*distribution_spaces)\\n                        ans.append(spaces.join(current_line_words))\\n                    else:\\n                        \"\"\"\\n                        If spaces does not divide evenly with words\\n                        \"\"\"\\n                        extras = spaces%(len(current_line_words)-1)\\n                        temp = \"\"\\n                        for i in range(len(current_line_words)-1):\\n                            temp += current_line_words[i]\\n                            if extras:\\n                                temp += \"\".join(([\\' \\']*distribution_spaces)+[\\' \\'])\\n                                extras -= 1\\n                            else:\\n                                temp += \"\".join(([\\' \\'] * distribution_spaces))\\n                        temp += current_line_words[-1]\\n                        ans.append(temp)\\n                \"\"\"\\n                This is the last line and should be justified evenly\\n                \"\"\"\\n                current_line_length = len(word)+1\\n                current_line_words.clear()\\n                current_line_words.append(word)\\n        temp = \" \".join(current_line_words)\\n        temp += \"\".join([\\' \\']*(maxWidth-len(temp)))\\n        ans.append(temp)\\n        return ans\\n```\\n\\nPlease vote this solution if you feel its helpful",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Initilize three varaibles as we form line-by-line\\n        current_line_length = 0\\n        current_line_words = []\\n        ans = []\\n        for word in words: #-----> O(n)\\n            word_length = len(word)\\n            \"\"\"For each word, we consider the space after that word also\\n                We check if current line length exceeds the maxiWidth if this word is added or not\"\"\"\\n            if current_line_length+word_length+1 <= maxWidth or (current_line_length+word_length == maxWidth):\\n                \"\"\"\\n                Append the word to current line words\\n                \"\"\"\\n                current_line_words.append(word)\\n                current_line_length += word_length+1\\n            else:\\n                if len(current_line_words) == 1:\\n                    \"\"\"\\n                    If there is only word for this line, that word should be left-justified\\n                    \"\"\"\\n                    characters = len(current_line_words[0])\\n                    spaces = maxWidth-characters\\n                    ans.append(\"\".join(current_line_words+([\\' \\']*spaces)))\\n                else:\\n                    \"\"\"\\n                    If there are multiple words for this line\\n                    \"\"\"\\n                    characters = current_line_length-len(current_line_words)\\n                    spaces = maxWidth-characters\\n                    distribution_spaces = spaces//(len(current_line_words)-1)\\n                    if not spaces%(len(current_line_words)-1):\\n                        \"\"\"\\n                        If the spaces divide evenly between words\\n                        \"\"\"\\n                        spaces = \"\".join([\\' \\']*distribution_spaces)\\n                        ans.append(spaces.join(current_line_words))\\n                    else:\\n                        \"\"\"\\n                        If spaces does not divide evenly with words\\n                        \"\"\"\\n                        extras = spaces%(len(current_line_words)-1)\\n                        temp = \"\"\\n                        for i in range(len(current_line_words)-1):\\n                            temp += current_line_words[i]\\n                            if extras:\\n                                temp += \"\".join(([\\' \\']*distribution_spaces)+[\\' \\'])\\n                                extras -= 1\\n                            else:\\n                                temp += \"\".join(([\\' \\'] * distribution_spaces))\\n                        temp += current_line_words[-1]\\n                        ans.append(temp)\\n                \"\"\"\\n                This is the last line and should be justified evenly\\n                \"\"\"\\n                current_line_length = len(word)+1\\n                current_line_words.clear()\\n                current_line_words.append(word)\\n        temp = \" \".join(current_line_words)\\n        temp += \"\".join([\\' \\']*(maxWidth-len(temp)))\\n        ans.append(temp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392508,
                "title": "easy-understanding-java-solution",
                "content": "to further understand, please check the below link\\nhttps://www.youtube.com/watch?v=GqXlEbFVTXY\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int i=0, n=words.length;\\n        while(i<n) {\\n            int j=i+1;\\n            int lineLength=words[i].length();\\n            while(j<n && (lineLength+words[j].length()+(j-i-1)<maxWidth)) {\\n                lineLength+=words[j].length();\\n                j++;\\n            }\\n            int diff=maxWidth-lineLength;\\n            int noOfWords=j-i;\\n            if(noOfWords==1 || j>=n)\\n                result.add(leftJustify(words,diff,i,j));\\n            else\\n                result.add(middleJustify(words,diff,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++) {\\n            sb.append(\" \"+words[k]);\\n        }\\n        sb.append(\" \".repeat(spacesOnRight));\\n        return sb.toString();\\n    }\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesNeeded=j-i-1;\\n        int spaces=diff/spacesNeeded;\\n        int extraSpaces=diff%spacesNeeded;\\n        for(int k=i+1;k<j;k++) {\\n            int spacesToApply=spaces+(extraSpaces-->0?1:0);\\n            sb.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int i=0, n=words.length;\\n        while(i<n) {\\n            int j=i+1;\\n            int lineLength=words[i].length();\\n            while(j<n && (lineLength+words[j].length()+(j-i-1)<maxWidth)) {\\n                lineLength+=words[j].length();\\n                j++;\\n            }\\n            int diff=maxWidth-lineLength;\\n            int noOfWords=j-i;\\n            if(noOfWords==1 || j>=n)\\n                result.add(leftJustify(words,diff,i,j));\\n            else\\n                result.add(middleJustify(words,diff,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++) {\\n            sb.append(\" \"+words[k]);\\n        }\\n        sb.append(\" \".repeat(spacesOnRight));\\n        return sb.toString();\\n    }\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesNeeded=j-i-1;\\n        int spaces=diff/spacesNeeded;\\n        int extraSpaces=diff%spacesNeeded;\\n        for(int k=i+1;k<j;k++) {\\n            int spacesToApply=spaces+(extraSpaces-->0?1:0);\\n            sb.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376795,
                "title": "simple-js-solution-w-comments",
                "content": "```\\n/**\\n * *Time: O(N^2)\\n * *Space: O(N)\\n */\\n// Runtime: 89 ms, faster than 45.91% of JavaScript online submissions for Text Justification.\\n// Memory Usage: 42 MB, less than 58.01% of JavaScript online submissions for Text Justification.\\nconst fullJustify = (words, maxWidth) => {\\n\\tconst justifyLine = (line, width) => {\\n\\t\\t// if single word, it\\'s left justified, add spaces to the end\\n\\t\\tif (line.length === 1) {\\n\\t\\t\\tlet word = line[0];\\n\\n\\t\\t\\tword += \\' \\'.repeat(width);\\n\\t\\t\\treturn word;\\n\\n\\t\\t}\\n\\n\\t\\tconst end = line.length - 1; // all words except the last word should have spaced added to their string\\n\\t\\tlet i = 0;\\n\\n\\t\\t// distribute spaces evenly among the words\\n\\t\\twhile (width-- > 0) {\\n\\t\\t\\tline[i++] += \\' \\';\\n\\t\\t\\ti = i % end; // loop back to start to avoid adding space to the final word\\n\\t\\t}\\n\\n\\t\\treturn line.join(\\'\\');\\n\\t};\\n\\n\\tconst output = [];\\n\\tlet line = [];\\n\\tlet width = maxWidth; // spaces left\\n\\n\\t// greedily add words to each line\\n\\t// when current word cannot be added\\n\\t// justify and add current line and start a new line\\n\\tfor (const word of words) {\\n\\t\\t// if word fits: add word and update spaces left\\n\\t\\tif (word.length <= width - line.length) {\\n\\t\\t\\tline.push(word); // word fits: add word to current line\\n\\t\\t\\twidth -= word.length; // subtract length of current word and update spaces left\\n\\t\\t} else {\\n\\t\\t\\t// not enough spaces, word does not fit: justify current line and add to output\\n\\t\\t\\tconst justified = justifyLine(line, width);\\n\\n\\t\\t\\toutput.push(justified); // add justified line to output\\n\\t\\t\\tline = [word]; // start a new line with current word\\n\\t\\t\\twidth = maxWidth - word.length; // reset current line width\\n\\t\\t}\\n\\t}\\n\\n\\t// handle last line: justify words to the left and add spaces to the right\\n\\tif (line.length) {\\n\\t\\tlet lastLine = line.join(\\' \\'); // convert last line into string\\n\\t\\tconst spacesLeft = maxWidth - lastLine.length; // spaces left for last line\\n\\n\\t\\tlastLine += \\' \\'.repeat(spacesLeft);\\n\\t\\toutput.push(lastLine);\\n\\t}\\n\\n\\treturn output;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * *Time: O(N^2)\\n * *Space: O(N)\\n */\\n// Runtime: 89 ms, faster than 45.91% of JavaScript online submissions for Text Justification.\\n// Memory Usage: 42 MB, less than 58.01% of JavaScript online submissions for Text Justification.\\nconst fullJustify = (words, maxWidth) => {\\n\\tconst justifyLine = (line, width) => {\\n\\t\\t// if single word, it\\'s left justified, add spaces to the end\\n\\t\\tif (line.length === 1) {\\n\\t\\t\\tlet word = line[0];\\n\\n\\t\\t\\tword += \\' \\'.repeat(width);\\n\\t\\t\\treturn word;\\n\\n\\t\\t}\\n\\n\\t\\tconst end = line.length - 1; // all words except the last word should have spaced added to their string\\n\\t\\tlet i = 0;\\n\\n\\t\\t// distribute spaces evenly among the words\\n\\t\\twhile (width-- > 0) {\\n\\t\\t\\tline[i++] += \\' \\';\\n\\t\\t\\ti = i % end; // loop back to start to avoid adding space to the final word\\n\\t\\t}\\n\\n\\t\\treturn line.join(\\'\\');\\n\\t};\\n\\n\\tconst output = [];\\n\\tlet line = [];\\n\\tlet width = maxWidth; // spaces left\\n\\n\\t// greedily add words to each line\\n\\t// when current word cannot be added\\n\\t// justify and add current line and start a new line\\n\\tfor (const word of words) {\\n\\t\\t// if word fits: add word and update spaces left\\n\\t\\tif (word.length <= width - line.length) {\\n\\t\\t\\tline.push(word); // word fits: add word to current line\\n\\t\\t\\twidth -= word.length; // subtract length of current word and update spaces left\\n\\t\\t} else {\\n\\t\\t\\t// not enough spaces, word does not fit: justify current line and add to output\\n\\t\\t\\tconst justified = justifyLine(line, width);\\n\\n\\t\\t\\toutput.push(justified); // add justified line to output\\n\\t\\t\\tline = [word]; // start a new line with current word\\n\\t\\t\\twidth = maxWidth - word.length; // reset current line width\\n\\t\\t}\\n\\t}\\n\\n\\t// handle last line: justify words to the left and add spaces to the right\\n\\tif (line.length) {\\n\\t\\tlet lastLine = line.join(\\' \\'); // convert last line into string\\n\\t\\tconst spacesLeft = maxWidth - lastLine.length; // spaces left for last line\\n\\n\\t\\tlastLine += \\' \\'.repeat(spacesLeft);\\n\\t\\toutput.push(lastLine);\\n\\t}\\n\\n\\treturn output;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2252192,
                "title": "simple-java-solution-0ms",
                "content": "\\n\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {        \\n        List<String> result = new ArrayList<>();\\n        int nextWordIndex = 0;\\n        while(nextWordIndex < words.length){\\n            int endIndex = wordsAllowed(words, nextWordIndex, maxWidth);\\n            result.add(createLine(words, nextWordIndex, endIndex, maxWidth));\\n            nextWordIndex = endIndex + 1;\\n        }\\n        return result;        \\n    }\\n        \\n    \\n    private int wordsAllowed(String[] words, int startIndex, int maxWidth){\\n        int spaceLeft = maxWidth;\\n        int endIndex = startIndex;\\n        spaceLeft -= words[endIndex].length();\\n        \\n        while(endIndex+1 < words.length && spaceLeft >= 1 + words[endIndex+1].length() ) {\\n            spaceLeft -= 1 + words[endIndex+1].length();\\n            endIndex++;\\n        }\\n        return endIndex;        \\n    }\\n    \\n    \\n    private String createLine(String[] words, int startIndex, int endIndex, int maxWidth){\\n        StringBuilder sb = new StringBuilder(maxWidth);        \\n        \\n        // Last Line or a single word line\\n        if (endIndex == words.length-1 || endIndex == startIndex) {\\n            for(int i = startIndex; i < endIndex ; i++){\\n                sb.append(words[i]);\\n                sb.append(\\' \\');\\n            }\\n            sb.append(words[endIndex]);\\n            for(int i = sb.length() + 1; i <= maxWidth; i++) sb.append(\\' \\');\\n        }\\n                \\n        else{\\n            int spaceSlots = endIndex - startIndex;\\n            int totalSpacesRequired = maxWidth;\\n            \\n            for(int i =startIndex; i<= endIndex; i++){\\n                totalSpacesRequired -= words[i].length();\\n            }\\n           \\n            String commonSpace = \" \".repeat(totalSpacesRequired / spaceSlots);\\n            int remainder = totalSpacesRequired % spaceSlots;\\n            \\n            int nextSpaceSlot = 1;\\n            for(int i = startIndex; i< endIndex; i++){\\n                sb.append(words[i]);\\n                sb.append(commonSpace);\\n                if (nextSpaceSlot++<= remainder) sb.append(\\' \\');               \\n            }   \\n            sb.append(words[endIndex]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {        \\n        List<String> result = new ArrayList<>();\\n        int nextWordIndex = 0;\\n        while(nextWordIndex < words.length){\\n            int endIndex = wordsAllowed(words, nextWordIndex, maxWidth);\\n            result.add(createLine(words, nextWordIndex, endIndex, maxWidth));\\n            nextWordIndex = endIndex + 1;\\n        }\\n        return result;        \\n    }\\n        \\n    \\n    private int wordsAllowed(String[] words, int startIndex, int maxWidth){\\n        int spaceLeft = maxWidth;\\n        int endIndex = startIndex;\\n        spaceLeft -= words[endIndex].length();\\n        \\n        while(endIndex+1 < words.length && spaceLeft >= 1 + words[endIndex+1].length() ) {\\n            spaceLeft -= 1 + words[endIndex+1].length();\\n            endIndex++;\\n        }\\n        return endIndex;        \\n    }\\n    \\n    \\n    private String createLine(String[] words, int startIndex, int endIndex, int maxWidth){\\n        StringBuilder sb = new StringBuilder(maxWidth);        \\n        \\n        // Last Line or a single word line\\n        if (endIndex == words.length-1 || endIndex == startIndex) {\\n            for(int i = startIndex; i < endIndex ; i++){\\n                sb.append(words[i]);\\n                sb.append(\\' \\');\\n            }\\n            sb.append(words[endIndex]);\\n            for(int i = sb.length() + 1; i <= maxWidth; i++) sb.append(\\' \\');\\n        }\\n                \\n        else{\\n            int spaceSlots = endIndex - startIndex;\\n            int totalSpacesRequired = maxWidth;\\n            \\n            for(int i =startIndex; i<= endIndex; i++){\\n                totalSpacesRequired -= words[i].length();\\n            }\\n           \\n            String commonSpace = \" \".repeat(totalSpacesRequired / spaceSlots);\\n            int remainder = totalSpacesRequired % spaceSlots;\\n            \\n            int nextSpaceSlot = 1;\\n            for(int i = startIndex; i< endIndex; i++){\\n                sb.append(words[i]);\\n                sb.append(commonSpace);\\n                if (nextSpaceSlot++<= remainder) sb.append(\\' \\');               \\n            }   \\n            sb.append(words[endIndex]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249331,
                "title": "0ms-with-detailed-comments",
                "content": "```\\nclass Solution {\\n  \\n  public List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;       // index of word in words array\\n        int wordsLen = 0;    // sum of all words that can be put in same line\\n        int spaces = 0;      // spaces that need to be filled\\n        \\n        while (index < words.length) { // check if the index is less than the length ...\\n            if ((tempLen + words[index].length()) <= maxLen) { // making sure that the current temp len is less than \\n                // max length ... so keep adding words as long as the length is less than max length ...\\n                // and this is the greedy algorithm ...\\n                tempLen += words[index].length() + 1; // increase the temp length by adding the current word ...\\n                tempList.add(words[index++]); // increase the index post addition to the temp list ...\\n            } else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size(); // temp length has the additional +1\\'s ... line 15 ...\\n                spaces = maxLen - wordsLen; // so this is the total number of spaces ... i.e., maxlen <minus> word len ...\\n                if(tempList.size() == 1) { // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0)); // add the first and only word ...\\n                    for(int i = 0; i < spaces; i++) { // fill the rest with spaces ...\\n                        sb.append(\" \"); // append with spaces ...\\n                    }\\n                    ans.add(sb.toString()); // add this string to the final answer\\n                } else if (tempList.size() > 1) { // there\\'s many words in cur line, do the evenly spaceing\\n                    \\n                    // you see tempList - 1 because ... lets say, you have 3 words\\n                    // w1 space1 w2 space2 w3\\n                    // as you can see ... spaces will be 1 less than the words ...\\n                    // \\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) { // if 3 words ...\\n                        // you are only going up to 2 ... and adding the last in line 48 ...\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){ // here we are adding the extra spaces\\n                            // because the question says \\n                            // If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \"); // and here we are adding the spaces ...\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1)); // line 48, adding the last word ...\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear(); // clear the temp list ...\\n                tempLen = 0; // set the temp length back to 0 ...\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) { // the -1 is because ... we want to keep that last space ...\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++) {\\n          sb.append(\" \");          \\n        }\\n\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  \\n  public List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;       // index of word in words array\\n        int wordsLen = 0;    // sum of all words that can be put in same line\\n        int spaces = 0;      // spaces that need to be filled\\n        \\n        while (index < words.length) { // check if the index is less than the length ...\\n            if ((tempLen + words[index].length()) <= maxLen) { // making sure that the current temp len is less than \\n                // max length ... so keep adding words as long as the length is less than max length ...\\n                // and this is the greedy algorithm ...\\n                tempLen += words[index].length() + 1; // increase the temp length by adding the current word ...\\n                tempList.add(words[index++]); // increase the index post addition to the temp list ...\\n            } else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size(); // temp length has the additional +1\\'s ... line 15 ...\\n                spaces = maxLen - wordsLen; // so this is the total number of spaces ... i.e., maxlen <minus> word len ...\\n                if(tempList.size() == 1) { // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0)); // add the first and only word ...\\n                    for(int i = 0; i < spaces; i++) { // fill the rest with spaces ...\\n                        sb.append(\" \"); // append with spaces ...\\n                    }\\n                    ans.add(sb.toString()); // add this string to the final answer\\n                } else if (tempList.size() > 1) { // there\\'s many words in cur line, do the evenly spaceing\\n                    \\n                    // you see tempList - 1 because ... lets say, you have 3 words\\n                    // w1 space1 w2 space2 w3\\n                    // as you can see ... spaces will be 1 less than the words ...\\n                    // \\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) { // if 3 words ...\\n                        // you are only going up to 2 ... and adding the last in line 48 ...\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){ // here we are adding the extra spaces\\n                            // because the question says \\n                            // If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \"); // and here we are adding the spaces ...\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1)); // line 48, adding the last word ...\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear(); // clear the temp list ...\\n                tempLen = 0; // set the temp length back to 0 ...\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) { // the -1 is because ... we want to keep that last space ...\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++) {\\n          sb.append(\" \");          \\n        }\\n\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125624,
                "title": "c-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    //\\u5F88\\u6076\\u5FC3\\u7684\\u4E00\\u9053\\u9898\\u76EE\\uFF0C\\u5B9E\\u73B0\\u633A\\u96BE\\n    //\\u4E3B\\u8981\\u662F3\\u70B9\\n    //1. \\u9700\\u8981\\u5BF9\\u6BCF\\u4E2A\\u5355\\u8BCD\\u4E2D\\u95F4\\u586B\\u4E0A\\u975E\\u5E38\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\uFF0C\\u8FD9\\u4E2A\\u7528line[i % (gaps)].Append(\" \");\\u6765\\u89E3\\u51B3\\uFF0C\\u8FD9\\u91CC\\u7528line.Count-1\\u6765\\u5F97\\u5230\\u5355\\u8BCD\\u4E4B\\u95F4\\u7684gaps\\u9700\\u8981\\u591A\\u5C11,\\u7136\\u540E\\u901A\\u8FC7\\u4F59\\u6570\\u6765\\u6765\\u56DE\\u7ED9\\u5355\\u8BCD\\u4E2D\\u95F4\\u52A0\\u4E0A\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\n    //Ex This_is_an_ _ _\\n    //   \\u4E0A\\u9762\\u8FD9\\u4E2A\\u4F8B\\u5B50\\u6211\\u4EEC\\u53EF\\u4EE5\\u770B\\u5230\\u4E00\\u4E2Aline\\u4E0A\\u603B\\u5171\\u67093\\u4E2A\\u5355\\u8BCD\\u7136\\u540E\\u9700\\u89812\\u4E2Agaps,\\u5982\\u4F55\\u628A\\u8FD9\\u4E9Bgap\\u5747\\u5300\\u5206\\u914D\\u7A7A\\u683C\\u5462\\uFF0C\\u90A3\\u5C31\\u662Fline[i%gaps].Append(\" \")\\n    //2. \\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u65B0\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u5355\\u8BCD\\u4E4B\\u95F4\\u9700\\u8981\\u9884\\u7559\\u7684\\u7A7A\\u683C\\u5982\\u679C\\u5927\\u4E8EmaxWidth\\u90A3\\u5C31\\u9700\\u8981\\u5228\\u53BB\\u65B0\\u5355\\u8BCD\\u5BF9\\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u4E2Dgaps\\u505A\\u7A7A\\u683C\\u5747\\u8861\\n    //3. \\u6700\\u540E\\u4E00\\u884C\\u5904\\u7406\\u7684\\u65F6\\u5019\\u76F4\\u63A5\\u7528string.Join(\" \", line)\\u628A\\u5355\\u8BCD\\u9694\\u5F00\\uFF0C\\u7136\\u540E\\u7528string.PadRight(maxWidth)\\u628A\\u5355\\u8BCD\\u505A\\u5DE6\\u5BF9\\u9F50\\u4E5F\\u5C31\\u662F\\u5F80\\u53F3\\u586B\\u5145\\u8DB3\\u591F\\u7684\\u7A7A\\u683C\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> res = new List<string>();\\n        List<StringBuilder> wordsEachLine = new List<StringBuilder>();\\n        int totalCharsEachLine = 0;\\n        int wordIndex = 0;\\n        while(wordIndex < words.Length)\\n        {\\n            string word = words[wordIndex];\\n            wordsEachLine.Add(new StringBuilder(word));\\n            totalCharsEachLine+=word.Length;\\n            //\\u5148\\u8BA1\\u7B97\\u5F53\\u524Dsingle gap\\u9700\\u8981\\u591A\\u5C11\\u4E2A\\n            // Ex This_is_an  \\u8FD9\\u91CC\\u5C31\\u9700\\u89812\\u4E2A\\n            int gaps = wordsEachLine.Count - 1;\\n            \\n            //\\u5982\\u679C\\u73B0\\u5728line\\u4E0A\\u5F53\\u524D\\u6240\\u5B58\\u5728\\u7684word\\u52A0\\u4E0A\\u4E0B\\u4E00\\u4E2Aword\\u548C\\u9700\\u8981\\u7684singleGaps\\u6570\\u91CF\\u518D\\u52A0\\u4E0A\\u989D\\u5916\\u76841\\uFF08\\u8FD9\\u91CC\\u56E0\\u4E3A\\u591A\\u52A0\\u4E86\\u4E00\\u4E2Aword\\uFF09\\u957F\\u5EA6\\u5927\\u4E8EmaxWidth\\uFF0C\\n            //\\u6211\\u4EEC\\u5C31\\u9700\\u8981\\u5F80gaps\\u91CC\\u9762\\u6DFB\\u52A0\\u65B0\\u7684\\u7A7A\\u683C\\u6765\\u5747\\u8861gap\\u7684\\u7A7A\\u683C\\u6570\\u91CF\\n            if (wordIndex + 1 < words.Length && totalCharsEachLine + words[wordIndex+1].Length + gaps + 1 > maxWidth)\\n            {\\n                int restSpaces = maxWidth - totalCharsEachLine;\\n                for(int i = 0; i < restSpaces; i++)\\n                {\\n                    if (wordsEachLine.Count == 1)\\n                    {\\n                        wordsEachLine[0].Append(\" \");\\n                    }\\n                    else\\n                    {\\n                        wordsEachLine[i % gaps].Append(\" \");\\n                    }\\n                }\\n                \\n                res.Add(string.Join(\"\", wordsEachLine));\\n                wordsEachLine = new List<StringBuilder>();\\n                totalCharsEachLine = 0;\\n            }\\n            \\n            wordIndex++;\\n        }\\n        \\n        if (wordsEachLine.Count > 0)\\n        {\\n            string lastLine = string.Join(\" \", wordsEachLine);\\n            string lastLineRightpad = lastLine.PadRight(maxWidth);\\n            res.Add(lastLineRightpad);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    //\\u5F88\\u6076\\u5FC3\\u7684\\u4E00\\u9053\\u9898\\u76EE\\uFF0C\\u5B9E\\u73B0\\u633A\\u96BE\\n    //\\u4E3B\\u8981\\u662F3\\u70B9\\n    //1. \\u9700\\u8981\\u5BF9\\u6BCF\\u4E2A\\u5355\\u8BCD\\u4E2D\\u95F4\\u586B\\u4E0A\\u975E\\u5E38\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\uFF0C\\u8FD9\\u4E2A\\u7528line[i % (gaps)].Append(\" \");\\u6765\\u89E3\\u51B3\\uFF0C\\u8FD9\\u91CC\\u7528line.Count-1\\u6765\\u5F97\\u5230\\u5355\\u8BCD\\u4E4B\\u95F4\\u7684gaps\\u9700\\u8981\\u591A\\u5C11,\\u7136\\u540E\\u901A\\u8FC7\\u4F59\\u6570\\u6765\\u6765\\u56DE\\u7ED9\\u5355\\u8BCD\\u4E2D\\u95F4\\u52A0\\u4E0A\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\n    //Ex This_is_an_ _ _\\n    //   \\u4E0A\\u9762\\u8FD9\\u4E2A\\u4F8B\\u5B50\\u6211\\u4EEC\\u53EF\\u4EE5\\u770B\\u5230\\u4E00\\u4E2Aline\\u4E0A\\u603B\\u5171\\u67093\\u4E2A\\u5355\\u8BCD\\u7136\\u540E\\u9700\\u89812\\u4E2Agaps,\\u5982\\u4F55\\u628A\\u8FD9\\u4E9Bgap\\u5747\\u5300\\u5206\\u914D\\u7A7A\\u683C\\u5462\\uFF0C\\u90A3\\u5C31\\u662Fline[i%gaps].Append(\" \")\\n    //2. \\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u65B0\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u5355\\u8BCD\\u4E4B\\u95F4\\u9700\\u8981\\u9884\\u7559\\u7684\\u7A7A\\u683C\\u5982\\u679C\\u5927\\u4E8EmaxWidth\\u90A3\\u5C31\\u9700\\u8981\\u5228\\u53BB\\u65B0\\u5355\\u8BCD\\u5BF9\\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u4E2Dgaps\\u505A\\u7A7A\\u683C\\u5747\\u8861\\n    //3. \\u6700\\u540E\\u4E00\\u884C\\u5904\\u7406\\u7684\\u65F6\\u5019\\u76F4\\u63A5\\u7528string.Join(\" \", line)\\u628A\\u5355\\u8BCD\\u9694\\u5F00\\uFF0C\\u7136\\u540E\\u7528string.PadRight(maxWidth)\\u628A\\u5355\\u8BCD\\u505A\\u5DE6\\u5BF9\\u9F50\\u4E5F\\u5C31\\u662F\\u5F80\\u53F3\\u586B\\u5145\\u8DB3\\u591F\\u7684\\u7A7A\\u683C\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> res = new List<string>();\\n        List<StringBuilder> wordsEachLine = new List<StringBuilder>();\\n        int totalCharsEachLine = 0;\\n        int wordIndex = 0;\\n        while(wordIndex < words.Length)\\n        {\\n            string word = words[wordIndex];\\n            wordsEachLine.Add(new StringBuilder(word));\\n            totalCharsEachLine+=word.Length;\\n            //\\u5148\\u8BA1\\u7B97\\u5F53\\u524Dsingle gap\\u9700\\u8981\\u591A\\u5C11\\u4E2A\\n            // Ex This_is_an  \\u8FD9\\u91CC\\u5C31\\u9700\\u89812\\u4E2A\\n            int gaps = wordsEachLine.Count - 1;\\n            \\n            //\\u5982\\u679C\\u73B0\\u5728line\\u4E0A\\u5F53\\u524D\\u6240\\u5B58\\u5728\\u7684word\\u52A0\\u4E0A\\u4E0B\\u4E00\\u4E2Aword\\u548C\\u9700\\u8981\\u7684singleGaps\\u6570\\u91CF\\u518D\\u52A0\\u4E0A\\u989D\\u5916\\u76841\\uFF08\\u8FD9\\u91CC\\u56E0\\u4E3A\\u591A\\u52A0\\u4E86\\u4E00\\u4E2Aword\\uFF09\\u957F\\u5EA6\\u5927\\u4E8EmaxWidth\\uFF0C\\n            //\\u6211\\u4EEC\\u5C31\\u9700\\u8981\\u5F80gaps\\u91CC\\u9762\\u6DFB\\u52A0\\u65B0\\u7684\\u7A7A\\u683C\\u6765\\u5747\\u8861gap\\u7684\\u7A7A\\u683C\\u6570\\u91CF\\n            if (wordIndex + 1 < words.Length && totalCharsEachLine + words[wordIndex+1].Length + gaps + 1 > maxWidth)\\n            {\\n                int restSpaces = maxWidth - totalCharsEachLine;\\n                for(int i = 0; i < restSpaces; i++)\\n                {\\n                    if (wordsEachLine.Count == 1)\\n                    {\\n                        wordsEachLine[0].Append(\" \");\\n                    }\\n                    else\\n                    {\\n                        wordsEachLine[i % gaps].Append(\" \");\\n                    }\\n                }\\n                \\n                res.Add(string.Join(\"\", wordsEachLine));\\n                wordsEachLine = new List<StringBuilder>();\\n                totalCharsEachLine = 0;\\n            }\\n            \\n            wordIndex++;\\n        }\\n        \\n        if (wordsEachLine.Count > 0)\\n        {\\n            string lastLine = string.Join(\" \", wordsEachLine);\\n            string lastLineRightpad = lastLine.PadRight(maxWidth);\\n            res.Add(lastLineRightpad);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112533,
                "title": "cpp-with-proper-thinking-process-commented",
                "content": "First thing, text justification is very common in word processing tools like MSWord `(Ctrl + j)`.\\n\\n**We need to think on below points:**\\n\\n1. How do we know how many words would fit in each line?\\n2. Once we know the how many words would fit in current line, how do we divide the spaces? What if spaces are uneven? How do we handle such part?\\n3. How do we handle last line?\\n\\n**Lets think . . .** \\n\\nWe can add the length of the words as we go forward + we need to add 1 space at-least just after every word we encounter. We\\u2019ll stop as soon as we couldn\\u2019t fit any more word bounded by `maxWidth`.\\n\\n**We can use two pointers to do that. Previous pointer will mark the starting of the word and next pointer will mark the ending of the word for the current line. We also need a sum that keeps track of how many characters it has seen yet.**\\n\\nLet\\u2019s code the basic part\\n\\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n}\\n```\\n\\nAbove logic is wrong, we also need to add \\u201Cspace\\u201D while checking `<= maxWidth`. \\n\\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + 1 + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n}\\n```\\n\\nAbove logic is also wrong, we can\\u2019t add 1 for the first word of the current line. We need something that will make above code add 0 for the first time then 1 each time afterwards.\\n\\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nbool startWord = true; // true for first word for each new line**\\nwhile (endWordIndex < int(words.size())) {\\n    int tempCharCount = charsTillNow + int(words[endWordIndex].size());\\n    if (!startWord) tempCharCount++; // For space after if not the first word\\n    if (tempCharCount <= maxWidth) {\\n        charsTillNow += tempCharCount;\\n        endWordIndex++;\\n        startWord = false;\\n        continue;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n\\t\\t// means after this next time while loop will be executed that would be for new line\\n    startWord = true;\\n}\\n```\\n\\nNow, `charTillNow` will have all the valid chars count + 1 space b/w each word.\\n\\n**How many words?**  `wordCount = endWordIndex - startWordIndex`\\n\\n**How many spaces?** We must subtract the additional spaces we considered in `charsTillNow`. Those would be `wordCount-1`.\\n\\n`spaceCount = maxWidth - (charsTillNow - (wordCount-1))`\\n\\n**How much minimum space to allocate?**\\n\\n`minSpaceForEachWord = spaceCount / (wordCount-1)` \\u2014> Division by 0 is likely\\n\\n**What about any extra space left? Due to improper division of spaceCount and space locations**\\n\\n`extraSpace = spaceCount - (spaceLocations * minSpaceForEachWord)`\\n\\nWe\\u2019ll add these additional space from left to right as we go forward with each word of the current line. Note that `extraSpace` will be less than `minSpaceForEachWord` as its the remainder. so if we add 1 by 1 if its more than 0, we\\u2019ll run out before the last word. [as per problem constraint]\\n\\n**Let\\u2019s add these words bounded by [startWordIndex : endWordIndex)**\\n\\n```cpp\\nstring currentLine;\\n\\nwhile(startWordIndex < endWordIndex) {\\n    currentLine.append(words[startWordIndex]);\\n    // Now add space but do not add space for last word\\n    if (startWordIndex != endWordIndex - 1)\\n        currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n    startWordIndex++;\\n\\t\\textraSpace--; // even goes to negative, we really don\\'t care\\n}\\n```\\n\\nNote: if `extraSpace > 0` \\u2192 `int(extraspace>0)` will return 1 for `true`.\\n\\nFull code till now:\\n```\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int startWordIndex = 0;\\n        int endWordIndex = 0;\\n        int charsTillNow = 0;\\n        int wordCount, spaceLocations, spaceCount, minSpaceForEachWord, extraSpace;\\n        string currentLine;\\n\\n        bool startWord = true;\\n        while (endWordIndex < int(words.size())) {\\n            int tempCharCount = int(words[endWordIndex].size());\\n            if (!startWord) tempCharCount++; // For space\\n            if (tempCharCount + charsTillNow <= maxWidth) {\\n                charsTillNow += tempCharCount;\\n                endWordIndex++;\\n                startWord = false;\\n                continue;\\n            }\\n\\n            startWord = true;\\n            wordCount = endWordIndex - startWordIndex;\\n            spaceLocations = wordCount - 1; // we put space b/w each word so it will always be wordCount-1\\n            spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t// put the default value as full space count as we also need to handle if we found just one word\\n            // for one word, assign all spaceCount just after that word and there wouldn\\'t be any extraSpace thing if there is just one word\\n            minSpaceForEachWord = spaceCount;\\n            extraSpace = 0;\\n            if (wordCount > 1) { // if word is more than 1, then calculate properly\\n                minSpaceForEachWord = spaceCount / spaceLocations;\\n                extraSpace = spaceCount - (spaceLocations * minSpaceForEachWord);\\n            }\\n\\n\\t\\t\\t// Create current Line\\n            while (startWordIndex < endWordIndex) {\\n                currentLine.append(words[startWordIndex]);\\n                // Now add space but do not add space for last word\\n                if (startWordIndex != endWordIndex - 1)\\n                    currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n                else if (wordCount == 1) // if word length is 1, above condition will fail always, so in that case put all the spaces behind\\n                    currentLine.append(string(spaceCount, \\' \\'));\\n                startWordIndex++;\\n                extraSpace--; // even go to negative, we really don\\'t care\\n            }\\n            ans.push_back(currentLine);\\n            currentLine.clear();\\n            charsTillNow = 0;\\n        }\\n\\t\\t\\n\\t\\t// Above while loop breaks leaving us handle the last line separately\\n        // we\\'ll come here for last line. It has different rule\\n        wordCount = endWordIndex - startWordIndex;\\n        spaceLocations = wordCount - 1;\\n        spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n        while (startWordIndex < endWordIndex) {\\n            currentLine.append(words[startWordIndex]);\\n            // For last line, just add one space\\n            if (startWordIndex != endWordIndex - 1)\\n                currentLine.append(\" \");\\n            startWordIndex++;\\n        }\\n\\t\\t// append the remaining spaces [totalspace - how much we already filled (spaceLocations)]\\n        currentLine.append(string(spaceCount-spaceLocations, \\' \\'));\\n        ans.push_back(currentLine);\\n        \\n        return ans;\\n\\n    }\\n```\\n\\n\\nPS: Above code can be modularized but I didn\\'t want to break the flow of going through the code.\\nI have also one solution that\\'s a little modularized that uses similar logic.\\n[https://leetcode.com/submissions/detail/714605666/]\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n}\\n```\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + 1 + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n}\\n```\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nbool startWord = true; // true for first word for each new line**\\nwhile (endWordIndex < int(words.size())) {\\n    int tempCharCount = charsTillNow + int(words[endWordIndex].size());\\n    if (!startWord) tempCharCount++; // For space after if not the first word\\n    if (tempCharCount <= maxWidth) {\\n        charsTillNow += tempCharCount;\\n        endWordIndex++;\\n        startWord = false;\\n        continue;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n\\t\\t// means after this next time while loop will be executed that would be for new line\\n    startWord = true;\\n}\\n```\n```cpp\\nstring currentLine;\\n\\nwhile(startWordIndex < endWordIndex) {\\n    currentLine.append(words[startWordIndex]);\\n    // Now add space but do not add space for last word\\n    if (startWordIndex != endWordIndex - 1)\\n        currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n    startWordIndex++;\\n\\t\\textraSpace--; // even goes to negative, we really don\\'t care\\n}\\n```\n```\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int startWordIndex = 0;\\n        int endWordIndex = 0;\\n        int charsTillNow = 0;\\n        int wordCount, spaceLocations, spaceCount, minSpaceForEachWord, extraSpace;\\n        string currentLine;\\n\\n        bool startWord = true;\\n        while (endWordIndex < int(words.size())) {\\n            int tempCharCount = int(words[endWordIndex].size());\\n            if (!startWord) tempCharCount++; // For space\\n            if (tempCharCount + charsTillNow <= maxWidth) {\\n                charsTillNow += tempCharCount;\\n                endWordIndex++;\\n                startWord = false;\\n                continue;\\n            }\\n\\n            startWord = true;\\n            wordCount = endWordIndex - startWordIndex;\\n            spaceLocations = wordCount - 1; // we put space b/w each word so it will always be wordCount-1\\n            spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t// put the default value as full space count as we also need to handle if we found just one word\\n            // for one word, assign all spaceCount just after that word and there wouldn\\'t be any extraSpace thing if there is just one word\\n            minSpaceForEachWord = spaceCount;\\n            extraSpace = 0;\\n            if (wordCount > 1) { // if word is more than 1, then calculate properly\\n                minSpaceForEachWord = spaceCount / spaceLocations;\\n                extraSpace = spaceCount - (spaceLocations * minSpaceForEachWord);\\n            }\\n\\n\\t\\t\\t// Create current Line\\n            while (startWordIndex < endWordIndex) {\\n                currentLine.append(words[startWordIndex]);\\n                // Now add space but do not add space for last word\\n                if (startWordIndex != endWordIndex - 1)\\n                    currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n                else if (wordCount == 1) // if word length is 1, above condition will fail always, so in that case put all the spaces behind\\n                    currentLine.append(string(spaceCount, \\' \\'));\\n                startWordIndex++;\\n                extraSpace--; // even go to negative, we really don\\'t care\\n            }\\n            ans.push_back(currentLine);\\n            currentLine.clear();\\n            charsTillNow = 0;\\n        }\\n\\t\\t\\n\\t\\t// Above while loop breaks leaving us handle the last line separately\\n        // we\\'ll come here for last line. It has different rule\\n        wordCount = endWordIndex - startWordIndex;\\n        spaceLocations = wordCount - 1;\\n        spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n        while (startWordIndex < endWordIndex) {\\n            currentLine.append(words[startWordIndex]);\\n            // For last line, just add one space\\n            if (startWordIndex != endWordIndex - 1)\\n                currentLine.append(\" \");\\n            startWordIndex++;\\n        }\\n\\t\\t// append the remaining spaces [totalspace - how much we already filled (spaceLocations)]\\n        currentLine.append(string(spaceCount-spaceLocations, \\' \\'));\\n        ans.push_back(currentLine);\\n        \\n        return ans;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897672,
                "title": "simple-solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<String> resText = new ArrayList<>();\\n        int i = 0;\\n        while(i < words.length){\\n            StringBuilder resStr = new StringBuilder(words[i]);\\n            \\n            int j = i + 1;\\n            int currWidth = words[i].length();\\n            while(j < words.length && currWidth + 1 + words[j].length() <= maxWidth){\\n                currWidth += 1 + words[j].length();\\n                j++;\\n            }\\n            \\n            // Number of words in the current line are: (excluding the first one)\\n            int numWords = j - i - 1;\\n            \\n            if(numWords == 0 || j == words.length){\\n                // Last Line\\n                for(int k=i+1; k<j; k++){\\n                    resStr.append(\" \");\\n                    resStr.append(words[k]);\\n                }\\n                \\n                // Do padding at the end \\n                int remLen = maxWidth - resStr.length();\\n                for(int space=0; space < remLen; space++){\\n                    resStr.append(\" \");\\n                }\\n                \\n            }else{\\n                int numSpace = (maxWidth - currWidth)/numWords;\\n                int extraSpace = (maxWidth - currWidth)%numWords;\\n                \\n                for(int k=i+1; k<j; k++){\\n                    for(int space=0; space < numSpace; space++){\\n                        resStr.append(\" \");\\n                    }\\n                    \\n                    if(extraSpace > 0){\\n                        resStr.append(\" \");\\n                        extraSpace--;\\n                    }\\n                    \\n                    resStr.append(\" \"); // One space was already included \\n                    resStr.append(words[k]);\\n                }\\n                \\n            }\\n            \\n            resText.add(resStr.toString());\\n            i = j;\\n        }\\n        \\n        return resText;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<String> resText = new ArrayList<>();\\n        int i = 0;\\n        while(i < words.length){\\n            StringBuilder resStr = new StringBuilder(words[i]);\\n            \\n            int j = i + 1;\\n            int currWidth = words[i].length();\\n            while(j < words.length && currWidth + 1 + words[j].length() <= maxWidth){\\n                currWidth += 1 + words[j].length();\\n                j++;\\n            }\\n            \\n            // Number of words in the current line are: (excluding the first one)\\n            int numWords = j - i - 1;\\n            \\n            if(numWords == 0 || j == words.length){\\n                // Last Line\\n                for(int k=i+1; k<j; k++){\\n                    resStr.append(\" \");\\n                    resStr.append(words[k]);\\n                }\\n                \\n                // Do padding at the end \\n                int remLen = maxWidth - resStr.length();\\n                for(int space=0; space < remLen; space++){\\n                    resStr.append(\" \");\\n                }\\n                \\n            }else{\\n                int numSpace = (maxWidth - currWidth)/numWords;\\n                int extraSpace = (maxWidth - currWidth)%numWords;\\n                \\n                for(int k=i+1; k<j; k++){\\n                    for(int space=0; space < numSpace; space++){\\n                        resStr.append(\" \");\\n                    }\\n                    \\n                    if(extraSpace > 0){\\n                        resStr.append(\" \");\\n                        extraSpace--;\\n                    }\\n                    \\n                    resStr.append(\" \"); // One space was already included \\n                    resStr.append(words[k]);\\n                }\\n                \\n            }\\n            \\n            resText.add(resStr.toString());\\n            i = j;\\n        }\\n        \\n        return resText;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804542,
                "title": "clean-easy-to-understand-python-o-n",
                "content": "```\\nclass Solution:\\n    def createSentence(self, line):\\n        sentence = \\'\\'\\n        for word, spaceCount in line:\\n            sentence+=word\\n            sentence+=\\' \\'*spaceCount\\n            \\n        return sentence\\n    \\n    def adjustSpaces(self, line, spaceLeft):\\n        lastSpaces = line[-1][1]\\n        line[-1][1] = 0\\n        spaceLeft +=lastSpaces\\n        totalWords = len(line)\\n        \\n        if totalWords == 1:\\n            line[0][1] = spaceLeft\\n            return self.createSentence(line)\\n        \\n        for i in range(totalWords-1, 0, -1):\\n            spaceAfterWord = spaceLeft//i\\n            spaceLeft-=spaceAfterWord\\n            \\n            line[i-1][1] += spaceAfterWord\\n            \\n        return self.createSentence(line)    \\n        \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        line = []\\n        cUsage = 0\\n        output = []\\n        for word in words:\\n            if cUsage + len(word) > maxWidth:\\n                output.append(self.adjustSpaces(line, maxWidth-cUsage))\\n                cUsage = len(word)+1\\n                line = [[word,1]]\\n                \\n            elif cUsage + len(word) == maxWidth:\\n                line.append([word,0])\\n                cUsage = maxWidth\\n                \\n            else:\\n                line.append([word,1])\\n                cUsage+=len(word)+1\\n                \\n        line[-1][1] += maxWidth - cUsage\\n        output.append(self.createSentence(line))\\n                \\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def createSentence(self, line):\\n        sentence = \\'\\'\\n        for word, spaceCount in line:\\n            sentence+=word\\n            sentence+=\\' \\'*spaceCount\\n            \\n        return sentence\\n    \\n    def adjustSpaces(self, line, spaceLeft):\\n        lastSpaces = line[-1][1]\\n        line[-1][1] = 0\\n        spaceLeft +=lastSpaces\\n        totalWords = len(line)\\n        \\n        if totalWords == 1:\\n            line[0][1] = spaceLeft\\n            return self.createSentence(line)\\n        \\n        for i in range(totalWords-1, 0, -1):\\n            spaceAfterWord = spaceLeft//i\\n            spaceLeft-=spaceAfterWord\\n            \\n            line[i-1][1] += spaceAfterWord\\n            \\n        return self.createSentence(line)    \\n        \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        line = []\\n        cUsage = 0\\n        output = []\\n        for word in words:\\n            if cUsage + len(word) > maxWidth:\\n                output.append(self.adjustSpaces(line, maxWidth-cUsage))\\n                cUsage = len(word)+1\\n                line = [[word,1]]\\n                \\n            elif cUsage + len(word) == maxWidth:\\n                line.append([word,0])\\n                cUsage = maxWidth\\n                \\n            else:\\n                line.append([word,1])\\n                cUsage+=len(word)+1\\n                \\n        line[-1][1] += maxWidth - cUsage\\n        output.append(self.createSentence(line))\\n                \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740385,
                "title": "python-simple-faster-than-97-60",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        def balanceSpaces(string, isLast):\\n            spacesToAdd = maxWidth - len(string)\\n            stringAsList = string.split(\\' \\')\\n            \\n            if len(stringAsList) == 1 or isLast:\\n                return string + (\\' \\' * spacesToAdd)\\n            else:\\n                while spacesToAdd:\\n                    for i in range(len(stringAsList) - 1):\\n                        if spacesToAdd:\\n                            stringAsList[i] += \\' \\'\\n                            spacesToAdd -= 1\\n                        else:\\n                            break\\n            return \\' \\'.join(stringAsList)\\n        \\n        output = []\\n        \\n        currLayer = \"\"\\n        for each in words:\\n            if not currLayer:\\n                currLayer += each\\n            elif len(currLayer + \\' \\' + each) <= maxWidth:\\n                currLayer += \\' \\' + each\\n            else:\\n                output.append(balanceSpaces(currLayer, False))\\n                currLayer = each\\n        \\n        output.append(balanceSpaces(currLayer, True))\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        def balanceSpaces(string, isLast):\\n            spacesToAdd = maxWidth - len(string)\\n            stringAsList = string.split(\\' \\')\\n            \\n            if len(stringAsList) == 1 or isLast:\\n                return string + (\\' \\' * spacesToAdd)\\n            else:\\n                while spacesToAdd:\\n                    for i in range(len(stringAsList) - 1):\\n                        if spacesToAdd:\\n                            stringAsList[i] += \\' \\'\\n                            spacesToAdd -= 1\\n                        else:\\n                            break\\n            return \\' \\'.join(stringAsList)\\n        \\n        output = []\\n        \\n        currLayer = \"\"\\n        for each in words:\\n            if not currLayer:\\n                currLayer += each\\n            elif len(currLayer + \\' \\' + each) <= maxWidth:\\n                currLayer += \\' \\' + each\\n            else:\\n                output.append(balanceSpaces(currLayer, False))\\n                currLayer = each\\n        \\n        output.append(balanceSpaces(currLayer, True))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731481,
                "title": "greedy-python-solution",
                "content": "I split this up into three parts: First, partitioning the array into blocks to be justified, then justifying these blocks either left or right. Partitioning is easy, we just take as many words as we can, considering that we need at least one space after the first word. Justifying left is very easy as well.\\n\\nFully justifying is also not hard, the number of spaces you use is the integer division of the number of gaps and the difference between the width and the used space. We need the reminder of this division as well to distribute the excess space on the left.\\n\\n```python\\nclass Solution:\\n    def justifyFull(self, curLine: List[str], maxWidth: int) -> str:\\n        spacingNeeded: int = maxWidth - sum([len(word) for word in curLine])\\n        numGaps: int = max(1, len(curLine) - 1)\\n        numSpacesBase: int = spacingNeeded // numGaps\\n        numExtra: int = spacingNeeded % numGaps\\n        \\n        line: List[str] = []\\n        \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n            else:\\n                line.append(\" \" * numSpacesBase)\\n                if i <= numExtra:\\n                    line.append(\" \")\\n                line.append(word)\\n        return \"\".join(line)\\n    \\n    def justifyLeft(self, curLine: List[str], maxWidth: int) -> str:\\n        line: List[str] = []\\n        spaceUsed: int = 0\\n            \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n                spaceUsed += len(word)\\n            else:\\n                line.append(\" \")\\n                line.append(word)\\n                spaceUsed += len(word) + 1\\n        if spaceUsed < maxWidth:\\n            line.append(\" \" * (maxWidth - spaceUsed))\\n        return \"\".join(line)\\n\\n                \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        curWidth: int = 0\\n        curLine: List[str] = []\\n        justified: List[str] = []\\n        \\n        for i, word in enumerate(words):\\n            addedLength = 0\\n            if curWidth == 0:\\n                addedLength = len(word)\\n            else:\\n                addedLength = len(word) + 1\\n            \\n            if curWidth + addedLength > maxWidth:\\n                if len(curLine) > 1:\\n                    justified.append(self.justifyFull(curLine, maxWidth))\\n                else:\\n                    justified.append(self.justifyLeft(curLine, maxWidth))\\n                    \\n                curWidth = len(word)\\n                curLine = [word]\\n            else:\\n                curWidth += addedLength\\n                curLine.append(word)\\n                \\n        if curWidth > 0:\\n            justified.append(self.justifyLeft(curLine, maxWidth))\\n        \\n        return justified\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def justifyFull(self, curLine: List[str], maxWidth: int) -> str:\\n        spacingNeeded: int = maxWidth - sum([len(word) for word in curLine])\\n        numGaps: int = max(1, len(curLine) - 1)\\n        numSpacesBase: int = spacingNeeded // numGaps\\n        numExtra: int = spacingNeeded % numGaps\\n        \\n        line: List[str] = []\\n        \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n            else:\\n                line.append(\" \" * numSpacesBase)\\n                if i <= numExtra:\\n                    line.append(\" \")\\n                line.append(word)\\n        return \"\".join(line)\\n    \\n    def justifyLeft(self, curLine: List[str], maxWidth: int) -> str:\\n        line: List[str] = []\\n        spaceUsed: int = 0\\n            \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n                spaceUsed += len(word)\\n            else:\\n                line.append(\" \")\\n                line.append(word)\\n                spaceUsed += len(word) + 1\\n        if spaceUsed < maxWidth:\\n            line.append(\" \" * (maxWidth - spaceUsed))\\n        return \"\".join(line)\\n\\n                \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        curWidth: int = 0\\n        curLine: List[str] = []\\n        justified: List[str] = []\\n        \\n        for i, word in enumerate(words):\\n            addedLength = 0\\n            if curWidth == 0:\\n                addedLength = len(word)\\n            else:\\n                addedLength = len(word) + 1\\n            \\n            if curWidth + addedLength > maxWidth:\\n                if len(curLine) > 1:\\n                    justified.append(self.justifyFull(curLine, maxWidth))\\n                else:\\n                    justified.append(self.justifyLeft(curLine, maxWidth))\\n                    \\n                curWidth = len(word)\\n                curLine = [word]\\n            else:\\n                curWidth += addedLength\\n                curLine.append(word)\\n                \\n        if curWidth > 0:\\n            justified.append(self.justifyLeft(curLine, maxWidth))\\n        \\n        return justified\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643285,
                "title": "c-easy-to-understand-broken-into-several-methods",
                "content": "```\\npublic class Solution\\n{\\n    public IList<string> FullJustify(string[] words, int maxWidth)\\n    {\\n        var lines = new List<string>();\\n\\n        var left = 0;\\n        var lineLength = 0;\\n        var wordsLength = 0;\\n\\n        for (var i = 0; i < words.Length; i++)\\n        {\\n            var word = words[i];\\n            if (lineLength + word.Length > maxWidth)\\n            {\\n                lines.Add(JustifyLine(words, maxWidth, left, i - 1, wordsLength));\\n                \\n                // reset state\\n                lineLength = 0;\\n                wordsLength = 0;\\n                left = i;\\n            }\\n\\n            lineLength += word.Length + 1;\\n            wordsLength += word.Length;\\n        }\\n\\n        // yustify the last line\\n        if (left <= words.Length - 1)\\n        {\\n            var line = string.Join(\" \", words.Skip(left));\\n            lines.Add(line + new string(\\' \\', maxWidth - line.Length));\\n        }\\n\\n        return lines;\\n    }\\n\\n    private string JustifyLine(string[] words, int maxWidth, int start, int end, int wordsLength)\\n    {\\n        var builder = new StringBuilder();\\n        var spaces = maxWidth - wordsLength;\\n\\n        // justify one word\\n        if (start == end)\\n        {\\n            builder.Append(words[start]);\\n            builder.Append(\\' \\', spaces);\\n\\n            return builder.ToString();\\n        }\\n\\n        // justify multiple words\\n        var gaps = end - start;\\n\\n        for (var i = start; i <= end; i++)\\n        {\\n            builder.Append(words[i]);\\n\\n            // adding spaces if the word isn\\'t last\\n            if (i != end)\\n            {\\n                var count = spaces / gaps + (spaces % gaps == 0 ? 0 : 1);\\n                builder.Append(\\' \\', count);\\n\\n                spaces -= count;\\n                gaps--;\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public IList<string> FullJustify(string[] words, int maxWidth)\\n    {\\n        var lines = new List<string>();\\n\\n        var left = 0;\\n        var lineLength = 0;\\n        var wordsLength = 0;\\n\\n        for (var i = 0; i < words.Length; i++)\\n        {\\n            var word = words[i];\\n            if (lineLength + word.Length > maxWidth)\\n            {\\n                lines.Add(JustifyLine(words, maxWidth, left, i - 1, wordsLength));\\n                \\n                // reset state\\n                lineLength = 0;\\n                wordsLength = 0;\\n                left = i;\\n            }\\n\\n            lineLength += word.Length + 1;\\n            wordsLength += word.Length;\\n        }\\n\\n        // yustify the last line\\n        if (left <= words.Length - 1)\\n        {\\n            var line = string.Join(\" \", words.Skip(left));\\n            lines.Add(line + new string(\\' \\', maxWidth - line.Length));\\n        }\\n\\n        return lines;\\n    }\\n\\n    private string JustifyLine(string[] words, int maxWidth, int start, int end, int wordsLength)\\n    {\\n        var builder = new StringBuilder();\\n        var spaces = maxWidth - wordsLength;\\n\\n        // justify one word\\n        if (start == end)\\n        {\\n            builder.Append(words[start]);\\n            builder.Append(\\' \\', spaces);\\n\\n            return builder.ToString();\\n        }\\n\\n        // justify multiple words\\n        var gaps = end - start;\\n\\n        for (var i = start; i <= end; i++)\\n        {\\n            builder.Append(words[i]);\\n\\n            // adding spaces if the word isn\\'t last\\n            if (i != end)\\n            {\\n                var count = spaces / gaps + (spaces % gaps == 0 ? 0 : 1);\\n                builder.Append(\\' \\', count);\\n\\n                spaces -= count;\\n                gaps--;\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1620628,
                "title": "java-100-faster-with-explanation",
                "content": "Overall time: O(n)\\nspace: O(n)\\nPlease consider upvote if you like my solution. Thank you!\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\t\\t// list to be returned\\n        List<String> list = new ArrayList<>();\\n        \\n\\t\\t// store the combined word length in *section* list\\n        int length = 0;\\n\\t\\t// *section* list to store the words at current iteration\\n        List<String> section = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n\\t\\t\\t// if and only if the word that we are currently looking at exceeds the wordWidth limit\\n\\t\\t\\t// we start to build a solution at this level\\n            if (length + section.size() + words[i].length() > maxWidth) {\\n\\t\\t\\t\\t// number of spaces total\\n                int diff = maxWidth - length;\\n                StringBuilder sb = new StringBuilder();\\n                int spaceCount = section.size() > 1 ? diff / (section.size() - 1) : diff;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// extra spaces when we can\\'t evenly distribute them\\n                int extraCount = section.size() > 1 ? diff % (section.size() - 1) : 0;\\n                diff -= extraCount;\\n                for (int j = 0; j < section.size(); j++) {\\n                    sb.append(section.get(j));\\n                    if (extraCount > 0) {\\n                        addSpace(sb, 1);\\n                        extraCount -= 1;\\n                    }\\n                    if (diff > 0) {\\n                        addSpace(sb, spaceCount);\\n                        diff -= spaceCount;\\n                    }\\n                }\\n                \\n                list.add(sb.toString());\\n\\t\\t\\t\\t// clear section list for next iteration\\n                section.clear();\\n\\t\\t\\t\\t// clear length counter for next iteration\\n                length = 0;\\n            }\\n            section.add(words[i]);\\n            length += words[i].length();\\n        }\\n        // build the last line differently\\n        if (!section.isEmpty()) {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 0;\\n            for (int j = 0; j < section.size(); j++) {\\n                sb.append(section.get(j));\\n                if (j != section.size() - 1) {\\n                    addSpace(sb, 1);\\n                    count += 1;\\n                }\\n            }\\n            int diff = maxWidth - length - count;\\n            addSpace(sb, diff);\\n            list.add(sb.toString());\\n        }\\n        \\n        return list;\\n    }\\n    // helper function to append spaces to string builder\\n    private void addSpace(StringBuilder sb, int count) {\\n        for (int i = 0; i < count; i++) {\\n            sb.append(\" \");\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\t\\t// list to be returned\\n        List<String> list = new ArrayList<>();\\n        \\n\\t\\t// store the combined word length in *section* list\\n        int length = 0;\\n\\t\\t// *section* list to store the words at current iteration\\n        List<String> section = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n\\t\\t\\t// if and only if the word that we are currently looking at exceeds the wordWidth limit\\n\\t\\t\\t// we start to build a solution at this level\\n            if (length + section.size() + words[i].length() > maxWidth) {\\n\\t\\t\\t\\t// number of spaces total\\n                int diff = maxWidth - length;\\n                StringBuilder sb = new StringBuilder();\\n                int spaceCount = section.size() > 1 ? diff / (section.size() - 1) : diff;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// extra spaces when we can\\'t evenly distribute them\\n                int extraCount = section.size() > 1 ? diff % (section.size() - 1) : 0;\\n                diff -= extraCount;\\n                for (int j = 0; j < section.size(); j++) {\\n                    sb.append(section.get(j));\\n                    if (extraCount > 0) {\\n                        addSpace(sb, 1);\\n                        extraCount -= 1;\\n                    }\\n                    if (diff > 0) {\\n                        addSpace(sb, spaceCount);\\n                        diff -= spaceCount;\\n                    }\\n                }\\n                \\n                list.add(sb.toString());\\n\\t\\t\\t\\t// clear section list for next iteration\\n                section.clear();\\n\\t\\t\\t\\t// clear length counter for next iteration\\n                length = 0;\\n            }\\n            section.add(words[i]);\\n            length += words[i].length();\\n        }\\n        // build the last line differently\\n        if (!section.isEmpty()) {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 0;\\n            for (int j = 0; j < section.size(); j++) {\\n                sb.append(section.get(j));\\n                if (j != section.size() - 1) {\\n                    addSpace(sb, 1);\\n                    count += 1;\\n                }\\n            }\\n            int diff = maxWidth - length - count;\\n            addSpace(sb, diff);\\n            list.add(sb.toString());\\n        }\\n        \\n        return list;\\n    }\\n    // helper function to append spaces to string builder\\n    private void addSpace(StringBuilder sb, int count) {\\n        for (int i = 0; i < count; i++) {\\n            sb.append(\" \");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613771,
                "title": "0-ms-java-solution-faster-than-100-of-java-solutions",
                "content": "I really sacrificed readability/elegance for performance on this one. I use start and end pointers into the given array to avoid keeping a list of words. Use linked list to avoid cost of resizing array list (even though it is amortized constant, we never index into the list so a linked list works fine). Used loops rather than streams, also for speed. \\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Text Justification.\\nMemory Usage: 37.1 MB, less than 95.74% of Java online submissions for Text Justification.\\n\\n```\\nclass Solution {\\n    private int maxWidth;\\n    private String[] words;\\n    \\n    public List<String> fullJustify(String[] ws, int maxW) {        \\n        \\n        List<String> text = new LinkedList<>();        \\n        maxWidth = maxW;\\n        words = ws; \\n        // Use start/end indexes into words array to avoid making a list of words in current line (for efficiency).\\n        int start = 0; \\n        int end = 1;\\n        int lineLen = words[start].length();\\n        \\n        for (; end < words.length; end++) {\\n            String word = words[end];\\n            \\n            if (lineLen + word.length() + 1 <= maxWidth) { // Word fits in this line. Plus one is for a space.\\n                lineLen += word.length() + 1; \\n            } else { // Word does not fit in this line, space out current line and start a new one.\\n                text.add(constructLine(start, end, lineLen));\\n                start = end;\\n                lineLen = word.length();\\n            }   \\n        }\\n        \\n        if (end - start > 0) {\\n            text.add(lineWithoutInterWordPadding(start, end, lineLen));\\n        }\\n        \\n        return text;\\n    }\\n    \\n    private String lineWithoutInterWordPadding(int start, int end, int lineLength) {\\n        // Don\\'t use stream Collectors.joining(\" \") here, even though it is more readable. The below is faster.\\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \");\\n            line.append(words[i]);\\n        }\\n        return line.toString() + \" \".repeat(maxWidth - lineLength);\\n    }\\n    \\n    private String constructLine(int start, int end, int lineLength) {\\n        int numSpaces = end - (start + 1);\\n        \\n        if (numSpaces == 0) { // Only one word in the line.\\n            return lineWithoutInterWordPadding(start, end, lineLength);\\n        }\\n        \\n        int padding = maxWidth - lineLength;       // Extra padding needed.\\n        int spaceNeeded = padding / numSpaces + 1; // Padding between each word (extra + minimum one).\\n        int leftOverSpaces = padding % numSpaces;  // Extra spaces that don\\'t divide evenly between words.\\n        \\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        \\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \".repeat(spaceNeeded));\\n            if (leftOverSpaces-- > 0) {\\n                line.append(\\' \\');\\n            }\\n            line.append(words[i]);\\n        }\\n        \\n        return line.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int maxWidth;\\n    private String[] words;\\n    \\n    public List<String> fullJustify(String[] ws, int maxW) {        \\n        \\n        List<String> text = new LinkedList<>();        \\n        maxWidth = maxW;\\n        words = ws; \\n        // Use start/end indexes into words array to avoid making a list of words in current line (for efficiency).\\n        int start = 0; \\n        int end = 1;\\n        int lineLen = words[start].length();\\n        \\n        for (; end < words.length; end++) {\\n            String word = words[end];\\n            \\n            if (lineLen + word.length() + 1 <= maxWidth) { // Word fits in this line. Plus one is for a space.\\n                lineLen += word.length() + 1; \\n            } else { // Word does not fit in this line, space out current line and start a new one.\\n                text.add(constructLine(start, end, lineLen));\\n                start = end;\\n                lineLen = word.length();\\n            }   \\n        }\\n        \\n        if (end - start > 0) {\\n            text.add(lineWithoutInterWordPadding(start, end, lineLen));\\n        }\\n        \\n        return text;\\n    }\\n    \\n    private String lineWithoutInterWordPadding(int start, int end, int lineLength) {\\n        // Don\\'t use stream Collectors.joining(\" \") here, even though it is more readable. The below is faster.\\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \");\\n            line.append(words[i]);\\n        }\\n        return line.toString() + \" \".repeat(maxWidth - lineLength);\\n    }\\n    \\n    private String constructLine(int start, int end, int lineLength) {\\n        int numSpaces = end - (start + 1);\\n        \\n        if (numSpaces == 0) { // Only one word in the line.\\n            return lineWithoutInterWordPadding(start, end, lineLength);\\n        }\\n        \\n        int padding = maxWidth - lineLength;       // Extra padding needed.\\n        int spaceNeeded = padding / numSpaces + 1; // Padding between each word (extra + minimum one).\\n        int leftOverSpaces = padding % numSpaces;  // Extra spaces that don\\'t divide evenly between words.\\n        \\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        \\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \".repeat(spaceNeeded));\\n            if (leftOverSpaces-- > 0) {\\n                line.append(\\' \\');\\n            }\\n            line.append(words[i]);\\n        }\\n        \\n        return line.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603795,
                "title": "c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        string s;\\n        for(auto it:words) \\n        {\\n            if(s.length() + it.length() > maxWidth) \\n            {\\n                s = s.substr(1);\\n                s = add_spaces(s, s.length(), maxWidth, maxWidth-s.length());\\n                ans.push_back(s);\\n                s = \" \" + it;\\n            }\\n            else \\n            {\\n                s = s + \" \" + it;\\n            }\\n        }\\n        s = s.substr(1);\\n        ans.push_back(s);\\n        string tmp = ans.back();\\n        ans.pop_back();\\n        int sz = tmp.size();\\n        for(int i=0; i<maxWidth-sz; i++) tmp += \" \";\\n        ans.push_back(tmp);\\n        return ans;\\n    }\\n    \\n    string add_spaces(string s, int sz, int maxWidth, int extra) \\n    {\\n        int cnt = 0;\\n        vector<string> v;\\n        string tmp;\\n        \\n        // count total numbet=r of spaces necessary and storing all the words in given string\\n        for(int i=0; i<sz; i++) \\n        {\\n            if(s[i] != \\' \\') tmp += s[i];\\n            else {\\n                v.push_back(tmp);\\n                cnt++;\\n                tmp = \" \";\\n            }\\n        }\\n        v.push_back(tmp);\\n        extra += cnt;\\n        \\n        int tot = v.size();\\n        // if there\\'s only one word simply add spaces after the word\\n        if(cnt == 0) \\n        {\\n            string ans;\\n            ans += v[0];\\n            for(int i=0; i<extra; i++) ans += \" \";\\n            return ans;\\n        }\\n        \\n        string ans;\\n        // if total spaces are evenly divided between words\\n        // insert (totalSpaces)/(totalWords-1) spaces between each words\\n        if(extra % (tot-1) == 0) \\n        {\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    for(int j=0; j<(extra/(tot-1))-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        } \\n        else // else insert extra spaces between first (totalSpaces)%(totalWords-1) words\\n        {\\n            int extra_space = extra % (tot-1);\\n            int y = extra / (tot-1);\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    if(extra_space > 0) {\\n                        for(int j=0; j<y; j++) ans +=  \" \";\\n                        extra_space--;\\n                    }\\n                    else for(int j=0; j<y-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        string s;\\n        for(auto it:words) \\n        {\\n            if(s.length() + it.length() > maxWidth) \\n            {\\n                s = s.substr(1);\\n                s = add_spaces(s, s.length(), maxWidth, maxWidth-s.length());\\n                ans.push_back(s);\\n                s = \" \" + it;\\n            }\\n            else \\n            {\\n                s = s + \" \" + it;\\n            }\\n        }\\n        s = s.substr(1);\\n        ans.push_back(s);\\n        string tmp = ans.back();\\n        ans.pop_back();\\n        int sz = tmp.size();\\n        for(int i=0; i<maxWidth-sz; i++) tmp += \" \";\\n        ans.push_back(tmp);\\n        return ans;\\n    }\\n    \\n    string add_spaces(string s, int sz, int maxWidth, int extra) \\n    {\\n        int cnt = 0;\\n        vector<string> v;\\n        string tmp;\\n        \\n        // count total numbet=r of spaces necessary and storing all the words in given string\\n        for(int i=0; i<sz; i++) \\n        {\\n            if(s[i] != \\' \\') tmp += s[i];\\n            else {\\n                v.push_back(tmp);\\n                cnt++;\\n                tmp = \" \";\\n            }\\n        }\\n        v.push_back(tmp);\\n        extra += cnt;\\n        \\n        int tot = v.size();\\n        // if there\\'s only one word simply add spaces after the word\\n        if(cnt == 0) \\n        {\\n            string ans;\\n            ans += v[0];\\n            for(int i=0; i<extra; i++) ans += \" \";\\n            return ans;\\n        }\\n        \\n        string ans;\\n        // if total spaces are evenly divided between words\\n        // insert (totalSpaces)/(totalWords-1) spaces between each words\\n        if(extra % (tot-1) == 0) \\n        {\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    for(int j=0; j<(extra/(tot-1))-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        } \\n        else // else insert extra spaces between first (totalSpaces)%(totalWords-1) words\\n        {\\n            int extra_space = extra % (tot-1);\\n            int y = extra / (tot-1);\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    if(extra_space > 0) {\\n                        for(int j=0; j<y; j++) ans +=  \" \";\\n                        extra_space--;\\n                    }\\n                    else for(int j=0; j<y-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597909,
                "title": "python-solution-with-recursive-helper-function",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\\n        \"\"\"Given a list of words and a max line width, justify the text to fit each line.\\n        \\n        Take a greedy approach.\\n        Words by themselves AND the line will be left-justified.\\n            The last line will have no extra spaces between words.\\n        Normal lines will have spaces evenly distributed between words, with more\\n            spaces going to the left-most slots.\\n        \"\"\"\\n        output = []\\n\\n        while words:\\n            # Calling this with maxWidth + 1 accomodates for the \\n            # recursive fit_line function adding +1 space\\n            # for every word (when in reality there\\'s one less space than words)\\n            line = self.fit_line(words, maxWidth + 1)\\n            # This shortens the list to only include the remaining words,\\n            # and gives the loop a termination condition.\\n            words = words[len(line):]\\n\\n            # Case for the last line, or any line that only has one word.\\n            if len(line) == 1 or not words:\\n                output.append(self.left_justify(line, maxWidth))\\n            # Case for normal lines.\\n            else:\\n                output.append(self.center_justify(line, maxWidth))\\n        \\n        return output\\n    \\n    def fit_line(self, sublist: list[str], max_width) -> list[str]:\\n        \"\"\"Fit as many words as possible from sublist onto a line.\"\"\"\\n        # If the sublist is empty or if we can\\'t put anything else onto the line.\\n        if not sublist or max_width == 0:\\n            return []\\n        # We can\\'t fit any more words on this line (no more space left).\\n        elif len(sublist[0]) + 1 > max_width:\\n            return []\\n        else:\\n            # The first word in this list, plus the most words from the remaining\\n            # sublist that can fit. The +1 at the end is to account for the 1\\n            # mandatory space between words.\\n            return [sublist[0]] + self.fit_line(sublist[1:], max_width - (len(sublist[0]) + 1))\\n    \\n    def center_justify(self, sublist: list[str], max_width: int) -> str:\\n        \"\"\"Center justify the words in sublist, and return that as a string.\"\"\"\\n        # Calculate how much space we have left.\\n        space_left = self.find_space_left(sublist, max_width)\\n\\n        # Create space slots.\\n        # There are one less slots than number of words.\\n        space_slots = [\" \"] * (len(sublist) - 1)\\n\\n        slot_index = 0\\n        while space_left:\\n            space_slots[slot_index] += \" \"\\n            space_left -= 1\\n            # This will keep the index between 0 and the number of space_slots.\\n            slot_index += 1\\n            slot_index = slot_index % len(space_slots)\\n        \\n        # Add a blank space slot before the first word, now space_slots and\\n        # sublist have the same number of elements.\\n        space_slots.insert(0, \"\")\\n\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        return \"\".join(together)\\n    \\n    def left_justify(self, sublist: list[str], max_width: int) -> str:\\n        space_left = self.find_space_left(sublist, max_width)\\n        \\n        # Create space slots as though we were center justifying.\\n        # The difference is we don\\'t need to rotate bewteen slots.\\n        space_slots = [\"\"] + [\" \"] * (len(sublist) - 1)\\n\\n        # Join the words and the space slots.\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        output = \"\".join(together)\\n        # Add all the remaining spaces to the end.\\n        output += \" \" * space_left\\n\\n        return output\\n    \\n    def find_space_left(self, words: list[str], max_width: int) -> int:\\n        # The max width - minimum number of spaces - combined length of words.\\n        return max_width - (len(words) - 1) - sum([len(w) for w in words])\\n\\'\\'\\'\\n\\nThere\\'s probably room for some optimization, but I feel like this one is easy to understand.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\\n        \"\"\"Given a list of words and a max line width, justify the text to fit each line.\\n        \\n        Take a greedy approach.\\n        Words by themselves AND the line will be left-justified.\\n            The last line will have no extra spaces between words.\\n        Normal lines will have spaces evenly distributed between words, with more\\n            spaces going to the left-most slots.\\n        \"\"\"\\n        output = []\\n\\n        while words:\\n            # Calling this with maxWidth + 1 accomodates for the \\n            # recursive fit_line function adding +1 space\\n            # for every word (when in reality there\\'s one less space than words)\\n            line = self.fit_line(words, maxWidth + 1)\\n            # This shortens the list to only include the remaining words,\\n            # and gives the loop a termination condition.\\n            words = words[len(line):]\\n\\n            # Case for the last line, or any line that only has one word.\\n            if len(line) == 1 or not words:\\n                output.append(self.left_justify(line, maxWidth))\\n            # Case for normal lines.\\n            else:\\n                output.append(self.center_justify(line, maxWidth))\\n        \\n        return output\\n    \\n    def fit_line(self, sublist: list[str], max_width) -> list[str]:\\n        \"\"\"Fit as many words as possible from sublist onto a line.\"\"\"\\n        # If the sublist is empty or if we can\\'t put anything else onto the line.\\n        if not sublist or max_width == 0:\\n            return []\\n        # We can\\'t fit any more words on this line (no more space left).\\n        elif len(sublist[0]) + 1 > max_width:\\n            return []\\n        else:\\n            # The first word in this list, plus the most words from the remaining\\n            # sublist that can fit. The +1 at the end is to account for the 1\\n            # mandatory space between words.\\n            return [sublist[0]] + self.fit_line(sublist[1:], max_width - (len(sublist[0]) + 1))\\n    \\n    def center_justify(self, sublist: list[str], max_width: int) -> str:\\n        \"\"\"Center justify the words in sublist, and return that as a string.\"\"\"\\n        # Calculate how much space we have left.\\n        space_left = self.find_space_left(sublist, max_width)\\n\\n        # Create space slots.\\n        # There are one less slots than number of words.\\n        space_slots = [\" \"] * (len(sublist) - 1)\\n\\n        slot_index = 0\\n        while space_left:\\n            space_slots[slot_index] += \" \"\\n            space_left -= 1\\n            # This will keep the index between 0 and the number of space_slots.\\n            slot_index += 1\\n            slot_index = slot_index % len(space_slots)\\n        \\n        # Add a blank space slot before the first word, now space_slots and\\n        # sublist have the same number of elements.\\n        space_slots.insert(0, \"\")\\n\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        return \"\".join(together)\\n    \\n    def left_justify(self, sublist: list[str], max_width: int) -> str:\\n        space_left = self.find_space_left(sublist, max_width)\\n        \\n        # Create space slots as though we were center justifying.\\n        # The difference is we don\\'t need to rotate bewteen slots.\\n        space_slots = [\"\"] + [\" \"] * (len(sublist) - 1)\\n\\n        # Join the words and the space slots.\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        output = \"\".join(together)\\n        # Add all the remaining spaces to the end.\\n        output += \" \" * space_left\\n\\n        return output\\n    \\n    def find_space_left(self, words: list[str], max_width: int) -> int:\\n        # The max width - minimum number of spaces - combined length of words.\\n        return max_width - (len(words) - 1) - sum([len(w) for w in words])\\n\\'\\'\\'\\n\\nThere\\'s probably room for some optimization, but I feel like this one is easy to understand.",
                "codeTag": "Java"
            },
            {
                "id": 1590497,
                "title": "go-solution-0-ms-100-00-2-3-mb-52-44",
                "content": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strings\"\\n)\\n\\n/*\\n\\n68. Text Justification\\n\\nhttps://leetcode.com/problems/text-justification/\\n\\n*/\\n\\nfunc nextWords(words []string, maxWidth int, index int) ([]string, int) {\\n\\tresult := make([]string, 0)\\n\\n\\twidth := 0\\n\\tfirst := true\\n\\n\\tfor {\\n\\t\\tif index >= len(words) {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tword := words[index]\\n\\n\\t\\twidth += len(word)\\n\\t\\tif !first {\\n\\t\\t\\twidth++\\n\\t\\t} else {\\n\\t\\t\\tfirst = false\\n\\t\\t}\\n\\n\\t\\tif width > maxWidth {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tresult = append(result, word)\\n\\n\\t\\tindex++\\n\\t}\\n}\\n\\nfunc generateRow(words []string, maxWidth int, lastRow bool) string {\\n\\tif lastRow {\\n\\t\\tresult := strings.Join(words, \" \")\\n\\n\\t\\treturn result + strings.Repeat(\" \", maxWidth-len(result))\\n\\t}\\n\\n\\ttotalWordsWidth := 0\\n\\tfor _, word := range words {\\n\\t\\ttotalWordsWidth += len(word)\\n\\t}\\n\\n\\tresult := \"\"\\n\\tfor index, word := range words {\\n\\t\\tresult += word\\n\\t\\ttotalWordsWidth -= len(word)\\n\\t\\textraSpace := maxWidth - len(result) - totalWordsWidth\\n\\t\\twordsLeft := len(words) - index - 1\\n\\n\\t\\tif wordsLeft == 0 {\\n\\t\\t\\tresult += strings.Repeat(\" \", maxWidth-len(result))\\n\\t\\t} else {\\n\\t\\t\\tresult += strings.Repeat(\" \", extraSpace/wordsLeft)\\n\\t\\t\\tif extraSpace%wordsLeft != 0 {\\n\\t\\t\\t\\tresult += \" \"\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tresults := make([]string, 0)\\n\\n\\tindex := 0\\n\\n\\tfor {\\n\\t\\tvar row []string\\n\\t\\trow, index = nextWords(words, maxWidth, index)\\n\\n\\t\\tresults = append(results, generateRow(row, maxWidth, index >= len(words)))\\n\\n\\t\\tif index >= len(words) {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn results\\n}\\n\\nfunc printResult(result []string) {\\n\\tfor _, row := range result {\\n\\t\\tfmt.Println(\"[\" + row + \"]\")\\n\\t}\\n\\n\\tfmt.Println()\\n}\\n\\nfunc main() {\\n\\twords1 := []string{\\n\\t\\t\"This\",\\n\\t\\t\"is\",\\n\\t\\t\"an\",\\n\\t\\t\"example\",\\n\\t\\t\"of\",\\n\\t\\t\"text\",\\n\\t\\t\"justification.\",\\n\\t}\\n\\n\\t// [This    is    an]\\n\\t// [example  of text]\\n\\t// [justification.  ]\\n\\n\\tprintResult(fullJustify(words1, 16))\\n\\n\\twords2 := []string{\\n\\t\\t\"What\",\\n\\t\\t\"must\",\\n\\t\\t\"be\",\\n\\t\\t\"acknowledgment\",\\n\\t\\t\"shall\",\\n\\t\\t\"be\",\\n\\t}\\n\\n\\t// [What   must   be]\\n\\t// [acknowledgment  ]\\n\\t// [shall be        ]\\n\\n\\tprintResult(fullJustify(words2, 16))\\n\\n\\twords3 := []string{\\n\\t\\t\"Science\",\\n\\t\\t\"is\",\\n\\t\\t\"what\",\\n\\t\\t\"we\",\\n\\t\\t\"understand\",\\n\\t\\t\"well\",\\n\\t\\t\"enough\",\\n\\t\\t\"to\",\\n\\t\\t\"explain\",\\n\\t\\t\"to\",\\n\\t\\t\"a\",\\n\\t\\t\"computer.\",\\n\\t\\t\"Art\",\\n\\t\\t\"is\",\\n\\t\\t\"everything\",\\n\\t\\t\"else\",\\n\\t\\t\"we\",\\n\\t\\t\"do\",\\n\\t}\\n\\n\\t// [Science  is  what we]\\n\\t// [understand      well]\\n\\t// [enough to explain to]\\n\\t// [a  computer.  Art is]\\n\\t// [everything  else  we]\\n\\t// [do                  ]\\n\\n\\tprintResult(fullJustify(words3, 20))\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Iterator"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strings\"\\n)\\n\\n/*\\n\\n68. Text Justification\\n\\nhttps://leetcode.com/problems/text-justification/\\n\\n*/\\n\\nfunc nextWords(words []string, maxWidth int, index int) ([]string, int) {\\n\\tresult := make([]string, 0)\\n\\n\\twidth := 0\\n\\tfirst := true\\n\\n\\tfor {\\n\\t\\tif index >= len(words) {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tword := words[index]\\n\\n\\t\\twidth += len(word)\\n\\t\\tif !first {\\n\\t\\t\\twidth++\\n\\t\\t} else {\\n\\t\\t\\tfirst = false\\n\\t\\t}\\n\\n\\t\\tif width > maxWidth {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tresult = append(result, word)\\n\\n\\t\\tindex++\\n\\t}\\n}\\n\\nfunc generateRow(words []string, maxWidth int, lastRow bool) string {\\n\\tif lastRow {\\n\\t\\tresult := strings.Join(words, \" \")\\n\\n\\t\\treturn result + strings.Repeat(\" \", maxWidth-len(result))\\n\\t}\\n\\n\\ttotalWordsWidth := 0\\n\\tfor _, word := range words {\\n\\t\\ttotalWordsWidth += len(word)\\n\\t}\\n\\n\\tresult := \"\"\\n\\tfor index, word := range words {\\n\\t\\tresult += word\\n\\t\\ttotalWordsWidth -= len(word)\\n\\t\\textraSpace := maxWidth - len(result) - totalWordsWidth\\n\\t\\twordsLeft := len(words) - index - 1\\n\\n\\t\\tif wordsLeft == 0 {\\n\\t\\t\\tresult += strings.Repeat(\" \", maxWidth-len(result))\\n\\t\\t} else {\\n\\t\\t\\tresult += strings.Repeat(\" \", extraSpace/wordsLeft)\\n\\t\\t\\tif extraSpace%wordsLeft != 0 {\\n\\t\\t\\t\\tresult += \" \"\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tresults := make([]string, 0)\\n\\n\\tindex := 0\\n\\n\\tfor {\\n\\t\\tvar row []string\\n\\t\\trow, index = nextWords(words, maxWidth, index)\\n\\n\\t\\tresults = append(results, generateRow(row, maxWidth, index >= len(words)))\\n\\n\\t\\tif index >= len(words) {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn results\\n}\\n\\nfunc printResult(result []string) {\\n\\tfor _, row := range result {\\n\\t\\tfmt.Println(\"[\" + row + \"]\")\\n\\t}\\n\\n\\tfmt.Println()\\n}\\n\\nfunc main() {\\n\\twords1 := []string{\\n\\t\\t\"This\",\\n\\t\\t\"is\",\\n\\t\\t\"an\",\\n\\t\\t\"example\",\\n\\t\\t\"of\",\\n\\t\\t\"text\",\\n\\t\\t\"justification.\",\\n\\t}\\n\\n\\t// [This    is    an]\\n\\t// [example  of text]\\n\\t// [justification.  ]\\n\\n\\tprintResult(fullJustify(words1, 16))\\n\\n\\twords2 := []string{\\n\\t\\t\"What\",\\n\\t\\t\"must\",\\n\\t\\t\"be\",\\n\\t\\t\"acknowledgment\",\\n\\t\\t\"shall\",\\n\\t\\t\"be\",\\n\\t}\\n\\n\\t// [What   must   be]\\n\\t// [acknowledgment  ]\\n\\t// [shall be        ]\\n\\n\\tprintResult(fullJustify(words2, 16))\\n\\n\\twords3 := []string{\\n\\t\\t\"Science\",\\n\\t\\t\"is\",\\n\\t\\t\"what\",\\n\\t\\t\"we\",\\n\\t\\t\"understand\",\\n\\t\\t\"well\",\\n\\t\\t\"enough\",\\n\\t\\t\"to\",\\n\\t\\t\"explain\",\\n\\t\\t\"to\",\\n\\t\\t\"a\",\\n\\t\\t\"computer.\",\\n\\t\\t\"Art\",\\n\\t\\t\"is\",\\n\\t\\t\"everything\",\\n\\t\\t\"else\",\\n\\t\\t\"we\",\\n\\t\\t\"do\",\\n\\t}\\n\\n\\t// [Science  is  what we]\\n\\t// [understand      well]\\n\\t// [enough to explain to]\\n\\t// [a  computer.  Art is]\\n\\t// [everything  else  we]\\n\\t// [do                  ]\\n\\n\\tprintResult(fullJustify(words3, 20))\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1566039,
                "title": "python-concise-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # number of characters that a group of words occupy is\\n        # numTotalLetters + words - 1 (for spaces)\\n        # The moment a new word causes this computation to exceed max width is when we introduce a new row\\n        # Spread the spaces of the remainder of maxwidth and this computation as spaces for each word in a round robin left to right \\n        \\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        \\n        remainder = \\' \\'.join(cur)\\n        remainder += \\' \\' * (maxWidth - len(remainder))\\n        \\n        return res + [remainder]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # number of characters that a group of words occupy is\\n        # numTotalLetters + words - 1 (for spaces)\\n        # The moment a new word causes this computation to exceed max width is when we introduce a new row\\n        # Spread the spaces of the remainder of maxwidth and this computation as spaces for each word in a round robin left to right \\n        \\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        \\n        remainder = \\' \\'.join(cur)\\n        remainder += \\' \\' * (maxWidth - len(remainder))\\n        \\n        return res + [remainder]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546004,
                "title": "java-simple-short-and-easy-for-dummies-like-me-heavily-commented",
                "content": "```\\n/*\\nBasic Idea:\\n1. Add words to each line until they fit within maxWidth\\n2. Calculate the extra spaces remaining, (maxWidth - characterCountAdded)\\n3. Distribute the extra spaces among every word in the line in a Round Robin Fashion. Now your line is justified.\\n4. Add the justified line to the resultList\\n5. Repeat it for the rest of the words\\n*/\\n\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // ArrayList to store the justified text result\\n        List<String> result = new ArrayList<>();\\n        \\n        // ArrayList to store a justified line\\n        // We use StringBuilder instead of String, because we want to append spaces to it\\n        List<StringBuilder> line = new ArrayList<>();\\n        \\n        // No of characters in a given line\\n        int charCount = 0;\\n        \\n        for (String word : words) {\\n            \\n            int spacesNeeded = line.size(); // represents single space needed between words\\n            if (charCount + word.length() + spacesNeeded > maxWidth) {\\n                // We could not add the new word to the line\\n                // Hence, lets justify the words already present in the line\\n                \\n                // In order to justify, we need to calculate the extra spaces\\n                // and distribute the spaces among the words in a Round Robin Fashion\\n                int spacesAvailable = maxWidth - charCount;\\n                for (int i = 0; i < spacesAvailable; i++) {\\n                    if (line.size() == 1) {\\n                        // If there is only one word present in the line,\\n                        // keep adding all the available spaces to the end of the single word\\n                        line.get(0).append(\" \");    \\n                    } else {\\n                        // If there are more than 1 word in the line,\\n                        // Add spaces to every word one after the other, except the last word (question\\'s requirement)\\n                        // Since we do not want to add space to the last word, we are doing line.size() - 1, else it would be just line.size()\\n                        line.get(i % (line.size() - 1)).append(\" \");\\n                    }\\n                }\\n                \\n                // convert the line list to String\\n                // Since we already added all the necessary spacing,\\n                // we just need to join with empty string \"\"\\n                result.add(String.join(\"\", line));\\n                line.clear(); // empty the line\\n                charCount = 0; // clear the charCount\\n            }\\n            \\n            \\n            // Add the current word, because we are within the maxWidth\\n            line.add(new StringBuilder(word));\\n            charCount += word.length(); // Increment the charCount for the word added\\n            \\n        }\\n        \\n        // We are at the last line\\n        // Last line needs to be Left Justified,\\n        // meaning we still need to add all the extra spaces to the right\\n        if (!line.isEmpty()) { // check if line is not empty, (not sure if this is needed, just to be safe)\\n            // Build the lastLine String,\\n            // for which we need to join with a single space because we did not add any space before\\n            String lastLine = String.join(\" \", line);\\n            // Left Justification is done here,\\n            // Ex: String.format(\"%-6s\", \"12345\") will give \"12345 \"  (12345 and 1 extra space)\\n            // Ex: String.format(\"%-7s\", \"12345\") will give \"12345  \" (12345 and 2 extra spaces)\\n            // Ex: String.format(\"%-5s\", \"12345\") will give \"12345\"   (12345 and 0 extra spaces)\\n            String justifiedLastLine = String.format(\"%-\"+maxWidth+\"s\", lastLine);\\n            result.add(justifiedLastLine); // Add to result\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nBasic Idea:\\n1. Add words to each line until they fit within maxWidth\\n2. Calculate the extra spaces remaining, (maxWidth - characterCountAdded)\\n3. Distribute the extra spaces among every word in the line in a Round Robin Fashion. Now your line is justified.\\n4. Add the justified line to the resultList\\n5. Repeat it for the rest of the words\\n*/\\n\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // ArrayList to store the justified text result\\n        List<String> result = new ArrayList<>();\\n        \\n        // ArrayList to store a justified line\\n        // We use StringBuilder instead of String, because we want to append spaces to it\\n        List<StringBuilder> line = new ArrayList<>();\\n        \\n        // No of characters in a given line\\n        int charCount = 0;\\n        \\n        for (String word : words) {\\n            \\n            int spacesNeeded = line.size(); // represents single space needed between words\\n            if (charCount + word.length() + spacesNeeded > maxWidth) {\\n                // We could not add the new word to the line\\n                // Hence, lets justify the words already present in the line\\n                \\n                // In order to justify, we need to calculate the extra spaces\\n                // and distribute the spaces among the words in a Round Robin Fashion\\n                int spacesAvailable = maxWidth - charCount;\\n                for (int i = 0; i < spacesAvailable; i++) {\\n                    if (line.size() == 1) {\\n                        // If there is only one word present in the line,\\n                        // keep adding all the available spaces to the end of the single word\\n                        line.get(0).append(\" \");    \\n                    } else {\\n                        // If there are more than 1 word in the line,\\n                        // Add spaces to every word one after the other, except the last word (question\\'s requirement)\\n                        // Since we do not want to add space to the last word, we are doing line.size() - 1, else it would be just line.size()\\n                        line.get(i % (line.size() - 1)).append(\" \");\\n                    }\\n                }\\n                \\n                // convert the line list to String\\n                // Since we already added all the necessary spacing,\\n                // we just need to join with empty string \"\"\\n                result.add(String.join(\"\", line));\\n                line.clear(); // empty the line\\n                charCount = 0; // clear the charCount\\n            }\\n            \\n            \\n            // Add the current word, because we are within the maxWidth\\n            line.add(new StringBuilder(word));\\n            charCount += word.length(); // Increment the charCount for the word added\\n            \\n        }\\n        \\n        // We are at the last line\\n        // Last line needs to be Left Justified,\\n        // meaning we still need to add all the extra spaces to the right\\n        if (!line.isEmpty()) { // check if line is not empty, (not sure if this is needed, just to be safe)\\n            // Build the lastLine String,\\n            // for which we need to join with a single space because we did not add any space before\\n            String lastLine = String.join(\" \", line);\\n            // Left Justification is done here,\\n            // Ex: String.format(\"%-6s\", \"12345\") will give \"12345 \"  (12345 and 1 extra space)\\n            // Ex: String.format(\"%-7s\", \"12345\") will give \"12345  \" (12345 and 2 extra spaces)\\n            // Ex: String.format(\"%-5s\", \"12345\") will give \"12345\"   (12345 and 0 extra spaces)\\n            String justifiedLastLine = String.format(\"%-\"+maxWidth+\"s\", lastLine);\\n            result.add(justifiedLastLine); // Add to result\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531563,
                "title": "c-solutuion",
                "content": "class Solution\\n{\\n\\tpublic:\\n\\t\\tvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n\\t\\t\\tvector<string> vec;\\n        \\n        int i = 0;\\n        \\n        while(i<words.size())\\n        {\\n            int j = i+1;\\n            int sum = words[i].length();\\n            int curr = 0;\\n            while(j<words.size() and sum+words[j].size()+1+curr<=maxWidth)\\n            {\\n                sum += words[j].length();\\n                j++;\\n                curr++;\\n            }\\n            string now = \"\";\\n            int extra = (curr==0)?0:(maxWidth - sum)/curr;\\n            int more = (curr==0)?0:(maxWidth - sum)%curr;\\n            if(j==words.size())\\n            {\\n                 for(int k=i;k<j;k++)\\n                {\\n                      now += words[k];\\n                     now += \" \";\\n                }\\n                now.pop_back();\\n            }\\n            else\\n            {\\n                 for(int k=i;k<j;k++)\\n                {\\n                    now += words[k];\\n                    if(k==j-1)\\n                        break;\\n                    for(int g=0;g<extra;g++)\\n                    {\\n                        now += \" \";\\n                    }\\n                    if(more)\\n                    {\\n                        now += \" \";\\n                        more--;\\n                    }\\n                }\\n            }\\n           \\n            cout<<now.length()<<\" \";\\n            while(now.length()<maxWidth)\\n                now += \" \";\\n            vec.push_back(now);\\n            i=j;\\n        }\\n        \\n        return vec;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution\\n{\\n\\tpublic:\\n\\t\\tvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n\\t\\t\\tvector<string> vec;\\n        \\n        int i = 0;\\n        \\n        while(i<words.size())\\n        {\\n            int j = i+1;\\n            int sum = words[i].length();\\n            int curr = 0;\\n            while(j<words.size() and sum+words[j].size()+1+curr<=maxWidth)\\n            {\\n                sum += words[j].length();\\n                j++;\\n                curr++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1525084,
                "title": "python-approach-with-comments-to-explain-the-logic",
                "content": "**I divided the code in 2 methods:**\\n1. One that have the Justify logic\\n2. The main method\\n\\nThe one with the Justify logic will check an edge case where only 1 word fits into the line so it has to fill blanks at the end of the line.\\n\\nThe rest is just calculating the length of the spaces and how many reminders are so we need to an extra space.\\n\\nThe main method will start with the first word in the current line and check if we can add another word to the line and meet the condition that fits in a line of max_width.\\n\\n**O(N) Time Complexity:** We have to traverse the words 1 time in the main method which is O(N) + another time when formatting which is O(N) and join method will traverse the words and its spaces ~O(N+N-1) = O(2N-1) which is in total O(4N) ~= O(N)\\n\\n**O(N) Space Complexity:** Current Line can store potentially all the words which is an additional space of O(N) + O(N+N-1) for the words and spaces in the formating which is still O(N) so the space will require O(3N-1) ~= O(N)\\n\\n```\\nclass Solution:\\n    \\n    # formatLine will justify left and right sizes or just left\\n    # if there are only 1 word\\n    def formatLine(self, line, cur_len, max_length):\\n        \\n        # If we have N words we need N-1 spaces to separate\\n        spaces = len(line) - 1\\n        if spaces == 0:\\n            line.append(\\' \\' * (max_length - cur_len))\\n            return \\'\\'.join(line)\\n        \\n        # To know the length of spaces we need to know the remaining\\n        # characters to fill the line (max_length - cur_len) and divide\\n        # this remaining characters between the amount of spaces\\n        space_length = (max_length - cur_len) // spaces\\n\\t\\t\\n        # We might have a reminder and we will use an extra space from left\\n        # to right until we fill the gaps\\n        space_reminders = (max_length - cur_len) % spaces\\n        \\n        sb = [line[0]]\\n        space = \\' \\' * space_length\\n        \\n        for i in range(1, len(line)):\\n            # space already have the right length except for the reminder\\n            sb.append(space)\\n            if space_reminders > 0:\\n                # adding one reminder if we have\\n                sb.append(\\' \\')\\n                space_reminders -= 1\\n            # Adding the actual word\\n            sb.append(line[i])\\n        \\n        # This will finally format the line\\n        return \\'\\'.join(sb)\\n    \\n    \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # line have all de words we can add in a single line\\n        line = [words[0]]\\n\\t\\t\\n        # length for all the words in the current line but not taking in count\\n        # the spaces\\n        cur_len = len(words[0])\\n\\t\\t\\n        # final answer\\n        ans = []\\n        \\n        for i in range(1, len(words)):\\n            # If we add another word there will be N+1 words in the line so we\\n            # need N spaces at least\\n            min_need_spaces = len(line)\\n            \\n            # If we add another word the minimum length of the line will be\\n            # the total length we have so far for that line + the length of the\\n            # word we want to add and the minimum amount of spaces that we need\\n            # to separate the words\\n            if (cur_len + len(words[i]) + min_need_spaces) > maxWidth:\\n                # If the condition is met, we can\\'t add another word\\n                ans.append(self.formatLine(line, cur_len, maxWidth))\\n\\t\\t\\t\\t\\n                # As the line has been formatted we start over\\n                line.clear()\\n                cur_len = 0\\n            \\n            line.append(words[i])\\n            cur_len += len(words[i])\\n        \\n        # We just fill the last line with spaces at the end so it reaches the maxWidth\\n        last = \\' \\'.join(line)\\n        ans.append(last + (\\' \\' * (maxWidth - len(last))))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    # formatLine will justify left and right sizes or just left\\n    # if there are only 1 word\\n    def formatLine(self, line, cur_len, max_length):\\n        \\n        # If we have N words we need N-1 spaces to separate\\n        spaces = len(line) - 1\\n        if spaces == 0:\\n            line.append(\\' \\' * (max_length - cur_len))\\n            return \\'\\'.join(line)\\n        \\n        # To know the length of spaces we need to know the remaining\\n        # characters to fill the line (max_length - cur_len) and divide\\n        # this remaining characters between the amount of spaces\\n        space_length = (max_length - cur_len) // spaces\\n\\t\\t\\n        # We might have a reminder and we will use an extra space from left\\n        # to right until we fill the gaps\\n        space_reminders = (max_length - cur_len) % spaces\\n        \\n        sb = [line[0]]\\n        space = \\' \\' * space_length\\n        \\n        for i in range(1, len(line)):\\n            # space already have the right length except for the reminder\\n            sb.append(space)\\n            if space_reminders > 0:\\n                # adding one reminder if we have\\n                sb.append(\\' \\')\\n                space_reminders -= 1\\n            # Adding the actual word\\n            sb.append(line[i])\\n        \\n        # This will finally format the line\\n        return \\'\\'.join(sb)\\n    \\n    \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # line have all de words we can add in a single line\\n        line = [words[0]]\\n\\t\\t\\n        # length for all the words in the current line but not taking in count\\n        # the spaces\\n        cur_len = len(words[0])\\n\\t\\t\\n        # final answer\\n        ans = []\\n        \\n        for i in range(1, len(words)):\\n            # If we add another word there will be N+1 words in the line so we\\n            # need N spaces at least\\n            min_need_spaces = len(line)\\n            \\n            # If we add another word the minimum length of the line will be\\n            # the total length we have so far for that line + the length of the\\n            # word we want to add and the minimum amount of spaces that we need\\n            # to separate the words\\n            if (cur_len + len(words[i]) + min_need_spaces) > maxWidth:\\n                # If the condition is met, we can\\'t add another word\\n                ans.append(self.formatLine(line, cur_len, maxWidth))\\n\\t\\t\\t\\t\\n                # As the line has been formatted we start over\\n                line.clear()\\n                cur_len = 0\\n            \\n            line.append(words[i])\\n            cur_len += len(words[i])\\n        \\n        # We just fill the last line with spaces at the end so it reaches the maxWidth\\n        last = \\' \\'.join(line)\\n        ans.append(last + (\\' \\' * (maxWidth - len(last))))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485789,
                "title": "object-oriented-approach-java",
                "content": "I solved this using an object-oriented approach where I created a `Line` object for each line that was going to be returned. Each `Line` object contains a list of words, and concatenates the words in its `toString()` method. I just found this approach clean, but in other regards it is no different from solutions already shared here. The `fullJustify` method itself is very small with this approach.\\n\\n```\\nclass Solution {\\n    private static final class Line {\\n        private int maxLength;\\n        private int currentLength = 0;\\n        private List<String> words = new ArrayList<>();\\n        private boolean lastWord = false;\\n        \\n        private Line(int maxLength) {\\n            this.maxLength = maxLength;\\n        }\\n        \\n        private boolean tryAdd(String word) {\\n            if (currentLength == 0) {\\n                currentLength += word.length();\\n                words.add(word);\\n                return true;\\n            }\\n            boolean canAddWord = currentLength + word.length() + 1 <= maxLength;\\n            if (canAddWord) {\\n                currentLength += word.length() + 1;\\n                words.add(word);\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        private void flagAsLastWord() {\\n            lastWord = true;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            if (lastWord) {\\n                return toStringLastWord();\\n            } else {\\n                return toStringNotLastWord();\\n            }\\n        }\\n        \\n        private String toStringNotLastWord() {\\n            \\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            int numEmptySpots = this.words.size() == 1 ? 1 : this.words.size() - 1;\\n            int spareSpaces = emptySpaces % numEmptySpots;\\n            int minSpacesPerSpot = emptySpaces / numEmptySpots;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (int i = 0; i < words.size(); i++) {\\n                String word = words.get(i);\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    int spacesAfterWord;\\n                    if (spareSpaces > 0) {\\n                        spacesAfterWord = minSpacesPerSpot + 1;\\n                        spareSpaces--;\\n                    } else {\\n                        spacesAfterWord = minSpacesPerSpot;\\n                    }\\n                    emptySpaces -= spacesAfterWord;\\n                    for (int j = 0; j < spacesAfterWord; j++) {\\n                        sb.append(\\' \\');\\n                    }\\n                }\\n                \\n            }\\n            return sb.toString();\\n        }\\n        \\n        private String toStringLastWord() {\\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (String word : words) {\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    sb.append(\\' \\');\\n                    emptySpaces--;\\n                }\\n            }\\n            for (int i = 0; i < emptySpaces; i++) {\\n                sb.append(\\' \\');\\n            }\\n            return sb.toString();\\n        }\\n    }\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<Line> lines = new ArrayList<>();\\n        lines.add(new Line(maxWidth));\\n        \\n        for (String word : words) {\\n            Line last = lines.get(lines.size() - 1);\\n            if (!last.tryAdd(word)) {\\n                Line newLine = new Line(maxWidth);\\n                lines.add(newLine);\\n                newLine.tryAdd(word);\\n            }\\n        }\\n        \\n        Line last = lines.get(lines.size() - 1);\\n        last.flagAsLastWord();\\n        \\n        List<String> result = new ArrayList<>(lines.size());\\n        for (Line line : lines) {\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final class Line {\\n        private int maxLength;\\n        private int currentLength = 0;\\n        private List<String> words = new ArrayList<>();\\n        private boolean lastWord = false;\\n        \\n        private Line(int maxLength) {\\n            this.maxLength = maxLength;\\n        }\\n        \\n        private boolean tryAdd(String word) {\\n            if (currentLength == 0) {\\n                currentLength += word.length();\\n                words.add(word);\\n                return true;\\n            }\\n            boolean canAddWord = currentLength + word.length() + 1 <= maxLength;\\n            if (canAddWord) {\\n                currentLength += word.length() + 1;\\n                words.add(word);\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        private void flagAsLastWord() {\\n            lastWord = true;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            if (lastWord) {\\n                return toStringLastWord();\\n            } else {\\n                return toStringNotLastWord();\\n            }\\n        }\\n        \\n        private String toStringNotLastWord() {\\n            \\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            int numEmptySpots = this.words.size() == 1 ? 1 : this.words.size() - 1;\\n            int spareSpaces = emptySpaces % numEmptySpots;\\n            int minSpacesPerSpot = emptySpaces / numEmptySpots;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (int i = 0; i < words.size(); i++) {\\n                String word = words.get(i);\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    int spacesAfterWord;\\n                    if (spareSpaces > 0) {\\n                        spacesAfterWord = minSpacesPerSpot + 1;\\n                        spareSpaces--;\\n                    } else {\\n                        spacesAfterWord = minSpacesPerSpot;\\n                    }\\n                    emptySpaces -= spacesAfterWord;\\n                    for (int j = 0; j < spacesAfterWord; j++) {\\n                        sb.append(\\' \\');\\n                    }\\n                }\\n                \\n            }\\n            return sb.toString();\\n        }\\n        \\n        private String toStringLastWord() {\\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (String word : words) {\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    sb.append(\\' \\');\\n                    emptySpaces--;\\n                }\\n            }\\n            for (int i = 0; i < emptySpaces; i++) {\\n                sb.append(\\' \\');\\n            }\\n            return sb.toString();\\n        }\\n    }\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<Line> lines = new ArrayList<>();\\n        lines.add(new Line(maxWidth));\\n        \\n        for (String word : words) {\\n            Line last = lines.get(lines.size() - 1);\\n            if (!last.tryAdd(word)) {\\n                Line newLine = new Line(maxWidth);\\n                lines.add(newLine);\\n                newLine.tryAdd(word);\\n            }\\n        }\\n        \\n        Line last = lines.get(lines.size() - 1);\\n        last.flagAsLastWord();\\n        \\n        List<String> result = new ArrayList<>(lines.size());\\n        for (Line line : lines) {\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465043,
                "title": "java-simple-implementation-faster-than-100",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> list = new ArrayList<>();\\n        int i = 0;\\n        while(true){\\n            List<String> al = new ArrayList<>();\\n            int len = 0;\\n            while(i < words.length && len + words[i].length() <= maxWidth){\\n                al.add(words[i]);\\n                len += words[i].length() + 1;\\n                i++;\\n            }\\n            len--;\\n            int remLen = maxWidth - len;\\n            if(i == words.length){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n                break;\\n            } else if(al.size() == 1){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n            } else{\\n                int div = remLen / (al.size() - 1), rem = remLen % (al.size() - 1);\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    for(int k = 0; k < div; k++)\\n                        sb.append(\" \");\\n                    if(rem-- > 0)\\n                        sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                list.add(sb.toString());\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> list = new ArrayList<>();\\n        int i = 0;\\n        while(true){\\n            List<String> al = new ArrayList<>();\\n            int len = 0;\\n            while(i < words.length && len + words[i].length() <= maxWidth){\\n                al.add(words[i]);\\n                len += words[i].length() + 1;\\n                i++;\\n            }\\n            len--;\\n            int remLen = maxWidth - len;\\n            if(i == words.length){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n                break;\\n            } else if(al.size() == 1){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n            } else{\\n                int div = remLen / (al.size() - 1), rem = remLen % (al.size() - 1);\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    for(int k = 0; k < div; k++)\\n                        sb.append(\" \");\\n                    if(rem-- > 0)\\n                        sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                list.add(sb.toString());\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435489,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }\\n            bool isLast = (end == words.size());\\n            res.push_back(justify(words, start, end, maxWidth - total, isLast));\\n            start = end;\\n        }\\n        return res;\\n    }\\n    \\n    string justify(const vector<string>& words, int start, int end, int space, bool isLast) {\\n        string line;\\n        if (!isLast) {\\n            // eg: \"Science  is  what we\" maxwidth = 20\\n            // characters: 7 + 2 + 4 + 2 = 15\\n            // left = 20 - 15 = 5\\n            // 5/3 => 5 % 3 != 0? => space 1 = 5/3 + 1 = 2\\n            // 3/2 -> 3 % 2 != 0? => space 2 = 3/2 + 1 = 2\\n            // 1 => space 3 = 1\\n\\t\\t\\tint count = end - start - 1;  // number of space slots = number of words - 1\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (count > 0) {\\n                    int cur = space % count != 0? space/count + 1: space/count;\\n                    line.insert(line.end(), cur, \\' \\');\\n                    space -= cur;\\n                    --count;\\n                }\\n            }\\n        } else {\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (space-- > 0) line.push_back(\\' \\');\\n            }\\n        }\\n        if (space > 0) line.insert(line.end(), space, \\' \\');\\n        return line;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }\\n            bool isLast = (end == words.size());\\n            res.push_back(justify(words, start, end, maxWidth - total, isLast));\\n            start = end;\\n        }\\n        return res;\\n    }\\n    \\n    string justify(const vector<string>& words, int start, int end, int space, bool isLast) {\\n        string line;\\n        if (!isLast) {\\n            // eg: \"Science  is  what we\" maxwidth = 20\\n            // characters: 7 + 2 + 4 + 2 = 15\\n            // left = 20 - 15 = 5\\n            // 5/3 => 5 % 3 != 0? => space 1 = 5/3 + 1 = 2\\n            // 3/2 -> 3 % 2 != 0? => space 2 = 3/2 + 1 = 2\\n            // 1 => space 3 = 1\\n\\t\\t\\tint count = end - start - 1;  // number of space slots = number of words - 1\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (count > 0) {\\n                    int cur = space % count != 0? space/count + 1: space/count;\\n                    line.insert(line.end(), cur, \\' \\');\\n                    space -= cur;\\n                    --count;\\n                }\\n            }\\n        } else {\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (space-- > 0) line.push_back(\\' \\');\\n            }\\n        }\\n        if (space > 0) line.insert(line.end(), space, \\' \\');\\n        return line;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429859,
                "title": "simplest-and-cleanest-solutions-java-and-python",
                "content": "Java\\n```\\nclass Solution {\\n    public void appendSpaces(StringBuilder sb, int spaces) {\\n        for (int i = 0; i < spaces; i++) {\\n            sb.append(\\' \\');\\n        }\\n    }\\n    \\n    public String makeLeftJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        for (int i = 1; i < row.size(); i++) {\\n            sb.append(\\' \\');\\n            sb.append(row.get(i));\\n        }\\n        appendSpaces(sb, totalSpaces + 1 - row.size());\\n        return sb.toString();\\n    }\\n    \\n    public String makeJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        if (row.size() <= 1) {\\n            // only one word in row: left-justify\\n            appendSpaces(sb, totalSpaces);\\n        } else {\\n            int n = row.size() - 1;\\n            // distribute total spaces among n slots\\n            int q = totalSpaces / n;\\n            int r = totalSpaces % n;\\n            for (int i = 1; i <= n; i++) {\\n                int spaces = q + (i <= r ? 1 : 0);\\n                appendSpaces(sb, spaces);\\n                sb.append(row.get(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> row = new ArrayList<>();\\n        int charCount = 0;\\n        for (String word : words) {\\n            // check if we exceed maxWidth if we add word to the current row\\n            // remember that for k words, we need at least k-1 spaces\\n            if (charCount + word.length() + row.size() > maxWidth) {\\n                result.add(makeJustifiedLine(row, maxWidth - charCount));\\n                row.clear();\\n                charCount = 0;\\n            }\\n            row.add(word);\\n            charCount += word.length();\\n        }\\n        // last row is left-justified\\n        result.add(makeLeftJustifiedLine(row, maxWidth - charCount));\\n        return result;\\n    }\\n}\\n```\\nPython3\\n```\\n class Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def makeLeftJustifiedLine(wordsRow, totalSpaces):\\n            return \\' \\'.join(wordsRow) + (\\' \\' *  (totalSpaces + 1 - len(wordsRow)))\\n        def makeJustifiedLine(wordsRow, totalSpaces):\\n            l = len(wordsRow)\\n            if l <= 1:\\n                return \\'\\'.join(wordsRow) + (\\' \\' * totalSpaces)\\n            # distribute total spaces among l-1 slots\\n            q, r = divmod(totalSpaces, l-1)\\n            line = [wordsRow[0]]\\n            for i in range(1,l):\\n                spaces = q + (1 if i <= r else 0)\\n                line.append(\\' \\' * spaces)\\n                line.append(wordsRow[i])\\n            return \\'\\'.join(line)\\n        result = []\\n        row = []\\n        charCount = 0\\n        for word in words:\\n            # check if we exceed maxWidth if we add word to the current row\\n            # remember that for k words, we need at least k-1 spaces\\n            if charCount + len(word) + len(row) > maxWidth:\\n                result.append(makeJustifiedLine(row, maxWidth - charCount))\\n                row.clear()\\n                charCount = 0\\n            row.append(word)\\n            charCount += len(word)\\n        # last row is left-justified\\n        result.append(makeLeftJustifiedLine(row, maxWidth - charCount))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void appendSpaces(StringBuilder sb, int spaces) {\\n        for (int i = 0; i < spaces; i++) {\\n            sb.append(\\' \\');\\n        }\\n    }\\n    \\n    public String makeLeftJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        for (int i = 1; i < row.size(); i++) {\\n            sb.append(\\' \\');\\n            sb.append(row.get(i));\\n        }\\n        appendSpaces(sb, totalSpaces + 1 - row.size());\\n        return sb.toString();\\n    }\\n    \\n    public String makeJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        if (row.size() <= 1) {\\n            // only one word in row: left-justify\\n            appendSpaces(sb, totalSpaces);\\n        } else {\\n            int n = row.size() - 1;\\n            // distribute total spaces among n slots\\n            int q = totalSpaces / n;\\n            int r = totalSpaces % n;\\n            for (int i = 1; i <= n; i++) {\\n                int spaces = q + (i <= r ? 1 : 0);\\n                appendSpaces(sb, spaces);\\n                sb.append(row.get(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> row = new ArrayList<>();\\n        int charCount = 0;\\n        for (String word : words) {\\n            // check if we exceed maxWidth if we add word to the current row\\n            // remember that for k words, we need at least k-1 spaces\\n            if (charCount + word.length() + row.size() > maxWidth) {\\n                result.add(makeJustifiedLine(row, maxWidth - charCount));\\n                row.clear();\\n                charCount = 0;\\n            }\\n            row.add(word);\\n            charCount += word.length();\\n        }\\n        // last row is left-justified\\n        result.add(makeLeftJustifiedLine(row, maxWidth - charCount));\\n        return result;\\n    }\\n}\\n```\n```\\n class Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def makeLeftJustifiedLine(wordsRow, totalSpaces):\\n            return \\' \\'.join(wordsRow) + (\\' \\' *  (totalSpaces + 1 - len(wordsRow)))\\n        def makeJustifiedLine(wordsRow, totalSpaces):\\n            l = len(wordsRow)\\n            if l <= 1:\\n                return \\'\\'.join(wordsRow) + (\\' \\' * totalSpaces)\\n            # distribute total spaces among l-1 slots\\n            q, r = divmod(totalSpaces, l-1)\\n            line = [wordsRow[0]]\\n            for i in range(1,l):\\n                spaces = q + (1 if i <= r else 0)\\n                line.append(\\' \\' * spaces)\\n                line.append(wordsRow[i])\\n            return \\'\\'.join(line)\\n        result = []\\n        row = []\\n        charCount = 0\\n        for word in words:\\n            # check if we exceed maxWidth if we add word to the current row\\n            # remember that for k words, we need at least k-1 spaces\\n            if charCount + len(word) + len(row) > maxWidth:\\n                result.append(makeJustifiedLine(row, maxWidth - charCount))\\n                row.clear()\\n                charCount = 0\\n            row.append(word)\\n            charCount += len(word)\\n        # last row is left-justified\\n        result.append(makeLeftJustifiedLine(row, maxWidth - charCount))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331025,
                "title": "python-easy-to-understand",
                "content": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], max_width: int) -> List[str]:        \\n        def left_justify(line):\\n            tmp = \" \".join(line)\\n            return tmp + \" \" * (max_width - len(tmp))\\n\\n        def justify(line):\\n            number_of_spaces = len(line) - 1\\n            if number_of_spaces == 0:\\n                return left_justify(line)\\n            \\n            available_space = max_width - sum(len(w) for w in line)\\n            space_size = available_space // number_of_spaces\\n            extra = available_space % number_of_spaces\\n            \\n            result = \"\"\\n            for i, word in enumerate(line):\\n                result += word\\n                if i != len(line) - 1:\\n                    result += \" \" * (space_size + int(i < extra))\\n            return result\\n        \\n        result = []\\n        current = [words[0]]\\n        counter = len(words[0])\\n\\n        for word in words[1:]:\\n            if counter + 1 + len(word) <= max_width:\\n                current.append(word)\\n                counter += 1 + len(word)\\n            else:\\n                result.append(justify(current))\\n                current = [word]\\n                counter = len(word)\\n        \\n        result.append(left_justify(current))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], max_width: int) -> List[str]:        \\n        def left_justify(line):\\n            tmp = \" \".join(line)\\n            return tmp + \" \" * (max_width - len(tmp))\\n\\n        def justify(line):\\n            number_of_spaces = len(line) - 1\\n            if number_of_spaces == 0:\\n                return left_justify(line)\\n            \\n            available_space = max_width - sum(len(w) for w in line)\\n            space_size = available_space // number_of_spaces\\n            extra = available_space % number_of_spaces\\n            \\n            result = \"\"\\n            for i, word in enumerate(line):\\n                result += word\\n                if i != len(line) - 1:\\n                    result += \" \" * (space_size + int(i < extra))\\n            return result\\n        \\n        result = []\\n        current = [words[0]]\\n        counter = len(words[0])\\n\\n        for word in words[1:]:\\n            if counter + 1 + len(word) <= max_width:\\n                current.append(word)\\n                counter += 1 + len(word)\\n            else:\\n                result.append(justify(current))\\n                current = [word]\\n                counter = len(word)\\n        \\n        result.append(left_justify(current))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316379,
                "title": "java-solution-with-detailed-explanation-0ms-100-runtime-97-memory",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int wordCount = 0;\\n        int lastIndex = 0;\\n        int runningLength=0;\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            String s = words[i];\\n            /**\\n            * runningLength : total length of words until current word is added\\n            * s.length() : length of current word\\n            * wordCount : count of words till now (represents minimum spaces we would need with all the words already include)\\n            * Adding all of this tells us if current word can fit into current line\\n            *\\n            */\\n            if (runningLength + s.length() + wordCount > maxWidth) {\\n                //create a line since adding current word crosses the width\\n                int extraSpace = maxWidth - runningLength;\\n                // space per word, but not if wordCount is only 1                 \\n                int spw = wordCount > 1 ? extraSpace / (wordCount - 1) : 0;\\n                // left over spaces which need to be added 1 after each word until it last\\n                int los = wordCount > 1 ? extraSpace % (wordCount - 1) : 0;\\n                // construct line\\n                result.add(constructLine(words, lastIndex, wordCount, spw, los, maxWidth));\\n                // reset word count and running length\\n                wordCount = 0;\\n                runningLength = 0;\\n                // update last index to indicate index of word to start new line from\\n                lastIndex = i;\\n            }\\n            // add word length to running length\\n            runningLength += s.length();             \\n            wordCount ++;\\n        }\\n        // last line\\n        if (runningLength > 0) {\\n            result.add(constructLine(words, lastIndex, wordCount, 1, 0, maxWidth));\\n        }\\n        return result;\\n    }\\n    \\n    private String constructLine(String[] words, int li, int n, int spw, int los, int maxWidth) {\\n        StringBuffer sb = new StringBuffer();\\n        // start appending words in the line\\n        for (int i = li; i < li + n - 1; i ++) {\\n            sb.append(words[i]);\\n            // append `space per word` spaces after each word, until last word\\n            for (int j = 0; j < spw; j++) {\\n                sb.append(\" \");\\n            }\\n            // append one space from `left over space` after each word, and decrement left over space\\n            sb.append(los-- > 0 ? \" \" : \"\");\\n        }\\n        // append last word\\n        sb.append(words[li + n - 1]);\\n        \\n        // this is specifically for situation when line length still not matches width, append spaces at the end\\n        // Two situation can lead to this:\\n        // 1. line only has one word, so we are not adding any space from above logic\\n        // 2. its last line, so  we are only adding one space per word\\n        if (sb.length() < maxWidth) {\\n            int diff = maxWidth - sb.length();\\n            while (diff-- > 0) {\\n                sb.append(\" \");\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int wordCount = 0;\\n        int lastIndex = 0;\\n        int runningLength=0;\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            String s = words[i];\\n            /**\\n            * runningLength : total length of words until current word is added\\n            * s.length() : length of current word\\n            * wordCount : count of words till now (represents minimum spaces we would need with all the words already include)\\n            * Adding all of this tells us if current word can fit into current line\\n            *\\n            */\\n            if (runningLength + s.length() + wordCount > maxWidth) {\\n                //create a line since adding current word crosses the width\\n                int extraSpace = maxWidth - runningLength;\\n                // space per word, but not if wordCount is only 1                 \\n                int spw = wordCount > 1 ? extraSpace / (wordCount - 1) : 0;\\n                // left over spaces which need to be added 1 after each word until it last\\n                int los = wordCount > 1 ? extraSpace % (wordCount - 1) : 0;\\n                // construct line\\n                result.add(constructLine(words, lastIndex, wordCount, spw, los, maxWidth));\\n                // reset word count and running length\\n                wordCount = 0;\\n                runningLength = 0;\\n                // update last index to indicate index of word to start new line from\\n                lastIndex = i;\\n            }\\n            // add word length to running length\\n            runningLength += s.length();             \\n            wordCount ++;\\n        }\\n        // last line\\n        if (runningLength > 0) {\\n            result.add(constructLine(words, lastIndex, wordCount, 1, 0, maxWidth));\\n        }\\n        return result;\\n    }\\n    \\n    private String constructLine(String[] words, int li, int n, int spw, int los, int maxWidth) {\\n        StringBuffer sb = new StringBuffer();\\n        // start appending words in the line\\n        for (int i = li; i < li + n - 1; i ++) {\\n            sb.append(words[i]);\\n            // append `space per word` spaces after each word, until last word\\n            for (int j = 0; j < spw; j++) {\\n                sb.append(\" \");\\n            }\\n            // append one space from `left over space` after each word, and decrement left over space\\n            sb.append(los-- > 0 ? \" \" : \"\");\\n        }\\n        // append last word\\n        sb.append(words[li + n - 1]);\\n        \\n        // this is specifically for situation when line length still not matches width, append spaces at the end\\n        // Two situation can lead to this:\\n        // 1. line only has one word, so we are not adding any space from above logic\\n        // 2. its last line, so  we are only adding one space per word\\n        if (sb.length() < maxWidth) {\\n            int diff = maxWidth - sb.length();\\n            while (diff-- > 0) {\\n                sb.append(\" \");\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242044,
                "title": "easy-to-understand-java-solution-with-comments",
                "content": "Ask of the problem is to justify the words on each line. For the solution, we will try to place each word on the current line. We will try to fit as many words as we can on each line by trying to keep \"at least one space\" between each word.\\n\\nLogic is straightforward:\\n*  Iterate over each word and ask:\\n\\t*  Can this word \"fit\" on the current line?\\n\\t\\t*  If yes, add it to the sentence list, reduce the remaining characters\\n\\t\\t*  If no, Justify all the words added so far in the sentence and reiterate on this word so that it can be considered for next line\\n\\t\\t\\t*  If there\\'s only one word on this line, we leftJustify() it\\n\\t\\t\\t*  For more than one word, we fullJustify() them\\n*  How do we determine whether the current word will \"fit\" on the current line?\\n\\t*  By comparing the length of the current word with the remaining character count\\n\\t*  if the word.length() <= remaining, it fits\\n\\t*  In this case, remaining = remaining - (word.length()+1)\\n\\t*  Why + 1 ? Because there must be \"at least one space\" between this word and next word\\n*  What about the last line?\\n\\t*  In case of the last line, we will reach the end of the array and there will be still some words in the sentence list, we will simply call leftJustify()\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        //Stores num of words on each line in the output\\n        int numWords = 0;\\n        //Stores the sum of lengths of all the words on a line in the output - Doesn\\'t account for spaces\\n        int sum = 0;\\n        //Stores how many more characters are remaining on the current line of the output\\n        int remaining = maxWidth;\\n        //Stores all the words that will go on the current line of the output\\n        List<String> sentence = new ArrayList<>();\\n        for(int i = 0; i < words.length; i++) {\\n            //Checks if the word can be chosen for current line\\n            if(words[i].length() <= remaining) {\\n                //If the word is chosen for current line, add it to sentence list\\n                sentence.add(words[i]);\\n                //Remaining = Remaining - size of the word + 1 character for space after it\\n                remaining -= (words[i].length()+1);\\n                //Increasing num of words on this line of the output\\n                numWords++;\\n                //sum = sum of length of all the words on current line + length of chosen word\\n                sum += words[i].length();\\n            }\\n            //If the word can\\'t fit on the current line, Justify the words of current line and\\n            //Iterate over this word again to consider it for next line\\n            else {\\n                //Checking if the line has more than 1 word\\n                if(numWords > 1) {\\n                    //space[] stores the number of space between each word\\n                    //Total number of spaces = maxWidth-sum\\n                    //Total number of slots for spaces = numWords - 1\\n                    //eg: \"Science is what we\" - numWords = 4, total slots for spaces = 4-1 = 3 (between each word)\\n                    int[] space = new int[numWords-1];\\n                    calcSpaces(space, maxWidth-sum);\\n                    res.add(fullJustify(sentence, space));\\n                } else {\\n                    res.add(leftJustify(sentence, maxWidth));\\n                }\\n                //Since the current word was not taken on current line, we need to reiterate on this word, therefore --i\\n                --i;\\n                //Reinitializing all the counters for next line\\n                sum = 0;\\n                numWords = 0;\\n                remaining = maxWidth;\\n                sentence = new ArrayList<>();\\n            }\\n        }\\n        //If the sentence still has words, then leftJustify the sentence\\n        //Eg: \"Leetcode is fun\", maxWidth = 20\\n        //All the words fit on same line, so leftJustify. This is also useful for last line of the output\\n        if(!sentence.isEmpty()) {\\n            res.add(leftJustify(sentence, maxWidth));\\n        }\\n        return res;\\n    }\\n    \\n    void calcSpaces(int[] space, int numSpace) {\\n        int n = space.length;\\n        Arrays.fill(space, numSpace/n);\\n        int remaining = numSpace%n;\\n        int i = 0;\\n        while(remaining > 0) {\\n            space[i]++;\\n            ++i;\\n            --remaining;\\n        }\\n    }\\n    \\n    String leftJustify(List<String> sentence, int maxWidth) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String w : sentence) {\\n            sb.append(w).append(\" \");\\n        }\\n        //In case the last character of the last word of the sentence occupy maxWidth, we don\\'t need that leading space, so removing it\\n        sb.deleteCharAt(sb.length()-1);\\n        //Padding with spaces to reach maxWidth\\n        while(sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    String fullJustify(List<String> sentence, int[] space) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < sentence.size()-1; i++) {\\n            sb.append(sentence.get(i));\\n            while(space[i] > 0) {\\n                sb.append(\" \");\\n                space[i]--;\\n            }\\n        }\\n        sb.append(sentence.get(sentence.size()-1));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        //Stores num of words on each line in the output\\n        int numWords = 0;\\n        //Stores the sum of lengths of all the words on a line in the output - Doesn\\'t account for spaces\\n        int sum = 0;\\n        //Stores how many more characters are remaining on the current line of the output\\n        int remaining = maxWidth;\\n        //Stores all the words that will go on the current line of the output\\n        List<String> sentence = new ArrayList<>();\\n        for(int i = 0; i < words.length; i++) {\\n            //Checks if the word can be chosen for current line\\n            if(words[i].length() <= remaining) {\\n                //If the word is chosen for current line, add it to sentence list\\n                sentence.add(words[i]);\\n                //Remaining = Remaining - size of the word + 1 character for space after it\\n                remaining -= (words[i].length()+1);\\n                //Increasing num of words on this line of the output\\n                numWords++;\\n                //sum = sum of length of all the words on current line + length of chosen word\\n                sum += words[i].length();\\n            }\\n            //If the word can\\'t fit on the current line, Justify the words of current line and\\n            //Iterate over this word again to consider it for next line\\n            else {\\n                //Checking if the line has more than 1 word\\n                if(numWords > 1) {\\n                    //space[] stores the number of space between each word\\n                    //Total number of spaces = maxWidth-sum\\n                    //Total number of slots for spaces = numWords - 1\\n                    //eg: \"Science is what we\" - numWords = 4, total slots for spaces = 4-1 = 3 (between each word)\\n                    int[] space = new int[numWords-1];\\n                    calcSpaces(space, maxWidth-sum);\\n                    res.add(fullJustify(sentence, space));\\n                } else {\\n                    res.add(leftJustify(sentence, maxWidth));\\n                }\\n                //Since the current word was not taken on current line, we need to reiterate on this word, therefore --i\\n                --i;\\n                //Reinitializing all the counters for next line\\n                sum = 0;\\n                numWords = 0;\\n                remaining = maxWidth;\\n                sentence = new ArrayList<>();\\n            }\\n        }\\n        //If the sentence still has words, then leftJustify the sentence\\n        //Eg: \"Leetcode is fun\", maxWidth = 20\\n        //All the words fit on same line, so leftJustify. This is also useful for last line of the output\\n        if(!sentence.isEmpty()) {\\n            res.add(leftJustify(sentence, maxWidth));\\n        }\\n        return res;\\n    }\\n    \\n    void calcSpaces(int[] space, int numSpace) {\\n        int n = space.length;\\n        Arrays.fill(space, numSpace/n);\\n        int remaining = numSpace%n;\\n        int i = 0;\\n        while(remaining > 0) {\\n            space[i]++;\\n            ++i;\\n            --remaining;\\n        }\\n    }\\n    \\n    String leftJustify(List<String> sentence, int maxWidth) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String w : sentence) {\\n            sb.append(w).append(\" \");\\n        }\\n        //In case the last character of the last word of the sentence occupy maxWidth, we don\\'t need that leading space, so removing it\\n        sb.deleteCharAt(sb.length()-1);\\n        //Padding with spaces to reach maxWidth\\n        while(sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    String fullJustify(List<String> sentence, int[] space) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < sentence.size()-1; i++) {\\n            sb.append(sentence.get(i));\\n            while(space[i] > 0) {\\n                sb.append(\" \");\\n                space[i]--;\\n            }\\n        }\\n        sb.append(sentence.get(sentence.size()-1));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228647,
                "title": "thinking-process-greedy-approach",
                "content": "**Insights from problem description:**\\n* Two types of line to form\\n\\t* Fully-Justified (all lines except last line)\\n\\t* Left-justified (last line)\\n\\n**For each fully justified line, we can form the line in greedy way**- \\n1. Include as many word as possible in the current line where consecuative words are separated by single space until current line length smaller than maxWidth\\n2. Add one more word in current line and If **currentLineLength == maxWidth**, current line fits in the maxWidth perfectly where consecuative words in current line are separated by single space. Add this line to final result. \\n3. Add one more word in current line and If **current Line Length exceeds maxWidth**, exclude last added word from the current line-\\n\\t1. Distribute remaining-width-to-fill number of space evenly among each space placeholder of current line. **Number of space placeholder in current line = number of word in current line - 1**\\n\\t2. Number of space in each space placeholder = **((maxWidth - currentLineLength) // ( Number of space placeholder in current line)) +1**\\n\\t3. If there are some width to fill up ( **(maxWidth - currentLineLength)% ( Number of space placeholder in current line)** ) which can not be distributed evenly among each space placeholder of current line, distribute it from leftmost space placeholder to rightmost space placeholder of current line\\n\\n**For the last line which is left-justified**, \\n1. Include all remaining words in the current line where consecuative words are sperated by single space\\n2. Add  **(maxWidth - currentLineLength)** number of space at the end of current line\\n\\n**Time Complexity**:\\nWe have to traverse the words list at most 2 times and for each word, we have to calculate corresponding word length. Thus, the time complexity will be **O(len(words) * maxWordLen)**.\\n\\n**Space Complexity**:\\nWe are not using any additional space except the list to store the final result. In the worst case, each word in the words list can form a  line. Thus, **O(len(words) * maxWidth)**.\\n\\n**Code**\\n```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] #final result\\n        currentLine = \\'\\'\\n        left = 0 # tracks first word in current line\\n        \\n        currentLineLength = 0\\n        remainingWidth = 0 \\n        \\n        firstWord = True\\n        wordsLen = len(words)\\n        \\n        for i in range(wordsLen):\\n            wordLen = len(words[i])  \\n            \\n            # First word of the current line\\n            if firstWord:\\n                firstWord = False\\n                currentLineLength = wordLen\\n                left = i\\n            \\n            # Adding words[i] and a single space in the current line exceeds the maxWidth, thus words[i] will not be included in current line\\n            elif currentLineLength + 1 + wordLen > maxWidth:\\n                #  wordCount = number of words in the current line\\n                wordCount = i - left\\n                \\n                # For all lines except last line, distribute remaining width evenly among the each space placeholder\\n                if wordCount > 1: \\n                    # Number of space in each space placeholder = (remaining place to fill // (number of space placeholder)) + 1 (single space counted in currentLineLength). This is evenly distributed space\\n                    # Number of space placeholder in the current line = wordCount - 1 \\n                    totalSpaceInEachPlaceHolder = ((maxWidth - currentLineLength) // (wordCount - 1)) + 1 \\n            \\n                    # remainingWidth number of space can not be distributed evenly\\n                    remainingWidth = (maxWidth - currentLineLength) % (wordCount - 1)\\n                    \\n                else:\\n                    # Current line contains single word, thus 0 space placeHolder\\n                    totalSpaceInEachPlaceHolder = 0\\n                    remainingWidth = maxWidth - currentLineLength\\n                    \\n                line = words[left]\\n                left += 1\\n                \\n                # Process the current line and add it to final result\\n                # For fully-justified lines(all lines except last line), we have to distribute remainingWidth number of space to the space placeholder from leftmost space placeholder of current line to right\\n                while left < i:\\n                    line += (\" \"* totalSpaceInEachPlaceHolder)\\n                    if remainingWidth > 0:\\n                        line += \" \"\\n                        remainingWidth -= 1\\n                    line += words[left]\\n                    left += 1\\n                    \\n                if remainingWidth > 0:\\n                    line += (\" \"* remainingWidth)\\n                if line:\\n                    lines.append(line)\\n                \\n                currentLineLength = wordLen\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] fits perfectly in the maxWidth. Start new line after processing this line\\n            elif currentLineLength + 1 + wordLen == maxWidth:\\n                lines.append(\" \".join(words[left:i+1]))\\n                firstWord = True\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] does not fill upto maxWidth. Add one space and current word to the current line\\n            else:\\n                currentLineLength += 1 + wordLen\\n        \\n        # All words are processed and no remaingwidth to fill with space\\n        if firstWord:\\n            return lines\\n        \\n        \\n        # Process the last line. \\n        # It is left-justified: Add single space between consecutive word and remainingWidth number of space at the end\\n        wordCount = wordsLen - left\\n        if wordCount > 1:\\n            totalSpaceInEachPlaceHolder =  1\\n        else:\\n            totalSpaceInEachPlaceHolder = 0\\n            \\n        remainingWidth = maxWidth - currentLineLength\\n        line = words[left]\\n        left += 1\\n\\n        # Add single space between consecutive word of last line\\n        while left < wordsLen:\\n            line += (\" \"* totalSpaceInEachPlaceHolder)\\n            line += words[left]\\n            left += 1\\n\\n        # Add remainingWidth number of space at the end of last line\\n        if remainingWidth > 0:\\n            line += (\" \"* remainingWidth)\\n        if line:\\n            lines.append(line)\\n            \\n        return lines\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] #final result\\n        currentLine = \\'\\'\\n        left = 0 # tracks first word in current line\\n        \\n        currentLineLength = 0\\n        remainingWidth = 0 \\n        \\n        firstWord = True\\n        wordsLen = len(words)\\n        \\n        for i in range(wordsLen):\\n            wordLen = len(words[i])  \\n            \\n            # First word of the current line\\n            if firstWord:\\n                firstWord = False\\n                currentLineLength = wordLen\\n                left = i\\n            \\n            # Adding words[i] and a single space in the current line exceeds the maxWidth, thus words[i] will not be included in current line\\n            elif currentLineLength + 1 + wordLen > maxWidth:\\n                #  wordCount = number of words in the current line\\n                wordCount = i - left\\n                \\n                # For all lines except last line, distribute remaining width evenly among the each space placeholder\\n                if wordCount > 1: \\n                    # Number of space in each space placeholder = (remaining place to fill // (number of space placeholder)) + 1 (single space counted in currentLineLength). This is evenly distributed space\\n                    # Number of space placeholder in the current line = wordCount - 1 \\n                    totalSpaceInEachPlaceHolder = ((maxWidth - currentLineLength) // (wordCount - 1)) + 1 \\n            \\n                    # remainingWidth number of space can not be distributed evenly\\n                    remainingWidth = (maxWidth - currentLineLength) % (wordCount - 1)\\n                    \\n                else:\\n                    # Current line contains single word, thus 0 space placeHolder\\n                    totalSpaceInEachPlaceHolder = 0\\n                    remainingWidth = maxWidth - currentLineLength\\n                    \\n                line = words[left]\\n                left += 1\\n                \\n                # Process the current line and add it to final result\\n                # For fully-justified lines(all lines except last line), we have to distribute remainingWidth number of space to the space placeholder from leftmost space placeholder of current line to right\\n                while left < i:\\n                    line += (\" \"* totalSpaceInEachPlaceHolder)\\n                    if remainingWidth > 0:\\n                        line += \" \"\\n                        remainingWidth -= 1\\n                    line += words[left]\\n                    left += 1\\n                    \\n                if remainingWidth > 0:\\n                    line += (\" \"* remainingWidth)\\n                if line:\\n                    lines.append(line)\\n                \\n                currentLineLength = wordLen\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] fits perfectly in the maxWidth. Start new line after processing this line\\n            elif currentLineLength + 1 + wordLen == maxWidth:\\n                lines.append(\" \".join(words[left:i+1]))\\n                firstWord = True\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] does not fill upto maxWidth. Add one space and current word to the current line\\n            else:\\n                currentLineLength += 1 + wordLen\\n        \\n        # All words are processed and no remaingwidth to fill with space\\n        if firstWord:\\n            return lines\\n        \\n        \\n        # Process the last line. \\n        # It is left-justified: Add single space between consecutive word and remainingWidth number of space at the end\\n        wordCount = wordsLen - left\\n        if wordCount > 1:\\n            totalSpaceInEachPlaceHolder =  1\\n        else:\\n            totalSpaceInEachPlaceHolder = 0\\n            \\n        remainingWidth = maxWidth - currentLineLength\\n        line = words[left]\\n        left += 1\\n\\n        # Add single space between consecutive word of last line\\n        while left < wordsLen:\\n            line += (\" \"* totalSpaceInEachPlaceHolder)\\n            line += words[left]\\n            left += 1\\n\\n        # Add remainingWidth number of space at the end of last line\\n        if remainingWidth > 0:\\n            line += (\" \"* remainingWidth)\\n        if line:\\n            lines.append(line)\\n            \\n        return lines\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1160268,
                "title": "python-solution-easy-to-understand",
                "content": "Got this question in an interview then worked on my solution to get it to work! Not as complicated once I understood the problem! Split the problem into first how to parse the string and decide what goes into a line, then how to actually add the spaces. Then I do the last line seperately since it\\'s dealt with differently! \\n\\n\\t output_string = []\\n        \\n        #figure out how many can fit in a line (less than the width)\\n        curr_word_pos = 0 \\n        curr_width = 0\\n        curr_line = []\\n\\n        while curr_word_pos < len(words):\\n\\n            curr_word = words[curr_word_pos]\\n\\n            #if curr word can fit (without space b/c might be last word in line), then add to curr_line list and move position to next word\\n            if (curr_width+len(curr_word)) <= maxWidth: \\n                \\n                                  \\n                curr_line.append(curr_word)\\n                \\n                curr_width+=len(curr_word) + 1\\n                \\n                curr_word_pos +=1\\n                \\n            \\n            #no space left, process current words into line\\n            else: \\n\\n                #process the line, add spaces, \\n                spaces = maxWidth - curr_width + len(curr_line)\\n                \\n                #go through all left over spaces and add behind each word that isn\\'t the last one\\n                added = 0\\n                pos = 0\\n            \\n                while (added < spaces):\\n\\n                    #avoid last word\\n                    if pos >= len(curr_line)-1:\\n                        pos = 0\\n                        \\n                    curr_line[pos] += \" \"\\n                    added +=1\\n                    pos+=1\\n                    \\n                #building a string of the curr line and appending to output array\\n                output_string.append(\"\".join(curr_line))\\n                    \\n                #reset these for the next line \\n                curr_line = []\\n                curr_width  = 0\\n           \\n        \\n        #add each word with normal number of spaces for last line\\n        for word in range(len(curr_line)-1):\\n\\n            curr_line[word] +=\" \"\\n        \\n        #add all extra spaces to last line\\n        curr_line[-1]+=(maxWidth-curr_width+1)*\" \"\\n                \\n        output_string.append(\"\".join(curr_line))\\n            \\n        return output_string",
                "solutionTags": [
                    "Python"
                ],
                "code": "Got this question in an interview then worked on my solution to get it to work! Not as complicated once I understood the problem! Split the problem into first how to parse the string and decide what goes into a line, then how to actually add the spaces. Then I do the last line seperately since it\\'s dealt with differently! \\n\\n\\t output_string = []\\n        \\n        #figure out how many can fit in a line (less than the width)\\n        curr_word_pos = 0 \\n        curr_width = 0\\n        curr_line = []\\n\\n        while curr_word_pos < len(words):\\n\\n            curr_word = words[curr_word_pos]\\n\\n            #if curr word can fit (without space b/c might be last word in line), then add to curr_line list and move position to next word\\n            if (curr_width+len(curr_word)) <= maxWidth: \\n                \\n                                  \\n                curr_line.append(curr_word)\\n                \\n                curr_width+=len(curr_word) + 1\\n                \\n                curr_word_pos +=1\\n                \\n            \\n            #no space left, process current words into line\\n            else: \\n\\n                #process the line, add spaces, \\n                spaces = maxWidth - curr_width + len(curr_line)\\n                \\n                #go through all left over spaces and add behind each word that isn\\'t the last one\\n                added = 0\\n                pos = 0\\n            \\n                while (added < spaces):\\n\\n                    #avoid last word\\n                    if pos >= len(curr_line)-1:\\n                        pos = 0\\n                        \\n                    curr_line[pos] += \" \"\\n                    added +=1\\n                    pos+=1\\n                    \\n                #building a string of the curr line and appending to output array\\n                output_string.append(\"\".join(curr_line))\\n                    \\n                #reset these for the next line \\n                curr_line = []\\n                curr_width  = 0\\n           \\n        \\n        #add each word with normal number of spaces for last line\\n        for word in range(len(curr_line)-1):\\n\\n            curr_line[word] +=\" \"\\n        \\n        #add all extra spaces to last line\\n        curr_line[-1]+=(maxWidth-curr_width+1)*\" \"\\n                \\n        output_string.append(\"\".join(curr_line))\\n            \\n        return output_string",
                "codeTag": "Unknown"
            },
            {
                "id": 1126418,
                "title": "javascript-easy-to-understand-99-4",
                "content": "![image](https://assets.leetcode.com/users/images/3ec3ac94-a3bd-46bc-8c48-5a3668d3877c_1616683285.730853.png)\\n\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    let currentLine = \\'\\', lines = [];\\n\\t//Group words into lines.\\n    for (const word of words) {\\n        if (!currentLine.length) currentLine += word;\\n        else if (word.length + 1 + currentLine.length <= maxWidth) currentLine += \\' \\' + word\\n        else {\\n            lines.push(currentLine);\\n            currentLine = word\\n        }\\n    }\\n    lines.push(currentLine)\\n    for (let i = 0; i < lines.length; i++) {\\n\\t\\t//Handle Last Line\\n        if (i === lines.length - 1) {\\n            lines[i] = lines[i] + \\' \\'.repeat(maxWidth - lines[i].length)\\n        } else {\\n            currentLine = lines[i];\\n            const lineLen = lines[i].replace(/[ ]/g, \\'\\').length;\\n\\t\\t\\t//Below handles if line only has one word. currLine.length - lineLen gives # of spaces on line.\\n            //If they are ===, then line has no spaces.  \\n            if (currentLine.length === lineLen) {\\n                currentLine = currentLine + \\' \\'.repeat(maxWidth - lineLen)\\n            } else {\\n                //This block handles regular lines with spaces.  Replace all spaces with biggest\\n\\t\\t\\t\\t//necessary space, then remove from right to left until lineWidth === maxWidth.\\n                //RepeatSpaces is the size of the largest space in the line.\\n                const repeatSpaces = Math.ceil((maxWidth - lineLen) / (lines[i].length - lineLen));\\n                currentLine = currentLine.replace(/[ ]/g, \\' \\'.repeat(repeatSpaces));\\n                while (currentLine.length > maxWidth) {\\n                    let spacePos = currentLine.lastIndexOf(\\' \\'.repeat(repeatSpaces));\\n                    currentLine = currentLine.substring(0, spacePos) + currentLine.substring(spacePos + 1)\\n                }\\n            }\\n            lines[i] = currentLine\\n        }\\n    }\\n    return lines\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar fullJustify = function(words, maxWidth) {\\n    let currentLine = \\'\\', lines = [];\\n\\t//Group words into lines.\\n    for (const word of words) {\\n        if (!currentLine.length) currentLine += word;\\n        else if (word.length + 1 + currentLine.length <= maxWidth) currentLine += \\' \\' + word\\n        else {\\n            lines.push(currentLine);\\n            currentLine = word\\n        }\\n    }\\n    lines.push(currentLine)\\n    for (let i = 0; i < lines.length; i++) {\\n\\t\\t//Handle Last Line\\n        if (i === lines.length - 1) {\\n            lines[i] = lines[i] + \\' \\'.repeat(maxWidth - lines[i].length)\\n        } else {\\n            currentLine = lines[i];\\n            const lineLen = lines[i].replace(/[ ]/g, \\'\\').length;\\n\\t\\t\\t//Below handles if line only has one word. currLine.length - lineLen gives # of spaces on line.\\n            //If they are ===, then line has no spaces.  \\n            if (currentLine.length === lineLen) {\\n                currentLine = currentLine + \\' \\'.repeat(maxWidth - lineLen)\\n            } else {\\n                //This block handles regular lines with spaces.  Replace all spaces with biggest\\n\\t\\t\\t\\t//necessary space, then remove from right to left until lineWidth === maxWidth.\\n                //RepeatSpaces is the size of the largest space in the line.\\n                const repeatSpaces = Math.ceil((maxWidth - lineLen) / (lines[i].length - lineLen));\\n                currentLine = currentLine.replace(/[ ]/g, \\' \\'.repeat(repeatSpaces));\\n                while (currentLine.length > maxWidth) {\\n                    let spacePos = currentLine.lastIndexOf(\\' \\'.repeat(repeatSpaces));\\n                    currentLine = currentLine.substring(0, spacePos) + currentLine.substring(spacePos + 1)\\n                }\\n            }\\n            lines[i] = currentLine\\n        }\\n    }\\n    return lines\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059497,
                "title": "javascript-solution-iterative-98-48-faster-76-06-less-memory-usage",
                "content": "```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 907092,
                "title": "java-1ms-fast-solution-explained",
                "content": "If you found the solution helpful, kindly upvote. :)\\n\\n        METHOD:\\n        1. We need to check where the words length exceeds the maxWidth. When that happens, we need to add it to the result.\\n        2. During adding spaces, there are 2 allignments to consider:\\n            a. Left justify: (use in last line, or the lines where there is only one word) In this, the spaces will be at the end of the list\\n            b. Middle justify: in this, the spaces will be equally distributed in between the words. If there are any extra spaces, \\n            those will be added from left to right.\\n            Eg: if there are 3 words and 5 spaces\\n            word1_ _ _word2_ _word3\\n\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n                /*\\n        */\\n        List<String> result= new ArrayList<>();  \\n        //We need to traverse the list to see upto where the words can be added\\n        int i=0; \\n        while(i<words.length){\\n            int j= i+1;\\n            //Initially the linelength just has the length of the word at position i\\n            int linelength= words[i].length();\\n            //Here, j+i-1 is the minimum spaces required between the words\\n            while(j<words.length && (linelength+words[j].length()+(j-i-1)<maxWidth)){\\n                linelength+= words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth-linelength;\\n            int numberOfWords=j-i;\\n            //Checking for the left justify case\\n            if(numberOfWords==1 || j >= words.length) result.add(leftJustify(words, diff,i,j));\\n            else result.add(middleJustify(words, diff,i,j));    \\n\\n            i=j;\\n        }\\n        return result;\\n    }\\n\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        //Groups of spaces we need (equal to number of words-1)\\n        int groupSpaces= j-i-1;\\n        //Spaces minimum after every word\\n        int space= diff/groupSpaces;\\n        //The extra spaces left which would be added from the left to right\\n        int extraSpace= diff%groupSpaces;\\n        \\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //The spaces required after every word \\n            int spacesApply= space+(extraSpace-- >0 ? 1:0);\\n            str.append(\" \".repeat(spacesApply)+words[k]);\\n        }\\n        return str.toString();\\n    }\\n\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        //number of spaces which are going to be at the end\\n        int rightSpaces= diff-(j-i-1);\\n        //Initially add the string at position i\\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //Adding 1 space after the word\\n            str.append(\" \"+words[k]);\\n        }\\n        //Add the extra spaces in the end\\n        str.append(\" \".repeat(rightSpaces));\\n        return str.toString();\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n                /*\\n        */\\n        List<String> result= new ArrayList<>();  \\n        //We need to traverse the list to see upto where the words can be added\\n        int i=0; \\n        while(i<words.length){\\n            int j= i+1;\\n            //Initially the linelength just has the length of the word at position i\\n            int linelength= words[i].length();\\n            //Here, j+i-1 is the minimum spaces required between the words\\n            while(j<words.length && (linelength+words[j].length()+(j-i-1)<maxWidth)){\\n                linelength+= words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth-linelength;\\n            int numberOfWords=j-i;\\n            //Checking for the left justify case\\n            if(numberOfWords==1 || j >= words.length) result.add(leftJustify(words, diff,i,j));\\n            else result.add(middleJustify(words, diff,i,j));    \\n\\n            i=j;\\n        }\\n        return result;\\n    }\\n\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        //Groups of spaces we need (equal to number of words-1)\\n        int groupSpaces= j-i-1;\\n        //Spaces minimum after every word\\n        int space= diff/groupSpaces;\\n        //The extra spaces left which would be added from the left to right\\n        int extraSpace= diff%groupSpaces;\\n        \\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //The spaces required after every word \\n            int spacesApply= space+(extraSpace-- >0 ? 1:0);\\n            str.append(\" \".repeat(spacesApply)+words[k]);\\n        }\\n        return str.toString();\\n    }\\n\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        //number of spaces which are going to be at the end\\n        int rightSpaces= diff-(j-i-1);\\n        //Initially add the string at position i\\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //Adding 1 space after the word\\n            str.append(\" \"+words[k]);\\n        }\\n        //Add the extra spaces in the end\\n        str.append(\" \".repeat(rightSpaces));\\n        return str.toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833996,
                "title": "easy-explanation-with-algorithm-and-code-c",
                "content": "The question seems quite difficult,but when u understand its simple. Basically u have to fit as many words as possible in single line with even spacing between them,if a word dosen\\'t fit it will go to next line.\\nRefernce Example:\\n```\\nwords = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\\nmaxWidth = 16\\n```\\n1. To make this possible we have to do a greedy approach,fit as many words in a line with single space between words, we take single space because if we have words whose toatl length is equal to maxWidth then we cant add spaces and will look like \"thisisanexample\".\\n In above example we can fit \"this,is,an\",if we try to fit \"example\" it will exceed maxWidth. So we know first line consits of \"this\",\"is\",\"an\".\\nFor this line we have to add spaces evenly between words until it reaches maxWidth.\\nSo for `\"This\",\"is\",\"an\"` should be a string `\"This     is    an\"` which has length == maxWidth.\\n3. Now we know how we can justify a line ,we need to form these lines\\n\\nAlgorithm\\n```\\nresult=[]                //To store the justified lines\\ncur_line=[]             //this is store the words in current line\\nnum_of_letters=0       // number of letters in current line  \\nIterate each word in input:\\n\\tcheck if we add word to cur_line exceeds maxWidth:\\n\\t\\tif it exceeds : \\n\\t\\t\\tadd spaces evenly to current line and add it result\\n\\t\\t\\tSince we are done with cur_line we empty it and set num_of_letters to 0\\n\\t\\tadd the word to cur_line                          //if the word exceeds maxWidth this word will be added to a newline beacuse we reset cur_line in previous step\\n\\t\\tadd num_of_letters with length of word\\nafter iterating all words check if cur_line is empty      // we add line to result only when it exceeds maxWidth,but when we finish all words some words might be left in cur_line\\nif not empty :\\n\\tadd spaces and add to result \\n\\nreturn result\\n```\\nNow u know approach try it, if u get stuck continue reading\\n* **Formula to check whether word will fit in cur_line** : `num_of_letters+len(word) + len(cur_line) > maxWidth`\\n\\tKeep in mind len(cur_line) is number of words in cur_line,so if there are two words it translates to single spaces between words after adding third word.\\n\\tUnderstand above statement properly,u are doing this in greedy approach words should have atleast a single space between them.\\n\\tEx: \\n\\t`cur_line=\"this\",is\",\"an\"` and  word to be added `\"example\"` then condition will be\\n\\tnum_of_letters=8, len(word)=len(\"example\")=7,len(cur_line)=3 so 8+3+7>16 so we break the line and add \"example\" to next Line.\\n\\t\"this is an example\" >16 (adding example will make line>maxWidth)\\n*  **How to justify a line** :To do that we need to find number of spaces to insert so it reaches maxWidth, so `maxWidth - num_of_letters (in cur_line) ` gives it.\\nSay we have 4 words (u have to fill 3 spots ) and 5 spaces to add to reach maxWidth,we need to distribute evenly from left to right according to question, so (2,2,1) will be spacing between them.(Think of adding 5 stones to 3 containers from left to right one at a time ,at end how many stones are in each container?)\\ndivide the number of spaces to add by (num of words -1) .\\nThe Qutioent is space to be added between words.\\nThe remainder is extra spaces we need to distribute from left to right one at a time (Think of stones 5/3=1 , 5%3=2 so first two containers will have extra one stone (1+1, 1+1, 1).\\nTo make it simple u are adding spaces in Round robin fashion,just to do it in one step we divide and use qutieont and remainder.\\n**A corner case while justifying is what if that line has only word then we need to add empty spaces until it reaches maxWidth**\\nWhile justifying last line a single space between words is enough with last word appended with spaces to cover maxWidth. (Last line should be left justified according to Problem)\\n\\n\\n\\nCode in C++\\n```\\nstring fillSpaces(vector<string> line,int num_letters, int maxWidth){\\n        string res;\\n        int spaces_to_add=maxWidth-num_letters;\\n        int between_space=spaces_to_add/(line.size()-1);\\n        int extra_spaces=spaces_to_add%(line.size()-1);\\n        for(int i=0;i<line.size()-1;i++){\\n            res+=line[i] + string(between_space,\\' \\')+ string(extra_spaces?1:0,\\' \\');\\n            if(extra_spaces>0) extra_spaces--;\\n        }\\n        res+=line.back();\\n        \\n        return res;\\n    }\\n    \\n    \\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        vector<string> line;\\n        int cur_letters = 0;\\n        for(auto word:words){\\n            if(cur_letters + word.length() + line.size() > maxWidth){   \\n                if(line.size()==1){\\n                    res.push_back(line[0]+string(maxWidth-cur_letters,\\' \\'));  //corner case\\n                }\\n                else\\n                   res.push_back(fillSpaces(line,cur_letters,maxWidth)); \\n                cur_letters=0;\\n                line.clear();\\n                \\n            }\\n            line.push_back(word);\\n            cur_letters+=word.length();\\n        }      \\n        string last;      //For the last line Left Justification\\n        for(int i=0;i<line.size()-1;i++){\\n            last+=line[i]+\" \";\\n            \\n        }\\n        last+=line.back()+string(maxWidth-(cur_letters+line.size()-1),\\' \\');\\n        res.push_back(last);\\n        return res;\\n        \\n    }\\n```\\nDo a Dry run ,u will get to know.\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nwords = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\\nmaxWidth = 16\\n```\n```\\nresult=[]                //To store the justified lines\\ncur_line=[]             //this is store the words in current line\\nnum_of_letters=0       // number of letters in current line  \\nIterate each word in input:\\n\\tcheck if we add word to cur_line exceeds maxWidth:\\n\\t\\tif it exceeds : \\n\\t\\t\\tadd spaces evenly to current line and add it result\\n\\t\\t\\tSince we are done with cur_line we empty it and set num_of_letters to 0\\n\\t\\tadd the word to cur_line                          //if the word exceeds maxWidth this word will be added to a newline beacuse we reset cur_line in previous step\\n\\t\\tadd num_of_letters with length of word\\nafter iterating all words check if cur_line is empty      // we add line to result only when it exceeds maxWidth,but when we finish all words some words might be left in cur_line\\nif not empty :\\n\\tadd spaces and add to result \\n\\nreturn result\\n```\n```\\nstring fillSpaces(vector<string> line,int num_letters, int maxWidth){\\n        string res;\\n        int spaces_to_add=maxWidth-num_letters;\\n        int between_space=spaces_to_add/(line.size()-1);\\n        int extra_spaces=spaces_to_add%(line.size()-1);\\n        for(int i=0;i<line.size()-1;i++){\\n            res+=line[i] + string(between_space,\\' \\')+ string(extra_spaces?1:0,\\' \\');\\n            if(extra_spaces>0) extra_spaces--;\\n        }\\n        res+=line.back();\\n        \\n        return res;\\n    }\\n    \\n    \\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        vector<string> line;\\n        int cur_letters = 0;\\n        for(auto word:words){\\n            if(cur_letters + word.length() + line.size() > maxWidth){   \\n                if(line.size()==1){\\n                    res.push_back(line[0]+string(maxWidth-cur_letters,\\' \\'));  //corner case\\n                }\\n                else\\n                   res.push_back(fillSpaces(line,cur_letters,maxWidth)); \\n                cur_letters=0;\\n                line.clear();\\n                \\n            }\\n            line.push_back(word);\\n            cur_letters+=word.length();\\n        }      \\n        string last;      //For the last line Left Justification\\n        for(int i=0;i<line.size()-1;i++){\\n            last+=line[i]+\" \";\\n            \\n        }\\n        last+=line.back()+string(maxWidth-(cur_letters+line.size()-1),\\' \\');\\n        res.push_back(last);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 821052,
                "title": "thanks-to-michael-for-step-by-step-explanation-code-added-c-java",
                "content": "[Awesome Expalantion](https://youtu.be/GqXlEbFVTXY)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int i= 0;\\n        int n= words.size();\\n        vector<string> result;\\n        while(i<n){\\n            int j= i+1;\\n            int lineLength= words[i].length();\\n            \\n            while(j < n && (lineLength + words[j].length() + (j-i-1))  < maxWidth){\\n                lineLength= lineLength + words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth - lineLength;\\n            int numberOfwords= j-i;\\n            //Chcek if the line needs to be left justified o r not\\n            if(numberOfwords == 1  ||  j>=n){ \\n                result.push_back(leftJustify(words, diff, i, j));\\n            }else{\\n                result.push_back(middleJustify(words, diff, i, j));\\n            }\\n            \\n            i = j;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string middleJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        result = words[i];\\n        int sections= j-i-1;\\n        int spaces= diff/sections;\\n        int extraSpaces= diff % sections;\\n        for(int k= i+1; k<j; ++k){\\n            int spacesToApply= spaces + (extraSpaces-- > 0? 1:0);\\n            while(spacesToApply){\\n                result= result + \" \";\\n                spacesToApply--;\\n            }\\n            result= result + words[k];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string leftJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        int spacesInRight= diff - (j-i-1);\\n        result = words[i];\\n        for(int k= i+1; k<j; ++k){\\n            result += \" \" + words[k];\\n        }\\n        while(spacesInRight>0){\\n            result= result + \" \";\\n            spacesInRight--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int i= 0;\\n        int n= words.size();\\n        vector<string> result;\\n        while(i<n){\\n            int j= i+1;\\n            int lineLength= words[i].length();\\n            \\n            while(j < n && (lineLength + words[j].length() + (j-i-1))  < maxWidth){\\n                lineLength= lineLength + words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth - lineLength;\\n            int numberOfwords= j-i;\\n            //Chcek if the line needs to be left justified o r not\\n            if(numberOfwords == 1  ||  j>=n){ \\n                result.push_back(leftJustify(words, diff, i, j));\\n            }else{\\n                result.push_back(middleJustify(words, diff, i, j));\\n            }\\n            \\n            i = j;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string middleJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        result = words[i];\\n        int sections= j-i-1;\\n        int spaces= diff/sections;\\n        int extraSpaces= diff % sections;\\n        for(int k= i+1; k<j; ++k){\\n            int spacesToApply= spaces + (extraSpaces-- > 0? 1:0);\\n            while(spacesToApply){\\n                result= result + \" \";\\n                spacesToApply--;\\n            }\\n            result= result + words[k];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string leftJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        int spacesInRight= diff - (j-i-1);\\n        result = words[i];\\n        for(int k= i+1; k<j; ++k){\\n            result += \" \" + words[k];\\n        }\\n        while(spacesInRight>0){\\n            result= result + \" \";\\n            spacesInRight--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756745,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int n = words.length;\\n        List<String> result = new ArrayList<>();\\n        int left = 0;\\n        while(left < n) {\\n            int right = findRight(left, words, maxWidth);\\n            String str = justify(left, right, words, maxWidth);\\n            result.add(str); //add the justified line to result\\n            left = right + 1; // we have justified the words till left.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //return the right index till which the words can fit on current line\\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right].length();\\n        int n = words.length;\\n        right++;\\n        while(right < n && (sum + 1 + words[right].length()) <= maxWidth) {\\n            sum += 1 + words[right].length(); // add space and new word\\n            right++;\\n        }\\n        \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        int n = words.length;\\n        \\n        //if only one word\\n        if (left == right) {\\n            return words[left] + blanks(maxWidth - words[left].length());\\n        }\\n        \\n        if (isLastLine(right, n)) {\\n            String line = getLine(left, right, words);\\n            return line + blanks(maxWidth - line.length());\\n        }\\n        \\n        int len = getLineLength(left, right, words);\\n        int gaps = right - left;\\n        int spaces = maxWidth - len;\\n        String fixedSpace = blanks(spaces / gaps);\\n        int odd = 0;\\n        if (spaces % gaps != 0) {\\n            odd = spaces % gaps;\\n        }\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(fixedSpace);\\n            if (odd > 0) {\\n                sb.append(\" \");\\n                odd--;\\n            }\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n        \\n    \\n    private String getLine(int left, int right, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(\" \");\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n    \\n    private int getLineLength(int left, int right, String[] words) {\\n        int len = 0;\\n        for (int i = left; i <= right; i++) {\\n            len += words[i].length();\\n        }\\n        return len;\\n    }\\n\\n    \\n    \\n    private String blanks(int length) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < length; i++) {\\n            sb.append(\\' \\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n    private boolean isLastLine(int index, int n) {\\n        return index == n-1;\\n    }\\n}\\n\\n/*\\nLoop over the words array.\\nkeep on adding the words to current line until the width is less than max\\nCount the number of spaces required bw words.\\nEvenly append the spaces between each word. so n-1 places for spaces.\\nMake the current line string and add it to the sol\\nIn case all the words fit in one line and there are no more words, left justify\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int n = words.length;\\n        List<String> result = new ArrayList<>();\\n        int left = 0;\\n        while(left < n) {\\n            int right = findRight(left, words, maxWidth);\\n            String str = justify(left, right, words, maxWidth);\\n            result.add(str); //add the justified line to result\\n            left = right + 1; // we have justified the words till left.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //return the right index till which the words can fit on current line\\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right].length();\\n        int n = words.length;\\n        right++;\\n        while(right < n && (sum + 1 + words[right].length()) <= maxWidth) {\\n            sum += 1 + words[right].length(); // add space and new word\\n            right++;\\n        }\\n        \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        int n = words.length;\\n        \\n        //if only one word\\n        if (left == right) {\\n            return words[left] + blanks(maxWidth - words[left].length());\\n        }\\n        \\n        if (isLastLine(right, n)) {\\n            String line = getLine(left, right, words);\\n            return line + blanks(maxWidth - line.length());\\n        }\\n        \\n        int len = getLineLength(left, right, words);\\n        int gaps = right - left;\\n        int spaces = maxWidth - len;\\n        String fixedSpace = blanks(spaces / gaps);\\n        int odd = 0;\\n        if (spaces % gaps != 0) {\\n            odd = spaces % gaps;\\n        }\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(fixedSpace);\\n            if (odd > 0) {\\n                sb.append(\" \");\\n                odd--;\\n            }\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n        \\n    \\n    private String getLine(int left, int right, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(\" \");\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n    \\n    private int getLineLength(int left, int right, String[] words) {\\n        int len = 0;\\n        for (int i = left; i <= right; i++) {\\n            len += words[i].length();\\n        }\\n        return len;\\n    }\\n\\n    \\n    \\n    private String blanks(int length) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < length; i++) {\\n            sb.append(\\' \\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n    private boolean isLastLine(int index, int n) {\\n        return index == n-1;\\n    }\\n}\\n\\n/*\\nLoop over the words array.\\nkeep on adding the words to current line until the width is less than max\\nCount the number of spaces required bw words.\\nEvenly append the spaces between each word. so n-1 places for spaces.\\nMake the current line string and add it to the sol\\nIn case all the words fit in one line and there are no more words, left justify\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534511,
                "title": "my-ac-c-codes-with-comments",
                "content": "Although it is a bit long, time and space complexity beat 100% C++ submission.\\nI think it is very straight forward with the help of comments.\\n\\nWithout comments:\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0;\\n        vector<string> res{};\\n        string cur = \"\"; \\n        while (i < n) {\\n            int l = i;\\n            int sum = 0;\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else {\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                cur += words[i - 1];\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n \\nWith comments:\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0; // index goes through the words vector\\n        vector<string> res{}; // return results\\n        string cur = \"\"; // string of each result row \\n        while (i < n) {\\n            int l = i; // l is the leftmost index of each row\\n            int sum = 0;\\n            // through this while loop, I wnat to find the end index of each row\\n            // for example, for row \"This    is    an\", after the wihle loop the \\n            // index will be 3\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            // if i == n, it is the last row, we need only one space between each word\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                // add the last word of each row and add the remain space to the end\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else { // if i != n\\n                // count counts if the spaces do not divide evenly, then we need to count\\n                // number of remainder words to add one more space than others\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    // for example, \"This    is    an\"\\n                    // maxWidth == 16;\\n                    // sum == (5 + 3 + 3 = 11); each word has one more white space to be counted\\n                    // i == 3;\\n                    // l == 0;\\n                    // then (maxWidth - sum + i - l) == (16 - 11 + 3 - 0 = 8) how many white spaces\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    // those words that need one more space than others\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                // add the last word of each row\\n                cur += words[i - 1];\\n                // in case of only one word in a row like \"acknowledgment  \"\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                // reset cur\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0;\\n        vector<string> res{};\\n        string cur = \"\"; \\n        while (i < n) {\\n            int l = i;\\n            int sum = 0;\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else {\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                cur += words[i - 1];\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0; // index goes through the words vector\\n        vector<string> res{}; // return results\\n        string cur = \"\"; // string of each result row \\n        while (i < n) {\\n            int l = i; // l is the leftmost index of each row\\n            int sum = 0;\\n            // through this while loop, I wnat to find the end index of each row\\n            // for example, for row \"This    is    an\", after the wihle loop the \\n            // index will be 3\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            // if i == n, it is the last row, we need only one space between each word\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                // add the last word of each row and add the remain space to the end\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else { // if i != n\\n                // count counts if the spaces do not divide evenly, then we need to count\\n                // number of remainder words to add one more space than others\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    // for example, \"This    is    an\"\\n                    // maxWidth == 16;\\n                    // sum == (5 + 3 + 3 = 11); each word has one more white space to be counted\\n                    // i == 3;\\n                    // l == 0;\\n                    // then (maxWidth - sum + i - l) == (16 - 11 + 3 - 0 = 8) how many white spaces\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    // those words that need one more space than others\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                // add the last word of each row\\n                cur += words[i - 1];\\n                // in case of only one word in a row like \"acknowledgment  \"\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                // reset cur\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529464,
                "title": "java-modularized-suitable-for-an-interview",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList();\\n        int lo = 0;\\n        while (lo < words.length) { // while we still have next line\\n            int hi = nextHiIndex(words, lo, maxWidth);\\n            formatLine(words, lo, hi, maxWidth, res);\\n            lo = hi;\\n        }\\n        return res;\\n    }\\n    \\n    private int nextHiIndex(String[] words, int lo, int maxWidth) {\\n        int hi = lo;\\n        // while next word could fit in\\n        while (hi < words.length && words[hi].length() <= maxWidth) {\\n            maxWidth -= words[hi].length(); // reduce word len\\n            maxWidth--; // reduce one space\\n            hi++;\\n        }\\n        return hi;\\n    }\\n    \\n    private void formatLine(String[] words, int lo, int hi, int maxWidth, List<String> res) {\\n        // compute signals needed for format\\n        List<String> wordsList = Arrays.asList(words).subList(lo, hi);\\n        int size = hi - lo;\\n        boolean isLastLine = (hi == words.length);\\n        boolean isSingleWordLine = (size == 1);\\n        // format\\n        if (isSingleWordLine || isLastLine) {\\n            // \"%-30s\"\\n            res.add(String.format(\"%-\" + maxWidth + \"s\", String.join(\" \", wordsList)));\\n        } else {\\n            StringBuilder sb = new StringBuilder();\\n            int wordsLen  = wordsList.stream().map(w -> w.length()).reduce(0, (a, b) -> a + b);\\n            int spacesLen = maxWidth - wordsLen;\\n            int avgSpaces = spacesLen / (size - 1);\\n            int extraSpaces = spacesLen % (size - 1);\\n            for (int i = lo; i < hi; i++) {\\n                sb.append(words[i] + String.format(\"%\" + avgSpaces + \"s\", \"\"));\\n                if (extraSpaces-- > 0) sb.append(\" \");\\n            }\\n            res.add(sb.toString().trim());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList();\\n        int lo = 0;\\n        while (lo < words.length) { // while we still have next line\\n            int hi = nextHiIndex(words, lo, maxWidth);\\n            formatLine(words, lo, hi, maxWidth, res);\\n            lo = hi;\\n        }\\n        return res;\\n    }\\n    \\n    private int nextHiIndex(String[] words, int lo, int maxWidth) {\\n        int hi = lo;\\n        // while next word could fit in\\n        while (hi < words.length && words[hi].length() <= maxWidth) {\\n            maxWidth -= words[hi].length(); // reduce word len\\n            maxWidth--; // reduce one space\\n            hi++;\\n        }\\n        return hi;\\n    }\\n    \\n    private void formatLine(String[] words, int lo, int hi, int maxWidth, List<String> res) {\\n        // compute signals needed for format\\n        List<String> wordsList = Arrays.asList(words).subList(lo, hi);\\n        int size = hi - lo;\\n        boolean isLastLine = (hi == words.length);\\n        boolean isSingleWordLine = (size == 1);\\n        // format\\n        if (isSingleWordLine || isLastLine) {\\n            // \"%-30s\"\\n            res.add(String.format(\"%-\" + maxWidth + \"s\", String.join(\" \", wordsList)));\\n        } else {\\n            StringBuilder sb = new StringBuilder();\\n            int wordsLen  = wordsList.stream().map(w -> w.length()).reduce(0, (a, b) -> a + b);\\n            int spacesLen = maxWidth - wordsLen;\\n            int avgSpaces = spacesLen / (size - 1);\\n            int extraSpaces = spacesLen % (size - 1);\\n            for (int i = lo; i < hi; i++) {\\n                sb.append(words[i] + String.format(\"%\" + avgSpaces + \"s\", \"\"));\\n                if (extraSpaces-- > 0) sb.append(\" \");\\n            }\\n            res.add(sb.toString().trim());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491150,
                "title": "o-n-solution-using-queue",
                "content": "```\\n/*\\n * add the queue if words not exceed the maxWidth. if exceed the maxWidth we pop all out to form the string\\n * when we reach the end we handle the special case \\n * see comments below on the conditions applied.\\n */\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        int curr = 0;\\n        Queue<String> queue = new LinkedList<>();\\n        List<String> res =new ArrayList<>();\\n        int size = 0;\\n        int space = 0;\\n        int extraleft = 0;\\n        \\n        for(int i=0; i<words.length; i++){\\n            size = queue.size();\\n            //if the current string addition plus the single space in between is still with in the maxWidth\\n            //the queue size here can be used to represent the single space between each word including the \\n            //addition of the words[i]\\n            if(curr + words[i].length() + size <= maxWidth){\\n                queue.offer(words[i]);\\n                curr+=words[i].length();\\n            }else{\\n            \\t//calculating the base space in between \\n                space = size == 1? maxWidth-curr : (maxWidth-curr)/(size-1);\\n                //if not even, I grab the reminder as the space to distribute across the words in queue starting from beginning \\n                //one at a time\\n                //of course special case handle if the current queue has only one word. all spaces added from left to right\\n                extraleft = size == 1? 0 : (maxWidth-curr)%(size-1);\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    //dont add the spaces to the last word\\n                    if(sb.length() < maxWidth){ \\n                        for(int j=0; j<space; j++) sb.append(\" \");\\n                        //now we add the extra space calculated above one per word from the starting until the extraleft reaches 0\\n                        if(extraleft-- > 0) sb.append(\" \");\\n                    }\\n                }\\n                //adding the builded string and reset curr and queue\\n                res.add(sb.toString());\\n                curr = words[i].length();\\n                queue.offer(words[i]);\\n            }\\n            \\n            //when i reaches the last word we build the last row as the special case\\n            if(i == words.length-1){\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    if(!queue.isEmpty()) sb.append(\" \");\\n                }\\n                while(sb.length() < maxWidth){\\n                    sb.append(\" \");\\n                }\\n                   res.add(sb.toString());\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * add the queue if words not exceed the maxWidth. if exceed the maxWidth we pop all out to form the string\\n * when we reach the end we handle the special case \\n * see comments below on the conditions applied.\\n */\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        int curr = 0;\\n        Queue<String> queue = new LinkedList<>();\\n        List<String> res =new ArrayList<>();\\n        int size = 0;\\n        int space = 0;\\n        int extraleft = 0;\\n        \\n        for(int i=0; i<words.length; i++){\\n            size = queue.size();\\n            //if the current string addition plus the single space in between is still with in the maxWidth\\n            //the queue size here can be used to represent the single space between each word including the \\n            //addition of the words[i]\\n            if(curr + words[i].length() + size <= maxWidth){\\n                queue.offer(words[i]);\\n                curr+=words[i].length();\\n            }else{\\n            \\t//calculating the base space in between \\n                space = size == 1? maxWidth-curr : (maxWidth-curr)/(size-1);\\n                //if not even, I grab the reminder as the space to distribute across the words in queue starting from beginning \\n                //one at a time\\n                //of course special case handle if the current queue has only one word. all spaces added from left to right\\n                extraleft = size == 1? 0 : (maxWidth-curr)%(size-1);\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    //dont add the spaces to the last word\\n                    if(sb.length() < maxWidth){ \\n                        for(int j=0; j<space; j++) sb.append(\" \");\\n                        //now we add the extra space calculated above one per word from the starting until the extraleft reaches 0\\n                        if(extraleft-- > 0) sb.append(\" \");\\n                    }\\n                }\\n                //adding the builded string and reset curr and queue\\n                res.add(sb.toString());\\n                curr = words[i].length();\\n                queue.offer(words[i]);\\n            }\\n            \\n            //when i reaches the last word we build the last row as the special case\\n            if(i == words.length-1){\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    if(!queue.isEmpty()) sb.append(\" \");\\n                }\\n                while(sb.length() < maxWidth){\\n                    sb.append(\" \");\\n                }\\n                   res.add(sb.toString());\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2027769,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1564657,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1848509,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1568133,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027716,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1565739,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567183,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2028196,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1717407,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567836,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027769,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1564657,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1848509,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1568133,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027716,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1565739,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567183,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2028196,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1717407,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567836,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027997,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027824,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1576360,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1568889,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1567184,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1571160,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2028958,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2028293,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027872,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027795,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027755,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1721898,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571161,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571162,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571164,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571167,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1888329,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1570416,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 2027770,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571163,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571166,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2069885,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2037564,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2036310,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2030690,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2029117,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028898,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028892,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028874,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028814,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028481,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028372,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028302,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028285,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028223,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028206,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028175,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028152,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028123,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028121,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028119,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2028081,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2028041,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2028030,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027904,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027898,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027847,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027797,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027792,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027783,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027726,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2027709,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2027702,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2027694,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2016549,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1967098,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1955090,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1754120,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1734806,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1575777,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            }
        ]
    },
    {
        "title": "Excel Sheet Column Title",
        "question_content": "<p>Given an integer <code>columnNumber</code>, return <em>its corresponding column title as it appears in an Excel sheet</em>.</p>\n\n<p>For example:</p>\n\n<pre>\nA -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 1\n<strong>Output:</strong> &quot;A&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 28\n<strong>Output:</strong> &quot;AB&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 701\n<strong>Output:</strong> &quot;ZY&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= columnNumber &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 441430,
                "title": "detailed-explanation-here-s-why-we-need-n-at-first-of-every-loop-java-python-c",
                "content": "The problem originates from here:\\nIt is a 26-nary system, but without the \\'0\\'.\\nA typical 26-nary system would be:\\n```\\n0 -> A\\n25 -> Z\\n26 -> BA\\n```\\nHowever, the excel system actually behaves differently:\\n```\\n1 -> A\\n26 -> Z\\n27 -> AA\\n```\\nYou could think it for a while and then get the idea why this excel system is actually behaving quite strangly. It is like in a number system in which after 9 it is 00 instead of 10; or like a system without zero: starting with 1, 2.. and after 9 it is 11. \\nAlthough the code is quite short and simple, I DO think it is hard to fully understand how this system behaves.\\n\\n\\nNow, how to solve it:\\n\\nEquation relationships will help us through the process, and It it not very difficult to derive them. With equations we can understand how to get the n-1 at first of the loop.\\nThe relationship between the string and number is:\\n```\\nfor String ABZ and its corresponding number n:\\nn = (A+1) * 26^2 + (B+1) * 26^1 + (Z+1) * 26^0\\n```\\nWhy (A+1)? Because in char system \\'A\\' is 0, but in excel system \\'A\\' is one. Every char get an extra one.\\n\\nInorder to get Z, or whatever char is at Z, we will first do a minus 1 on both sides:\\n```\\nboth sides -1\\nn-1 = (A+1) * 26^2 + (B+1) * 26^1 + Z\\n```\\nThen do a %26 we will get Z.\\n```\\n(n-1)%26 =  Z                                                  (1)\\n(n-1)/26 = (A+1) * 26^1 + (B+1) * 26^0                         (2)\\n```\\n\\nWith the above equations, we can understand why we need the n-- at first of every loop:\\nFor each loop, we use (1) to obtain what the current char is.\\nAnd we divide n-1 by 26 to get (2), in preparation for the next loop.\\n\\nJava:\\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while(n > 0){\\n            n--;\\n            int curr = n%26;\\n            n /= 26;\\n            sb.append((char)(curr+\\'A\\'));\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n```\\n\\nPython:\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = []\\n        while(n > 0):\\n            n -= 1\\n            curr = n % 26\\n            n = int(n / 26)\\n            ans.append(chr(curr + ord(\\'A\\')))\\n        \\n        return \\'\\'.join(ans[::-1])\\n```\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;\\n        while(n > 0) {\\n            n--;\\n            int curr = n % 26;\\n            n = n / 26;\\n            ans.push_back(curr + \\'A\\');\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n0 -> A\\n25 -> Z\\n26 -> BA\\n```\n```\\n1 -> A\\n26 -> Z\\n27 -> AA\\n```\n```\\nfor String ABZ and its corresponding number n:\\nn = (A+1) * 26^2 + (B+1) * 26^1 + (Z+1) * 26^0\\n```\n```\\nboth sides -1\\nn-1 = (A+1) * 26^2 + (B+1) * 26^1 + Z\\n```\n```\\n(n-1)%26 =  Z                                                  (1)\\n(n-1)/26 = (A+1) * 26^1 + (B+1) * 26^0                         (2)\\n```\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while(n > 0){\\n            n--;\\n            int curr = n%26;\\n            n /= 26;\\n            sb.append((char)(curr+\\'A\\'));\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = []\\n        while(n > 0):\\n            n -= 1\\n            curr = n % 26\\n            n = int(n / 26)\\n            ans.append(chr(curr + ord(\\'A\\')))\\n        \\n        return \\'\\'.join(ans[::-1])\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;\\n        while(n > 0) {\\n            n--;\\n            int curr = n % 26;\\n            n = n / 26;\\n            ans.push_back(curr + \\'A\\');\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51398,
                "title": "my-1-lines-code-in-java-c-and-python",
                "content": "Java:\\n\\n    return n == 0 ? \"\" : convertToTitle(--n / 26) + (char)('A' + (n % 26));\\n\\nC++:\\n\\n    return n == 0 ? \"\" : convertToTitle(n / 26) + (char) (--n % 26 + 'A');\\n\\nupdate: because the behavior of different compilers, the safe version should be:\\n\\n    return n == 0 ? \"\" : convertToTitle((n - 1) / 26) + (char) ((n - 1) % 26 + 'A');\\n\\nPython:\\n\\n    return \"\" if num == 0 else self.convertToTitle((num - 1) / 26) + chr((num - 1) % 26 + ord('A'))",
                "solutionTags": [
                    "Java"
                ],
                "code": "Java:\\n\\n    return n == 0 ? \"\" : convertToTitle(--n / 26) + (char)('A' + (n % 26));\\n\\nC++:\\n\\n    return n == 0 ? \"\" : convertToTitle(n / 26) + (char) (--n % 26 + 'A');\\n\\nupdate: because the behavior of different compilers, the safe version should be:\\n\\n    return n == 0 ? \"\" : convertToTitle((n - 1) / 26) + (char) ((n - 1) % 26 + 'A');\\n\\nPython:\\n\\n    return \"\" if num == 0 else self.convertToTitle((num - 1) / 26) + chr((num - 1) % 26 + ord('A'))",
                "codeTag": "Unknown"
            },
            {
                "id": 51404,
                "title": "python-solution-with-explanation",
                "content": "Let's see the relationship between the Excel sheet column title and the number:\\n\\n    A   1     AA    26+ 1     BA  2\\xd726+ 1     ...     ZA  26\\xd726+ 1     AAA  1\\xd726\\xb2+1\\xd726+ 1\\n    B   2     AB    26+ 2     BB  2\\xd726+ 2     ...     ZB  26\\xd726+ 2     AAB  1\\xd726\\xb2+1\\xd726+ 2\\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............   \\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............\\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............\\n    Z  26     AZ    26+26     BZ  2\\xd726+26     ...     ZZ  26\\xd726+26     AAZ  1\\xd726\\xb2+1\\xd726+26\\n\\nNow we can see that ABCD\\uff1dA\\xd726\\xb3\\uff0bB\\xd726\\xb2\\uff0bC\\xd726\\xb9\\uff0bD\\uff1d1\\xd726\\xb3\\uff0b2\\xd726\\xb2\\uff0b3\\xd726\\xb9\\uff0b4\\n\\nBut how to get the column title from the number? We can't simply use the n%26 method because:\\n\\nZZZZ\\uff1dZ\\xd726\\xb3\\uff0bZ\\xd726\\xb2\\uff0bZ\\xd726\\xb9\\uff0bZ\\uff1d26\\xd726\\xb3\\uff0b26\\xd726\\xb2\\uff0b26\\xd726\\xb9\\uff0b26\\n\\nWe can use (n-1)%26 instead, then we get a number range from 0 to 25.\\n\\n    class Solution:\\n        # @return a string\\n        def convertToTitle(self, num):\\n            capitals = [chr(x) for x in range(ord('A'), ord('Z')+1)]\\n            result = []\\n            while num > 0:\\n                result.append(capitals[(num-1)%26])\\n                num = (num-1) // 26\\n            result.reverse()\\n            return ''.join(result)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Let's see the relationship between the Excel sheet column title and the number:\\n\\n    A   1     AA    26+ 1     BA  2\\xd726+ 1     ...     ZA  26\\xd726+ 1     AAA  1\\xd726\\xb2+1\\xd726+ 1\\n    B   2     AB    26+ 2     BB  2\\xd726+ 2     ...     ZB  26\\xd726+ 2     AAB  1\\xd726\\xb2+1\\xd726+ 2\\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............   \\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............\\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............\\n    Z  26     AZ    26+26     BZ  2\\xd726+26     ...     ZZ  26\\xd726+26     AAZ  1\\xd726\\xb2+1\\xd726+26\\n\\nNow we can see that ABCD\\uff1dA\\xd726\\xb3\\uff0bB\\xd726\\xb2\\uff0bC\\xd726\\xb9\\uff0bD\\uff1d1\\xd726\\xb3\\uff0b2\\xd726\\xb2\\uff0b3\\xd726\\xb9\\uff0b4\\n\\nBut how to get the column title from the number? We can't simply use the n%26 method because:\\n\\nZZZZ\\uff1dZ\\xd726\\xb3\\uff0bZ\\xd726\\xb2\\uff0bZ\\xd726\\xb9\\uff0bZ\\uff1d26\\xd726\\xb3\\uff0b26\\xd726\\xb2\\uff0b26\\xd726\\xb9\\uff0b26\\n\\nWe can use (n-1)%26 instead, then we get a number range from 0 to 25.\\n\\n    class Solution:\\n        # @return a string\\n        def convertToTitle(self, num):\\n            capitals = [chr(x) for x in range(ord('A'), ord('Z')+1)]\\n            result = []\\n            while num > 0:\\n                result.append(capitals[(num-1)%26])\\n                num = (num-1) // 26\\n            result.reverse()\\n            return ''.join(result)",
                "codeTag": "Java"
            },
            {
                "id": 51399,
                "title": "accepted-java-solution",
                "content": "    public class Solution {\\n        public String convertToTitle(int n) {\\n            StringBuilder result = new StringBuilder();\\n    \\n            while(n>0){\\n                n--;\\n                result.insert(0, (char)('A' + n % 26));\\n                n /= 26;\\n            }\\n    \\n            return result.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n        public String convertToTitle(int n) {\\n            StringBuilder result = new StringBuilder();\\n    \\n            while(n>0){\\n                n--;\\n                result.insert(0, (char)('A' + n % 26));\\n                n /= 26;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51541,
                "title": "readable-c-code-within-1ms",
                "content": "class Solution {\\n\\npublic:\\n\\n    string convertToTitle(int n) {\\n\\n        string res;\\n\\n        char tmp;\\n\\n        while(n){\\n\\n            n -= 1;\\n\\n            tmp = 'A' + n % 26;\\n\\n            res = tmp + res;\\n\\n            n /= 26;\\n\\n        }\\n\\n        return res;\\n\\n    }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    string convertToTitle(int n) {\\n\\n        string res;\\n\\n        char tmp;\\n\\n        while(n){\\n\\n            n -= 1;\\n\\n            tmp = 'A' + n % 26;\\n\\n            res = tmp + res;\\n\\n            n /= 26;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2448578,
                "title": "easy-0-ms-100-fully-explained-java-c-python-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Excel Sheet Column Title.\\n```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        // Create an empty string for storing the characters...\\n        StringBuilder output = new StringBuilder();\\n        // Run a while loop while columnNumber is positive...\\n        while(columnNumber > 0){\\n            // Subtract 1 from columnNumber...\\n            columnNumber--;\\n            // Get current character by doing modulo of columnNumber by 26...\\n            char c = (char) (columnNumber % 26 + \\'A\\');\\n            // Divide columnNumber by 26...\\n            columnNumber /= 26;\\n            // Append the character into output...\\n            output.append(c);\\n        }\\n        // Reverse the output string...\\n        // Bcause we have found characters from right to left...\\n        output.reverse();\\n        // Return the reversed string.\\n        return output.toString();\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // Create an empty string for storing the characters...\\n        string output;\\n        // Run a while loop while columnNumber is positive...\\n        while(columnNumber > 0){\\n            // Subtract 1 from columnNumber...\\n            columnNumber--;\\n            // Get current character by doing modulo of columnNumber by 26...\\n            int m = columnNumber % 26;\\n            // Divide columnNumber by 26...\\n            columnNumber /= 26;\\n            output += \\'A\\' + m;\\n        }\\n        // Reverse the output string...\\n        // Bcause we have found characters from right to left...\\n        reverse(output.begin(),output.end());\\n        // Return the reversed string.\\n        return output;\\n    }\\n};\\n```\\n\\n# **Python / Python3 Solution:**\\n```\\nclass Solution(object):\\n    def convertToTitle(self, columnNumber):\\n        # Create an empty string for storing the characters...\\n        output = \"\"\\n        # Run a while loop while columnNumber is positive...\\n        while columnNumber > 0:\\n            # Subtract 1 from columnNumber and get current character by doing modulo of columnNumber by 26...\\n            output = chr(ord(\\'A\\') + (columnNumber - 1) % 26) + output\\n            # Divide columnNumber by 26...\\n            columnNumber = (columnNumber - 1) // 26\\n        # Return the output string.\\n        return output\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        // Create an empty string for storing the characters...\\n        StringBuilder output = new StringBuilder();\\n        // Run a while loop while columnNumber is positive...\\n        while(columnNumber > 0){\\n            // Subtract 1 from columnNumber...\\n            columnNumber--;\\n            // Get current character by doing modulo of columnNumber by 26...\\n            char c = (char) (columnNumber % 26 + \\'A\\');\\n            // Divide columnNumber by 26...\\n            columnNumber /= 26;\\n            // Append the character into output...\\n            output.append(c);\\n        }\\n        // Reverse the output string...\\n        // Bcause we have found characters from right to left...\\n        output.reverse();\\n        // Return the reversed string.\\n        return output.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // Create an empty string for storing the characters...\\n        string output;\\n        // Run a while loop while columnNumber is positive...\\n        while(columnNumber > 0){\\n            // Subtract 1 from columnNumber...\\n            columnNumber--;\\n            // Get current character by doing modulo of columnNumber by 26...\\n            int m = columnNumber % 26;\\n            // Divide columnNumber by 26...\\n            columnNumber /= 26;\\n            output += \\'A\\' + m;\\n        }\\n        // Reverse the output string...\\n        // Bcause we have found characters from right to left...\\n        reverse(output.begin(),output.end());\\n        // Return the reversed string.\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def convertToTitle(self, columnNumber):\\n        # Create an empty string for storing the characters...\\n        output = \"\"\\n        # Run a while loop while columnNumber is positive...\\n        while columnNumber > 0:\\n            # Subtract 1 from columnNumber and get current character by doing modulo of columnNumber by 26...\\n            output = chr(ord(\\'A\\') + (columnNumber - 1) % 26) + output\\n            # Divide columnNumber by 26...\\n            columnNumber = (columnNumber - 1) // 26\\n        # Return the output string.\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51401,
                "title": "my-easy-to-understand-java-solution",
                "content": "Instead of 1 -> A, 26 -> Z, we can assume that 0 -> A, 25 -> Z, and then here comes the base 26 representation, it's similar when you convert a number from base 10 to base 2\\n\\n    public class Solution {\\n    public String convertToTitle(int n) {\\n        String res = \"\";\\n        while(n != 0) {\\n            char ch = (char)((n - 1) % 26 + 65);\\n            n = (n - 1) / 26;\\n            res = ch + res;\\n        }\\n        return res;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String convertToTitle(int n) {\\n        String res = \"\";\\n        while(n != 0) {\\n            char ch = (char)((n - 1) % 26 + 65);\\n            n = (n - 1) / 26;\\n            res = ch + res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 51421,
                "title": "share-my-simple-solution-just-a-little-trick-to-handle-corner-case-26",
                "content": "    string convertToTitle(int n) {\\n            string ans;\\n            while (n) {\\n                ans = char ((n - 1) % 26 + 'A') + ans;\\n                n = (n - 1) / 26;\\n            }\\n            return ans;\\n        }",
                "solutionTags": [],
                "code": "    string convertToTitle(int n) {\\n            string ans;\\n            while (n) {\\n                ans = char ((n - 1) % 26 + 'A') + ans;\\n                n = (n - 1) / 26;\\n            }\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3943071,
                "title": "100-recursive-iterative-2-approaches",
                "content": "# Problem Understanding\\n\\nIn the \"Excel Sheet Column Title\" problem, we are given an integer representing a column number. The task is to return its corresponding column title as it appears in an Excel sheet, where the letters range from A to Z for the numbers 1 to 26, and then AA to AZ, BA to BZ, and so on.\\n\\nFor instance, given the input 28, the output should be \"AB\".\\n\\n**Input**: columnNumber = 28\\n**Output**: \"AB\"\\n\\n---\\n\\n# Live Coding Iterative & Recursive:\\nhttps://youtu.be/Vlu300w6HbY\\n\\n- [Coding in Python \\uD83D\\uDC0D](https://youtu.be/Vlu300w6HbY)\\n- [Coding in Rust \\uD83E\\uDD80](https://youtu.be/nutdEPmd3kM)\\n\\n---\\n\\n# Approach 1: Iterative\\n\\nTo solve the \"Excel Sheet Column Title\" problem using the iterative approach, we continuously divide the given number by 26 and determine the remainder. This remainder gives us the current character of the Excel title, starting from the least significant character.\\n\\n## Key Data Structures:\\n- **List (result)**: Used to store the characters of the Excel title.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Create an empty list named `result`.\\n   \\n2. **Processing Each Number**:\\n   - While `columnNumber` is not zero:\\n     - Use the `divmod` function to get the quotient and remainder of `columnNumber` when divided by 26.\\n     - Decrement the `columnNumber` by 1 and append the corresponding character to the `result` list.\\n     \\n3. **Wrap-up**:\\n   - Reverse the `result` list and join the characters to form the final Excel title.\\n\\n## Example:\\n\\nGiven the input 701:\\n\\n**Iterative Approach:**\\n\\n- First iteration: remainder = 24, quotient = 26; result = [\"Y\"]\\n- Second iteration: remainder = 25, quotient = 0; result = [\"Y\", \"Z\"]\\n- No further iterations since quotient is now 0; final result = \"ZY\"\\n\\n---\\n\\n# Approach 2: Recursive\\n\\nTo tackle this problem recursively, we adopt a top-down approach, determining the most significant character first and then recursively determining the rest.\\n\\n## Key Data Structures:\\n- **String**: As this is a recursive approach, we construct the Excel title directly as a string.\\n\\n## Enhanced Breakdown:\\n\\n1. **Base Case**:\\n   - If `columnNumber` is zero, return an empty string.\\n   \\n2. **Recursive Call**:\\n   - Use the `divmod` function to determine the quotient and remainder of `columnNumber` divided by 26.\\n   - Construct the current character of the Excel title using the remainder.\\n   - Recursively call the function with the quotient to determine the preceding characters of the Excel title.\\n\\n3. **Wrap-up**:\\n   - Concatenate the result of the recursive call with the current character to form the current state of the Excel title.\\n\\n## Example:\\n\\nGiven the input 701:\\n\\n**Recursive Approach:**\\n\\n- First call: remainder = 24, quotient = 26; current character = \"Y\"\\n- Second call: remainder = 25, quotient = 0; current character = \"Z\"\\n- No further recursive calls as quotient is now 0; final result = \"ZY\"\\n\\n(Note: The order of the recursive approach\\'s results is due to the nature of recursion, where the deeper levels of recursion resolve first.)\\n\\n---\\n\\n# Complexity:\\n\\n**Time Complexity for Both Approaches:** \\n- The time complexity is $$O(\\\\log_{26} n)$$ for both methods, where $$n$$ is the given `columnNumber`. This is because we\\'re continuously dividing the number by 26 until it becomes zero.\\n\\n**Space Complexity for Iterative Approach:** \\n- The space complexity is $$O(\\\\log_{26} n)$$ due to the list we use to store the Excel title characters.\\n\\n**Space Complexity for Recursive Approach:** \\n- The space complexity is also $$O(\\\\log_{26} n)$$ due to the recursive call stack.\\n\\n---\\n\\n# Performance:\\n\\n**Iterative Approach:**\\n\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| Rust       | 0 ms         | 100%             | 2 MB        | 86.84%          |\\n| Java       | 0 ms         | 100%             | 39.7 MB     | 61.65%          |\\n| Go         | 1 ms         | 74.84%           | 1.9 MB      | 94.34%          |\\n| C++        | 2 ms         | 49.78%           | 6 MB        | 37.93%          |\\n| Python3    | 32 ms        | 93.98%           | 16.3 MB     | 23.11%          |\\n| JavaScript | 44 ms        | 93.13%           | 42.1 MB     | 11.16%          |\\n| C#         | 55 ms        | 97.28%           | 36.8 MB     | 15.65%          |\\n\\n![it1.png](https://assets.leetcode.com/users/images/a1229abf-72de-4d98-a48d-4c280de56bd0_1692666229.2393072.png)\\n\\n\\n**Recursive Approach:**\\n\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| Rust       | 0 ms         | 100%             | 2.2 MB      | 23.68%          |\\n| C++        | 0 ms         | 100%             | 5.9 MB      | 37.93%          |\\n| Go         | 1 ms         | 74.84%           | 1.9 MB      | 94.34%          |\\n| Java       | 6 ms         | 34.8%            | 40.6 MB     | 5.65%           |\\n| Python3    | 34 ms        | 88.27%           | 16.4 MB     | 23.11%          |\\n| JavaScript | 42 ms        | 96.14%           | 41.3 MB     | 86.70%          |\\n| C#         | 69 ms        | 51.2%            | 36.8 MB     | 15.65%          |\\n\\n![r2.png](https://assets.leetcode.com/users/images/eaebd8ab-c1ac-42e6-8722-afe3fe167c8c_1692666240.177567.png)\\n\\n\\n---\\n\\n# Code Iterative\\n``` Python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        result = []\\n        while columnNumber:\\n            columnNumber, remainder = divmod(columnNumber - 1, 26)\\n            result.append(chr(65 + remainder))\\n        return \\'\\'.join(reversed(result))\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string result = \"\";\\n        while (columnNumber) {\\n            columnNumber--;\\n            char c = \\'A\\' + columnNumber % 26;\\n            result = c + result;\\n            columnNumber /= 26;\\n        }\\n        return result;\\n    }\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn convert_to_title(column_number: i32) -> String {\\n        let mut result = String::new();\\n        let mut number = column_number;\\n        while number > 0 {\\n            number -= 1;\\n            let char_code = ((number % 26) as u8) + b\\'A\\';\\n            result.insert(0, char_code as char);\\n            number /= 26;\\n        }\\n        result\\n    }\\n}\\n```\\n``` Go []\\nfunc convertToTitle(columnNumber int) string {\\n    var result string\\n    for columnNumber > 0 {\\n        columnNumber--\\n        charCode := \\'A\\' + rune(columnNumber % 26)\\n        result = string(charCode) + result\\n        columnNumber /= 26\\n    }\\n    return result\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder result = new StringBuilder();\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            char c = (char) (\\'A\\' + columnNumber % 26);\\n            result.insert(0, c);\\n            columnNumber /= 26;\\n        }\\n        return result.toString();\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        string result = \"\";\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            char c = (char) (\\'A\\' + columnNumber % 26);\\n            result = c + result;\\n            columnNumber /= 26;\\n        }\\n        return result;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    let result = \"\";\\n    while (columnNumber > 0) {\\n        columnNumber--;\\n        let charCode = \\'A\\'.charCodeAt(0) + columnNumber % 26;\\n        result = String.fromCharCode(charCode) + result;\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n    return result;\\n};\\n```\\n\\n# Code Recusrive\\n``` Python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        if not columnNumber:\\n            return \"\"\\n        columnNumber, remainder = divmod(columnNumber - 1, 26)\\n        return self.convertToTitle(columnNumber) + chr(65 + remainder)\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = \\'A\\' + columnNumber % 26;\\n        return convertToTitle(columnNumber / 26) + c;\\n    }\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn convert_to_title(column_number: i32) -> String {\\n        if column_number == 0 {\\n            return String::new();\\n        }\\n        let mut number = column_number;\\n        number -= 1;\\n        let char_code = ((number % 26) as u8) + b\\'A\\';\\n        let prev = Self::convert_to_title(number / 26);\\n        return format!(\"{}{}\", prev, char_code as char);\\n    }\\n}\\n```\\n``` Go []\\nfunc convertToTitle(columnNumber int) string {\\n    if columnNumber == 0 {\\n        return \"\"\\n    }\\n    columnNumber--\\n    charCode := \\'A\\' + rune(columnNumber%26)\\n    return convertToTitle(columnNumber/26) + string(charCode)\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public String convertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = (char) (\\'A\\' + columnNumber % 26);\\n        return convertToTitle(columnNumber / 26) + c;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = (char) (\\'A\\' + columnNumber % 26);\\n        return ConvertToTitle(columnNumber / 26) + c;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    if (columnNumber === 0) return \"\";\\n    columnNumber--;\\n    let charCode = \\'A\\'.charCodeAt(0) + columnNumber % 26;\\n    return convertToTitle(Math.floor(columnNumber / 26)) + String.fromCharCode(charCode);\\n};\\n```\\n\\n# Live Coding in Rust:\\nhttps://youtu.be/nutdEPmd3kM\\n\\nThis problem provides an elegant demonstration of how to convert base-10 numbers to another base, in this case, base-26. It\\'s a great reminder that sometimes algorithmic problems can be rooted in simple number base conversions. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "Go",
                    "Rust",
                    "Math",
                    "String"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        result = []\\n        while columnNumber:\\n            columnNumber, remainder = divmod(columnNumber - 1, 26)\\n            result.append(chr(65 + remainder))\\n        return \\'\\'.join(reversed(result))\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string result = \"\";\\n        while (columnNumber) {\\n            columnNumber--;\\n            char c = \\'A\\' + columnNumber % 26;\\n            result = c + result;\\n            columnNumber /= 26;\\n        }\\n        return result;\\n    }\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn convert_to_title(column_number: i32) -> String {\\n        let mut result = String::new();\\n        let mut number = column_number;\\n        while number > 0 {\\n            number -= 1;\\n            let char_code = ((number % 26) as u8) + b\\'A\\';\\n            result.insert(0, char_code as char);\\n            number /= 26;\\n        }\\n        result\\n    }\\n}\\n```\n``` Go []\\nfunc convertToTitle(columnNumber int) string {\\n    var result string\\n    for columnNumber > 0 {\\n        columnNumber--\\n        charCode := \\'A\\' + rune(columnNumber % 26)\\n        result = string(charCode) + result\\n        columnNumber /= 26\\n    }\\n    return result\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder result = new StringBuilder();\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            char c = (char) (\\'A\\' + columnNumber % 26);\\n            result.insert(0, c);\\n            columnNumber /= 26;\\n        }\\n        return result.toString();\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        string result = \"\";\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            char c = (char) (\\'A\\' + columnNumber % 26);\\n            result = c + result;\\n            columnNumber /= 26;\\n        }\\n        return result;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    let result = \"\";\\n    while (columnNumber > 0) {\\n        columnNumber--;\\n        let charCode = \\'A\\'.charCodeAt(0) + columnNumber % 26;\\n        result = String.fromCharCode(charCode) + result;\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n    return result;\\n};\\n```\n``` Python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        if not columnNumber:\\n            return \"\"\\n        columnNumber, remainder = divmod(columnNumber - 1, 26)\\n        return self.convertToTitle(columnNumber) + chr(65 + remainder)\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = \\'A\\' + columnNumber % 26;\\n        return convertToTitle(columnNumber / 26) + c;\\n    }\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn convert_to_title(column_number: i32) -> String {\\n        if column_number == 0 {\\n            return String::new();\\n        }\\n        let mut number = column_number;\\n        number -= 1;\\n        let char_code = ((number % 26) as u8) + b\\'A\\';\\n        let prev = Self::convert_to_title(number / 26);\\n        return format!(\"{}{}\", prev, char_code as char);\\n    }\\n}\\n```\n``` Go []\\nfunc convertToTitle(columnNumber int) string {\\n    if columnNumber == 0 {\\n        return \"\"\\n    }\\n    columnNumber--\\n    charCode := \\'A\\' + rune(columnNumber%26)\\n    return convertToTitle(columnNumber/26) + string(charCode)\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public String convertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = (char) (\\'A\\' + columnNumber % 26);\\n        return convertToTitle(columnNumber / 26) + c;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = (char) (\\'A\\' + columnNumber % 26);\\n        return ConvertToTitle(columnNumber / 26) + c;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    if (columnNumber === 0) return \"\";\\n    columnNumber--;\\n    let charCode = \\'A\\'.charCodeAt(0) + columnNumber % 26;\\n    return convertToTitle(Math.floor(columnNumber / 26)) + String.fromCharCode(charCode);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51465,
                "title": "solution-with-explanation",
                "content": "The idea behind this problem is as follows: \\n\\nConsider getting the characters for 28: It's 26^1 * (first Character) + 26^0 * (second Character), which in this case is 26*'A' + 1*'B' . Therefore to get the last character mod by 26. Then to get the character prior to that divide by 26 then mod by 26 and so on till what remains is zero.\\n\\n    string convertToTitle(int n) {\\n    \\tstring res=\"\";\\n        while(n>0){\\n    \\t\\tres=char('A'+(n-1)%26)+res;\\n    \\t\\tn=(n-1)/26;\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "The idea behind this problem is as follows: \\n\\nConsider getting the characters for 28: It's 26^1 * (first Character) + 26^0 * (second Character), which in this case is 26*'A' + 1*'B' . Therefore to get the last character mod by 26. Then to get the character prior to that divide by 26 then mod by 26 and so on till what remains is zero.\\n\\n    string convertToTitle(int n) {\\n    \\tstring res=\"\";\\n        while(n>0){\\n    \\t\\tres=char('A'+(n-1)%26)+res;\\n    \\t\\tn=(n-1)/26;\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51532,
                "title": "share-my-java-solusion",
                "content": "    public String convertToTitle(int n) {\\n            String res = \"\";\\n            while(n != 0) {\\n                res = (char)('A' + (n - 1) % 26) + res;\\n                n = (n - 1) / 26;\\n            }\\n            return res;\\n    }",
                "solutionTags": [],
                "code": "    public String convertToTitle(int n) {\\n            String res = \"\";\\n            while(n != 0) {\\n                res = (char)('A' + (n - 1) % 26) + res;\\n                n = (n - 1) / 26;\\n            }\\n            return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 338842,
                "title": "clear-python3-solution",
                "content": "There no concept of \"zero\" in excel numeral system. So every time we get a new \"digit\" we decrease n-number by 1, so we wouldn\\'t treat \"A\" as zero. Usually you\\'d consider 1, 01, 001 and 0001 as the same numbers. But in such zero-less system you can\\'t treat E, AE, AAE and AAAE as the same numbers - so we are building a number view without zero-symbol.\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        abc=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        ans=\"\"\\n        while n:\\n            n=n-1\\n            ans=abc[n%26]+ans\\n            n=n//26\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        abc=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        ans=\"\"\\n        while n:\\n            n=n-1\\n            ans=abc[n%26]+ans\\n            n=n//26\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970322,
                "title": "very-easy-3-line-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        String ans = \"\";\\n        while (columnNumber>0){\\n            columnNumber--;\\n            ans = (char) (\\'A\\'+ (columnNumber%26)) + ans;\\n            columnNumber = columnNumber/26;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Please Upvote if it was helpful",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        String ans = \"\";\\n        while (columnNumber>0){\\n            columnNumber--;\\n            ans = (char) (\\'A\\'+ (columnNumber%26)) + ans;\\n            columnNumber = columnNumber/26;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674844,
                "title": "java-easy-solution-without-stringbuilder",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n      String result = \"\";\\n       \\n       while(n > 0) {\\n           n --;\\n           result = (char)(\\'A\\' + (n % 26)) + result;\\n           n = n / 26;\\n       }\\n       return result;\\n    }\\n}\\n```\\n\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n      String result = \"\";\\n       \\n       while(n > 0) {\\n           n --;\\n           result = (char)(\\'A\\' + (n % 26)) + result;\\n           n = n / 26;\\n       }\\n       return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51561,
                "title": "straightforward-python-solution",
                "content": "Conversion from 10-ary numbers to 26-ary numbers. The tricky part is the lack of the equivalent number '0' in the 26-ary system.\\n\\n    def convertToTitle(self, n):\\n        r = ''\\n        while(n>0):\\n            n -= 1\\n            r = chr(n%26+65) + r\\n            n /= 26\\n        return r",
                "solutionTags": [
                    "Python"
                ],
                "code": "Conversion from 10-ary numbers to 26-ary numbers. The tricky part is the lack of the equivalent number '0' in the 26-ary system.\\n\\n    def convertToTitle(self, n):\\n        r = ''\\n        while(n>0):\\n            n -= 1\\n            r = chr(n%26+65) + r\\n            n /= 26\\n        return r",
                "codeTag": "Python3"
            },
            {
                "id": 3035652,
                "title": "c-solution-with-detailed-explanation",
                "content": "# Intuition\\n- This problem requires a number system conversion.\\n- We need to convert the base(10) input to base(26).\\n- But there\\'s a catch. Excel system has range: [1, 26], whereas base(26) has range: [0, 25].\\n\\n# Approach\\n- If we try to represent ```columnNumber``` using **base(26)**, then they can be represented like this:\\n```\\n// target: AXY\\ncolumnNumber = (26^2)*(A) + (26^1)*(X) + (26^0)*(Y)\\n```\\n- **base(26)**\\n    - *A -> 0*\\n    - *B -> 1*\\n    - *C -> 2*\\n    - *and so on till, Z -> 25*\\n- But according to **Excel**:\\n    - *A -> 1*\\n    - *B -> 2*\\n    - *C -> 3*\\n    - *and so on till, Z -> 26*\\n- If we observe the pattern here, numeric representation of every corresponding alphabet in **Excel** is one more than that of **base(26)**, *right*?\\n- So, any ```columnNumber``` can be represented using **Excel** format like this:\\n```\\n// target: AXY\\ncolumnNumber: (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)\\n```\\n- Why **+1**? Because, as explained above, each corresponding letter is one more than its corresponding representation in base(26).\\n\\n### Now, how do we retrieve the letters?\\n```\\ncolumnNumber = (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)  \\n// to retrieve Y\\n    // 26^0 is just 1, so there is (1)*(Y+1)\\n    // to retrieve Y, subtract 1 from both side, then divide both side by 26, the remainder will be Y\\n\\n// Subtracting 1 from both sides\\ncolumnNumber-1 = (26^2)*(A+1) + (26^1)*(X+1) + Y\\n\\n// dividing both sides by 26\\ncolumnNumber-1 = (26^1)*(A+1) + (26^0)*(X+1)\\nrem = Y\\n\\n// If you observe, we have just reduced our problem size, we have to continue this process until we run out of numbers(i.e: columnNumber becomes 0)\\n```\\n\\n# Complexity\\n- Time complexity:\\n    O(log(N))\\n\\n- Space complexity:\\n    O(log(N))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // base(10) -> base(26)   \\n        string column = \"\";\\n        int rem;\\n\\n        while(columnNumber){\\n            rem = (--columnNumber)%26;  // similar to subtracting 1 from both sides and obtaining the remainder\\n            columnNumber /= 26;\\n\\n            column = char(\\'A\\' + rem) + column;\\n        }\\n\\n        return column;\\n    }\\n};\\n```\\n\\n#### Consider upvoting, if it helped :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```columnNumber```\n```\\n// target: AXY\\ncolumnNumber = (26^2)*(A) + (26^1)*(X) + (26^0)*(Y)\\n```\n```columnNumber```\n```\\n// target: AXY\\ncolumnNumber: (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)\\n```\n```\\ncolumnNumber = (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)  \\n// to retrieve Y\\n    // 26^0 is just 1, so there is (1)*(Y+1)\\n    // to retrieve Y, subtract 1 from both side, then divide both side by 26, the remainder will be Y\\n\\n// Subtracting 1 from both sides\\ncolumnNumber-1 = (26^2)*(A+1) + (26^1)*(X+1) + Y\\n\\n// dividing both sides by 26\\ncolumnNumber-1 = (26^1)*(A+1) + (26^0)*(X+1)\\nrem = Y\\n\\n// If you observe, we have just reduced our problem size, we have to continue this process until we run out of numbers(i.e: columnNumber becomes 0)\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // base(10) -> base(26)   \\n        string column = \"\";\\n        int rem;\\n\\n        while(columnNumber){\\n            rem = (--columnNumber)%26;  // similar to subtracting 1 from both sides and obtaining the remainder\\n            columnNumber /= 26;\\n\\n            column = char(\\'A\\' + rem) + column;\\n        }\\n\\n        return column;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067071,
                "title": "7lines-of-code-with-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/17995446-4274-499b-9c70-ef840963152a_1613408567.810666.png)\\n![Uploading file...]()\\n```\\n    string s=\"\";\\n    n--;\\n    while(n>=0){\\n        s+=(\\'A\\'+n%26);\\n        n/=26;\\n        n--;\\n    }\\n    reverse(s.begin(),s.end());\\n    return s;\\n```\\n\\n\\n***IF you found it helpfull don\\'t forget to upvote and if query then ask i\\'ll try my best to make you understand Thank you so much ***\\nCoding is all about logic building and thinking just think before solve happy codding folks:)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    string s=\"\";\\n    n--;\\n    while(n>=0){\\n        s+=(\\'A\\'+n%26);\\n        n/=26;\\n        n--;\\n    }\\n    reverse(s.begin(),s.end());\\n    return s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943090,
                "title": "c-c-solutions-theorem-for-length-of-string-vs-deque-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReal Math is done in this post. Think of this problem as a problem of expressing numbers without 0 in this number system. Simply perform the conversion using a base-26 system and manipulate the resulting string. Some related questions:\\n\\n[171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/description/)\\n[2194. Cells in a Range on an Excel Sheet](https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/)\\n[13. Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3692505/python-c-using-hash-table-w-explanation/)\\n[12. Integer to Roman](https://leetcode.com/problems/integer-to-roman/)\\n[273. Integer to English Words](https://leetcode.com/problems/integer-to-english-words/)\\n\\nHow to express n as a 26-radix number? Consider the following\\n$$\\nn=\\\\sum_i a_i26^i\\n$$\\nwhere $0\\\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs a modification, i.e.\\n$$\\nn=\\\\sum_i (a_i+1)26^i\\n$$\\nThe process is shown in following pseudo code:\\n```\\nwhile (n > 0) {\\n    n--;\\n    q, r = div(n, 26);\\n    ans=(r+\\'A\\')+ans;\\n    n = q;\\n}\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe push_back takes O(1) running time for C++ string for appending a character. Then use reverse function to get the correct answer.\\n\\nI don\\'t use something like push_front (C++ string doesn\\'t have it, can use insert or operator+) because it takes properly O(len(string)) of of elapsed time.\\n\\n2nd solution does not use reverse function. Use  the formula (borrowed from number system with 0)\\n```\\nint len=floor(log(n)/log(26))+1;\\n```\\nto estimate the the length for string. There could be some better formula.  Before returning answer, check whether ans has whitespace, especially when \\'Z\\' is obtained at the last division. \\n\\n3rd solution uses deque, O(1) push_front is therefore possible!!! \\n\\nThe following theorem can be proved by using geometric sequence:\\n$$\\na+a^2+\\\\cdots+a^d=a\\\\frac{a^d-1}{a-1}\\n$$\\n # Theorem for length of the desired string\\nIf n>26 then  len(ans)=d $\\\\iff$\\n$\\n26(\\\\frac{26^{d-1}-1}{25})<n\\\\leq 26(\\\\frac{26^{d}-1}{25})=(ZZ\\\\cdots Z)\\n$\\nwhere $(ZZ\\\\cdots Z)$ denotes the number consisting of d \\'Z\\'s. After some standard manipulations for inequalities, the exact string length formula is obtained as follows\\n```\\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\\n```\\nNo need for adjustment. Cheers!!!! With this correct formula, C solution is also done.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(\\\\log n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        string ans;\\n        while (n > 0) {\\n            n--;\\n            auto [q, r] = div(n, 26);\\n            ans.push_back(char(\\'A\\'+r));\\n            n = q;\\n        }\\n        reverse(ans.begin(), ans.end()); // Reverse the ans string\\n        return ans; // Return the reversed ans string\\n    }\\n};\\n```\\n# 2nd Solution beats 100% in 0 ms also in C\\n\\n```C []\\nchar *convertToTitle(int columnNumber) {\\n    int n = columnNumber;\\n    // Compute the length for the string\\n    int len = (n <= 26) ? 1 : ceil(log(n * 25.0 / 26 + 1) / log(26));    \\n    // Allocate memory for the string including the null-terminator\\n    char *ans = (char *)malloc((len + 1) * sizeof(char));\\n    ans[len] = \\'\\\\0\\'; // Null-terminate the string\\n    \\n    while (n > 0) {\\n        n--;\\n        div_t x = div(n, 26);\\n        ans[--len] = (char)(\\'A\\' + x.rem);\\n        n = x.quot;\\n    }\\n    return ans;\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        //Compute the length for string\\n        int len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\\n        string ans(len, \\' \\');// fill with whitespace\\n        while (n > 0) {\\n            n--;\\n            auto x = div(n, 26);\\n            ans[--len]=char(\\'A\\'+x.rem);\\n            n = x.quot;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n# 3rd Solution uses deque\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        deque<char> q;\\n        while (n > 0) {\\n            n--;\\n            auto x = div(n, 26);\\n            q.push_front(char(\\'A\\'+x.rem));\\n            n = x.quot;\\n        }       \\n        return string(q.begin(), q.end()); \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String",
                    "Queue"
                ],
                "code": "```\\nwhile (n > 0) {\\n    n--;\\n    q, r = div(n, 26);\\n    ans=(r+\\'A\\')+ans;\\n    n = q;\\n}\\n```\n```\\nint len=floor(log(n)/log(26))+1;\\n```\n```\\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        string ans;\\n        while (n > 0) {\\n            n--;\\n            auto [q, r] = div(n, 26);\\n            ans.push_back(char(\\'A\\'+r));\\n            n = q;\\n        }\\n        reverse(ans.begin(), ans.end()); // Reverse the ans string\\n        return ans; // Return the reversed ans string\\n    }\\n};\\n```\n```C []\\nchar *convertToTitle(int columnNumber) {\\n    int n = columnNumber;\\n    // Compute the length for the string\\n    int len = (n <= 26) ? 1 : ceil(log(n * 25.0 / 26 + 1) / log(26));    \\n    // Allocate memory for the string including the null-terminator\\n    char *ans = (char *)malloc((len + 1) * sizeof(char));\\n    ans[len] = \\'\\\\0\\'; // Null-terminate the string\\n    \\n    while (n > 0) {\\n        n--;\\n        div_t x = div(n, 26);\\n        ans[--len] = (char)(\\'A\\' + x.rem);\\n        n = x.quot;\\n    }\\n    return ans;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        //Compute the length for string\\n        int len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\\n        string ans(len, \\' \\');// fill with whitespace\\n        while (n > 0) {\\n            n--;\\n            auto x = div(n, 26);\\n            ans[--len]=char(\\'A\\'+x.rem);\\n            n = x.quot;\\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        deque<char> q;\\n        while (n > 0) {\\n            n--;\\n            auto x = div(n, 26);\\n            q.push_front(char(\\'A\\'+x.rem));\\n            n = x.quot;\\n        }       \\n        return string(q.begin(), q.end()); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51585,
                "title": "the-way-i-come-up-with-my-solution",
                "content": "    1 -> A\\n    2 -> B\\n    3 -> C\\n    ...\\n    26 -> Z\\n    27 -> AA\\n    28 -> AB \\n\\nThe last character repeats from A to Z. The period is 26, which is similar to remainder when divided by 26. But remainder is from 0 to 25, so we need to subtract 1 on left and right side.\\n\\nLet n be the input number, r be the integer representation of the last character (1<=r<=26), we have\\n\\n> \\xa0\\xa0 n= 26x+r \\n>\\n> n-1=26x+(r-1)\\n>\\n> r-1=(n-1) % 26  and x=(n-1) / 26\\n\\n\\n\\tpublic String convertToTitle2(int n)\\n\\t{\\n\\t\\tint index = (int) Math.ceil(Math.log(1 + (26d - 1) * n / 26) / Math.log(26)) - 1;\\n\\t\\tStringBuilder result = new StringBuilder(index + 1);\\n\\t\\tresult.setLength(result.capacity());\\n\\t\\twhile (n > 0)\\n\\t\\t{\\n\\t\\t\\tint r = (n - 1) % 26 + 1;\\n\\t\\t\\tresult.setCharAt(index--, (char) (r - 1 + (int) 'A'));\\n\\t\\t\\tn = (n - 1) / 26;\\n\\t\\t}\\n\\t\\treturn result.toString();\\n\\t}\\n\\nI also calculate the length of title.\\n\\nThe maximum number of *l*-character title is ZZ...Z, ie.\\n![enter image description here][1]\\n\\n\\n  [1]: http://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20n%20&=%2026%5Ccdot%2026%5El+26%5Ccdot%2026%5E%7Bl-1%7D%20+%5Ccdots%20+26%5Ccdot%2026%5E0%5C%5C%20&=%20%5Cfrac%7B26-26%5Ccdot%2026%5El%7D%7B1-26%7D%20%5Cend%7Balign*%7D",
                "solutionTags": [
                    "Java"
                ],
                "code": "    1 -> A\\n    2 -> B\\n    3 -> C\\n    ...\\n    26 -> Z\\n    27 -> AA\\n    28 -> AB \\n\\nThe last character repeats from A to Z. The period is 26, which is similar to remainder when divided by 26. But remainder is from 0 to 25, so we need to subtract 1 on left and right side.\\n\\nLet n be the input number, r be the integer representation of the last character (1<=r<=26), we have\\n\\n> \\xa0\\xa0 n= 26x+r \\n>\\n> n-1=26x+(r-1)\\n>\\n> r-1=(n-1) % 26  and x=(n-1) / 26\\n\\n\\n\\tpublic String convertToTitle2(int n)\\n\\t{\\n\\t\\tint index = (int) Math.ceil(Math.log(1 + (26d - 1) * n / 26) / Math.log(26)) - 1;\\n\\t\\tStringBuilder result = new StringBuilder(index + 1);\\n\\t\\tresult.setLength(result.capacity());\\n\\t\\twhile (n > 0)\\n\\t\\t{\\n\\t\\t\\tint r = (n - 1) % 26 + 1;\\n\\t\\t\\tresult.setCharAt(index--, (char) (r - 1 + (int) 'A'));\\n\\t\\t\\tn = (n - 1) / 26;\\n\\t\\t}\\n\\t\\treturn result.toString();\\n\\t}\\n\\nI also calculate the length of title.\\n\\nThe maximum number of *l*-character title is ZZ...Z, ie.\\n![enter image description here][1]\\n\\n\\n  [1]: http://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20n%20&=%2026%5Ccdot%2026%5El+26%5Ccdot%2026%5E%7Bl-1%7D%20+%5Ccdots%20+26%5Ccdot%2026%5E0%5C%5C%20&=%20%5Cfrac%7B26-26%5Ccdot%2026%5El%7D%7B1-26%7D%20%5Cend%7Balign*%7D",
                "codeTag": "Unknown"
            },
            {
                "id": 3944445,
                "title": "c-string-day-22",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        string s = \"\";\\n        while(c>0){\\n            c = c - 1;\\n            char ch = \\'A\\' + c % 26;\\n            s += ch;\\n            c /= 26;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/d45b76a3-fafd-4782-9ac2-fe95633c8785_1692692402.437327.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        string s = \"\";\\n        while(c>0){\\n            c = c - 1;\\n            char ch = \\'A\\' + c % 26;\\n            s += ch;\\n            c /= 26;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943321,
                "title": "c-beats100-step-by-step-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen you look at **Excel column titles**, they are essentially a **base-26 numbering system** where the digits are represented by letters from A to Z. In other words, **A** represents **1**, **B** represents **2**, ...,**Z** represents **26**, **AA** represents **27**, **AB** represents **28**, and so on.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo convert a column number to its corresponding Excel column title, you can think of it as a **conversion from base-10 (decimal) to base-26**. Here\\'s the step-by-step approach:\\n\\n**1**. Initialize an **empty string to store the result**.\\n\\n**2**. In each iteration, **perform the following steps**:\\n-  Subtract 1 from the given columnNumber (to convert it to a 0-based index), and calculate the remainder of dividing it by 26.\\n-  Add \\'A\\' to the remainder to get the corresponding character.\\n-  Append the character to the beginning of the result string.\\n-  Update columnNumber by dividing it by 26 (integer division).\\n\\n**3**.**Repeat** the above steps until columnNumber becomes 0.\\n\\n**4**.Return the **resulting string**.\\n\\nThis approach converts the column number to its corresponding base-26 representation using characters A to Z. By continuously dividing the column number by 26 and calculating the remainders, you\\'re essentially converting the number into its corresponding digits in the Excel column title.\\n\\n**For example, let\\'s take columnNumber = 701:**\\n\\n- In the first iteration, remainder = (701 - 1) % 26 = 24, which corresponds to the character \\'Y\\'.\\n- In the second iteration, columnNumber = (701 - 1) / 26 = 26.\\n- In the third iteration, remainder = (26 - 1) % 26 = 25, which corresponds to the character \\'Z\\'.\\n- In the fourth iteration, columnNumber = (26 - 1) / 26 = 0.\\n\\n**So, the result is \"ZY\", which is the corresponding Excel column title for columnNumber 701.**\\n\\nI hope this explanation helps you understand the approach behind the solution! \\n\\n# **PLEASE UPVOTE ME IF IT IS HELPFUL TO YOU.IT WILLL MOTIVATE ME A LOT\\uD83D\\uDE0A**\\n\\n# Complexity\\n- Time complexity: **O(log(columnNumber))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(log(columnNumber))**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string>\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string result = \"\";\\n\\n        while (columnNumber > 0) {\\n            // Convert the column number to 0-based index\\n            columnNumber--;\\n\\n            // Calculate the remainder to determine the character\\n            char character = \\'A\\' + (columnNumber % 26);\\n\\n            // Append the character to the result\\n            result = character + result;\\n\\n            // Update the column number for the next iteration\\n            columnNumber /= 26;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\\n# **PLEASE UPVOTE ME IF IT IS HELPFUL TO YOU. IT WILLL MOTIVATE ME A LOT\\uD83D\\uDE0A.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string result = \"\";\\n\\n        while (columnNumber > 0) {\\n            // Convert the column number to 0-based index\\n            columnNumber--;\\n\\n            // Calculate the remainder to determine the character\\n            char character = \\'A\\' + (columnNumber % 26);\\n\\n            // Append the character to the result\\n            result = character + result;\\n\\n            // Update the column number for the next iteration\\n            columnNumber /= 26;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 51568,
                "title": "1-ms-easy-to-understand-c-solution-with-explanation",
                "content": "    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            /*\\n            Consider n as a three-char string;\\n            n = a * 26^2 + b * 26 + c; 1 <= (a,b,c) <= 26\\n            */\\n            string s;\\n            while(n>0){\\n                int tail = n % 26; // tail represents c;\\n                if(tail == 0){\\n                    tail = 26;  //c must be 26, thus last char mush be 'Z'; \\n                    s = 'Z' + s;\\n                }else{\\n                    char c = 'A' + tail - 1;\\n                    s = c + s;\\n                }\\n            \\n                n = n - tail;   // Remove last number and divided by 26;\\n                n = n / 26;     // In this way, b will be the last number for next iteration.\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            /*\\n            Consider n as a three-char string;\\n            n = a * 26^2 + b * 26 + c; 1 <= (a,b,c) <= 26\\n            */\\n            string s;\\n            while(n>0){\\n                int tail = n % 26; // tail represents c;\\n                if(tail == 0){\\n                    tail = 26;  //c must be 26, thus last char mush be 'Z'; \\n                    s = 'Z' + s;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 402247,
                "title": "javascript-easiest-and-cleanest-solution",
                "content": "```\\nvar convertToTitle = function(n) {\\n    if (n == 0) return null;\\n    let result = \\'\\';\\n    while (n > 0) {\\n        let r = n % 26;\\n        let d = parseInt(n / 26);\\n        if (r == 0) {\\n            r = 26;\\n            d = d - 1;\\n        }\\n        result += String.fromCharCode (64 + r);\\n        n = d;\\n    }\\n    return result.split(\\'\\').reverse().join(\"\");\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar convertToTitle = function(n) {\\n    if (n == 0) return null;\\n    let result = \\'\\';\\n    while (n > 0) {\\n        let r = n % 26;\\n        let d = parseInt(n / 26);\\n        if (r == 0) {\\n            r = 26;\\n            d = d - 1;\\n        }\\n        result += String.fromCharCode (64 + r);\\n        n = d;\\n    }\\n    return result.split(\\'\\').reverse().join(\"\");\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169793,
                "title": "c-readable-code",
                "content": "Sept. 13, 2018\\nIt is an easy level math algorithm. I failed my first five submission. And then I finally came out the idea to map the range from integer 1 to 26 to a smaller range from 0 to 25, deal with n - 1 in three places in the function. In other words, [0, 25] is the range to work on.\\n\\nIt took me over 15 minutes to solve the problem. I like to share my C# code here.  \\n\\n```\\npublic class Solution {\\n    const string maps = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    public string ConvertToTitle(int n)\\n        {\\n            if (n < 27)\\n            {\\n                return maps[n - 1].ToString();\\n            }\\n\\n            // 27 - AA\\n            return ConvertToTitle((n - 1 )/ 26) + maps[(n - 1)% 26].ToString();\\n    }\\n}\\n```\\nOct. 2, 2018\\nAnother problem is to define string maps with 26 characters, it is easy to make a mistake in those 26 characters. Actually it is not necessary to write down all 26 characters. \\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    const string maps = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    public string ConvertToTitle(int n)\\n        {\\n            if (n < 27)\\n            {\\n                return maps[n - 1].ToString();\\n            }\\n\\n            // 27 - AA\\n            return ConvertToTitle((n - 1 )/ 26) + maps[(n - 1)% 26].ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712859,
                "title": "java-100-faster-with-explanation",
                "content": "First of all, If you tried the problem <a href=\"https://leetcode.com/problems/excel-sheet-column-number/\">Excel Sheet Column Number</a> then this problem will be easy to solve. You can find solution of that problem <a href=\"https://leetcode.com/problems/excel-sheet-column-number/discuss/712836/Java-100-faster-with-easy-explanation\">Here.</a>\\n\\nConcept: Every time, we have to find reminder of number after divide by 26 so then we can find the character according to that with reference of A.\\n\\nEx. Input : 731\\n\\n\\t   n = 731;\\n\\t\\n\\t1)  --n = 730;\\n\\t    n % 26 = 730 % 26 = 2\\n\\t\\tsb.append( (char)(2 + \\'A\\') = \\'C\\');\\n\\t\\t\\n\\t\\tn = n / 26 ( 730 / 26 = 28 )\\n\\t\\t// sb = C\\n\\t\\n\\t2) --n = 27\\n\\t   n % 26 = 27 % 26 = 1\\n\\t   sb.append( (char)(1 + \\'A\\') = \\'B\\');\\n\\t   \\n\\t   n = n /26 ( 27 / 26 = 1 )\\n\\t   // sb = \\'CB\\'\\n\\t   \\n    2) --n = 0\\n\\t   n % 26 = 0 % 26 = 0\\n\\t   sb.append( (char)(0 + \\'A\\') = \\'A\\');\\n\\t   \\n\\t   n = n /26 ( 0 / 26 = 0 )\\n\\t   // sb = \\'CBA\\'\\n\\t   \\n\\t   sb.reverse() = \\'ABC\\'\\n\\t\\n\\treturn \"ABC\"\\n\\n<br />\\n\\nSolution :\\n\\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while( n > 0) {\\n            --n;\\n            sb.append((char)(n % 26 + \\'A\\'));\\n            n = n / 26;\\n        }\\n                \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while( n > 0) {\\n            --n;\\n            sb.append((char)(n % 26 + \\'A\\'));\\n            n = n / 26;\\n        }\\n                \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336155,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n    \\ts = \\'\\'\\n    \\twhile n > 0:\\n    \\t\\tr = n%26\\n    \\t\\tif r == 0: r = 26\\n    \\t\\ts = chr(64+r)+s\\n    \\t\\tn = int((n-r)/26)\\n    \\treturn(s)\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n    \\ts = \\'\\'\\n    \\twhile n > 0:\\n    \\t\\tr = n%26\\n    \\t\\tif r == 0: r = 26\\n    \\t\\ts = chr(64+r)+s\\n    \\t\\tn = int((n-r)/26)\\n    \\treturn(s)\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 51539,
                "title": "short-0ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            string result;\\n            while (n) {\\n                result.push_back('A' + (n - 1) % 26), n = (n - 1) / 26;    \\n            }\\n            reverse(result.begin(), result.end());\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            string result;\\n            while (n) {\\n                result.push_back('A' + (n - 1) % 26), n = (n - 1) / 26;    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1385535,
                "title": "python-simple-solution-with-explanation",
                "content": "We need to recursively divide by 26 till we reach 0, as the number of times we need to divide the column number by 26 determines the length of the column name (in letters).\\nWe subtract num by 1 so that the remainders range from (0,25) giving us the 26 alphabets we require.\\nThe ASCII value of \\'A\\' (capital letter A) is 65, so if remainder is 0, we need to return the character that corresponds with ASCII of 65, if remainder is 1, we need \\'B\\' which has ASCII value 66, and so on.\\nThe chr method returns the character corresponding to the given integral ASCII value.\\nAs we keep appending each new letter we encounter, the correct column name should be in the reverse order.\\n```\\ndef convertToTitle(self, num: int) -> str:\\n        s = \"\"\\n        \\n        while num > 0:\\n            num,rem = divmod(num-1,26)\\n            s += chr(65+rem)\\n        \\n        return s[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef convertToTitle(self, num: int) -> str:\\n        s = \"\"\\n        \\n        while num > 0:\\n            num,rem = divmod(num-1,26)\\n            s += chr(65+rem)\\n        \\n        return s[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1305525,
                "title": "python-3-simple-with-easy-explaination",
                "content": "```\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef convertToTitle(self, columnNumber: int) -> str:\\n        \\n\\t\\t\\t\\tres = \"\"\\n\\t\\t\\t\\tn = columnNumber\\n\\n\\t\\t\\t\\twhile n > 0 :   \\n\\n\\t\\t\\t\\t\\tn -= 1\\n\\t\\t\\t\\t\\tres += chr( (n % 26) + 65 )\\n\\t\\t\\t\\t\\tn //= 26\\n\\n\\t\\t\\t\\treturn res[::-1]  \\n        \\n```\\n```  \\n  \\'\\'\\'\\n        ABCD = [(A)*26^3] + [(B)*26^2] + [(C)*26^1] + [(D)] \\n        \\n        (A) = 1,(B) = 2 ......(AA) = 27....\\n        \\n        step1: ( n = n - 1 )\\n        \\n        step2: By n % 26 we get the columnuber of (alphabet)\\n        \\n        step3: Then we Add 65 (ord(A) == 65 ASCII) so that we can use it to get chr(columnuber) , \\n                but if add 65 to (n % 26) ,then we get the next element , for eg :\\n                \\n                n = 701 then 701 % 26 = 25 --> chr(25+65) == Z , but we need Y (as columnuber = Y ) \\n                therefore :\\n                we are n = n - 1 in step 1 ,\\n                n -> 700 , 700 % 26 = 24 --> chr(24+65) == Y\\n                \\n        step4: we divide it with 26 to jump to the next columnumber(B) (as it varies through 26^n) \\n        \\n        step5 : repeat while n > 0 \\n        \\n        step 6 : return the reverse eg : we are jumping from A to D in (ABCD)\\n        \\n       \\'\\'\\'\\n```\\n```\\n\\'\\'\\'\\n\\t    n = 701\\n        n-1 = 700\\n        700 % 26 = 24\\n        res += chr(24+65) == Y\\n        n = 700 // 26 == 26\\n        \\n        n = 26\\n        n-1 = 25\\n        25 % 26 = 25 -> if a > b and a % b then (a % b = a) always\\n        res += chr(25+65) == Z\\n        n = 25 // 26 ==> 0\\n\\t\\t\\n\\t\\t\\'\\'\\'\\n```\\n\\n**please upvote if u like : )**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef convertToTitle(self, columnNumber: int) -> str:\\n        \\n\\t\\t\\t\\tres = \"\"\\n\\t\\t\\t\\tn = columnNumber\\n\\n\\t\\t\\t\\twhile n > 0 :   \\n\\n\\t\\t\\t\\t\\tn -= 1\\n\\t\\t\\t\\t\\tres += chr( (n % 26) + 65 )\\n\\t\\t\\t\\t\\tn //= 26\\n\\n\\t\\t\\t\\treturn res[::-1]  \\n        \\n```\n```  \\n  \\'\\'\\'\\n        ABCD = [(A)*26^3] + [(B)*26^2] + [(C)*26^1] + [(D)] \\n        \\n        (A) = 1,(B) = 2 ......(AA) = 27....\\n        \\n        step1: ( n = n - 1 )\\n        \\n        step2: By n % 26 we get the columnuber of (alphabet)\\n        \\n        step3: Then we Add 65 (ord(A) == 65 ASCII) so that we can use it to get chr(columnuber) , \\n                but if add 65 to (n % 26) ,then we get the next element , for eg :\\n                \\n                n = 701 then 701 % 26 = 25 --> chr(25+65) == Z , but we need Y (as columnuber = Y ) \\n                therefore :\\n                we are n = n - 1 in step 1 ,\\n                n -> 700 , 700 % 26 = 24 --> chr(24+65) == Y\\n                \\n        step4: we divide it with 26 to jump to the next columnumber(B) (as it varies through 26^n) \\n        \\n        step5 : repeat while n > 0 \\n        \\n        step 6 : return the reverse eg : we are jumping from A to D in (ABCD)\\n        \\n       \\'\\'\\'\\n```\n```\\n\\'\\'\\'\\n\\t    n = 701\\n        n-1 = 700\\n        700 % 26 = 24\\n        res += chr(24+65) == Y\\n        n = 700 // 26 == 26\\n        \\n        n = 26\\n        n-1 = 25\\n        25 % 26 = 25 -> if a > b and a % b then (a % b = a) always\\n        res += chr(25+65) == Z\\n        n = 25 // 26 ==> 0\\n\\t\\t\\n\\t\\t\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51522,
                "title": "0-ms-java-solution",
                "content": "    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while (n > 0){\\n            int r = n % 26;\\n            n = n/26;\\n            if (r != 0){\\n                sb.append((char)(r - 1 + 'A'));\\n            } else {\\n                sb.append('Z');\\n                n--;\\n            }\\n            \\n        }\\n        return sb.reverse().toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while (n > 0){\\n            int r = n % 26;\\n            n = n/26;\\n            if (r != 0){\\n                sb.append((char)(r - 1 + 'A'));\\n            } else {\\n                sb.append('Z');\\n                n--;\\n            }\\n            \\n        }\\n        return sb.reverse().toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3946989,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nConvert to base 26 system.\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 246 videos as of August 22nd.\\n\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/q8DkXSns3Xk\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n**Initialization:**\\n- Initialize an empty string `res` to store the resulting column title.\\n\\n**Conversion Loop:**\\n- Enter a loop while `columnNumber` is greater than 0.\\n    - Decrement `columnNumber` by 1 to account for 1-based indexing in column titles.\\n    - Calculate the remainder of `columnNumber` divided by 26. This remainder will represent the position of the current letter in the alphabet (0 to 25).\\n    - Convert the calculated remainder to its corresponding uppercase letter using `chr((columnNumber % 26) + ord(\"A\"))`.\\n    - Add the calculated letter to the beginning of the `res` string.\\n    - Update `columnNumber` by performing integer division (floor division) by 26. This shifts to the next position in the column title.\\n\\n**Return:**\\n- Return the final `res` string, which represents the column title in Excel sheet notation.\\n\\nThis algorithm processes a given column number and converts it into its corresponding column title using a base-26 numbering system.\\n\\n# Complexity\\n- Time complexity:O(log26 n)\\nn is a given column number.\\n\\n- Space complexity: O(log26 n)\\n\\n```python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        res = \"\"\\n\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            res = chr((columnNumber % 26) + ord(\"A\")) + res\\n            columnNumber //= 26\\n        \\n        return res\\n```\\n```javascript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    let res = \"\";\\n\\n    while (columnNumber > 0) {\\n        columnNumber--;\\n        res = String.fromCharCode((columnNumber % 26) + \"A\".charCodeAt(0)) + res;\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n    \\n    return res;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder res = new StringBuilder();\\n\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            res.insert(0, (char) ((columnNumber % 26) + \\'A\\'));\\n            columnNumber /= 26;\\n        }\\n        \\n        return res.toString();        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            res = char((columnNumber % 26) + \\'A\\') + res;\\n            columnNumber /= 26;\\n        }\\n        \\n        return res;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        res = \"\"\\n\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            res = chr((columnNumber % 26) + ord(\"A\")) + res\\n            columnNumber //= 26\\n        \\n        return res\\n```\n```javascript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    let res = \"\";\\n\\n    while (columnNumber > 0) {\\n        columnNumber--;\\n        res = String.fromCharCode((columnNumber % 26) + \"A\".charCodeAt(0)) + res;\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n    \\n    return res;    \\n};\\n```\n```java []\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder res = new StringBuilder();\\n\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            res.insert(0, (char) ((columnNumber % 26) + \\'A\\'));\\n            columnNumber /= 26;\\n        }\\n        \\n        return res.toString();        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            res = char((columnNumber % 26) + \\'A\\') + res;\\n            columnNumber /= 26;\\n        }\\n        \\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945233,
                "title": "one-line-simple-c-solution-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code converts an Excel column number to its corresponding title. It iteratively derives characters by mapping values to letters, then appends them to the title.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere are the two key points of the approach:\\n\\n1. **Recursive Conversion:**\\n   - The base case of the recursion is when `columnNumber` is 0, in which case an empty string is returned.\\n   - For non-zero `columnNumber`, it is decremented by 1 (`--columnNumber`) before performing further calculations. This adjustment aligns the numbering to be 0-based, making calculations easier.\\n\\n2. **Mapping to Characters:**\\n   - The function recursively calls itself with the adjusted `columnNumber/26` value, which represents the quotient of dividing the current column number by 26.\\n   - The `(char)(columnNumber%26+\\'A\\')` expression calculates the corresponding letter for the remainder of the division by 26. Adding `\\'A\\'` ensures that the remainder values map to ASCII characters \\'A\\' to \\'Z\\'.\\n   - The calculated letter is appended to the result of the recursive call, effectively building the column title from right to left.\\n\\nIn summary, the code cleverly utilizes recursion to convert the column number into its corresponding title by iteratively dividing and calculating remainder values to map them to characters \\'A\\' to \\'Z\\'. This approach allows for an elegant solution to the problem.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        return (columnNumber==0)?\"\":convertToTitle(--columnNumber/26)+(char)(columnNumber%26+\\'A\\');\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/4806dbc5-f4c6-425e-8926-6686940dd2af_1692707036.9495242.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        return (columnNumber==0)?\"\":convertToTitle(--columnNumber/26)+(char)(columnNumber%26+\\'A\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791402,
                "title": "100-faster-solution-in-cpp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;\\n        while(columnNumber > 0){\\n            int tmp = columnNumber % 26;\\n\\t\\t\\tif(tmp == 0){    // if tmp is zero this value is (tmp + \\'A\\' - 1) is out of Ascii Captial letters, which is \\'Z\\' (desired value)\\n                ans += \\'Z\\';\\n                columnNumber--;   // If its is a multiple of 26 we need to decrement 1 from it to get desired o/p\\n            }\\n            else{\\n                ans += tmp + \\'A\\' - 1;\\n            }\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Find Helpful Upvote it**\\n**For Detailed DSA Solutions and Applications refer to Respective README files**\\nhttps://github.com/teja963/Advanced-DSA\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;\\n        while(columnNumber > 0){\\n            int tmp = columnNumber % 26;\\n\\t\\t\\tif(tmp == 0){    // if tmp is zero this value is (tmp + \\'A\\' - 1) is out of Ascii Captial letters, which is \\'Z\\' (desired value)\\n                ans += \\'Z\\';\\n                columnNumber--;   // If its is a multiple of 26 we need to decrement 1 from it to get desired o/p\\n            }\\n            else{\\n                ans += tmp + \\'A\\' - 1;\\n            }\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51477,
                "title": "my-short-java-solution-without-using-string-buffer-and-string-builder",
                "content": "    public class Solution {\\n    public static String convertToTitle(int n) {\\n      int fac=26;String s=\"\";\\n        while(n>0){\\n            n--;\\n            s=(char)(n%26+'A')+s;\\n            n/=fac;\\n        }\\n        return s;\\n    }    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static String convertToTitle(int n) {\\n      int fac=26;String s=\"\";\\n        while(n>0){\\n            n--;\\n            s=(char)(n%26+'A')+s;\\n            n/=fac;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3943544,
                "title": "0-ms-c-solution-clean-code",
                "content": "# Intuition: \\n**Prime Facorisation to find Binary number but here with a bit of twist , base is 26 insted of 2**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\nHere we run a while Loop.\\n\\nCase 1:**If the number is not exactly divisible by 2** : The remainder is converted to its corresponding character and push in the answer string(1-->A , 2-->B , 3-->C,.......) and the number is divided by 26 and then the loop is continued.\\n\\nCase 2: **If the number is exactly divisible by 26**: The number is changed to Quotient -1  and \\'Z\\' is pushed to the answer string.\\n\\nThe loop is run till columnNumber becomes 0\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn base 26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;\\n        while(columnNumber){\\n           if(columnNumber%26!=0){\\n                int x = columnNumber%26;\\n            ans.push_back(x+64);\\n            columnNumber/=26;\\n           }\\n           else{\\n               ans.push_back(\\'Z\\');\\n               int x = columnNumber/26;\\n               columnNumber = x-1;\\n           }\\n        }\\n        reverse(ans.begin() ,ans.end());\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Please Upvote\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;\\n        while(columnNumber){\\n           if(columnNumber%26!=0){\\n                int x = columnNumber%26;\\n            ans.push_back(x+64);\\n            columnNumber/=26;\\n           }\\n           else{\\n               ans.push_back(\\'Z\\');\\n               int x = columnNumber/26;\\n               columnNumber = x-1;\\n           }\\n        }\\n        reverse(ans.begin() ,ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810143,
                "title": "very-easy-c-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Consider this problem same as changing any_base number to base_10 number.\\n- This problem requires a number system conversion.\\n- We need to convert the base(10) input to base(26).\\n- But there\\'s a catch. Excel system has range: [1, 26], whereas base(26) has range: [0, 25].\\n# How to retrive letters\\n<!-- Describe your approach to solving the problem. -->\\n```\\ncolumnNumber = (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)  \\n// to retrieve Y\\n    // 26^0 is just 1, so there is (1)*(Y+1)\\n    // to retrieve Y, subtract 1 from both side, then divide both side by 26, the remainder will be Y\\n\\n// Subtracting 1 from both sides\\ncolumnNumber-1 = (26^2)*(A+1) + (26^1)*(X+1) + Y\\n\\n// dividing both sides by 26\\ncolumnNumber-1 = (26^1)*(A+1) + (26^0)*(X+1)\\nrem = Y\\n\\n// If you observe, we have just reduced our problem size, we have to continue this process until we run out of numbers(i.e: columnNumber becomes 0)\\n```\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int colNum) {\\n        // Just convert colNum into the 26 base Alpabets\\n        string res =\"\";\\n        while(colNum > 0){\\n            colNum--;\\n            res = char(colNum % 26 + \\'A\\') + res;\\n            colNum /= 26;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\ncolumnNumber = (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)  \\n// to retrieve Y\\n    // 26^0 is just 1, so there is (1)*(Y+1)\\n    // to retrieve Y, subtract 1 from both side, then divide both side by 26, the remainder will be Y\\n\\n// Subtracting 1 from both sides\\ncolumnNumber-1 = (26^2)*(A+1) + (26^1)*(X+1) + Y\\n\\n// dividing both sides by 26\\ncolumnNumber-1 = (26^1)*(A+1) + (26^0)*(X+1)\\nrem = Y\\n\\n// If you observe, we have just reduced our problem size, we have to continue this process until we run out of numbers(i.e: columnNumber becomes 0)\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int colNum) {\\n        // Just convert colNum into the 26 base Alpabets\\n        string res =\"\";\\n        while(colNum > 0){\\n            colNum--;\\n            res = char(colNum % 26 + \\'A\\') + res;\\n            colNum /= 26;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362699,
                "title": "java-no-excel",
                "content": "\\n```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder row = new StringBuilder();\\n        while (columnNumber > 0)\\n        {\\n            columnNumber--;\\n            row.insert(0,(char)(\\'A\\' + columnNumber % 26));\\n            columnNumber = columnNumber / 26;\\n        }\\n        return row.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder row = new StringBuilder();\\n        while (columnNumber > 0)\\n        {\\n            columnNumber--;\\n            row.insert(0,(char)(\\'A\\' + columnNumber % 26));\\n            columnNumber = columnNumber / 26;\\n        }\\n        return row.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549843,
                "title": "java-0ms-100-while-loop",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(n > 0){\\n            int rem = (n-1)%26;\\n            sb.append((char)(\\'A\\' + rem));\\n            n = (n-1)/26;\\n        }\\n        \\n        sb.reverse();\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(n > 0){\\n            int rem = (n-1)%26;\\n            sb.append((char)(\\'A\\' + rem));\\n            n = (n-1)/26;\\n        }\\n        \\n        sb.reverse();\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267024,
                "title": "c-100-faster-easy-clean-recursive-2-lines-only",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        if(columnNumber-- == 0) return \"\";\\n        return convertToTitle(columnNumber / 26) + (char)((columnNumber % 26) + \\'A\\');\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        if(columnNumber-- == 0) return \"\";\\n        return convertToTitle(columnNumber / 26) + (char)((columnNumber % 26) + \\'A\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875696,
                "title": "python3-simple-solution-faster-than-98",
                "content": "```\\nimport string\\n\\nalphabet = string.ascii_uppercase\\n\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        result = \"\"\\n\\n        while n > 0:\\n            n -= 1\\n\\n            n, i = divmod(n, 26)\\n            result += alphabet[i]\\n\\n        return result[::-1]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport string\\n\\nalphabet = string.ascii_uppercase\\n\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        result = \"\"\\n\\n        while n > 0:\\n            n -= 1\\n\\n            n, i = divmod(n, 26)\\n            result += alphabet[i]\\n\\n        return result[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 51510,
                "title": "my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            int num;\\n            int number = n;\\n            string s, ss;\\n            while(number>0)\\n            {\\n                number = number-1;\\n                num = number%26;\\n                ss = 'A' + num;\\n                s = ss + s;\\n                number = number/26;\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            int num;\\n            int number = n;\\n            string s, ss;\\n            while(number>0)\\n            {\\n                number = number-1;\\n                num = number%26;\\n                ss = 'A' + num;\\n                s = ss + s;\\n                number = number/26;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51607,
                "title": "c-just-a-problem-of-base-conversion",
                "content": "Convert base10/demical number n into \"base26\" string. \\n\\n(Note that there is **no \"zero\"** in A~Z, thus we regard it base26 instead of base27).\\n\\n1~26 represent A~Z separately. 27 represents \"AA\". \\nWhile in common presentation of baseX(binary, octal, ...),  27 should represent \"A0\".\\n\\nThe peoblem can be easily solved by iteration of \"mod 26 and divided by 26\".\\n\\n    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            if(n < 1)\\n                return \"\";\\n            else\\n            {\\n                string result = \"\";\\n                while(n)\\n                {//get every letter in n from right to left\\n                    n --;\\n                    char c = n%26 + 'A';\\n                    result += c;\\n                    n /= 26;\\n                }\\n                reverse(result.begin(), result.end());\\n                return result;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            if(n < 1)\\n                return \"\";\\n            else\\n            {\\n                string result = \"\";\\n                while(n)\\n                {//get every letter in n from right to left\\n                    n --;\\n                    char c = n%26 + 'A';\\n                    result += c;\\n                    n /= 26;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3943414,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:       \\n        ans=\"\"        \\n        while columnNumber>0:\\n            c=chr(ord(\\'A\\')+(columnNumber-1)%26)\\n            ans=c+ans\\n            columnNumber=(columnNumber-1)//26            \\n        return ans         \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:       \\n        ans=\"\"        \\n        while columnNumber>0:\\n            c=chr(ord(\\'A\\')+(columnNumber-1)%26)\\n            ans=c+ans\\n            columnNumber=(columnNumber-1)//26            \\n        return ans         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270141,
                "title": "python-easy-to-understand-solution",
                "content": "Please upvote if you like it.\\n```\\nclass Solution:\\n    def convertToTitle(self, num: int) -> str:\\n        ans=\"\"\\n        while num > 0:\\n            num -= 1\\n            ans = chr(num % 26 + 65) + ans\\n            num //= 26\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Please upvote if you like it.\\n```\\nclass Solution:\\n    def convertToTitle(self, num: int) -> str:\\n        ans=\"\"\\n        while num > 0:\\n            num -= 1\\n            ans = chr(num % 26 + 65) + ans\\n            num //= 26\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3212735,
                "title": "168-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo get the title, we can use the integer value of the alphabet characters to get their corresponding value.\\n\\nWe can loop through the columnNumber to get the corresponding column title. If the columnNumber is zero, then we can break the loop.\\n\\nTo get the column title, we can use the ASCII code of the alphabet characters. The ASCII code for the letter \"A\" is 65. Therefore, we can subtract 1 from the columnNumber and take the modulus of 26. This will give us the corresponding letter in the title. We can then append the corresponding letter to the title string.\\n\\nWe can then update the columnNumber by dividing it by 26 and taking the floor division. This will give us the new columnNumber that we can use for the next iteration of the loop.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n90.36%\\n\\n- Space complexity:\\nBeats\\n46.90%\\n\\n# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            title = chr(columnNumber % 26 + 65) + title\\n            columnNumber //= 26\\n        return title\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            title = chr(columnNumber % 26 + 65) + title\\n            columnNumber //= 26\\n        return title\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091641,
                "title": "100-faster-95-74-less-memory-c",
                "content": "I decrement the columnNumber by 1 everytime just to make remainder work with the expression **(columnNumber%26 + \\'A\\')**.\\n**I match not 1 to \\'A\\' but 0 to \\'A\\'**, so that when I add the remainder to \\'A\\' (which has the value range 0-25), it **correctly matches the intended letter**.\\nDo comment down in case of any queries or remarks.\\n**Please upvote if you find the algorithm useful.\\n*Thank You!!***\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n        while(columnNumber) {\\n            columnNumber--;\\n            res.push_back(columnNumber%26 + \\'A\\');\\n            columnNumber/=26;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n        while(columnNumber) {\\n            columnNumber--;\\n            res.push_back(columnNumber%26 + \\'A\\');\\n            columnNumber/=26;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309650,
                "title": "python-20-ms-faster-than-98",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        ans = \"\"\\n        \\n        while columnNumber:\\n            columnNumber -= 1\\n            ans = chr(65 + columnNumber % 26) + ans\\n            columnNumber //= 26\\n        \\n        return ans\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        ans = \"\"\\n        \\n        while columnNumber:\\n            columnNumber -= 1\\n            ans = chr(65 + columnNumber % 26) + ans\\n            columnNumber //= 26\\n        \\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 453496,
                "title": "javascript-solution-99-5-faster",
                "content": "Runtime: 40 ms, faster than 99.54% of JavaScript online submissions for Excel Sheet Column Title.\\nMemory Usage: 33.8 MB, less than 75.00% of JavaScript online submissions for Excel Sheet Column Title.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    \\n    let charMap = {\\n        0: \"Z\",\\n        1: \"A\",\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\"\\n    };\\n    \\n    \\n    let title = \"\";\\n    \\n    if (n <= 26) {\\n        return charMap[n%26]\\n    }\\n    \\n    while (n > 0) {\\n        let r = n%26;\\n       \\n        n = Math.floor(n/26);\\n        \\n        if (r == 0) {\\n            r = 0;\\n            n = n-1;\\n        }\\n        title = charMap[r] + title;\\n    }\\n    \\n    return title;\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    \\n    let charMap = {\\n        0: \"Z\",\\n        1: \"A\",\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\"\\n    };\\n    \\n    \\n    let title = \"\";\\n    \\n    if (n <= 26) {\\n        return charMap[n%26]\\n    }\\n    \\n    while (n > 0) {\\n        let r = n%26;\\n       \\n        n = Math.floor(n/26);\\n        \\n        if (r == 0) {\\n            r = 0;\\n            n = n-1;\\n        }\\n        title = charMap[r] + title;\\n    }\\n    \\n    return title;\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354651,
                "title": "javascript-100-faster-easy-to-understand-code",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    if (n < 27) return String.fromCharCode(n + 64);\\n    var s = \\'\\';\\n    while (n > 0) {\\n        var temp = n % 26;\\n        temp = temp == 0 ? 26 : temp;\\n        s = String.fromCharCode(temp + 64) + s;\\n        n -= temp;\\n        n /= 26;\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    if (n < 27) return String.fromCharCode(n + 64);\\n    var s = \\'\\';\\n    while (n > 0) {\\n        var temp = n % 26;\\n        temp = temp == 0 ? 26 : temp;\\n        s = String.fromCharCode(temp + 64) + s;\\n        n -= temp;\\n        n /= 26;\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326380,
                "title": "heavily-commented-long-division-javascript-solution",
                "content": "I wrote this one prior to lookig at all the short solutions, and though mine is quite a bit more code, I still thought it\\'d be interesting to share. It does run pretty fast, better than ~90%.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    // General idea: do long division with base 26\\n    // To do that, we need to build up a map of 26^0, 26^1, 26^2 etc\\n    // We do that in a while loop, until we reach a exp that\\'s bigger than n\\n    // Now we do long devision and store the numbers in an array\\n    \\n    // There\\'s a problem though: it\\'s not really base 26, as we can\\'t have zeroes\\n    // To fix that, there is a loop that turns zeroes into 26\\'s by borrowing 1 from 26^next\\n    \\n    // Then we can use fromCharCode(int) to turn numbers into letters    \\n    // String.fromCharCode() return will return A @ 65, Z @ 90 \\n    \\n    // Check for bad input\\n    if (!n) {\\n        return \\'\\';\\n    }\\n    \\n    // Fill up map to get the base 26 numbers\\n    let map = {\\n        0: 1,\\n        1: 26\\n    };\\n    let counter = 1;\\n    let result = 26;\\n      \\n    while (result < n) {\\n        result = result * 26;\\n        counter++;\\n        map[counter] = result;\\n    }\\n        \\n    // Long division part\\n    let i, l;\\n    let out = [];\\n    let remainder = n;\\n    for (i = counter - 1; i >= 0; i--) {\\n        \\n        // how many times can we take 26^i out of n ?\\n        let divisions = Math.floor(remainder / map[i]);\\n       \\n        // do that \\n        remainder = remainder - (divisions * map[i]);\\n        \\n        // record it\\n        out.push(divisions);\\n    }\\n    \\n    // Fix zeroes. Out can be something like [2,0,1], that should become [1,26,1]\\n    for (i = out.length - 1; i > 0; i--) {\\n        if (out[i] === 0) {\\n            out[i] = 26;\\n            out[i-1] = out[i-1] - 1;\\n        }   \\n    }\\n\\n    // Finally, convert the numbers to letters\\n    let title = \\'\\';\\n    for (i = 0, l = out.length; i < l; i++) {\\n        if (out[i] !== 0) {\\n            title += String.fromCharCode(out[i] + 64);\\n        }\\n    }\\n    \\n    return title;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    // General idea: do long division with base 26\\n    // To do that, we need to build up a map of 26^0, 26^1, 26^2 etc\\n    // We do that in a while loop, until we reach a exp that\\'s bigger than n\\n    // Now we do long devision and store the numbers in an array\\n    \\n    // There\\'s a problem though: it\\'s not really base 26, as we can\\'t have zeroes\\n    // To fix that, there is a loop that turns zeroes into 26\\'s by borrowing 1 from 26^next\\n    \\n    // Then we can use fromCharCode(int) to turn numbers into letters    \\n    // String.fromCharCode() return will return A @ 65, Z @ 90 \\n    \\n    // Check for bad input\\n    if (!n) {\\n        return \\'\\';\\n    }\\n    \\n    // Fill up map to get the base 26 numbers\\n    let map = {\\n        0: 1,\\n        1: 26\\n    };\\n    let counter = 1;\\n    let result = 26;\\n      \\n    while (result < n) {\\n        result = result * 26;\\n        counter++;\\n        map[counter] = result;\\n    }\\n        \\n    // Long division part\\n    let i, l;\\n    let out = [];\\n    let remainder = n;\\n    for (i = counter - 1; i >= 0; i--) {\\n        \\n        // how many times can we take 26^i out of n ?\\n        let divisions = Math.floor(remainder / map[i]);\\n       \\n        // do that \\n        remainder = remainder - (divisions * map[i]);\\n        \\n        // record it\\n        out.push(divisions);\\n    }\\n    \\n    // Fix zeroes. Out can be something like [2,0,1], that should become [1,26,1]\\n    for (i = out.length - 1; i > 0; i--) {\\n        if (out[i] === 0) {\\n            out[i] = 26;\\n            out[i-1] = out[i-1] - 1;\\n        }   \\n    }\\n\\n    // Finally, convert the numbers to letters\\n    let title = \\'\\';\\n    for (i = 0, l = out.length; i < l; i++) {\\n        if (out[i] !== 0) {\\n            title += String.fromCharCode(out[i] + 64);\\n        }\\n    }\\n    \\n    return title;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319399,
                "title": "javascript-solution-using-recursion",
                "content": "```\\nvar convertToTitle = function(n) {\\n     n = n - 1;\\n    if(n>=0&&n<26){\\n        return String.fromCharCode(65+n);\\n    }\\n    return convertToTitle(parseInt(n/26)) + convertToTitle((n%26)+1);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar convertToTitle = function(n) {\\n     n = n - 1;\\n    if(n>=0&&n<26){\\n        return String.fromCharCode(65+n);\\n    }\\n    return convertToTitle(parseInt(n/26)) + convertToTitle((n%26)+1);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51400,
                "title": "python-recursion",
                "content": "Surprisingly low acceptance rate for this one, just share my super beginner code here.\\n```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n <= 26:\\n            return chr(n -1 + 65)\\n        \\n        return self.convertToTitle((n-1)//26) + chr((n-1)% 26 + 65)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n <= 26:\\n            return chr(n -1 + 65)\\n        \\n        return self.convertToTitle((n-1)//26) + chr((n-1)% 26 + 65)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51405,
                "title": "javascript-1-line-code",
                "content": "```\\nreturn n === 0 ? '' : convertToTitle(~~(--n / 26)) + String.fromCharCode('A'.charCodeAt() + (n % 26));\\n```",
                "solutionTags": [],
                "code": "```\\nreturn n === 0 ? '' : convertToTitle(~~(--n / 26)) + String.fromCharCode('A'.charCodeAt() + (n % 26));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51462,
                "title": "44-ms-python-solution-with-clear-explanations",
                "content": "let [\\u03b2n \\u03b2n-1 ... \\u03b21] be a n-char string, so the number it represents is \\u03b2n * 26^(n-1) + \\u03b2n-1 * 26^(n-1-1) + ... + \\u03b21 * 26^(1-1)\\n\\nfor example:\\nA B C = A * 26^2 + B * 26^1 + C * 26^0\\n        = 1 * 26^2 + 2 * 26^1 + 3\\n\\nZ Z Z = Z * 26^2 + Z * 26^1 + Z * 26^0\\n       = 26 * 26^2 + 26 * 26^1 + 26\\n\\nTo convert the number into string, we can always get the \"small part\" which is less or equal than 26.\\nWe can divide the number by 26 recursively, the tricky part here is that when the remainder is 0, it means that the \"small part\" is exactly 26, so you must subtract the current number by 1. Here is the code:\\n\\n```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        resStr = \"\"\\n        numMod = n # in  case that n is 0 or less\\n        while True:\\n            if numMod <= 0:\\n                break\\n            numMod, numRem = divmod(numMod, 26)\\n            if numRem == 0:\\n                numMod -= 1\\n                resStr = \"Z\"+resStr\\n            else:\\n                resStr = chr(64+numRem)+resStr #ord(A) = 65\\n                \\n        return resStr\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        resStr = \"\"\\n        numMod = n # in  case that n is 0 or less\\n        while True:\\n            if numMod <= 0:\\n                break\\n            numMod, numRem = divmod(numMod, 26)\\n            if numRem == 0:\\n                numMod -= 1\\n                resStr = \"Z\"+resStr\\n            else:\\n                resStr = chr(64+numRem)+resStr #ord(A) = 65\\n                \\n        return resStr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51488,
                "title": "simple-java-solution-with-stringbuilder",
                "content": "    public String convertToTitle(int n) {\\n            StringBuilder str = new StringBuilder();\\n            int remainder = 0;\\n            while(n > 0){\\n                remainder = (n-1) % 26;\\n                str.insert(0, (char)(remainder + 'A'));\\n                n = (n - remainder) / 26;\\n            }\\n            return str.toString();\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String convertToTitle(int n) {\\n            StringBuilder str = new StringBuilder();\\n            int remainder = 0;\\n            while(n > 0){\\n                remainder = (n-1) % 26;\\n                str.insert(0, (char)(remainder + 'A'));\\n                n = (n - remainder) / 26;\\n            }\\n            return str.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 51525,
                "title": "0-ms-5-lines-c",
                "content": "    string convertToTitle(int n) {\\n        string res;\\n        while(n>=1){\\n            res=(char)('A'+(n-1)%26)+res;\\n            n=(n-1)/26;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    string convertToTitle(int n) {\\n        string res;\\n        while(n>=1){\\n            res=(char)('A'+(n-1)%26)+res;\\n            n=(n-1)/26;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3944038,
                "title": "python-3-6-lines-rotated-string-t-m-100-100",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n\\n        alpha, ans = \\'Z\\'+ ascii_uppercase, \"\"\\n\\n        while n:\\n            n, r = divmod(n,26)\\n            ans = alpha[r] + ans\\n            if not r: n-= 1\\n        return ans\\n```\\n[https://leetcode.com/problems/excel-sheet-column-title/submissions/611614578/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(log*N*) and space complexity is *O*(1), in which *N* ~ `n`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n\\n        alpha, ans = \\'Z\\'+ ascii_uppercase, \"\"\\n\\n        while n:\\n            n, r = divmod(n,26)\\n            ans = alpha[r] + ans\\n            if not r: n-= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943044,
                "title": "daily-leetcoding-challenge-august-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/excel-sheet-column-title/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/excel-sheet-column-title/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3065850,
                "title": "easiest-solution-c-with-0ms-beats-100-of-solutions",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI knew I would have to use some kind algorithem like converting to binary, so I basically did that. TO convert from the decimal equivalents I took from the ASCII table where 65 is \\'A\\' and I added the corresponding amount to get the values.\\nThen I would add it to the end and go on to the next one.\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        std::string result {};\\n        while(columnNumber>0){\\n            columnNumber-=1;\\n            result.insert(result.begin(),65+columnNumber%26);\\n            columnNumber/=26;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        std::string result {};\\n        while(columnNumber>0){\\n            columnNumber-=1;\\n            result.insert(result.begin(),65+columnNumber%26);\\n            columnNumber/=26;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744123,
                "title": "easy-to-understand-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. We can think of the solution by just pure mathematical derivation which can be done once you get hold of the pattern through some examples.\\n\\n2. We can also think of it like a n-base number system where there\\'s no 0-based counting (as per the excel format), or you may eventually get to this through the above said calculations.\\n\\n# Approach (as per intuition 1 of mathematical derivation)\\n<!-- Describe your approach to solving the problem. -->\\n- For each character, we need to see if the columnNumber is divisible by 26 or not. So if we get any remainder rem, then curr will be rem - 1 + \\'A\\', otherwise if rem is 0 but columNumber / 26 is greater than 0 then it would mean that there is a \\'Z\\' there.\\n- So, in the while loop, we will be checking for the above and then update ans to be curr + ans so as to add the curr in front of the previously found character, till columnNumber is greater than 0.\\n\\n# Complexity\\n- Time complexity: O(1) [I don\\'t think it\\'s linear but correct me if I\\'m wrong.]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) [A single string is maintained(curr is calculated each time).]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans = \"\", curr = \"\";\\n        int rem = 0;\\n        \\n        while(columnNumber > 0){\\n            rem = columnNumber % 26 ? columnNumber % 26 - 1 : 25;\\n            curr = rem + 65;\\n            ans = curr + ans;\\n            columnNumber = (columnNumber - rem) / 26;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans = \"\", curr = \"\";\\n        int rem = 0;\\n        \\n        while(columnNumber > 0){\\n            rem = columnNumber % 26 ? columnNumber % 26 - 1 : 25;\\n            curr = rem + 65;\\n            ans = curr + ans;\\n            columnNumber = (columnNumber - rem) / 26;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661322,
                "title": "easy-and-efficient-solution-c",
                "content": "string convertToTitle(int num) {\\n        \\n        string s;\\n       num =num-1;\\n        \\n        while(num >= 26)\\n        {\\n            int temp = num % 26 ;\\n            s+=char(temp +65);\\n            num = num / 26-1;\\n        }\\n        \\n         if(num <= 26)\\n        s+=char(num+65);\\n         \\n        for(int i = 0 ; i < s.size()/2 ; i++)\\n           swap(s[i],s[s.size()-1-i]);\\n        \\n        return s;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "string convertToTitle(int num) {\\n        \\n        string s;\\n       num =num-1;\\n        \\n        while(num >= 26)\\n        {\\n            int temp = num % 26 ;\\n            s+=char(temp +65);\\n            num = num / 26-1;\\n        }\\n        \\n         if(num <= 26)\\n        s+=char(num+65);\\n         \\n        for(int i = 0 ; i < s.size()/2 ; i++)\\n           swap(s[i],s[s.size()-1-i]);\\n        \\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2503369,
                "title": "simple-1-line-solution-java-c-python-0ms-solution",
                "content": "Java:\\n\\n```return n == 0 ? \"\" : convertToTitle(--n / 26) + (char)(\\'A\\' + (n % 26));```\\nC++:\\n\\n```return n == 0 ? \"\" : convertToTitle(n / 26) + (char) (--n % 26 + \\'A\\');```\\nupdate: because the behavior of different compilers, the safe version should be:\\n\\n```return n == 0 ? \"\" : convertToTitle((n - 1) / 26) + (char) ((n - 1) % 26 + \\'A\\');```\\nPython:\\n\\n```return \"\" if num == 0 else self.convertToTitle((num - 1) / 26) + chr((num - 1) % 26 + ord(\\'A\\'))```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```return n == 0 ? \"\" : convertToTitle(--n / 26) + (char)(\\'A\\' + (n % 26));```\n```return n == 0 ? \"\" : convertToTitle(n / 26) + (char) (--n % 26 + \\'A\\');```\n```return n == 0 ? \"\" : convertToTitle((n - 1) / 26) + (char) ((n - 1) % 26 + \\'A\\');```\n```return \"\" if num == 0 else self.convertToTitle((num - 1) / 26) + chr((num - 1) % 26 + ord(\\'A\\'))```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455909,
                "title": "a-simple-clear-solution",
                "content": "```\\nvar convertToTitle = function(columnNumber) {\\n    let ans = \\'\\'\\n\\n    while(columnNumber>0){\\n        let code = (--columnNumber)%26\\n        ans = String.fromCharCode(code+65) + ans\\n        columnNumber = (columnNumber-code)/26\\n    }\\n    \\n    return ans\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/db6b7b2f-1ed7-48ae-b777-4a4ba4d49c1d_1661030020.5921524.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar convertToTitle = function(columnNumber) {\\n    let ans = \\'\\'\\n\\n    while(columnNumber>0){\\n        let code = (--columnNumber)%26\\n        ans = String.fromCharCode(code+65) + ans\\n        columnNumber = (columnNumber-code)/26\\n    }\\n    \\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1886303,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        \\n        res = \\'\\'\\n        \\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            res = chr((columnNumber % 26) + ord(\\'A\\')) + res\\n            columnNumber //= 26\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        \\n        res = \\'\\'\\n        \\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            res = chr((columnNumber % 26) + ord(\\'A\\')) + res\\n            columnNumber //= 26\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790579,
                "title": "python-o-1-space",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        \\n        result = \\'\\'\\n            \\n        while(columnNumber):\\n            columnNumber -= 1\\n            charValue = (columnNumber % 26) \\n            columnNumber //= 26\\n            \\n            result = chr(charValue + ord(\\'A\\')) + result\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        \\n        result = \\'\\'\\n            \\n        while(columnNumber):\\n            columnNumber -= 1\\n            charValue = (columnNumber % 26) \\n            columnNumber //= 26\\n            \\n            result = chr(charValue + ord(\\'A\\')) + result\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628320,
                "title": "python-recursive-solution-faster-than-94-submissions",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str: \\n        \\n        if columnNumber==0:\\n            return \\'\\'\\n        \\n        q,r=divmod(columnNumber-1,26)\\n        \\n        return self.convertToTitle(q)+chr(r+ord(\\'A\\'))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str: \\n        \\n        if columnNumber==0:\\n            return \\'\\'\\n        \\n        q,r=divmod(columnNumber-1,26)\\n        \\n        return self.convertToTitle(q)+chr(r+ord(\\'A\\'))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339063,
                "title": "detailed-explanation",
                "content": "Only took me like five hours to *kinda* understand how this works.\\n\\n```ts\\n// N: column number\\n// Time: O(log N)\\n// Space: O(1) not including space reserved for output\\n\\nfunction convertToTitle(columnNumber: number): string {\\n    const CHAR_CODE_OFFSET = \"A\".charCodeAt(0);\\n    const letters: string[] = [];\\n\\n    let num = columnNumber;\\n    while (num > 0) {\\n        // Our conversion logic expects 0-based numbers, but Excel uses 1-based\\n        num--;\\n\\n        // Convert coefficient in 1s place to Excel column letter\\n        const leastSigBitCoeff = num % 26;\\n        const charCode = leastSigBitCoeff + CHAR_CODE_OFFSET;\\n        letters.unshift(String.fromCharCode(charCode));\\n\\n        // Shift coefficients right (10s place => 1s place)\\n        num = Math.floor(num / 26);\\n    }\\n\\n    return letters.join(\"\");\\n};\\n\\n/*\\nExplanation:\\nA normal base26 system maps A => 0, B => 1, ..., Z => 25\\nWith Excel, the mapping is A => 1, B => 2, ..., Z => 26\\n\\nEquation for a given number n in a normal base26 system, where coefficients range from [0, 25]:\\nn = (c2)26^2 + (c1)26^1 + (c0)26^0\\n\\nTo translate this to Excel\\'s system, we +1 all our coefficients, which now range from [1, 26]:\\nn = (c2+1)26^2 + (c1+1)26^1 + (c0+1)26^0\\n\\nOur conversion logic works by extracting the coefficient at the 1s place (c0), then shifting\\nthe coefficients to the right, where they will be extracted in future loop iterations.\\n\\nHere\\'s how to extract out the coefficient:\\n1. We start with our equation:\\n\\n    n = (c2+1)26^2 + (c1+1)26^1 + (c0+1)\\n\\n2. We then subtract 1 from each side. This is important otherwise c0+1 could be 26, which will\\n   throw off the modulo and division steps.\\n\\n    n-1 = (c2+1)26^2 + (c1+1)26^1 + c0\\n\\n3. We can then get c0 with modulo 26:\\n\\n    c0 = (n-1) % 26\\n\\nTo shift the coefficients to the right for the next iteration:\\n1. Start with our n-1 equation\\n\\n        n-1 = (c2+1)26^2 + (c1+1)26^1 + c0\\n\\n2. Divide by 26 then floor result to remove c0 and shift remaining terms\\n\\n    (n-1) / 26 = (c2+1)26^1 + (c1+1)\\n*/\\n```",
                "solutionTags": [],
                "code": "```ts\\n// N: column number\\n// Time: O(log N)\\n// Space: O(1) not including space reserved for output\\n\\nfunction convertToTitle(columnNumber: number): string {\\n    const CHAR_CODE_OFFSET = \"A\".charCodeAt(0);\\n    const letters: string[] = [];\\n\\n    let num = columnNumber;\\n    while (num > 0) {\\n        // Our conversion logic expects 0-based numbers, but Excel uses 1-based\\n        num--;\\n\\n        // Convert coefficient in 1s place to Excel column letter\\n        const leastSigBitCoeff = num % 26;\\n        const charCode = leastSigBitCoeff + CHAR_CODE_OFFSET;\\n        letters.unshift(String.fromCharCode(charCode));\\n\\n        // Shift coefficients right (10s place => 1s place)\\n        num = Math.floor(num / 26);\\n    }\\n\\n    return letters.join(\"\");\\n};\\n\\n/*\\nExplanation:\\nA normal base26 system maps A => 0, B => 1, ..., Z => 25\\nWith Excel, the mapping is A => 1, B => 2, ..., Z => 26\\n\\nEquation for a given number n in a normal base26 system, where coefficients range from [0, 25]:\\nn = (c2)26^2 + (c1)26^1 + (c0)26^0\\n\\nTo translate this to Excel\\'s system, we +1 all our coefficients, which now range from [1, 26]:\\nn = (c2+1)26^2 + (c1+1)26^1 + (c0+1)26^0\\n\\nOur conversion logic works by extracting the coefficient at the 1s place (c0), then shifting\\nthe coefficients to the right, where they will be extracted in future loop iterations.\\n\\nHere\\'s how to extract out the coefficient:\\n1. We start with our equation:\\n\\n    n = (c2+1)26^2 + (c1+1)26^1 + (c0+1)\\n\\n2. We then subtract 1 from each side. This is important otherwise c0+1 could be 26, which will\\n   throw off the modulo and division steps.\\n\\n    n-1 = (c2+1)26^2 + (c1+1)26^1 + c0\\n\\n3. We can then get c0 with modulo 26:\\n\\n    c0 = (n-1) % 26\\n\\nTo shift the coefficients to the right for the next iteration:\\n1. Start with our n-1 equation\\n\\n        n-1 = (c2+1)26^2 + (c1+1)26^1 + c0\\n\\n2. Divide by 26 then floor result to remove c0 and shift remaining terms\\n\\n    (n-1) / 26 = (c2+1)26^1 + (c1+1)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225914,
                "title": "java-recursion",
                "content": "Solution using recursion\\n\\n\\tclass Solution {\\n\\t\\tpublic String alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n\\t\\tString title=\"\";\\n\\t\\tpublic String convertToTitle(int columnNumber) {\\n\\t\\t\\tif(columnNumber <= 26){\\n\\t\\t\\t\\t return Character.toString(alphabet.charAt(columnNumber-1));\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tint rem =columnNumber%26;\\n\\t\\t\\t\\tint qu =columnNumber/26;\\n\\t\\t\\t\\tif(rem==0){\\n\\t\\t\\t\\t\\ttitle = convertToTitle(qu-1).concat(convertToTitle(26));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t title = convertToTitle(qu).concat(convertToTitle(rem));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn title;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic String alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n\\t\\tString title=\"\";\\n\\t\\tpublic String convertToTitle(int columnNumber) {\\n\\t\\t\\tif(columnNumber <= 26){\\n\\t\\t\\t\\t return Character.toString(alphabet.charAt(columnNumber-1));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 439343,
                "title": "clear-and-simple-solution-in-go-beat-100-and-100-with-a-hint",
                "content": "#### solution\\n```go\\nfunc convertToTitle(n int) string {\\n  chars := []byte{}\\n\\n  for n > 0 {\\n    n--\\n    chars = append(chars, byte(\\'A\\'+n%26))\\n    n /= 26\\n  }\\n\\n  // reverse order\\n  for h, t := 0, len(chars)-1; h < t; h, t = h+1, t-1 {\\n    chars[h], chars[t] = chars[t], chars[h]\\n  }\\n\\n  return string(chars)\\n}\\n```\\n\\n#### hint\\n```\\nA        1         1\\nAA       27        1 + 26\\nAAA      703       1 + 26 + 26*26\\nAAAA     18279     1 + 26 + 26*26 + 26*26*26\\nAAAAA    475255    1 + 26 + 26*26 + 26*26*26 + 26*26*26*26\\nBAAAA    475255    1 + 26 + 26*26 + 26*26*26 + 26*26*26*26*2\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc convertToTitle(n int) string {\\n  chars := []byte{}\\n\\n  for n > 0 {\\n    n--\\n    chars = append(chars, byte(\\'A\\'+n%26))\\n    n /= 26\\n  }\\n\\n  // reverse order\\n  for h, t := 0, len(chars)-1; h < t; h, t = h+1, t-1 {\\n    chars[h], chars[t] = chars[t], chars[h]\\n  }\\n\\n  return string(chars)\\n}\\n```\n```\\nA        1         1\\nAA       27        1 + 26\\nAAA      703       1 + 26 + 26*26\\nAAAA     18279     1 + 26 + 26*26 + 26*26*26\\nAAAAA    475255    1 + 26 + 26*26 + 26*26*26 + 26*26*26*26\\nBAAAA    475255    1 + 26 + 26*26 + 26*26*26 + 26*26*26*26*2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235117,
                "title": "javascript-solution",
                "content": "```\\nconst convertToTitle = n => {\\n  if (n < 27) {\\n    return String.fromCharCode(((n - 1) % 26) + 65);\\n  }\\n  return (\\n    convertToTitle(Math.floor((n - 1) / 26)) +\\n    String.fromCharCode(((n - 1) % 26) + 65)\\n  );\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst convertToTitle = n => {\\n  if (n < 27) {\\n    return String.fromCharCode(((n - 1) % 26) + 65);\\n  }\\n  return (\\n    convertToTitle(Math.floor((n - 1) / 26)) +\\n    String.fromCharCode(((n - 1) % 26) + 65)\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205987,
                "title": "python-solution-with-explanation",
                "content": "```\\n\\n```class Solution:\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        d=\\'0ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n        res=\\'\\'\\n        if n<=26:\\n            return d[n]\\n        else:\\n            while n > 0:\\n                n,r=divmod(n,26)\\n\\t\\t\\t\\t# This is the catcha on this problem where when r==0 as a result of n%26. eg, n=52//26=2, r=52%26=0. \\n\\t\\t\\t\\t#To get \\'AZ\\' as known for 52, n-=1 and r+=26. Same goes to 702.\\n\\t\\t\\t\\tif r == 0:\\n                    n-=1\\n                    r+=26\\n                res = d[r] + res\\n        return res\\n\\t\\t\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51460,
                "title": "c-1ms-solution-in-6-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;\\n        while (n-- != 0) {\\n            ans = char(int('A') + n % 26) + ans;\\n            n /= 26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;\\n        while (n-- != 0) {\\n            ans = char(int('A') + n % 26) + ans;\\n            n /= 26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51486,
                "title": "python-simple-solution",
                "content": "    class Solution(object):\\n        def convertToTitle(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: str\\n            \"\"\"\\n            res = ''\\n            base = ord('A')\\n            while n:\\n                n, r = divmod(n - 1, 26)\\n                res = '{}{}'.format(chr(base + r), res)\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n        def convertToTitle(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: str\\n            \"\"\"\\n            res = ''\\n            base = ord('A')\\n            while n:\\n                n, r = divmod(n - 1, 26)\\n                res = '{}",
                "codeTag": "Java"
            },
            {
                "id": 51544,
                "title": "one-line-in-java",
                "content": "    public String convertToTitle(int n) {\\n        return n<=0?\"\":convertToTitle((n-1)/26)+(char)('A'+(n-1)%26);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public String convertToTitle(int n) {\\n        return n<=0?\"\":convertToTitle((n-1)/26)+(char)('A'+(n-1)%26);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51604,
                "title": "short-and-non-recursive-c-solution-with-a-note-about-the-algorithm-trick",
                "content": "The solution is similar to converting a number to different base.  Only trick is when building the string the characters need to get inserted in the front rather that appended to the back.  Here's the code:\\n\\n    string convertToTitle(int n) {\\n        string r;\\n        for (; n > 0; n /= 26) r = (char)(--n % 26 + 'A') + r;\\n        return r;\\n    }",
                "solutionTags": [],
                "code": "The solution is similar to converting a number to different base.  Only trick is when building the string the characters need to get inserted in the front rather that appended to the back.  Here's the code:\\n\\n    string convertToTitle(int n) {\\n        string r;\\n        for (; n > 0; n /= 26) r = (char)(--n % 26 + 'A') + r;\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3944050,
                "title": "python-fastest-easy-to-understand-optimal-solution",
                "content": "# Python | Fastest | Easy to Understand | Optimal Solution\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = []\\n        while(n > 0):\\n            n -= 1\\n            curr = n % 26\\n            n = int(n / 26)\\n            ans.append(chr(curr + ord(\\'A\\')))\\n        \\n        return \\'\\'.join(ans[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = []\\n        while(n > 0):\\n            n -= 1\\n            curr = n % 26\\n            n = int(n / 26)\\n            ans.append(chr(curr + ord(\\'A\\')))\\n        \\n        return \\'\\'.join(ans[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943588,
                "title": "2-line-code-easy-100-accuracy-explanation",
                "content": "\\n# Approach\\n    Let given number = n\\n    Take remender of n, convert it into Alphabet and divide n by 26\\n    Do this untill your number become 0.\\n    One exception is when remender is 0 (It means we have to add alphabet \\'Z)\\n    In that case make remender to 26.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        string ans = \"\";\\n        while(n){\\n            ans = (char)(--n % 26 + \\'A\\') + ans;\\n            n /= 26;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![upvote_leetcode.jpeg](https://assets.leetcode.com/users/images/a47b6a99-0d7c-4040-90f5-6307284d244f_1692678224.2908423.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        string ans = \"\";\\n        while(n){\\n            ans = (char)(--n % 26 + \\'A\\') + ans;\\n            n /= 26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943126,
                "title": "simplest-python-solution-divide-by-26",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        res = \"\"\\n        while n > 0:\\n            r = (n-1) % 26\\n            n = (n-1)// 26\\n            res += chr(ord(\"A\")+r)\\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        res = \"\"\\n        while n > 0:\\n            r = (n-1) % 26\\n            n = (n-1)// 26\\n            res += chr(ord(\"A\")+r)\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406460,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log26 N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(log26 N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;    \\n        while(columnNumber) {\\n            columnNumber--;\\n            ans.push_back(columnNumber % 26 + \\'A\\');\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;    \\n        while(columnNumber) {\\n            columnNumber--;\\n            ans.push_back(columnNumber % 26 + \\'A\\');\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360578,
                "title": "easy-explain-4-line-c-code-o-log-n-please-upvote",
                "content": "\\n# Approach \\nSuppose we want to convert the number 701 to its corresponding Excel column title. We can call the function convertToTitle(701) and it will return the string \"ZY\".\\n\\nHere\\'s how the code works:\\n\\nInitialize an empty string ans.\\n```\\nstring ans;\\n```\\nEnter the loop and iterate while n is greater than or equal to 1.\\n```\\nwhile (n--) {\\n    // code here\\n}\\n```\\nIn this example, n is initially 701.\\n\\nFor each iteration of the loop, take the modulo of n with 26 and append the corresponding uppercase letter to ans.\\n\\n```\\nans.push_back(n % 26 + \\'A\\');\\n```\\nIn the first iteration, n % 26 is 23 (since 701 is greater than or equal to 26*26, we need at least two letters), so we append the letter corresponding to the ASCII code 23 + \\'A\\', which is \\'X\\'. ans is now \"X\".\\n\\nIn the second iteration, n % 26 is 0 (since 676 is divisible by 26, the second letter is \\'Z\\'), so we append the letter corresponding to the ASCII code 0 + \\'A\\', which is \\'A\\'. ans is now \"XA\".\\n\\nDivide n by 26, rounding down if necessary.\\n```\\nn /= 26;\\n```\\nIn the first iteration, n becomes 26.\\n\\nIn the second iteration, n becomes 0 (since 26 is not greater than or equal to 26).\\n\\nContinue iterating until n is less than 1.\\n\\nReverse the order of the letters in ans.\\n```\\nreverse(ans.begin(), ans.end());\\n```\\nans is now \"ZY\".\\n\\nReturn ans.\\n\\n```\\nreturn ans;\\n```\\nThe function returns \"ZY\", which is the correct Excel column title for the number 701.\\n\\nSo the function takes an integer as input, and converts it to its corresponding Excel column title, where each column title is composed of one or more uppercase letters, with the rightmost letter representing the ones digit, the second-to-rightmost letter representing the 26s digit, the third-to-rightmost letter representing the 26^2 digit, and so on.\\n\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;    \\n        while(n--){\\n            ans.push_back(n % 26 + \\'A\\');\\n            n /= 26;\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring ans;\\n```\n```\\nwhile (n--) {\\n    // code here\\n}\\n```\n```\\nans.push_back(n % 26 + \\'A\\');\\n```\n```\\nn /= 26;\\n```\n```\\nreverse(ans.begin(), ans.end());\\n```\n```\\nreturn ans;\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;    \\n        while(n--){\\n            ans.push_back(n % 26 + \\'A\\');\\n            n /= 26;\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815445,
                "title": "easy-c-solution-beats-100",
                "content": "# Code -->\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n       string al= \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        int n= columnNumber;\\n        string ans=\"\";\\n        while(n>0){\\n            n=n-1;\\n            int k= n%26;\\n            ans.push_back(al[k]);\\n            n=n/26;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n       string al= \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        int n= columnNumber;\\n        string ans=\"\";\\n        while(n>0){\\n            n=n-1;\\n            int k= n%26;\\n            ans.push_back(al[k]);\\n            n=n/26;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556971,
                "title": "c-faster-than-100-easy-solution",
                "content": "```\\n/*I decrement the columnNumber by 1 everytime just to make remainder work with the expression (columnNumber%26 + \\'A\\').\\nI match not 1 to \\'A\\' but 0 to \\'A\\', so that when I add the remainder to \\'A\\' (which has the value range 0-25), it correctly matches the intended letter.\\nDo comment down in case of any queries or remarks.\\nPlease upvote if you find the algorithm useful.\\nThank You!!\\n*/\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n        while(columnNumber) {\\n            columnNumber--;\\n            res.push_back(columnNumber%26 + \\'A\\');\\n            columnNumber/=26;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n/*I decrement the columnNumber by 1 everytime just to make remainder work with the expression (columnNumber%26 + \\'A\\').\\nI match not 1 to \\'A\\' but 0 to \\'A\\', so that when I add the remainder to \\'A\\' (which has the value range 0-25), it correctly matches the intended letter.\\nDo comment down in case of any queries or remarks.\\nPlease upvote if you find the algorithm useful.\\nThank You!!\\n*/\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n        while(columnNumber) {\\n            columnNumber--;\\n            res.push_back(columnNumber%26 + \\'A\\');\\n            columnNumber/=26;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065662,
                "title": "c-100-fast-very-simple-7-lines-best-approach",
                "content": "**All suggestions are welcome.\\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans=\"\";\\n        int reminder;\\n        while(columnNumber){\\n            reminder = columnNumber%26;\\n            if(reminder==0){\\n                reminder = 26;\\n            }\\n            char c = 64+reminder;\\n            ans =  c+ans;\\n            columnNumber = (columnNumber-reminder )/26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans=\"\";\\n        int reminder;\\n        while(columnNumber){\\n            reminder = columnNumber%26;\\n            if(reminder==0){\\n                reminder = 26;\\n            }\\n            char c = 64+reminder;\\n            ans =  c+ans;\\n            columnNumber = (columnNumber-reminder )/26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792173,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string s=\"\";\\n        while(columnNumber){\\n            columnNumber--;\\n            int a=columnNumber%26;\\n            s+=(\\'A\\'+a);\\n            columnNumber/=26;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string s=\"\";\\n        while(columnNumber){\\n            columnNumber--;\\n            int a=columnNumber%26;\\n            s+=(\\'A\\'+a);\\n            columnNumber/=26;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1515193,
                "title": "simple-to-understand-using-basic-loop-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        var result = new StringBuilder();\\n\\n        while (columnNumber > 0) {\\n            // Get the alphabet position of the last character\\n            var pos = columnNumber % 26;\\n            if (pos == 0) {\\n                pos = 26;\\n            }\\n            \\n            // Convert the position to a uppercase character\\n            var letter = (char)(\\'A\\' + (pos - 1));    \\n            \\n            // Save the character at the beginning of the result\\n            result.Insert(0, letter);\\n            \\n            // Remove the current position from consideration\\n            columnNumber -= pos;\\n            \\n            // Advance to the next position\\n            columnNumber /= 26;\\n        }        \\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        var result = new StringBuilder();\\n\\n        while (columnNumber > 0) {\\n            // Get the alphabet position of the last character\\n            var pos = columnNumber % 26;\\n            if (pos == 0) {\\n                pos = 26;\\n            }\\n            \\n            // Convert the position to a uppercase character\\n            var letter = (char)(\\'A\\' + (pos - 1));    \\n            \\n            // Save the character at the beginning of the result\\n            result.Insert(0, letter);\\n            \\n            // Remove the current position from consideration\\n            columnNumber -= pos;\\n            \\n            // Advance to the next position\\n            columnNumber /= 26;\\n        }        \\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402317,
                "title": "python-easy-to-understand",
                "content": "Do upvote if this helped you..\\nhappy learning :)\\n\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber>0:\\n            columnNumber-=1\\n            title = chr(65 + columnNumber%26) + title \\n            columnNumber //=26\\n        return title",
                "solutionTags": [],
                "code": "Do upvote if this helped you..\\nhappy learning :)\\n\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber>0:\\n            columnNumber-=1\\n            title = chr(65 + columnNumber%26) + title \\n            columnNumber //=26\\n        return title",
                "codeTag": "Java"
            },
            {
                "id": 1216846,
                "title": "java-solution-100",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder sb = new StringBuilder();\\n        while(columnNumber > 0){\\n            sb.append((char)((--columnNumber) % 26 + 65));\\n            columnNumber /= 26;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder sb = new StringBuilder();\\n        while(columnNumber > 0){\\n            sb.append((char)((--columnNumber) % 26 + 65));\\n            columnNumber /= 26;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157768,
                "title": "fast-python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        \\n        x = (columnNumber-1) % 26\\n        rest = (columnNumber-1) // 26\\n        \\n        if (rest == 0):\\n            return digits[x]\\n        return self.convertToTitle(rest) + digits[x]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        \\n        x = (columnNumber-1) % 26\\n        rest = (columnNumber-1) // 26\\n        \\n        if (rest == 0):\\n            return digits[x]\\n        return self.convertToTitle(rest) + digits[x]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110482,
                "title": "java-simple-solution-using-modulo",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        StringBuilder sb = new StringBuilder();\\n        while (n > 0){\\n            sb.append((char)((--n % 26) + 65));\\n            n = n / 26;\\n        }\\n            \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        StringBuilder sb = new StringBuilder();\\n        while (n > 0){\\n            sb.append((char)((--n % 26) + 65));\\n            n = n / 26;\\n        }\\n            \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874807,
                "title": "c-solutions",
                "content": "**C++:**\\n\\n**(1)**\\n```\\nstring convertToTitle(int n) {\\n\\tstring ans;\\n\\twhile(n){\\n\\t\\tn-=1;\\n\\t\\tans=(char)(n%26+\\'A\\')+ ans;\\n\\t\\tn/=26;\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**(2)**\\n```\\nstring convertToTitle(int n) {\\n\\treturn n==0?\"\":convertToTitle((n-1)/26)+(char)(\\'A\\'+(n-1)%26);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring convertToTitle(int n) {\\n\\tstring ans;\\n\\twhile(n){\\n\\t\\tn-=1;\\n\\t\\tans=(char)(n%26+\\'A\\')+ ans;\\n\\t\\tn/=26;\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nstring convertToTitle(int n) {\\n\\treturn n==0?\"\":convertToTitle((n-1)/26)+(char)(\\'A\\'+(n-1)%26);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601363,
                "title": "c-solution-beats-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans = \"\";\\n        while(n!=0){\\n            ans = (char)(\\'A\\'+ (n-1)%26) + ans;\\n            n = (n-1)/26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans = \"\";\\n        while(n!=0){\\n            ans = (char)(\\'A\\'+ (n-1)%26) + ans;\\n            n = (n-1)/26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387958,
                "title": "easy-to-understand-c-solution-0ms-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Excel Sheet Column Title.\\nMemory Usage: 8.3 MB, less than 36.36% of C++ online submissions for Excel Sheet Column Title.\\n\\n```\\nstring convertToTitle(int n) {\\n        \\n        string res;\\n        \\n        while(n-- > 0)\\n        {\\n            res = (char)(\\'A\\' + (n%26)) + res;\\n            n /= 26;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Excel Sheet Column Title.\\nMemory Usage: 8.3 MB, less than 36.36% of C++ online submissions for Excel Sheet Column Title.\\n\\n```\\nstring convertToTitle(int n) {\\n        \\n        string res;\\n        \\n        while(n-- > 0)\\n        {\\n            res = (char)(\\'A\\' + (n%26)) + res;\\n            n /= 26;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 281030,
                "title": "python-solution-beats-79-98-with-clear-explanation",
                "content": "Here is a explanation for the number:\\nFor decimal number, i.e., 1099? Why we express 1099 like this in decimal?\\nFrom the last digit, we make 1099 // (10 ^0) = 1099, then 1099 % 10 = 9, so the last digit is 9.\\nThen for the second last digit, first we should minus 9 * 10^0, so it would be 1099-9 = 1090, then 1090 // (10 ^1) = 109, then 109 % 10 = 9, so the last second digit is 9.\\nThen for the second digit, first we should minus 9 * 10^1, so it would be 1090 - 90 = 1000, then 1000 // (10^2) = 10, then 10 % 10 = 0, so the second digit is 0.\\nFinally, we should minus 0 * 10^2, so its still 1000, then 1000 // (10^3) = 1, then 1 % 10 = 1, so the first digit is 1, \\nand the loop condition should be the number still larger than 0.\\n\\nSame as base = 26.\\ni.e., 897.\\nFrom last digit, first we make 897 // (26^0), still 897, then 897 % 26 = 13, so the last digit is M;\\nThen for the second last digit, num = 897 - 13 * (26^0) = 884 >0 , so the loop will continue, and then we make 884 // (26^1) = 34, then 34 % 26 = 8, so the second last digit is H;\\nThen for the third last digit, num = 884 - 8*(26^1) = 676 >0, so the loop will continue, and then we make 676 // (26^2) = 1, then 1 % 26 = 1, so the third last digit is A;\\nThen we check the condition, 676 - 26^2 = 0 == 0, so the loop end. \\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:  \\n        if n <= 0:\\n            return \\'\\'\\n        ans = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n        ret = \\'\\'\\n        base = 0    \\n        while n > 0:\\n            tmp = int(n / (26 ** base))    ## everytime first devided by 26^base\\n            val = tmp % 26\\n            if val == 0:\\n                char = \\'Z\\'\\n                n = n - 26*(26**base)\\n            else:\\n                char = ans[val-1]\\n                n = n - val*(26**base)\\n            ret = char + ret\\n            base += 1\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:  \\n        if n <= 0:\\n            return \\'\\'\\n        ans = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n        ret = \\'\\'\\n        base = 0    \\n        while n > 0:\\n            tmp = int(n / (26 ** base))    ## everytime first devided by 26^base\\n            val = tmp % 26\\n            if val == 0:\\n                char = \\'Z\\'\\n                n = n - 26*(26**base)\\n            else:\\n                char = ans[val-1]\\n                n = n - val*(26**base)\\n            ret = char + ret\\n            base += 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249459,
                "title": "python3-beats-100",
                "content": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \\n        ref = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        s = \"\"\\n        while n > 0:\\n            n = n-1\\n            s = ref[n % 26] + s\\n            n = n // 26\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \\n        ref = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        s = \"\"\\n        while n > 0:\\n            n = n-1\\n            s = ref[n % 26] + s\\n            n = n // 26\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245803,
                "title": "java-solutions",
                "content": "**Solution 1: Iterative**\\n\\nTime complexity: `O(log n)` - the time complexity is log<sub>26</sub>(n)\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public String convertToTitle(int n)\\n\\t{\\n        StringBuilder sb = new StringBuilder();\\n\\n        while(n > 0)\\n\\t\\t{\\n            n--;\\n            char c = (char)(n % 26 + \\'A\\');\\n            sb.append(c);\\n            n /= 26;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n\\n**Solution 2: Recursive**\\n\\nTime complexity: `O(log n)`\\nSpace complexity: `O(log n)` - space required for the recursive function call stack\\n\\n```\\nclass Solution\\n{\\n    public String convertToTitle(int n)\\n\\t{\\n        if(n == 0)\\n            return \"\";\\n        else\\n            return convertToTitle(--n / 26) + (char)(n % 26 + \\'A\\');\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public String convertToTitle(int n)\\n\\t{\\n        StringBuilder sb = new StringBuilder();\\n\\n        while(n > 0)\\n\\t\\t{\\n            n--;\\n            char c = (char)(n % 26 + \\'A\\');\\n            sb.append(c);\\n            n /= 26;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public String convertToTitle(int n)\\n\\t{\\n        if(n == 0)\\n            return \"\";\\n        else\\n            return convertToTitle(--n / 26) + (char)(n % 26 + \\'A\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182520,
                "title": "easy-java-solution-0-ms-run-time",
                "content": "```\n String str = \"\";\n        while(n!=0){\n            int rem = (n-1)%26;\n            str = (char)(rem + 'A') + str ; \n            n=(n-1)/26;\n        }\n        return str;\n```",
                "solutionTags": [],
                "code": "```\n String str = \"\";\n        while(n!=0){\n            int rem = (n-1)%26;\n            str = (char)(rem + 'A') + str ; \n            n=(n-1)/26;\n        }\n        return str;\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51479,
                "title": "0ms-golang-solution",
                "content": "    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n    \\n    func reverse(b []byte){\\n        for i, j := 0, len(b)-1 ; i < j ; i, j = i+1, j - 1{\\n            \\n            b[i] , b [j] = b[j], b[i]\\n        } \\n        \\n    }\\n    \\n    \\n    func convertToTitle(n int) string {\\n        var b []byte\\n        for ;n > 0; n = (n - 1)/26 {\\n            b = append(b, letters[(n-1) % 26])\\n        }\\n        reverse(b)\\n        return string(b)\\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n    \\n    func reverse(b []byte){\\n        for i, j := 0, len(b)-1 ; i < j ; i, j = i+1, j - 1{\\n            \\n            b[i] , b [j] = b[j], b[i]\\n        } \\n        \\n    }\\n    \\n    \\n    func convertToTitle(n int) string {\\n        var b []byte\\n        for ;n > 0; n = (n - 1)/26 {\\n            b = append(b, letters[(n-1) % 26])\\n        }\\n        reverse(b)\\n        return string(b)\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51499,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "\\n>     1 -> A          0->A\\n>     2 -> B          1->B\\n>     3 -> C          2->C \\n>     ...             ...\\n>     26 -> Z         25->Z \\n>     27 -> AA        26->AA\\n>     28 -> AB        27->AB\\n\\n       class Solution {\\n        public:\\n            string convertToTitle(int n) {\\n                string ret = \"\";\\n                int r = 0;\\n                \\n                if (n <= 0) return ret;\\n                \\n                while (n > 0)\\n                {\\n                    r = (n - 1) % 26;\\n                    ret = (char)('A' + r) + ret;\\n                    n = (n - 1) / 26;\\n                }\\n                \\n                return ret;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            string convertToTitle(int n) {\\n                string ret = \"\";\\n                int r = 0;\\n                \\n                if (n <= 0) return ret;\\n                \\n                while (n > 0)\\n                {\\n                    r = (n - 1) % 26;\\n                    ret = (char)('A' + r) + ret;\\n                    n = (n - 1) / 26;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 51552,
                "title": "my-solution-in-c-0ms",
                "content": "  \\n\\n      char* convertToTitle(int n) \\n    {\\n        char* ans =(char*)malloc(sizeof(char)* 10);\\n        char ans2[10];\\n        int i =0;int x;int j;\\n        while(n)\\n        {\\n            x=n%26;\\n            if(x==0) x=26;\\n            ans[i]= x+'A'-1;\\n            i++;\\n            if(n%26==0) n--;\\n            n/=26;\\n        }\\n        int dig=i;\\n        for(j=0;j<dig;j++)\\n        {\\n            ans2[j] = ans[i-1-j] ;\\n        }\\n        ans2[j]='\\\\0';\\n        \\n        return ans2;",
                "solutionTags": [],
                "code": "  \\n\\n      char* convertToTitle(int n) \\n    {\\n        char* ans =(char*)malloc(sizeof(char)* 10);\\n        char ans2[10];\\n        int i =0;int x;int j;\\n        while(n)\\n        {\\n            x=n%26;\\n            if(x==0) x=26;\\n            ans[i]= x+'A'-1;\\n            i++;\\n            if(n%26==0) n--;\\n            n/=26;\\n        }\\n        int dig=i;\\n        for(j=0;j<dig;j++)\\n        {\\n            ans2[j] = ans[i-1-j] ;\\n        }\\n        ans2[j]='\\\\0';\\n        \\n        return ans2;",
                "codeTag": "Unknown"
            },
            {
                "id": 51571,
                "title": "accepted-simple-java-solution-and-how-to-improve",
                "content": "    public class Solution {\\n        public String convertToTitle(int n) {\\n            StringBuilder result = new StringBuilder();\\n    \\t\\twhile(n > 0) {\\n    \\t\\t\\tif(n % 26 == 0) {\\n    \\t\\t\\t\\tresult.append('Z');\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tresult.append((char) ('A' + n%26 - 1));\\n    \\t\\t\\t}\\n    \\t\\t\\tn = (n - 1) / 26;\\n    \\t\\t}\\n    \\t\\treturn result.reverse().toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String convertToTitle(int n) {\\n            StringBuilder result = new StringBuilder();\\n    \\t\\twhile(n > 0) {\\n    \\t\\t\\tif(n % 26 == 0) {\\n    \\t\\t\\t\\tresult.append('Z');\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 51569,
                "title": "shorter-c-solution-using-character-lookup-array",
                "content": "Use a char map to avoid character to integer calculation.\\n\\n        string convertToTitle(int n) {\\n            string map = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n            string res;\\n        \\n            while (n) {\\n                res = map[n-- % 26] + res; \\n                n /= 26;\\n            }\\n        \\n            return res;\\n        }\\n\\n\\nThe idea behind this algorithm is coming from:\\n\\nSince we have the following numeric representation mapping to characters:\\n\\n       A       B             Z\\n    1+26*0, 2+26*0, ..., 26+26*0\\n      AA      AB            AZ\\n    1+26*1, 2+26*1, ..., 26+26*1\\n      BA      BB            BZ\\n    1+26*2, 2+26*2, ..., 26+26*2\\n\\n, and we have the char lookup array:\\n\\n    A B C ... Z\\n    0 1 2 ... 25\\n\\n, the index for the lookup array is always less than the numeric representation by 1. \\nThus, we need to decrement the number n by 1 in order to locate the character in lookup map.\\n\\nSo we can write:\\n\\n    string convertToTitle(int n) {\\n        string map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        string res;\\n    \\n        while (n) {\\n            res = map[(n-1) % 26] + res; \\n            n = (n-1) / 26;\\n        }\\n    \\n        return res;\\n    }\\n\\n, which is equivalent to:\\n\\n    string convertToTitle(int n) {\\n        string map = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n        string res;\\n    \\n        while (n) {\\n            res = map[n % 26] + res; \\n            n = (n-1) / 26;\\n        }\\n    \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Use a char map to avoid character to integer calculation.\\n\\n        string convertToTitle(int n) {\\n            string map = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n            string res;\\n        \\n            while (n) {\\n                res = map[n-- % 26] + res; \\n                n /= 26;\\n            }\\n        \\n            return res;\\n        }\\n\\n\\nThe idea behind this algorithm is coming from:\\n\\nSince we have the following numeric representation mapping to characters:\\n\\n       A       B             Z\\n    1+26*0, 2+26*0, ..., 26+26*0\\n      AA      AB            AZ\\n    1+26*1, 2+26*1, ..., 26+26*1\\n      BA      BB            BZ\\n    1+26*2, 2+26*2, ..., 26+26*2\\n\\n, and we have the char lookup array:\\n\\n    A B C ... Z\\n    0 1 2 ... 25\\n\\n, the index for the lookup array is always less than the numeric representation by 1. \\nThus, we need to decrement the number n by 1 in order to locate the character in lookup map.\\n\\nSo we can write:\\n\\n    string convertToTitle(int n) {\\n        string map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        string res;\\n    \\n        while (n) {\\n            res = map[(n-1) % 26] + res; \\n            n = (n-1) / 26;\\n        }\\n    \\n        return res;\\n    }\\n\\n, which is equivalent to:\\n\\n    string convertToTitle(int n) {\\n        string map = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n        string res;\\n    \\n        while (n) {\\n            res = map[n % 26] + res; \\n            n = (n-1) / 26;\\n        }\\n    \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51605,
                "title": "simple-c-code",
                "content": "    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            if (n == 0) return \"\";\\n            int r = (n-1)%26;\\n            char c = r+'A';\\n            return convertToTitle((n-r)/26)+c;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            if (n == 0) return \"\";\\n            int r = (n-1)%26;\\n            char c = r+'A';\\n            return convertToTitle((n-r)/26)+c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3944867,
                "title": "excel-sheet-column-title-java-0-time-complexity",
                "content": "# Intuition\\n- The problem requires converting an integer into an Excel-style column title. Essentially, the task is to represent a number in base 26 where each digit corresponds to a letter in the alphabet.\\n\\n# Approach\\n- The approach taken here involves repeatedly dividing the given number by 26 (the base) while also calculating the remainder. The remainder is then mapped to a character (\\'A\\' to \\'Z\\') to form a part of the column title. The process continues until the number becomes 0. During each iteration, the remainder is calculated as (n - 1) % 26 to ensure the correct mapping to alphabet character\\n\\n# Complexity\\n- Time Complexity: The while loop iterates as many times as the number of digits in the column title, which is proportional to the logarithm of the input n in base 26. Hence, the time complexity is O(log_base_26(n)).\\n- Space Complexity: The space complexity is O(log_base_26(n)) as well, since the size of the columnTitle StringBuilder is proportional to the number of iterations in the loop.\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder columnTitle = new StringBuilder();\\n\\n        while (n > 0) {\\n            int remainder = (n - 1) % 26; // Calculate the remainder in the range [0, 25]\\n            char currentChar = (char) (\\'A\\' + remainder);\\n            columnTitle.insert(0, currentChar); // Insert at the beginning of the StringBuilder\\n            n = (n - 1) / 26; // Update n for the next iteration\\n        }\\n\\n        return columnTitle.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder columnTitle = new StringBuilder();\\n\\n        while (n > 0) {\\n            int remainder = (n - 1) % 26; // Calculate the remainder in the range [0, 25]\\n            char currentChar = (char) (\\'A\\' + remainder);\\n            columnTitle.insert(0, currentChar); // Insert at the beginning of the StringBuilder\\n            n = (n - 1) / 26; // Update n for the next iteration\\n        }\\n\\n        return columnTitle.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944229,
                "title": "c-thanks-aryabhatta-for-0-more-such-problems-solution",
                "content": "Here is the solution for the problem, you can also checkout other problems related to this!\\n[Leetcode 171 - excel sheet column number ](https://leetcode.com/problems/excel-sheet-column-number/description/)\\n[Leetcode 2194 - cells in a range on an excel sheet](https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/description/)\\n\\nPLEASE UPVOTE IF THIS HELPED YOU!\\nCHEERS!!\\n\\n# Complexity\\n- Time complexity:\\nEqual to number of cn=cn/26 operations until cn becomes 0.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int cn) { \\n\\n        //cn  =  column number\\n        string ans = \"\";\\n        char c;\\n\\n        while(cn!=0){\\n\\n            int rem = cn%26; //remainder\\n            if(rem==0) c = \\'Z\\'; //if remainder is zero, character is Z (as we\\'re in 26 based system)\\n            else c = char(\\'A\\' + rem - 1 ); //other char we calulate using this way\\n\\n            ans += c; //add your obtained char to ans string\\n\\n            //for further operation (if we have more characters to add):\\n            if(rem==0) cn = cn/26 - 1;\\n            else cn = cn / 26;\\n        }\\n        \\n        reverse(ans.begin(), ans.end()); //as answer was stored in inverse manner\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int cn) { \\n\\n        //cn  =  column number\\n        string ans = \"\";\\n        char c;\\n\\n        while(cn!=0){\\n\\n            int rem = cn%26; //remainder\\n            if(rem==0) c = \\'Z\\'; //if remainder is zero, character is Z (as we\\'re in 26 based system)\\n            else c = char(\\'A\\' + rem - 1 ); //other char we calulate using this way\\n\\n            ans += c; //add your obtained char to ans string\\n\\n            //for further operation (if we have more characters to add):\\n            if(rem==0) cn = cn/26 - 1;\\n            else cn = cn / 26;\\n        }\\n        \\n        reverse(ans.begin(), ans.end()); //as answer was stored in inverse manner\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944215,
                "title": "striver-s-approach-simple-c-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        vector<char>v={\\'Z\\',\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\'};\\n        string ans = \"\";\\n        while(c){\\n            char x = v[c%26];\\n            ans += x;\\n            if(x==\\'Z\\') c-=1;\\n            c/=26;\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        vector<char>v={\\'Z\\',\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\'};\\n        string ans = \"\";\\n        while(c){\\n            char x = v[c%26];\\n            ans += x;\\n            if(x==\\'Z\\') c-=1;\\n            c/=26;\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943214,
                "title": "easiest-c-solution-5-line-code-beast-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber){\\n        string ans = \"\";\\n        while(columnNumber--){\\n            ans += columnNumber%26 + \\'A\\';\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber){\\n        string ans = \"\";\\n        while(columnNumber--){\\n            ans += columnNumber%26 + \\'A\\';\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640228,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        res=\"\"\\n        while(columnNumber>0):\\n            columnNumber-=1\\n            i=columnNumber%26\\n            res+=chr(65+i)\\n            columnNumber=columnNumber//26\\n        return res[::-1]\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        res=\"\"\\n        while(columnNumber>0):\\n            columnNumber-=1\\n            i=columnNumber%26\\n            res+=chr(65+i)\\n            columnNumber=columnNumber//26\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603555,
                "title": "hindi-version-c-commented-code-easiest-explanation",
                "content": "**This post is written in HINDI as there are very less post explaining approaches in HINDI.**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Sabse pehle ek observation zaroori hai ki jab sirf single character hai toh A to Z hi print hoga lekin jab multiple characters honge toh kya karenge?**\\n\\nMultiple characters ko observe karte hai like : **AA** , **AB** , **AC** . In teeno cases ko observe karte hai :\\n\\n**Sample-Case-1 :** **\\'AA\\'** iska columnNumber 27 hoga lekin kese : toh hume pata hai ki english mein total 26 characters hai jinhe counting ke base par 1 to 26 numbers dete hai but coding mein agar dhyaan ho toh hum jab bhi koyi character ko represent karte hai toh wahan par \\'a\\' or \\'A\\' ko 0 se represent karte hai and \\'z\\' or \\'Z\\' ko 25 par end karte hai. Bas issi cheez ka fayda uthana hai. Hum (27-1)%26 karenge toh hume jo remainder milega usse hum \\'A\\' mein add kardenge taaki hum woh number mile jo ki rightmost character hoga toh 26%26 = 0 hoga toh rightmost character hoga \\'A\\'+ 0  = A. Ab hum columnNumber=27 ko 26 se divide kardenge taaki previous character find kar paayen. columnNumber = (27-1)/26 = 1 hoga. Ab ColumnNumber=1 hai toh remainder = (1-1)%26 = 0 hoga and yahan se hume next character \\'A\\'+0 = \\'A\\' miljaayega. Toh final answer hoga : \\'AA\\'\\n\\n**Sample-Case-1 : \\'AA\\'**\\n\\n    // ColumnNumber | Remainder      | Character    | Title\\n    //     27       | (27-1)%26 = 0  | (\\'A\\'+0) = A  |  A\\n    //(27-1)/26 = 1 | (1-1)%26 = 0   | (\\'A\\'+0) = A  |  AA\\n\\n**Sample-Case-2 : \\'AB\\'**\\n\\n    // ColumnNumber | Remainder      | Character    | Title\\n    //     28       | (28-1)%26 = 1  | (\\'A\\'+1) = B  |  B\\n    //(28-1)/26 = 1 | (1-1)%26 = 0   | (\\'A\\'+0) = A  |  AB\\n\\n**Sample-Case-3 : \\'AC\\'**\\n\\n    // ColumnNumber | Remainder      | Character    | Title\\n    //     29       | (29-1)%26 = 2  | (\\'A\\'+2) = C  |  C\\n    //(29-1)/26 = 1 | (1-1)%26 = 0   | (\\'A\\'+0) = A  |  AC\\n\\n**Ek example se dry run karke samjhte hai : columnNumber = 701**\\n\\n    // ColumnNumber   | Remainder      | Character    | Title\\n    //    701         |(701-1)%26 = 24 | (\\'A\\'+24) = Y |  Y\\n    //(701-1)/26 = 26 | (26-1)%26 = 25 | (\\'A\\'+25) = Z |  ZY\\n\\n# Complexity\\n- **Time complexity :** O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity :** O(logN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int rem = 0;\\n        string title = \"\";\\n        while(columnNumber>0)\\n        {\\n            \\n            // 1 ko subtract karne ka reason hi yehi hai ki hum coding scenario mein \\'A\\' to \\'Z\\' ko 0 to 25 represent karte hai\\n            rem = ((columnNumber-1)%26);\\n            title += (\\'A\\'+rem);\\n            columnNumber = (columnNumber-1)/26;\\n        }\\n        // reverse isliye karna zaroori hai because hum backward append kar rahe hai loop mein characters ko. \\n        // Agar reverse nahi karna chahate toh loop mein jo title waali line hai usse remove karke front appending karlo like this : title = (\\'A\\'+rem) + title\\n        reverse(title.begin(),title.end());\\n        return title;\\n    }\\n};\\n```\\n\\n# Ek motivational quote ke saath khatam karte hai post :\\n![LeetcodeMotivation.PNG](https://assets.leetcode.com/users/images/57d186b9-b010-4f5c-acd4-d6e6c91320e2_1686032598.2052639.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int rem = 0;\\n        string title = \"\";\\n        while(columnNumber>0)\\n        {\\n            \\n            // 1 ko subtract karne ka reason hi yehi hai ki hum coding scenario mein \\'A\\' to \\'Z\\' ko 0 to 25 represent karte hai\\n            rem = ((columnNumber-1)%26);\\n            title += (\\'A\\'+rem);\\n            columnNumber = (columnNumber-1)/26;\\n        }\\n        // reverse isliye karna zaroori hai because hum backward append kar rahe hai loop mein characters ko. \\n        // Agar reverse nahi karna chahate toh loop mein jo title waali line hai usse remove karke front appending karlo like this : title = (\\'A\\'+rem) + title\\n        reverse(title.begin(),title.end());\\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200056,
                "title": "converting-column-number-to-column-title-in-excel-sheet-using-base-26-system",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to convert a given column number into the corresponding column title in an Excel sheet. We can use the ASCII codes of the capital letters to represent the column titles.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use the algorithm mentioned earlier to convert the column number to its corresponding title. We start by initializing an empty string to store the column title. We then use a while loop to iterate over the column number until it becomes zero. Within the loop, we subtract 1 from the column number to account for 0-based indexing, and then compute the remainder of the column number when divided by 26. We add this remainder to the ASCII code of \\'A\\' to get the corresponding capital letter, which we then append to the beginning of the column title string. Finally, we divide the column number by 26 and update its value for the next iteration. We continue this process until the column number becomes zero, and then return the column title string.\\n# Complexity\\n- Time complexity:The time complexity of the algorithm is $$O(log N)$$, where N is the given column number. This is because we divide the column number by 26 in each iteration of the loop, which reduces its value by a factor of 26. Since the number of digits in the base 26 representation of N is $$log(N)$$, the number of iterations required to reduce N to zero is $$log(N)$$ The time complexity of the chr() and ord() functions used to convert between ASCII codes and characters is $$O(1)$$, so they do not affect the overall time complexity of the algorithm.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the algorithm is also $$O(log N$$), since the size of the column title string is proportional to the number of iterations of the loop.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n## Summary -\\nThis algorithm converts a given column number to its corresponding column title in an Excel sheet using the base-26 system and ASCII codes of capital letters. It works by iterating over the column number, computing the remainder when divided by 26, and adding the corresponding letter to the beginning of the column title. It then updates the column number and continues the process until the column number becomes zero. The time complexity of the algorithm is $$O(log N)$$, and the space complexity is also $$O(log N)$$ where N is the given column number.\\n# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            letter = chr(columnNumber % 26 + ord(\\'A\\'))\\n            title = letter + title\\n            columnNumber //= 26\\n        return title\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            letter = chr(columnNumber % 26 + ord(\\'A\\'))\\n            title = letter + title\\n            columnNumber //= 26\\n        return title\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149334,
                "title": "excel-sheet-column-title-in-python",
                "content": "# Intuition\\nAssign characters as per unicode values, keeping in mind the values that go beyond the 26 letters of the alphabet.\\n\\n# Approach\\nAssign the value of `columnNumber` to a variable `n`. Initialize a blank string `res`. Initialize a while loop with the condition `n > 0`. \\nInside the `while loop`:\\nDecrement the value of `n` by 1, to fit the number system starting with `0` instead of `1`. Calculate the modulus of `n` when divided by `26`, to get the value by which the number is exceeding the 26 letters of the alphabet. Add this value to the unicode value of `A`, to get the unicode value of the letter. Apply the `chr` function with this value as the input, to get the letter. Concatenate this with the string `res`. Calculate the value of the floor division of `n` by 26, to move on to the next value for consideration in the loop.\\n\\n**Let us understand this with the help of an example:**\\n\\nSuppose, `columnNumber` is given as 27.\\nWe assign this value to `n`.\\nThen initialize the empty string `res`.\\nCheck the while loop codition, which is passed. So, we enter the loop. \\nDecrement `n` by 1, so we get 26. \\nNext, the modulus of `n` when divided by 26 is calculated as 0. We add this to the unicode value of `A`, which gives us 65. \\nThe `chr` function returns `A` for this value. \\nWe concatenate `A` with res, to get `A`.\\nFloor division of `n` by 26 gives 1.\\nThis value goes back into the loop. \\nThe condition is passed, so we wnter the loop and `n` is decremented to 0. \\nThe modulus is still 0, so the output of `chr` function is `A`, which is concatenated with the previous value of `res`, which is `A`.\\nFloor division of `n` by 26 now gives 0, which fails the loop condition, so we exit.\\nFinally, we return the value of `res` as `AA`.\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        n = columnNumber\\n        res = \"\"\\n        while n > 0:\\n            n -= 1\\n            res = chr(n % 26 + ord(\\'A\\')) + res\\n            n //= 26\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        n = columnNumber\\n        res = \"\"\\n        while n > 0:\\n            n -= 1\\n            res = chr(n % 26 + ord(\\'A\\')) + res\\n            n //= 26\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035427,
                "title": "0ms-faster-than-100-easy-explained-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string res;\\n        while (n!=NULL) {\\n            res.push_back(\\'A\\' + (n - 1) % 26); //since n>=1 so we can have atleast one \\'A\\' \\n            n = (n - 1) / 26;   \\n        }\\n        reverse(res.begin(), res.end()); // coz when we pushing char. it was adding from behind so for getting in correct form we finally reversing\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string res;\\n        while (n!=NULL) {\\n            res.push_back(\\'A\\' + (n - 1) % 26); //since n>=1 so we can have atleast one \\'A\\' \\n            n = (n - 1) / 26;   \\n        }\\n        reverse(res.begin(), res.end()); // coz when we pushing char. it was adding from behind so for getting in correct form we finally reversing\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887082,
                "title": "100-mathematical",
                "content": "# Approach\\nSimple and mathematical approach\\n\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        string r = \"\";\\n\\n        while(c) {\\n            int  d = --c%26;\\n            c = c/26;\\n            r = (char)(d+\\'A\\') + r;            \\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        string r = \"\";\\n\\n        while(c) {\\n            int  d = --c%26;\\n            c = c/26;\\n            r = (char)(d+\\'A\\') + r;            \\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747536,
                "title": "java-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder ans = new StringBuilder();\\n        while (columnNumber != 0) {\\n            int rem = columnNumber % 26;\\n            ans.append(getChar(rem));\\n            columnNumber /= 26;\\n            columnNumber = (rem == 0 ? columnNumber - 1 : columnNumber);\\n        }\\n        return ans.reverse().toString();\\n    }\\n    \\n    private String getChar(int num) {\\n        int base = 64;\\n        if (num == 0) {\\n            return \"Z\";\\n        }\\n        return String.valueOf((char)(base + num));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder ans = new StringBuilder();\\n        while (columnNumber != 0) {\\n            int rem = columnNumber % 26;\\n            ans.append(getChar(rem));\\n            columnNumber /= 26;\\n            columnNumber = (rem == 0 ? columnNumber - 1 : columnNumber);\\n        }\\n        return ans.reverse().toString();\\n    }\\n    \\n    private String getChar(int num) {\\n        int base = 64;\\n        if (num == 0) {\\n            return \"Z\";\\n        }\\n        return String.valueOf((char)(base + num));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403803,
                "title": "easy-to-understand-java-solution-using-stringbuilder-100-faster-than-others",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder str = new StringBuilder();\\n        while (columnNumber > 0) {\\n            int cid = (columnNumber - 1) % 26;\\n            str.append((char) (cid + \\'A\\'));\\n            columnNumber = (columnNumber - 1) / 26;\\n        }\\n        return str.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder str = new StringBuilder();\\n        while (columnNumber > 0) {\\n            int cid = (columnNumber - 1) % 26;\\n            str.append((char) (cid + \\'A\\'));\\n            columnNumber = (columnNumber - 1) / 26;\\n        }\\n        return str.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377341,
                "title": "easy-python-explained",
                "content": "# Hello!\\uD83D\\uDC31\\u200D\\uD83D\\uDC64\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F\\n```\\nclass Solution:\\n    def convertToTitle(self, num: int) -> str:\\n\\t\\t# We make this lookup list, having A-Z in ascending order\\n        alpha = [chr(x) for x in range(ord(\"A\"), ord(\"Z\")+1)]     # range(65, 90+1) -> 91-65 = 26\\n        res = \"\"\\n\\n        while num > 0:\\n            res += alpha[(num-1)%26]     # since 0 indexed list, num-1 % 26 gives the index of ch in alpha\\n            num = (num-1) // 26 \\n        return res[::-1]\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, num: int) -> str:\\n\\t\\t# We make this lookup list, having A-Z in ascending order\\n        alpha = [chr(x) for x in range(ord(\"A\"), ord(\"Z\")+1)]     # range(65, 90+1) -> 91-65 = 26\\n        res = \"\"\\n\\n        while num > 0:\\n            res += alpha[(num-1)%26]     # since 0 indexed list, num-1 % 26 gives the index of ch in alpha\\n            num = (num-1) // 26 \\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322848,
                "title": "java-easy-commented-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int column) {\\n\\t\\t// StringBuilder to store the result\\n        StringBuilder result = new StringBuilder();\\n\\t\\t\\n        while (column > 0) {\\n            int letter = (column % 26); // get letter from the column number\\n            if (letter == 0) { // edge case for Z (26 % 26 == 0)\\n                result.append(\\'Z\\');\\n                column = (column / 26) - 1;\\n                continue;\\n            }\\n\\t\\t\\t// regular case\\n            result.append((char)(\\'A\\' + (letter - 1)));\\n            column /= 26;\\n        }\\n\\t\\t// reverse the result and return\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int column) {\\n\\t\\t// StringBuilder to store the result\\n        StringBuilder result = new StringBuilder();\\n\\t\\t\\n        while (column > 0) {\\n            int letter = (column % 26); // get letter from the column number\\n            if (letter == 0) { // edge case for Z (26 % 26 == 0)\\n                result.append(\\'Z\\');\\n                column = (column / 26) - 1;\\n                continue;\\n            }\\n\\t\\t\\t// regular case\\n            result.append((char)(\\'A\\' + (letter - 1)));\\n            column /= 26;\\n        }\\n\\t\\t// reverse the result and return\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176938,
                "title": "java-0ms-100-fatser",
                "content": "If the number is a multiple of 26 i.e. if remainder is 0, then definitely it is ending with \"Z\". Only if this condition is handled, rest others will fall in place.\\n```\\npublic String convertToTitle(int columnNumber) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\twhile (columnNumber > 26) {\\n\\t\\t\\tint rem = columnNumber % 26;\\n\\t\\t\\tif (rem == 0) {\\n\\t\\t\\t\\tsb.append(\"Z\");\\n\\t\\t\\t\\tcolumnNumber -= 26;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tsb.append((char) (rem + \\'A\\' - 1));\\n\\t\\t\\tcolumnNumber /= 26;\\n\\t\\t}\\n\\t\\tsb.append((char) (columnNumber + \\'A\\' - 1));\\n\\t\\treturn sb.reverse().toString();\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String convertToTitle(int columnNumber) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\twhile (columnNumber > 26) {\\n\\t\\t\\tint rem = columnNumber % 26;\\n\\t\\t\\tif (rem == 0) {\\n\\t\\t\\t\\tsb.append(\"Z\");\\n\\t\\t\\t\\tcolumnNumber -= 26;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tsb.append((char) (rem + \\'A\\' - 1));\\n\\t\\t\\tcolumnNumber /= 26;\\n\\t\\t}\\n\\t\\tsb.append((char) (columnNumber + \\'A\\' - 1));\\n\\t\\treturn sb.reverse().toString();\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2156221,
                "title": "java-100-faster-0ms",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder res=new StringBuilder();\\n        while(columnNumber>0){\\n            columnNumber--;\\n            res.append((char)(\\'A\\'+columnNumber%26));\\n            columnNumber/=26;\\n        }\\n        return res.reverse().toString();\\n    }   \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder res=new StringBuilder();\\n        while(columnNumber>0){\\n            columnNumber--;\\n            res.append((char)(\\'A\\'+columnNumber%26));\\n            columnNumber/=26;\\n        }\\n        return res.reverse().toString();\\n    }   \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106021,
                "title": "java-simple-solution-100",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        int n=columnNumber;\\n        StringBuilder b=new StringBuilder(\"\");\\n        \\n        while(n>0){\\n           int r=n%26;\\n           if(r==0){\\n               b.append(\"Z\");\\n               n=(n-26)/26;\\n           } else{\\n               b.append((char)(64+r));\\n               n=(n-r)/26;\\n           }\\n            \\n        }\\n     return b.reverse().toString();   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        int n=columnNumber;\\n        StringBuilder b=new StringBuilder(\"\");\\n        \\n        while(n>0){\\n           int r=n%26;\\n           if(r==0){\\n               b.append(\"Z\");\\n               n=(n-26)/26;\\n           } else{\\n               b.append((char)(64+r));\\n               n=(n-r)/26;\\n           }\\n            \\n        }\\n     return b.reverse().toString();   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001736,
                "title": "just-6-lines-shortest-c-code-just-check-it",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber)\\n    {\\n        string res = \"\";\\n        while (columnNumber)\\n        {\\n            char ch =\\'A\\' + (columnNumber - 1) % 26;\\n            res = ch + res;\\n            columnNumber = (columnNumber-1)/26;  \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber)\\n    {\\n        string res = \"\";\\n        while (columnNumber)\\n        {\\n            char ch =\\'A\\' + (columnNumber - 1) % 26;\\n            res = ch + res;\\n            columnNumber = (columnNumber-1)/26;  \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962460,
                "title": "fastest-0-ms-and-simplest-10-eloc-solution-in-c",
                "content": "char * convertToTitle(int columnNumber)\\n{\\n\\n    char * ptr;\\n    ptr = malloc(8 * sizeof(char));\\n    ptr += 7;\\n    *ptr = 0;\\n    \\n    while(columnNumber)\\n    {\\n        ptr--;\\n        columnNumber = columnNumber - 1;\\n        *ptr = (columnNumber%26) + 65;\\n        columnNumber = columnNumber/26;\\n    }    \\n\\n    return ptr;\\n}\\n\\n**Please, upvode if you believe this is the simplest solution in C.**",
                "solutionTags": [
                    "C"
                ],
                "code": "char * convertToTitle(int columnNumber)\\n{\\n\\n    char * ptr;\\n    ptr = malloc(8 * sizeof(char));\\n    ptr += 7;\\n    *ptr = 0;\\n    \\n    while(columnNumber)\\n    {\\n        ptr--;\\n        columnNumber = columnNumber - 1;\\n        *ptr = (columnNumber%26) + 65;\\n        columnNumber = columnNumber/26;\\n    }    \\n\\n    return ptr;\\n}\\n\\n**Please, upvode if you believe this is the simplest solution in C.**",
                "codeTag": "Unknown"
            },
            {
                "id": 1837466,
                "title": "python-simple-and-elegant",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n        \\n        while n:\\n            n, r = (n-1)//26, (n-1)%26\\n            ans = chr(ord(\"A\")+r) + ans\\n        \\n        return ans\\n```\\n\\n**Using *divmod***:\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = chr(ord(\"A\")+r) + ans\\n        \\n        return ans\\n```\\n\\n**Using char map**:\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n\\n        c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = c[r] + ans\\n        \\n        return ans\\n```\\n\\n**Generating the charmap using *map***:\\n```\\nclass Solution:\\n    def convertToTitle(self, n):\\n        ans = \"\"\\n\\n        c = list(map(chr,range(ord(\"A\"),ord(\"Z\")+1)))\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = c[r] + ans\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n        \\n        while n:\\n            n, r = (n-1)//26, (n-1)%26\\n            ans = chr(ord(\"A\")+r) + ans\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = chr(ord(\"A\")+r) + ans\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n\\n        c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = c[r] + ans\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def convertToTitle(self, n):\\n        ans = \"\"\\n\\n        c = list(map(chr,range(ord(\"A\"),ord(\"Z\")+1)))\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = c[r] + ans\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588244,
                "title": "python-easy-approach-simple-maths",
                "content": "\\tclass Solution:\\n\\t\\tdef convertToTitle(self, columnNumber: int) -> str:\\n\\t\\t\\t# AB = A\\xD726\\xB9\\uFF0BB \\uFF1D 1\\xD726\\xB9\\uFF0B2\\n\\t\\t\\t# ABCD\\uFF1DA\\xD726\\xB3\\uFF0BB\\xD726\\xB2\\uFF0BC\\xD726\\xB9\\uFF0BD\\uFF1D1\\xD726\\xB3\\uFF0B2\\xD726\\xB2\\uFF0B3\\xD726\\xB9\\uFF0B4\\n\\t\\t\\tsheet = [chr(i) for i in range(ord(\"A\"), ord(\"Z\")+1)]\\n\\t\\t\\tres = []\\n\\t\\t\\twhile columnNumber > 0:\\n\\t\\t\\t\\tres.append(sheet[(columnNumber-1) % 26])\\n\\t\\t\\t\\tcolumnNumber = (columnNumber-1)//26\\n\\t\\t\\treturn \"\".join(res[::-1])",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef convertToTitle(self, columnNumber: int) -> str:\\n\\t\\t\\t# AB = A\\xD726\\xB9\\uFF0BB \\uFF1D 1\\xD726\\xB9\\uFF0B2\\n\\t\\t\\t# ABCD\\uFF1DA\\xD726\\xB3\\uFF0BB\\xD726\\xB2\\uFF0BC\\xD726\\xB9\\uFF0BD\\uFF1D1\\xD726\\xB3\\uFF0B2\\xD726\\xB2\\uFF0B3\\xD726\\xB9\\uFF0B4\\n\\t\\t\\tsheet = [chr(i) for i in range(ord(\"A\"), ord(\"Z\")+1)]\\n\\t\\t\\tres = []\\n\\t\\t\\twhile columnNumber > 0:\\n\\t\\t\\t\\tres.append(sheet[(columnNumber-1) % 26])\\n\\t\\t\\t\\tcolumnNumber = (columnNumber-1)//26\\n\\t\\t\\treturn \"\".join(res[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 1473821,
                "title": "python-easy-to-understand-solution",
                "content": "1. Extract the ascii value of A and the module of columNumber, (caveat: columnNumber need to subtract itself by 1 in order to match the exact ascii value). \\n2. This process gives us the result in the reverse order, we still need to change it back to the normal order.\\n```\\nclass Solution(object):\\n    def convertToTitle(self, columnNumber):\\n        \"\"\"\\n        :type columnNumber: int\\n        :rtype: str\\n        \"\"\"\\n        ans = \\'\\'\\n        while columnNumber > 0:\\n              columnNumber -= 1 \\n              ans += chr(ord(\\'A\\') + columnNumber % 26)\\n              columnNumber /= 26\\n            \\n        \\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertToTitle(self, columnNumber):\\n        \"\"\"\\n        :type columnNumber: int\\n        :rtype: str\\n        \"\"\"\\n        ans = \\'\\'\\n        while columnNumber > 0:\\n              columnNumber -= 1 \\n              ans += chr(ord(\\'A\\') + columnNumber % 26)\\n              columnNumber /= 26\\n            \\n        \\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399078,
                "title": "c-7-lines-explanation",
                "content": "Let\\'s write down the first `26 + 26^2` excel titles.\\n\\n`A, B, C, ..., Z, AA, AB, ..., ZZ`\\n\\nNotice that the last digit always fluctuates between letters `A, B, C, ..., Z`. \\nSo the formula for the last digit is `x = (char) (\\'A\\' + (n-1) % 26)`\\n\\nNow, if we divide `n-1` by `26`, it is going to become 0 for the first 26 titles and `m` for everything else, \\nwhere `m` is the 1-based index of the second to last tittle letter in the alphabet.\\n\\nFor titles longer than 2 letters we can show by recursion that `m` is the number corresponding to the excel title \\n`s = convertToTitle(m) ` such that `s + x == convertToTitle(n)`.\\n\\nUsing this method, we can solve the problem by updating `n` until it reaches `0`, which means that there are no more letters left.\\n\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string s;\\n        while (n > 0) {\\n            n -= 1;\\n            s.push_back(\\'A\\' + n % 26);\\n            n /= 26;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string s;\\n        while (n > 0) {\\n            n -= 1;\\n            s.push_back(\\'A\\' + n % 26);\\n            n /= 26;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347481,
                "title": "0-ms-faster-than-100-java",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuffer s=new StringBuffer();\\n        while(n>0){\\n            n--;\\n            s.append((char)(\\'A\\' + n % 26));\\n            n /= 26;\\n        }\\n    return s.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuffer s=new StringBuffer();\\n        while(n>0){\\n            n--;\\n            s.append((char)(\\'A\\' + n % 26));\\n            n /= 26;\\n        }\\n    return s.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313492,
                "title": "100-faster-c",
                "content": "```class Solution {\\npublic:\\n    string convertToTitle(int n) {\\n      string result=\"\";\\n      while(n>0){\\n          char c=\\'A\\'+(n-1)%26;\\n          result=c+result;\\n          n=(n-1)/26;\\n      }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    string convertToTitle(int n) {\\n      string result=\"\";\\n      while(n>0){\\n          char c=\\'A\\'+(n-1)%26;\\n          result=c+result;\\n          n=(n-1)/26;\\n      }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256201,
                "title": "js-simple-and-easy-to-understand-o-n-only",
                "content": "Javascript beat 97%\\n```\\nvar convertToTitle = function(columnNumber) {\\n    let roundQuotient= 0;\\n    let result =\"\"\\n    while (columnNumber){\\n        result = String.fromCharCode(((columnNumber-1)%26)+97) + result\\n        columnNumber = Math.floor((columnNumber-1)/26);\\n        console.log(\"result in loop\", result, \"column#\", columnNumber)\\n    }\\n    console.log(\"final\",result)\\n    return result.toUpperCase()\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar convertToTitle = function(columnNumber) {\\n    let roundQuotient= 0;\\n    let result =\"\"\\n    while (columnNumber){\\n        result = String.fromCharCode(((columnNumber-1)%26)+97) + result\\n        columnNumber = Math.floor((columnNumber-1)/26);\\n        console.log(\"result in loop\", result, \"column#\", columnNumber)\\n    }\\n    console.log(\"final\",result)\\n    return result.toUpperCase()\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1252667,
                "title": "c-4-ms-100-faster",
                "content": "```\\nstring convertToTitle(int colNum) {\\n        string s;\\n        int x=0;\\n        while(colNum){\\n        x=colNum%26;colNum/=26;\\n        if(x<=0){ x+=26; colNum--;}\\n        s.push_back(\\'A\\'+x-1);\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring convertToTitle(int colNum) {\\n        string s;\\n        int x=0;\\n        while(colNum){\\n        x=colNum%26;colNum/=26;\\n        if(x<=0){ x+=26; colNum--;}\\n        s.push_back(\\'A\\'+x-1);\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1024324,
                "title": "easy-to-read-c-code",
                "content": "char * convertToTitle(int n){\\n    \\n    int numberOfCharacters = 0;\\n    int input = n;\\n    while(input > 0){\\n        input -= 1;\\n        input /=26;\\n        numberOfCharacters++;\\n    }\\n    \\n    //+1 for the null terminator\\n    char * rv = calloc(numberOfCharacters+1, sizeof(char));\\n    \\n    //filling characters from the back\\n    int index = numberOfCharacters - 1;\\n    input = n;\\n    while(index >= 0){\\n        input -= 1;\\n        rv[index--] = (input % 26) + \\'A\\';\\n            \\n        input /=26;\\n    }\\n    \\n    return rv;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "char * convertToTitle(int n){\\n    \\n    int numberOfCharacters = 0;\\n    int input = n;\\n    while(input > 0){\\n        input -= 1;\\n        input /=26;\\n        numberOfCharacters++;\\n    }\\n    \\n    //+1 for the null terminator\\n    char * rv = calloc(numberOfCharacters+1, sizeof(char));\\n    \\n    //filling characters from the back\\n    int index = numberOfCharacters - 1;\\n    input = n;\\n    while(index >= 0){\\n        input -= 1;\\n        rv[index--] = (input % 26) + \\'A\\';\\n            \\n        input /=26;\\n    }\\n    \\n    return rv;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1003417,
                "title": "python3-faster-than-98-iterative-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans=\\'\\'\\n        while n:\\n            ans=chr(ord(\\'A\\')+((n-1)%26))+ans\\n            n=(n-1)//26\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans=\\'\\'\\n        while n:\\n            ans=chr(ord(\\'A\\')+((n-1)%26))+ans\\n            n=(n-1)//26\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761494,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder res = new StringBuilder();\\n        while(n>0){\\n            n--;\\n            res.insert(0,(char)(\\'A\\'+n%26));\\n            n/=26;\\n        }\\n      return res.toString();  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder res = new StringBuilder();\\n        while(n>0){\\n            n--;\\n            res.insert(0,(char)(\\'A\\'+n%26));\\n            n/=26;\\n        }\\n      return res.toString();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732378,
                "title": "java-100-fast",
                "content": "If you found this solution helpful, kindly upvote. :)\\n\\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuffer s=new StringBuffer();\\n        while(n>0)\\n        {\\n            n--;\\n            char ch=(char)(n%26+\\'A\\');\\n            n=n/26;\\n            s.append(ch);\\n        }\\n        return s.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuffer s=new StringBuffer();\\n        while(n>0)\\n        {\\n            n--;\\n            char ch=(char)(n%26+\\'A\\');\\n            n=n/26;\\n            s.append(ch);\\n        }\\n        return s.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384223,
                "title": "swift-0ms-solution-without-unicodescalar",
                "content": "```\\n    func convertToTitle(_ n: Int) -> String {\\n        let chars = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\\n        var result = \"\"\\n        var current = n\\n        while current > 0 {\\n            result = chars[(current-1) % 26] + result\\n            current = (current-1) / 26\\n        }\\n        return result\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func convertToTitle(_ n: Int) -> String {\\n        let chars = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\\n        var result = \"\"\\n        var current = n\\n        while current > 0 {\\n            result = chars[(current-1) % 26] + result\\n            current = (current-1) / 26\\n        }\\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275262,
                "title": "python-1-line-solution",
                "content": "```python\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        return \\'\\' if n == 0 else self.convertToTitle((n - 1) // 26) + chr(ord(\\'A\\') + (n - 1) % 26)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        return \\'\\' if n == 0 else self.convertToTitle((n - 1) // 26) + chr(ord(\\'A\\') + (n - 1) % 26)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227481,
                "title": "c-recursive-and-iterative",
                "content": "I once thought this problem was just something that I would encounter as an interview problem until I was populating data from numpy arrays to excel sheets for analysis. At that time I needed to transfrom an integer numpy array column index to a string excel column name, which is exactly what this problem asks us to do :-)\\n\\n**Recursive**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        return n ? convertToTitle((n - 1) / 26) + char(65 + (n - 1) % 26) : \"\";\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string title;\\n        while (n) {\\n            title += char(65 + --n % 26);\\n            n /= 26;\\n        }\\n        reverse(title.begin(), title.end());\\n        return title;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        return n ? convertToTitle((n - 1) / 26) + char(65 + (n - 1) % 26) : \"\";\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string title;\\n        while (n) {\\n            title += char(65 + --n % 26);\\n            n /= 26;\\n        }\\n        reverse(title.begin(), title.end());\\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173559,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        while n > 26:\\n            n, r = divmod(n, 26)\\n            if r == 0:\\n                n -= 1\\n                r += 26\\n            res = chr(ord(\"A\") - 1 + r) + res\\n        res = chr(ord(\"A\") - 1 + n) + res\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        while n > 26:\\n            n, r = divmod(n, 26)\\n            if r == 0:\\n                n -= 1\\n                r += 26\\n            res = chr(ord(\"A\") - 1 + r) + res\\n        res = chr(ord(\"A\") - 1 + n) + res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51448,
                "title": "c-uff0cfirst-time-beats-100",
                "content": "```\\npublic string ConvertToTitle(int n) {\\n            string ss = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n            string res = \"\";\\n            while(n>0)\\n            {\\n                res = ss[n % 26] + res;\\n                n = (n % 26 == 0) ? (n / 26 - 1) : (n / 26);\\n            }\\n            return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic string ConvertToTitle(int n) {\\n            string ss = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n            string res = \"\";\\n            while(n>0)\\n            {\\n                res = ss[n % 26] + res;\\n                n = (n % 26 == 0) ? (n / 26 - 1) : (n / 26);\\n            }\\n            return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51470,
                "title": "java-concise-solution",
                "content": "        \\n    public String convertToTitle(int n) {\\n        String ret = \"\";\\n        while (n != 0) {\\n            ret = (char)('A'+(--n)%26) + ret;\\n            n /= 26;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        \\n    public String convertToTitle(int n) {\\n        String ret = \"\";\\n        while (n != 0) {\\n            ret = (char)('A'+(--n)%26) + ret;\\n            n /= 26;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51481,
                "title": "java-ac-solution",
                "content": "    public class Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while (n != 0) {\\n            sb.append((char)('A' + (n - 1) % 26)); \\n            n = (n - 1) / 26;\\n        }\\n        return sb.reverse().toString();\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while (n != 0) {\\n            sb.append((char)('A' + (n - 1) % 26)); \\n            n = (n - 1) / 26;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 51491,
                "title": "simple-solution-for-java",
                "content": "    public class Solution {\\n        public String convertToTitle(int n) {\\n            char[] alpha = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\".toCharArray();\\n            String s = \"\";\\n            while(n != 0){\\n                s = alpha[n % 26] + s;\\n                if(n % 26 == 0)\\n                    n -= 26;\\n                n /= 26;\\n            }\\n            return s;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String convertToTitle(int n) {\\n            char[] alpha = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\".toCharArray();\\n            String s = \"\";\\n            while(n != 0){\\n                s = alpha[n % 26] + s;\\n                if(n % 26 == 0)\\n                    n -= 26;\\n                n /= 26;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51511,
                "title": "easy-c-solution",
                "content": "    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            string str =\"\";\\n            while(n>0)\\n            {\\n                char letter = 'A'+(n-1)%26;\\n                str = letter+str;\\n                n = (n-1)/26;\\n            }\\n            return str;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            string str =\"\";\\n            while(n>0)\\n            {\\n                char letter = 'A'+(n-1)%26;\\n                str = letter+str;\\n                n = (n-1)/26;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51515,
                "title": "easy-recursive-solution-in-java-this-is-still-efficient-cause-log-by-26",
                "content": "    public class Solution {\\n        public String convertToTitle(int n) {\\n            // 0-25 -> A-Z, so n will dercrease by 1\\n            n = n-1;\\n            if(n<=25) \\n                return \"\"+(char)(n+65);\\n            else\\n                return convertToTitle(n/26)+\"\"+(char)(n%26+65);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String convertToTitle(int n) {\\n            // 0-25 -> A-Z, so n will dercrease by 1\\n            n = n-1;\\n            if(n<=25) \\n                return \"\"+(char)(n+65);\\n            else\\n                return convertToTitle(n/26)+\"\"+(char)(n%26+65);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 51526,
                "title": "0ms-in-c-code-we-don-t-need-stl",
                "content": "    char* convertToTitle(int n) {\\n        char *res = (char *)calloc(8, sizeof(char));\\n        int i = 6;\\n        while(n){\\n            res[i--] = (char)((n-1) % 26) + 'A';\\n            n = (n - 1) / 26;\\n        }\\n        return res+i+1;\\n    }",
                "solutionTags": [],
                "code": "    char* convertToTitle(int n) {\\n        char *res = (char *)calloc(8, sizeof(char));\\n        int i = 6;\\n        while(n){\\n            res[i--] = (char)((n-1) % 26) + 'A';\\n            n = (n - 1) / 26;\\n        }\\n        return res+i+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51577,
                "title": "my-simple-recursive-python-solution",
                "content": "    class Solution:\\n        # @return a string\\n        def convertToTitle(self, num):\\n            alph = ''.join(map(chr, range(65, 91)))\\n            return (self.convertToTitle((num-1)/len(alph)) if num>len(alph) else '' )+alph[(num-1)%len(alph)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return a string\\n        def convertToTitle(self, num):\\n            alph = ''.join(map(chr, range(65, 91)))\\n            return (self.convertToTitle((num-1)/len(alph)) if num>len(alph) else '' )+alph[(num-1)%len(alph)]",
                "codeTag": "Java"
            },
            {
                "id": 51524,
                "title": "share-my-code-with-c-1ms",
                "content": "    char *convertToTitle(int n) {\\n        int char_size = 0, num = n, i = 1;\\n    \\tchar *result;\\n    \\twhile(num > 0) {\\n            num = (num - 1) / 26;\\n            char_size++;\\n        }\\n    \\tresult = (char *) malloc(char_size*sizeof(char));\\n        while(n > 0) {\\n    \\t\\tif(n % 26 == 0) {\\n    \\t\\t\\t*(result + char_size - i) = 'Z';\\n    \\t\\t} else {\\n    \\t\\t\\t*(result+char_size-i) = (char)('A' + n%26 - 1);\\n    \\t\\t}\\n    \\t\\tn = (n - 1) / 26;\\n    \\t\\ti++;\\n    \\t}\\n    \\treturn result;\\n    }",
                "solutionTags": [],
                "code": "    char *convertToTitle(int n) {\\n        int char_size = 0, num = n, i = 1;\\n    \\tchar *result;\\n    \\twhile(num > 0) {\\n            num = (num - 1) / 26;\\n            char_size++;\\n        }\\n    \\tresult = (char *) malloc(char_size*sizeof(char));\\n        while(n > 0) {\\n    \\t\\tif(n % 26 == 0) {\\n    \\t\\t\\t*(result + char_size - i) = 'Z';\\n    \\t\\t} else {\\n    \\t\\t\\t*(result+char_size-i) = (char)('A' + n%26 - 1);\\n    \\t\\t}\\n    \\t\\tn = (n - 1) / 26;\\n    \\t\\ti++;\\n    \\t}\\n    \\treturn result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3997394,
                "title": "excel-sheet-column-title",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans=\"\";\\n        while(columnNumber)\\n        {\\n            columnNumber--;\\n            int digit=columnNumber%26+65;\\n             columnNumber=columnNumber/26;\\n            ans=(char)(digit)+ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans=\"\";\\n        while(columnNumber)\\n        {\\n            columnNumber--;\\n            int digit=columnNumber%26+65;\\n             columnNumber=columnNumber/26;\\n            ans=(char)(digit)+ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947106,
                "title": "beats-100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder sb=new StringBuilder(\"\");\\n        while(columnNumber!=0)\\n        {\\n            columnNumber-=1;\\n            int rem=columnNumber%26;\\n            sb.append((char)(rem+65));\\n            columnNumber/=26;\\n        }\\n        sb=sb.reverse();\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder sb=new StringBuilder(\"\");\\n        while(columnNumber!=0)\\n        {\\n            columnNumber-=1;\\n            int rem=columnNumber%26;\\n            sb.append((char)(rem+65));\\n            columnNumber/=26;\\n        }\\n        sb=sb.reverse();\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946744,
                "title": "simple-solution-explained-with-examples-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is really simple.It just needs some observation skills. Let us just take an example .let the column number be **126**\\n\\nNow,Let us just calculate the **remainder and divisor of 126 when we divide it by 26**\\n\\n**Remainder = 126%26 = 22**\\n\\n**Divisor = 126/22 = 4**\\n\\nNow, 22nd alphabet is \"V\"\\nNow, 4th alphabet is \"D\"\\n\\nSO your string becomes **\"DV\"**\\n\\nNow, let us take a bigger example , Let the no be **2832355**\\n\\nNow, let us calculate the remainder and divisor \\n\\nRemainder = 2832355%26 = 19\\n\\nDivisor = 2832355/26 = 108936\\n\\nNow we know the 19th alphabet is \"S\" so we will add this in our answer string ,\\nNow our divisor (108936) is really big so again we will calculate the remiander and divisor for this..\\n\\nRemainder = 108936%26 = 22\\n\\nDivisor = 108936/26 = 4189\\n\\nNow, we know the 22nd alpahbet is \"V\", so we will add this in our answer string so our answer string becomes \"SV\"\\n\\nNow, 4189 is also really big, wo we will again repeat this step and keep on adding the remainder.\\n\\n**We need to make sure that when the divisor is less then or equal to 26, we will add that particular alphabet in our string ...**\\n\\nNow, just **reverse this string** and return the ans...\\n\\n# **SPECIAL CASE-**\\n\\nLet us say the no is \"52\", Now you see when we calculate the remiander and divisor it comes to be\\n\\nrem = 52 %26 = 0\\n\\ndiv = 52/26 = 2\\n\\nNow, In such case when the rem = 0, if you follow the above case , then your answer will become \"B\", but that is wrong..\\n\\nSO, **whenever you rem comes to be 0**, you will do **rem  =  rem +26** and **div = div-1**\\n\\nso , if you calculate the string now, so it will become **\"AZ\"**...so this is how you will handel such cases\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are continously dividing the number by 26..so it will be **log(n**), but the **base of that log will be 26**...\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**No extra space taken**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int col) {\\n        string ans = \"\";\\n        while(col>0)\\n        {\\n            int d = col/26;\\n            int rem = col%26;\\n            if(rem==0)\\n            {\\n                rem  =26;\\n                d--;\\n            }\\n            if(rem!=0)\\n            {\\n                char z= rem+64;\\n                ans+=z;\\n            }\\n            if(d<=26 && d!=0)\\n            {\\n                char z = d+64;\\n                ans+=z;\\n                reverse(ans.begin(),ans.end());\\n                return ans;\\n            }\\n            else\\n            {\\n                col = d;\\n            }\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```\\n**TIME FOR A MEME NOW**\\n![WhatsApp Image 2023-08-22 at 22.55.11.jpeg](https://assets.leetcode.com/users/images/3442240d-cc49-490a-aff8-afc1b9caf1f5_1692725600.1917834.jpeg)\\n\\n# **IF YOU LIKE MY SOLUTION, PLEASE UPVOTE...**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int col) {\\n        string ans = \"\";\\n        while(col>0)\\n        {\\n            int d = col/26;\\n            int rem = col%26;\\n            if(rem==0)\\n            {\\n                rem  =26;\\n                d--;\\n            }\\n            if(rem!=0)\\n            {\\n                char z= rem+64;\\n                ans+=z;\\n            }\\n            if(d<=26 && d!=0)\\n            {\\n                char z = d+64;\\n                ans+=z;\\n                reverse(ans.begin(),ans.end());\\n                return ans;\\n            }\\n            else\\n            {\\n                col = d;\\n            }\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946669,
                "title": "c-easy-approach-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // Intution\\n        // The idea in here is really very simple. It is similar to base 2 with a base of 26. Here we will subract the value of 1 so that we will get the exact string.\\n\\n        string answer = \"\";\\n\\n        while(columnNumber > 0){\\n            columnNumber -= 1;\\n            answer = char(columnNumber % 26 + \\'A\\') + answer;\\n            columnNumber /= 26;\\n        }\\n        \\n        return answer;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // Intution\\n        // The idea in here is really very simple. It is similar to base 2 with a base of 26. Here we will subract the value of 1 so that we will get the exact string.\\n\\n        string answer = \"\";\\n\\n        while(columnNumber > 0){\\n            columnNumber -= 1;\\n            answer = char(columnNumber % 26 + \\'A\\') + answer;\\n            columnNumber /= 26;\\n        }\\n        \\n        return answer;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1721592,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2025000,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1564863,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2024756,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1568035,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1566874,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1917390,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1576624,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2024796,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1731930,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1721592,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2025000,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1564863,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2024756,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1568035,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1566874,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1917390,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1576624,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2024796,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1731930,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2025196,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 2025045,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1861327,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1673025,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1570273,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 2025258,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1898457,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1824372,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1787935,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1762523,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 2025764,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2024933,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2012185,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 1661065,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 1575253,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 1919041,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2055348,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2038741,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2036224,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2030357,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2028871,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2026300,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2026169,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2026137,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2026041,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025845,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025831,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025822,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025792,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025745,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025715,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025669,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025597,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025498,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025462,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025453,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025417,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025248,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025165,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025139,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025133,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2025075,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2025062,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2025034,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2025029,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2024850,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2024823,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2024789,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2024788,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2024782,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2009577,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 2006143,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 2005428,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 1958111,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 1925812,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 1902154,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 1805512,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 1738319,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 2025021,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 2024944,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            }
        ]
    }
]