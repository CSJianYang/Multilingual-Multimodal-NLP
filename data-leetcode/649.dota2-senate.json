[
    {
        "title": "Single Number II",
        "question_content": "Given an integer array nums where&nbsp;every element appears three times except for one, which appears exactly once. Find the single element and return it.\nYou must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.\n&nbsp;\nExample 1:\nInput: nums = [2,2,3,2]\nOutput: 3\nExample 2:\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 3 * 104\n\t-231 <= nums[i] <= 231 - 1\n\tEach element in nums appears exactly three times except for one element which appears once.",
        "solutions": [
            {
                "id": 43295,
                "title": "detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers",
                "content": "`I -- Statement of our problem`\\n\\n\"Given an array of integers, every element appears `k` (`k > 1`) times except for one, which appears `p` times (`p >= 1, p % k != 0`). Find that single one.\" \\n\\n---\\n\\n`II -- Special case with 1-bit numbers`\\n\\nAs others pointed out, in order to apply the bitwise operations, we should rethink how integers are represented in computers -- by bits. To start, let\\'s consider only one bit for now. Suppose we have an array of **1-bit** numbers (which can only be `0` or `1`), we\\'d like to count the number of `1`\\'s in the array such that whenever the counted number of `1` reaches a certain value, say `k`, the count returns to zero and starts over (in case you are curious, this `k` will be the same as the one in the problem statement above). To keep track of how many `1`\\'s we have encountered so far, we need a counter. Suppose the counter has `m` bits in binary form: `xm, ..., x1` (from most significant bit to least significant bit). We can conclude at least the following four properties of the counter:\\n\\n1. There is an initial state of the counter, which for simplicity is zero;\\n2. For each input from the array, if we hit a `0`, the counter should remain unchanged;\\n3. For each input from the array, if we hit a `1`, the counter should increase by one;\\n4. In order to cover `k` counts, we require `2^m >= k`, which implies `m >= logk`.\\n\\nHere is the key part: how each bit in the counter (`x1` to `xm`) changes as we are scanning the array. Note we are prompted to use bitwise operations. In order to satisfy the second property, recall what bitwise operations will not change the operand if the other operand is `0`? Yes, you got it: `x = x | 0` and `x = x ^ 0`. \\n\\nOkay, we have an expression now: `x = x | i`  or  `x = x ^ i`, where `i` is the scanned element from the array. Which one is better?  We don\\'t know yet. So, let\\'s just do the actual counting.\\n\\nAt the beginning, all bits of the counter is initialized to zero, i.e., `xm = 0, ..., x1 = 0`.  Since we are gonna choose bitwise operations that guarantee all bits of the counter remain unchanged if we hit `0`\\'s, the counter will be `0` until we hit the first `1` in the array. After we hit the first `1`, we got:  `xm = 0,  ...,x2 = 0, x1 = 1`. Let\\'s continue until we hit the second `1`, after which we have:  `xm = 0, ..., x2 = 1, x1 = 0`. Note that `x1` changed from `1` to `0`. For `x1 = x1 | i`, after the second count, `x1` will still be `1`. So it\\'s clear we should use `x1 = x1 ^ i`. What about `x2, ..., xm`? The idea is to find the condition under which `x2, ..., xm` will change their values. Take `x2` as an example. If we hit a `1` and need to change the value of `x2`, what must be the value of `x1` right before we do the change? The answer is: `x1` must be `1` otherwise we shouldn\\'t change `x2` because changing `x1` from `0` to `1` will do the job. So `x2` will change value only if `x1` and `i` are both `1`, or mathematically, `x2 = x2 ^ (x1 & i)`.  Similarly `xm` will change value only when `xm-1, ..., x1` and `i` are all `1`: `xm = xm ^ (xm-1 & ... &  x1 & i)`. Bingo, we\\'ve found the bitwise operations! \\n\\nHowever, you may notice that the bitwise operations found above will count from `0` until `2^m - 1`, instead of `k`. If `k < 2^m - 1`, we need some \"cutting\" mechanism to reinitialize the counter to `0` when the count reaches `k`. To this end, we apply bitwise **AND** to `xm,..., x1` with some variable called `mask`, i.e., `xm = xm & mask,  ...,  x1 = x1 & mask`. If we can make sure that `mask` will be `0` only when the count reaches `k` and be `1` for all other count cases, then we are done. How do we achieve that? Try to think what distinguishes the case with `k` count from all other count cases. Yes, it\\'s the count of `1`\\'s! For each count, we have unique values for each bit of the counter, which can be regarded as its state. If we write `k` in its binary form: `km,..., k1`, we can construct `mask` as follows:\\n\\n`mask = ~(y1 & y2 & ... & ym)`,  where `yj = xj`  if `kj = 1`, and  `yj = ~xj`  if `kj = 0` (`j = 1` to `m`). \\n\\nLet\\'s do some examples:\\n\\n`k = 3: k1 = 1, k2 = 1, mask = ~(x1 & x2)`;\\n\\n`k = 5: k1 = 1, k2 = 0, k3 = 1, mask = ~(x1 & ~x2 & x3)`;\\n\\nIn summary, our algorithm will go like this (`nums` is the input array):\\n```\\nfor (int i : nums) {\\n    xm ^= (xm-1 & ... & x1 & i);\\n    xm-1 ^= (xm-2 & ... & x1 & i);\\n    .....\\n    x1 ^= i;\\n    \\n    mask = ~(y1 & y2 & ... & ym) where yj = xj if kj = 1, and yj = ~xj if kj = 0 (j = 1 to m).\\n\\n    xm &= mask;\\n    ......\\n    x1 &= mask;\\n}\\n```\\n\\n---\\n`III -- General case with 32-bit numbers`\\n\\nNow it\\'s time to generalize our results from 1-bit number case to 32-bit integers. One straightforward way would be creating `32` counters for each bit in the integer. You\\'ve probably already seen this in other posted [solutions](https://discuss.leetcode.com/topic/455/constant-space-solution/4). However, if we take advantage of bitwise operations, we may be able to manage all the `32` counters \"collectively\". By saying \"collectively\", we mean using `m` **32-bit** integers instead of `32` **m-bit** counters, where `m` is the minimum integer that satisfies `m >= logk`. The reason is that bitwise operations apply only to each bit so operations on different bits are independent of each other (kind obvious, right?). This allows us to group the corresponding bits of the `32` counters into one 32-bit integer. Here is a schematic diagram showing how this is done. \\n\\n![0_1510941016426_137. Single Number II .png](/assets/uploads/files/1510941017203-137.single-number-ii-resized.png) \\n\\nThe top row is the 32-bit integer, where for each bit, we have a corresponding m-bit counter (shown by the column below the upward arrow). Since bitwise operations on each of the `32` bits are independent of each other, we can group, say the `m-th` bit of all counters, into one 32-bit number (shown by the orange box). All bits in this 32-bit number (denoted as `xm`) will follow the same bitwise operations. Since each counter has `m` bits, we end up with `m` 32-bit numbers, which correspond to `x1, ..., xm` defined in part `II`, but now they are 32-bit integers instead of 1-bit numbers. Therefore, in the algorithm developed above, we just need to regard `x1` to `xm` as 32-bit integers instead of 1-bit numbers. Everything else will be the same and we are done. Easy, hum?\\n\\n---\\n`IV -- What to return`\\n\\nThe last thing is what value we should return, or equivalently which one of `x1` to `xm` will equal the single element. To get the correct answer, we need to understand what the `m` 32-bit integers `x1` to `xm` represent. Take `x1` as an example. `x1` has `32` bits and let\\'s label them as `r` (`r = 1` to `32`). After we are done scanning the input array, the value for the `r-th` bit of `x1` will be determined by the `r-th` bit of all the elements in the array (more specifically, suppose the total count of `1` for the `r-th` bit of all the elements in the array is `q`, `q\\' = q % k` and in its binary form: `q\\'m,...,q\\'1`, then by definition the `r-th` bit of `x1` will be equal to `q\\'1`). Now you can ask yourself this question: what does it imply if the `r-th` bit of `x1` is `1`?\\n\\nThe answer is to find what can contribute to this `1`. Will an element that appears `k` times contribute? No. Why? Because for an element to contribute, it has to satisfy at least two conditions at the same time: the `r-th` bit of this element is `1` and the number of appearance of this `1` is not an integer multiple of `k`. The first condition is trivial. The second comes from the fact that whenever the number of `1` hit is `k`, the counter will go back to zero, which means the corresponding bit in `x1` will be reset to `0`. For an element that appears `k` times, it\\'s impossible to meet these two conditions simultaneously so it won\\'t contribute. At last, only the single element which appears `p` (`p % k != 0`) times will contribute. If `p > k`, then the first `k * [p/k]` (`[p/k]`denotes the integer part of `p/k`) single elements won\\'t contribute either. So we can always set `p\\' = p % k` and say the single element appears effectively `p\\'` times.\\n\\nLet\\'s write `p\\'` in its binary form: `p\\'m, ..., p\\'1` (note that `p\\' < k`, so it will fit into `m` bits). Here I **claim the condition** for `xj` to equal the single element is `p\\'j = 1` (`j = 1` to `m`), with a quick proof given below.\\n\\nIf the `r-th` bit of `xj` is `1`, we can safely say the `r-th` bit of the single element is also `1` (otherwise nothing can make the `r-th` bit of `xj` to be `1`). We are left to prove that if the `r-th` bit of `xj` is `0`, then the `r-th` bit of the single element can only be `0`. Just suppose in this case the `r-th` bit of the single element is `1`, let\\'s see what will happen. At the end of the scan, this `1` will be counted `p\\'` times. By definition the `r-th` bit of `xj` will be equal to `p\\'j`, which is `1`. This contradicts with the presumption that the `r-th` bit of `xj` is `0`. Therefore we conclude the `r-th` bit of `xj` will always be the same as the `r-th` bit of the single number as long as `p\\'j = 1`. Since this is true for all bits in `xj` (i.e., true for `r = 1` to `32`), we conclude `xj` will equal the single element as long as `p\\'j = 1`. \\n\\nSo now it\\'s clear what we should return. Just express `p\\' = p % k` in its binary form and return any of the corresponding `xj` as long as `p\\'j = 1`. In total, the algorithm will run in `O(n * logk)` time and `O(logk)` space.\\n\\n---\\n**Side note**: There is a general formula relating each bit of `xj` to `p\\'j` and each bit of the single number `s`, which is given by `(xj)_r = s_r & p\\'j`, with `(xj)_r` and `s_r` denoting respectively the `r-th` bit of `xj` and the single number `s`. From this formula, it\\'s easy to see that `(xj)_r = s_r` if `p\\'j = 1`, that is, `xj = s` as long as `p\\'j = 1`, as shown above. Furthermore, we have `(xj)_r = 0` if `p\\'j = 0`, regardless of the value of the single number, that is, `xj = 0` as long as `p\\'j = 0`. So in summary we obtain: `xj = s` if `p\\'j = 1`, and `xj = 0` if `p\\'j = 0`. This implies the expression (`x1 | x2 | ... | xm`) will also be evaluated to the single number `s`, since the expression will essentially take the `OR` operations of the single number with itself and some `0`s, which boils down to the single number eventually.\\n\\n---\\n`V -- Quick examples`\\n\\nHere is a list of few quick examples to show how the algorithm works (you can easily come up with other examples):\\n\\n1. `k = 2, p = 1`\\n`k` is `2`, then `m = 1`, we need only one 32-bit integer (`x1`) as the counter. And `2^m = k` so we do not even need a mask! A complete java program will look like:\\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0;\\n         \\n        for (int i : nums) {\\n            x1 ^= i;\\n        }\\n         \\n        return x1;\\n    }\\n```\\n\\n2. `k = 3, p = 1`\\n`k` is `3`, then `m = 2`, we need two 32-bit integers(`x2`, `x1`) as the counter. And `2^m > k` so we do need a mask. Write `k` in its binary form: `k = \\'11\\'`, then `k1 = 1`, `k2 = 1`, so we have `mask = ~(x1 & x2)`. A complete java program will look like:\\n\\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0, x2 = 0, mask = 0;\\n         \\n        for (int i : nums) {\\n            x2 ^= x1 & i;\\n            x1 ^= i;\\n            mask = ~(x1 & x2);\\n            x2 &= mask;\\n            x1 &= mask;\\n        }\\n\\n        return x1;  // Since p = 1, in binary form p = \\'01\\', then p1 = 1, so we should return x1. \\n                    // If p = 2, in binary form p = \\'10\\', then p2 = 1, and we should return x2.\\n                    // Or alternatively we can simply return (x1 | x2).\\n    }\\n```\\n\\n3. `k = 5, p = 3`\\n`k` is `5`, then `m = 3`, we need three 32-bit integers(`x3`, `x2`, `x1`) as the counter. And `2^m > k` so we need a mask. Write `k` in its binary form: `k = \\'101\\'`, then `k1 = 1`, `k2 = 0`, `k3 = 1`, so we have `mask = ~(x1 & ~x2 & x3)`. A complete java program will look like:\\n\\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0, x2 = 0, x3  = 0, mask = 0;\\n   \\n        for (int i : nums) {\\n            x3 ^= x2 & x1 & i;\\n            x2 ^= x1 & i;\\n            x1 ^= i;\\n            mask = ~(x1 & ~x2 & x3);\\n            x3 &= mask;\\n            x2 &= mask;\\n            x1 &= mask;\\n        }\\n        \\n        return x1;  // Since p = 3, in binary form p = \\'011\\', then p1 = p2 = 1, so we can return either x1 or x2. \\n                    // If p = 4, in binary form p = \\'100\\', only p3 = 1, which implies we can only return x3.\\n                    // Or alternatively we can simply return (x1 | x2 | x3).\\n    }\\n```\\n\\nLastly I would like to thank those for providing feedbacks to make this post better. Hope it helps and happy coding!",
                "solutionTags": [],
                "code": "```\\nfor (int i : nums) {\\n    xm ^= (xm-1 & ... & x1 & i);\\n    xm-1 ^= (xm-2 & ... & x1 & i);\\n    .....\\n    x1 ^= i;\\n    \\n    mask = ~(y1 & y2 & ... & ym) where yj = xj if kj = 1, and yj = ~xj if kj = 0 (j = 1 to m).\\n\\n    xm &= mask;\\n    ......\\n    x1 &= mask;\\n}\\n```\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0;\\n         \\n        for (int i : nums) {\\n            x1 ^= i;\\n        }\\n         \\n        return x1;\\n    }\\n```\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0, x2 = 0, mask = 0;\\n         \\n        for (int i : nums) {\\n            x2 ^= x1 & i;\\n            x1 ^= i;\\n            mask = ~(x1 & x2);\\n            x2 &= mask;\\n            x1 &= mask;\\n        }\\n\\n        return x1;  // Since p = 1, in binary form p = \\'01\\', then p1 = 1, so we should return x1. \\n                    // If p = 2, in binary form p = \\'10\\', then p2 = 1, and we should return x2.\\n                    // Or alternatively we can simply return (x1 | x2).\\n    }\\n```\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0, x2 = 0, x3  = 0, mask = 0;\\n   \\n        for (int i : nums) {\\n            x3 ^= x2 & x1 & i;\\n            x2 ^= x1 & i;\\n            x1 ^= i;\\n            mask = ~(x1 & ~x2 & x3);\\n            x3 &= mask;\\n            x2 &= mask;\\n            x1 &= mask;\\n        }\\n        \\n        return x1;  // Since p = 3, in binary form p = \\'011\\', then p1 = p2 = 1, so we can return either x1 or x2. \\n                    // If p = 4, in binary form p = \\'100\\', only p3 = 1, which implies we can only return x3.\\n                    // Or alternatively we can simply return (x1 | x2 | x3).\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43294,
                "title": "challenge-me-thx",
                "content": "    public int singleNumber(int[] A) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < A.length; i++){\\n            ones = (ones ^ A[i]) & ~twos;\\n            twos = (twos ^ A[i]) & ~ones;\\n        }\\n        return ones;\\n    }",
                "solutionTags": [],
                "code": "    public int singleNumber(int[] A) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < A.length; i++){\\n            ones = (ones ^ A[i]) & ~twos;\\n            twos = (twos ^ A[i]) & ~ones;\\n        }\\n        return ones;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43297,
                "title": "java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance",
                "content": "The usual bit manipulation code is bit hard to get and replicate.  I like to think about the number in 32 bits and just count how many 1s are there in each bit, and `sum %= 3` will clear it once it reaches 3.  After running for all the numbers for each bit, if we have a 1, then that 1 belongs to the single number, we can simply move it back to its spot by doing `ans |= sum << i;`  \\n\\nThis has complexity of O(32n), which is essentially O(n) and very easy to think and implement.  Plus, you get a general solution for any times of occurrence.  Say all the numbers have 5 times, just do `sum %= 5`.\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int sum = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(((nums[j] >> i) & 1) == 1) {\\n                    sum++;\\n                    sum %= 3;\\n                }\\n            }\\n            if(sum != 0) {\\n                ans |= sum << i;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The usual bit manipulation code is bit hard to get and replicate.  I like to think about the number in 32 bits and just count how many 1s are there in each bit, and `sum %= 3` will clear it once it reaches 3.  After running for all the numbers for each bit, if we have a 1, then that 1 belongs to the single number, we can simply move it back to its spot by doing `ans |= sum << i;`  \\n\\nThis has complexity of O(32n), which is essentially O(n) and very easy to think and implement.  Plus, you get a general solution for any times of occurrence.  Say all the numbers have 5 times, just do `sum %= 5`.\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int sum = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(((nums[j] >> i) & 1) == 1) {\\n                    sum++;\\n                    sum %= 3;\\n                }\\n            }\\n            if(sum != 0) {\\n                ans |= sum << i;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43296,
                "title": "an-general-way-to-handle-all-this-sort-of-questions",
                "content": "this kind of question the key idea is design a counter that record state. the problem can be every one occurs K times except one occurs M times. for this question, K =3 ,M = 1(or 2) .\\nso to represent 3 state, we need two bit. let say it is a and b, and c is the incoming bit.\\nthen we can design a table to implement the state move.\\n\\n    current   incoming  next\\n    a b            c    a b\\n    0 0            0    0 0\\n    0 1            0    0 1\\n    1 0            0    1 0\\n    0 0            1    0 1\\n    0 1            1    1 0\\n    1 0            1    0 0\\n\\nlike circuit design, we can find out what the next state will be with the incoming bit.( we only need find the ones)\\nthen we have for a to be 1, we have \\n\\n        current   incoming  next\\n        a b            c    a b\\n        1 0            0    1 0\\n        0 1            1    1 0\\n and this is can be represented by \\n\\n    a=a&~b&~c + ~a&b&c\\n\\nand b can do the same  we , and we find that \\n\\n    b= ~a&b&~c+~a&~b&c\\nand this is the final formula of a and b and just one of the result set, because for different state move table definition, we can generate different formulas, and this one is may not the most optimised. as you may see other's answer that have a much simple formula, and that formula also corresponding to specific state move table. (if you like ,you can reverse their formula to a state move table, just using the same way but reversely) \\n\\nfor this questions we need to find the except one \\nas the question don't say if the one appears one time or two time ,\\nso for ab both \\n\\n    01 10 => 1\\n    00 => 0\\nwe should return a|b;\\nthis is the key idea , we can design any based counter and find the occurs any times except one .\\nhere is my code. with comment.\\n\\n    public class Solution {\\n        \\n        public int singleNumber(int[] nums) {\\n            //we need to implement a tree-time counter(base 3) that if a bit appears three time ,it will be zero.\\n            //#curent  income  ouput\\n            //# ab      c/c       ab/ab\\n            //# 00      1/0       01/00\\n            //# 01      1/0       10/01\\n            //# 10      1/0       00/10\\n            // a=~abc+a~b~c;\\n            // b=~a~bc+~ab~c;\\n            int a=0;\\n            int b=0;\\n            for(int c:nums){\\n                int ta=(~a&b&c)|(a&~b&~c);\\n                b=(~a&~b&c)|(~a&b&~c);\\n                a=ta;\\n            }\\n            //we need find the number that is 01,10 => 1, 00 => 0.\\n            return a|b;\\n            \\n        }\\n    }\\nthis is a general solution . and it comes from the Circuit Design on course digital logic.",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        public int singleNumber(int[] nums) {\\n            //we need to implement a tree-time counter(base 3) that if a bit appears three time ,it will be zero.\\n            //#curent  income  ouput\\n            //# ab      c/c       ab/ab\\n            //# 00      1/0       01/00\\n            //# 01      1/0       10/01\\n            //# 10      1/0       00/10\\n            // a=~abc+a~b~c;\\n            // b=~a~bc+~ab~c;\\n            int a=0;\\n            int b=0;\\n            for(int c:nums){\\n                int ta=(~a&b&c)|(a&~b&~c);\\n                b=(~a&~b&c)|(~a&b&~c);\\n                a=ta;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3714928,
                "title": "bit-manipulation-c-java-python-beginner-friendly",
                "content": "# Approach 1: Brute Force\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        \\n        for(auto x: nums){\\n            m[x]++;\\n        }\\n\\n        for(auto x: m){\\n            if(x.second == 1){\\n                return x.first;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int x : nums) {\\n            map.put(x, map.getOrDefault(x, 0) + 1);\\n        }\\n\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() == 1) {\\n                return entry.getKey();\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        count = defaultdict(int)\\n        \\n        for x in nums:\\n            count[x] += 1\\n\\n        for x, freq in count.items():\\n            if freq == 1:\\n                return x\\n        \\n        return -1\\n```\\n\\n# Approach 2: Bit Manipulation\\n# Explanation:\\n\\n1. Initialize the variable `ans` to 0. This variable will store the resulting single number.\\n\\n2. Iterate from `i = 0` to `i = 31`. This loop considers each bit position from the least significant bit (LSB) to the most significant bit (MSB) of a 32-bit integer.\\n\\n3. Inside the loop, initialize a variable `sum` to 0. This variable will keep track of the number of 1s at the current bit position (`i`) for all the numbers in the input array.\\n\\n4. Iterate through each number `num` in the input array:\\n   - Right-shift `num` by `i` positions: `num >> i`. This operation moves the bit at position `i` to the least significant bit position.\\n   - Perform a bitwise AND with 1: `(num >> i) & 1`. This extracts the value of the bit at position `i` from `num`. If it is 1, the result will be 1; otherwise, it will be 0.\\n   - Add the result of `(num >> i) & 1` to `sum`. This counts the number of 1s at bit position `i` for all the numbers in the array.\\n\\n5. Take the modulo of `sum` by 3: `sum %= 3`. This step is performed to handle the numbers that appear three times. If `sum` is divisible by 3, it means the bit at position `i` has a balanced number of 1s. Otherwise, it is an unbalanced line.\\n\\n6. Left-shift the value of `sum` by `i` positions: `sum << i`. This step creates a bitmask `pos` where only the bit at position `i` is set to the value of `sum`. This bitmask identifies the position of the unbalanced line.\\n\\n7. Use the bitwise OR operation with `ans` and `pos`: `ans |= pos`. This sets the corresponding bit in `ans` to 1 if the bit at position `i` is part of an unbalanced line.\\n\\n8. After the loop completes, the value stored in `ans` represents the single number that appears only once in the array.\\n\\nThe logical thinking behind this approach is to count the number of 1s at each bit position for all the numbers. Since each number appears three times except for the single number, the sum of 1s at each bit position should be divisible by 3 for a balanced line. Any number of 1s that is not divisible by 3 indicates an unbalanced line, which means the single number contributes to that particular bit position.\\n\\nBy masking the positions of the unbalanced lines with 1s in `ans`, we effectively isolate the bits that are part of the single number. Finally, the resulting value in `ans` represents the binary representation of the single number.\\n\\nUsing the provided example: [1, 1, 1, 2, 2, 2, 5]\\n- At the LSB (i = 0), the sum of the number of 1s is 3 (balanced line).\\n- At the second bit (i = 1), the sum of the number of 1s is 4 (unbalanced line, not divisible by 3).\\n- At the third bit (i = 2), the sum of the number of 1s is 2 (unbalanced line, not divisible by 3).\\n- At the fourth bit\\n\\n (i = 3), the sum of the number of 1s is 1 (balanced line).\\n\\nThus, the resulting binary representation is \\'0101\\', which corresponds to the decimal value 5, and that is the single number we are searching for.\\n\\nThis approach effectively identifies the unbalanced lines and constructs the single number by setting the corresponding bit positions in `ans`.\\n\\n# Code\\n```C++ []\\nclass Solution {\\n public:\\n  int singleNumber(vector<int>& nums) {\\n    int ans = 0;\\n\\n    for (int i = 0; i < 32; ++i) {\\n      int sum = 0;\\n      for (const int num : nums)\\n        sum += num >> i & 1;\\n      sum %= 3;\\n      ans |= sum << i;\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int singleNumber(int[] nums) {\\n    int ans = 0;\\n\\n    for (int i = 0; i < 32; ++i) {\\n      int sum = 0;\\n      for (final int num : nums)\\n        sum += num >> i & 1;\\n      sum %= 3;\\n      ans |= sum << i;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        ans = 0\\n\\n        for i in range(32):\\n            bit_sum = 0\\n            for num in nums:\\n                # Convert the number to two\\'s complement representation to handle large test case\\n                if num < 0:\\n                    num = num & (2**32-1)\\n                bit_sum += (num >> i) & 1\\n            bit_sum %= 3\\n            ans |= bit_sum << i\\n\\n        # Convert the result back to two\\'s complement representation if it\\'s negative to handle large test case\\n        if ans >= 2**31:\\n            ans -= 2**32\\n\\n        return ans\\n\\n```\\n\\n# Approach 3: Magic:\\n# Explanation:\\n\\n1. Initialize two variables, `ones` and `twos`, to keep track of the count of each bit position.\\n   - `ones`: Tracks the bits that have appeared once.\\n   - `twos`: Tracks the bits that have appeared twice.\\n\\n2. Iterate through the array of numbers.\\n   - For each number `i` in the array:\\n     - Update `ones` and `twos`:\\n\\n     - Let\\'s analyze each step of the update process:\\n\\n       a. `ones = (ones ^ i) & (~twos);`:\\n          - `ones ^ i` XORs the current number `i` with the previous value of `ones`. This operation toggles the bits that have appeared an odd number of times, keeping the bits that have appeared twice unchanged.\\n          - `(~twos)` negates the bits in `twos`, effectively removing the bits that have appeared twice from consideration.\\n          - The `&` operation ensures that only the bits that have appeared once (after XOR) and not twice (after negating `twos`) are retained.\\n\\n       b. `twos = (twos ^ i) & (~ones);`:\\n          - `twos ^ i` XORs the current number `i` with the previous value of `twos`. This operation toggles the bits that have appeared an even number of times, effectively removing the bits that have appeared twice.\\n          - `(~ones)` negates the bits in `ones`, effectively removing the bits that have appeared once from consideration.\\n          - The `&` operation ensures that only the bits that have appeared twice (after XOR) and not once (after negating `ones`) are retained.\\n\\n3. After iterating through all the numbers, the value stored in `ones` will represent the single number that appears only once in the array.\\n\\nLet\\'s understand why this approach works:\\n\\n- The key idea is to use bitwise operations to keep track of the count of each bit position. By doing so, we can identify the bits that have appeared once, twice, or three times.\\n- When a bit appears for the first time (`ones` is 0 and the bit is toggled), it is stored in `ones`.\\n- When a bit appears for the second time (`ones` is 1 and the bit is toggled), it is removed from `ones` and stored in `twos`.\\n- When a bit appears for the third time (`ones` is 0 and the bit is toggled), it is removed from both `ones` and `twos`.\\n- By the end of the iteration, the bits that remain in `ones` represent the bits of the single number that appeared only once, while the bits in `twos` represent bits that appeared three times (which is not possible).\\n\\nIn summary, the algorithm uses bit manipulation to efficiently keep track of the counts of each bit position. By utilizing XOR and AND operations, it can identify the bits of the single number that appears only once in the array while ignoring the bits that appear multiple times.\\n\\n# Code\\n```C++ []\\nclass Solution {\\n public:\\n  int singleNumber(vector<int>& nums) {\\n    int ones = 0;\\n    int twos = 0;\\n\\n    for (const int num : nums) {\\n      ones ^= (num & ~twos);\\n      twos ^= (num & ~ones);\\n    }\\n\\n    return ones;\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int singleNumber(int[] nums) {\\n    int ones = 0;\\n    int twos = 0;\\n\\n    for (final int num : nums) {\\n      ones ^= (num & ~twos);\\n      twos ^= (num & ~ones);\\n    }\\n\\n    return ones;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> int:\\n    ones = 0\\n    twos = 0\\n\\n    for num in nums:\\n      ones ^= (num & ~twos)\\n      twos ^= (num & ~ones)\\n\\n    return ones\\n\\n```\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/90c52bfd-4b4f-4920-b559-cce87389f517_1688432286.2663784.png)\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        \\n        for(auto x: nums){\\n            m[x]++;\\n        }\\n\\n        for(auto x: m){\\n            if(x.second == 1){\\n                return x.first;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int x : nums) {\\n            map.put(x, map.getOrDefault(x, 0) + 1);\\n        }\\n\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() == 1) {\\n                return entry.getKey();\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        count = defaultdict(int)\\n        \\n        for x in nums:\\n            count[x] += 1\\n\\n        for x, freq in count.items():\\n            if freq == 1:\\n                return x\\n        \\n        return -1\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int singleNumber(vector<int>& nums) {\\n    int ans = 0;\\n\\n    for (int i = 0; i < 32; ++i) {\\n      int sum = 0;\\n      for (const int num : nums)\\n        sum += num >> i & 1;\\n      sum %= 3;\\n      ans |= sum << i;\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int singleNumber(int[] nums) {\\n    int ans = 0;\\n\\n    for (int i = 0; i < 32; ++i) {\\n      int sum = 0;\\n      for (final int num : nums)\\n        sum += num >> i & 1;\\n      sum %= 3;\\n      ans |= sum << i;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        ans = 0\\n\\n        for i in range(32):\\n            bit_sum = 0\\n            for num in nums:\\n                # Convert the number to two\\'s complement representation to handle large test case\\n                if num < 0:\\n                    num = num & (2**32-1)\\n                bit_sum += (num >> i) & 1\\n            bit_sum %= 3\\n            ans |= bit_sum << i\\n\\n        # Convert the result back to two\\'s complement representation if it\\'s negative to handle large test case\\n        if ans >= 2**31:\\n            ans -= 2**32\\n\\n        return ans\\n\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int singleNumber(vector<int>& nums) {\\n    int ones = 0;\\n    int twos = 0;\\n\\n    for (const int num : nums) {\\n      ones ^= (num & ~twos);\\n      twos ^= (num & ~ones);\\n    }\\n\\n    return ones;\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int singleNumber(int[] nums) {\\n    int ones = 0;\\n    int twos = 0;\\n\\n    for (final int num : nums) {\\n      ones ^= (num & ~twos);\\n      twos ^= (num & ~ones);\\n    }\\n\\n    return ones;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> int:\\n    ones = 0\\n    twos = 0\\n\\n    for num in nums:\\n      ones ^= (num & ~twos)\\n      twos ^= (num & ~ones)\\n\\n    return ones\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43313,
                "title": "a-general-c-solution-for-these-type-problems",
                "content": "There are so many brilliant solutions for this problem used \"| & ^ ~\", and I have learned a lot from these solutions. Here is a general solution for who not familiar with \"| & ^ ~\".\\n\\nQ: Most elements appeared k times, except one. Find this \"one\".\\n\\n  \\n\\n       int singleNumber(vector<int>& s) \\n        {\\n        \\tvector<int> t(32);////Made a array contain 32 elements.\\n        \\tint sz = s.size();\\n        \\tint i, j, n;\\n        \\tfor (i = 0; i < sz; ++i)\\n        \\t{\\n        \\t\\tn = s[i];\\n        \\t\\tfor (j = 31; j >= 0; --j)\\n        \\t\\t{\\n        \\t\\t\\tt[j] += n & 1;//Find the last digit.\\n        \\t\\t\\tn >>= 1;\\n        \\t\\t\\tif (!n)\\n        \\t\\t\\t\\tbreak;\\n        \\t    }\\n            }\\n    \\tint res = 0;\\n    \\tfor (j = 31; j >= 0; --j)\\n    \\t{\\n    \\t\\tn = t[j] % 3;//\"3\" represents k times. \\n    \\t\\tif (n)\\n    \\t\\t\\tres += 1 << (31 - j);\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "There are so many brilliant solutions for this problem used \"| & ^ ~\", and I have learned a lot from these solutions. Here is a general solution for who not familiar with \"| & ^ ~\".\\n\\nQ: Most elements appeared k times, except one. Find this \"one\".\\n\\n  \\n\\n       int singleNumber(vector<int>& s) \\n        {\\n        \\tvector<int> t(32);////Made a array contain 32 elements.\\n        \\tint sz = s.size();\\n        \\tint i, j, n;\\n        \\tfor (i = 0; i < sz; ++i)\\n        \\t{\\n        \\t\\tn = s[i];\\n        \\t\\tfor (j = 31; j >= 0; --j)\\n        \\t\\t{\\n        \\t\\t\\tt[j] += n & 1;//Find the last digit.\\n        \\t\\t\\tn >>= 1;\\n        \\t\\t\\tif (!n)\\n        \\t\\t\\t\\tbreak;\\n        \\t    }\\n            }\\n    \\tint res = 0;\\n    \\tfor (j = 31; j >= 0; --j)\\n    \\t{\\n    \\t\\tn = t[j] % 3;//\"3\" represents k times. \\n    \\t\\tif (n)\\n    \\t\\t\\tres += 1 << (31 - j);\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43302,
                "title": "accepted-code-with-proper-explaination-does-anyone-have-a-better-idea",
                "content": "   \\n The code makes use of 2 variables. \\n\\nones - At any point of time, this variable holds XOR of all the elements which have \\nappeared \"only\" once. \\ntwos - At any point of time, this variable holds XOR of all the elements which have \\nappeared \"only\" twice. \\n\\nSo if at any point time, \\n\\n1. A new number appears - It gets XOR'd to the variable \"ones\". \\n2. A number gets repeated(appears twice) - It is removed from \"ones\" and XOR'd to the \\nvariable \"twos\". \\n3. A number appears for the third time - It gets removed from both \"ones\" and \"twos\". \\n\\nThe final answer we want is the value present in \"ones\" - coz, it holds the unique element. \\n\\nSo if we explain how steps 1 to 3 happens in the code, we are done. \\nBefore explaining above 3 steps, lets look at last three lines of the code, \\n\\ncommon_bit_mask = ~(ones & twos) \\n\\nones & = common_bit_mask\\n\\ntwos & = common_bit_mask \\n\\nAll it does is, common 1's between \"ones\" and \"twos\" are converted to zero. \\n\\nFor simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique element and 3 repeated elements - in any order). \\n\\nExplanation for step 1 \\n------------------------ \\nLets say a new element(x) appears. \\n\\nCURRENT SITUATION - Both variables - \"ones\" and \"twos\" has not recorded \"x\". \\n\\nObserve the statement \"twos| = ones & x\". \\nSince bit representation of \"x\" is not present in \"ones\", AND condition yields nothing. So \"twos\" does not get bit representation of \"x\". \\nBut, in next step \"ones ^= x\" - \"ones\" ends up adding bits of \"x\". Thus new element gets recorded in \"ones\" but not in \"twos\". \\n\\nThe last 3 lines of code as explained already, converts common 1's b/w \"ones\" and \"twos\" to zeros. \\nSince as of now, only \"ones\" has \"x\" and not \"twos\" - last 3 lines does nothing. \\n\\nExplanation for step 2. \\n------------------------ \\nLets say an element(x) appears twice. \\n\\nCURRENT SITUATION - \"ones\" has recorded \"x\" but not \"twos\". \\n\\nNow due to the statement, \"twos| = ones & x\" - \"twos\" ends up getting bits of x. \\nBut due to the statement, \"ones ^ = x\" - \"ones\" removes \"x\" from its binary representation. \\n\\nAgain, last 3 lines of code does nothing. \\nSo ultimately, \"twos\" ends up getting bits of \"x\" and \"ones\" ends up losing bits of \"x\". \\n\\nExplanation for step 3. \\n------------------------- \\nLets say an element(x) appears for the third time. \\n\\nCURRENT SITUATION - \"ones\" does not have bit representation of \"x\" but \"twos\" has. \\n\\nThough \"ones & x\" does not yield nothing .. \"twos\" by itself has bit representation of \"x\". So after this statement, \"two\" has bit representation of \"x\". \\nDue to \"ones^=x\", after this step, \"one\" also ends up getting bit representation of \"x\". \\n\\nNow last 3 lines of code removes common 1's of \"ones\" and \"twos\" - which is the bit representation of \"x\".\\nThus both \"ones\" and \"twos\" ends up losing bit representation of \"x\".\\n\\n\\n\\n\\n\\n\\n\\n\\n     class Solution {\\n        public:\\n        // Let us take the example of {3, 3, 2, 3} to understand this\\n            int singleNumber(int A[], int n) {\\n                int ones=0, twos =0;\\n                int common_bit_mask;\\n                for(int i=0; i<n;i++)\\n                {\\n                     /* The expression \"one & arr[i]\" gives the bits that are\\n                   there in both 'ones' and new element from arr[].  We\\n                   add these bits to 'twos' using bitwise OR\\n         \\n                   Value of 'twos' will be set as 0, 3, 3 and 1 after 1st,\\n                   2nd, 3rd and 4th iterations respectively */\\n                   \\n                    twos= twos|(ones&A[i]);\\n                    /* XOR the new bits with previous 'ones' to get all bits\\n                   appearing odd number of times\\n         \\n                   Value of 'ones' will be set as 3, 0, 2 and 3 after 1st,\\n                   2nd, 3rd and 4th iterations respectively */\\n                    ones=ones^A[i];\\n                     /* The common bits are those bits which appear third time\\n                   So these bits should not be there in both 'ones' and 'twos'.\\n                   common_bit_mask contains all these bits as 0, so that the bits can \\n                   be removed from 'ones' and 'twos'   \\n         \\n                   Value of 'common_bit_mask' will be set as 00, 00, 01 and 10\\n                   after 1st, 2nd, 3rd and 4th iterations respectively */\\n                    common_bit_mask= ~(ones&twos);\\n                    /* Remove common bits (the bits that appear third time) from 'ones'\\n                     \\n                   Value of 'ones' will be set as 3, 0, 0 and 2 after 1st,\\n                   2nd, 3rd and 4th iterations respectively */\\n                    ones &=common_bit_mask;\\n                    /* Remove common bits (the bits that appear third time) from 'twos'\\n         \\n                   Value of 'twos' will be set as 0, 3, 1 and 0 after 1st,\\n                   2nd, 3rd and 4th itearations respectively */\\n                    twos &=common_bit_mask;\\n                }\\n                return ones;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        // Let us take the example of {3, 3, 2, 3}",
                "codeTag": "Java"
            },
            {
                "id": 43332,
                "title": "my-own-explanation-of-bit-manipulation-method-might-be-easier-to-understand",
                "content": "Consider the following fact:\\n\\nWrite all numbers in binary form, then for any bit 1 that appeared 3*n times (n is an integer), the bit can only present in numbers that appeared 3 times\\n\\ne.g. 0010 0010 0010 1011 1011 1011 1000 (assuming 4-bit integers)\\n2(0010) and 11(1011) appeared 3 times, and digit counts are:\\n\\n> **Digits**             3 2 1 0 \\n> \\n> **Counts**           4 0 6 3\\n> \\n> **Counts%3**     1 0 0 0\\n\\nCounts on 2,1,0 are all times of 3, the only digit index that has Counts % 3 != 0 is 3\\n\\nTherefore, to find the number that appeared only 1 or 2 times, we only need to extract all bits that has Counts %3 != 0\\n\\nNow consider how we could do this by bit manipulation\\n\\nsince counts % 3 has only 3 states: 0(00),1(01),2(10)\\nwe could use a TWO BIT COUNTER (Two, One) to represent Counts % 3, now we could do a little research on state transitions, for each bit, let B be the input bit, we can enumerate the all possible state transitions, Two+, One+ is the new state of Two, One. (here we need to use some knowledge in Digital Logic Design)\\n\\n-----------------------\\n\\n> Two One B Two+ One+\\n>\\n> 0    0  0    0   0\\n> \\n> 0    0  1    0   1\\n> \\n> 0    1  0    0   1\\n> \\n> 0    1  1    1   0\\n> \\n> 1    0  0    1   0\\n> \\n> 1    0  1    0   0\\n> \\n> 1    1  0    X   X (X represents we don't care)\\n> \\n> 1    1  1    X   X\\n\\n\\nWe could then draw the **Karnaugh map** to analyze the logic (https://en.wikipedia.org/wiki/Karnaugh_map), and then we get:\\n\\n> One+ = (One ^ B) & (~Two)\\n> \\n> Two+ = (~One+) & (Two ^ B)\\n\\nNow for int_32, we need only 2 int_32 two represent Two and One for each bit and update Two and One using the rules derived above\\n\\nCode is here (C++):\\n\\n    class Solution {\\n      public:\\n        int singleNumber(vector<int>& nums) {\\n            int counterOne = 0;\\n            int counterTwo = 0;\\n            \\n            for (int i = 0; i < nums.size(); i++){\\n                counterOne = (~counterTwo) & (counterOne ^ nums[i]);\\n                counterTwo = (~counterOne) & (counterTwo ^ nums[i]);\\n            }\\n            return counterOne;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n      public:\\n        int singleNumber(vector<int>& nums) {\\n            int counterOne = 0;\\n            int counterTwo = 0;\\n            \\n            for (int i = 0; i < nums.size(); i++){\\n                counterOne = (~counterTwo) & (counterOne ^ nums[i]);\\n                counterTwo = (~counterOne) & (counterTwo ^ nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 700046,
                "title": "single-number-ii-easy-to-understand-language-c",
                "content": "#### Basic Idea\\nWe are given an array where every integer, except one, occurs thrice. Therefore, at every bit position, there is an odd bit while all other bits occur as multiples of 3.\\nThe following example will make this clearer.\\n\\nTake the input array  : [2, 2, 2, 4, 4, 4, 5]\\n\\nA  B C\\n0  1  0  ~  2\\n0  1  0\\n0  1  0\\n1  0  0  ~  4\\n1  0  0\\n1  0  0\\n1  0  1 ~  5\\n\\nAt bit position A : 3 occurences of \\'0\\' + 3 occurences of \\'1\\' + **1 occurence of \\'1\\'**\\nAt bit position B : 3 occurences of \\'1\\' + 3 occurences of \\'0\\' + **1 occurence of \\'0\\'**\\nAt bit position C : 6 occurences of \\'0\\' + **1 occurence of  \\'1\\'**\\n\\nTherefore, at each bit position, we have bits that occur in multiples of 3, and one lone bit.\\nSo, if we add up the bits at a given position as *sum*, and find the remainder when *sum* is divided by 3, we get the left over bit.\\n\\nFor the bits at A, *sum*  = 4 :  4 % 3 = 1\\nFor the bits at B, *sum*  = 3 :  3 % 3 = 0\\nFor the bits at C, *sum*  = 1 :  1 % 3 = 1\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        long ans;\\n        int x, t;\\n        ans=0;\\n        int p=0;\\n\\t\\t// We have 32 bits integers as input\\n        for(int i=0;i<32;i++)\\n        {\\n            t=0;\\n            //calculate sum of ith bit for all numbers in nums\\n            for(int j=0;j<n;j++)\\n            {\\n                x=nums[j]&1;\\n                t=t+x;\\n                nums[j]=nums[j]>>1;\\n            }\\n            t=t%3;\\n            //the bit that does not occur as multiple of 3 is left as a remainder \\n            ans=ans+t*pow(2,p);\\n            p++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```\\n\\nAs the loop runs *32 * n*  times, Time Complexity = **O(N)**\\nSpace Complexity = **O(1)**\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        long ans;\\n        int x, t;\\n        ans=0;\\n        int p=0;\\n\\t\\t// We have 32 bits integers as input\\n        for(int i=0;i<32;i++)\\n        {\\n            t=0;\\n            //calculate sum of ith bit for all numbers in nums\\n            for(int j=0;j<n;j++)\\n            {\\n                x=nums[j]&1;\\n                t=t+x;\\n                nums[j]=nums[j]>>1;\\n            }\\n            t=t%3;\\n            //the bit that does not occur as multiple of 3 is left as a remainder \\n            ans=ans+t*pow(2,p);\\n            p++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715277,
                "title": "image-explanation-bit-manipulation-4-methods-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Single Number II` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/e8d593d2-241b-423b-af85-be3ef44fcb78_1688448136.2994149.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/43232616-e389-42ef-8ffe-d43048c68a76_1688442335.1273727.png)\\n![image.png](https://assets.leetcode.com/users/images/5f8e1275-7576-42f6-a3b7-854874b55be2_1688442361.026164.png)\\n![image.png](https://assets.leetcode.com/users/images/6c33c703-0276-48ec-90c2-0e0ef2a02e57_1688442369.934677.png)\\n![image.png](https://assets.leetcode.com/users/images/a4f250dc-1824-4b98-8bd1-8ed69398799e_1688442376.3737812.png)\\n![image.png](https://assets.leetcode.com/users/images/490efbe2-4a17-4b7a-8eef-eda96d74b24d_1688442384.6384706.png)\\n![image.png](https://assets.leetcode.com/users/images/b70e25fb-69d2-4aa2-b1a0-23a58add6f6b_1688442391.8456519.png)\\n![image.png](https://assets.leetcode.com/users/images/fefb3d96-efdc-452d-a268-bafcf2244d86_1688442404.268496.png)\\n![image.png](https://assets.leetcode.com/users/images/22c1cf77-04b7-4b9d-8a85-94c3ad1a4c8b_1688442412.753717.png)\\n![image.png](https://assets.leetcode.com/users/images/6e7d81b3-ed29-42c5-8e0b-7c94251a88c0_1688442419.0192356.png)\\n![image.png](https://assets.leetcode.com/users/images/ca71c58d-b49d-45b9-a332-e2ea25cf82e6_1688442425.601613.png)\\n![image.png](https://assets.leetcode.com/users/images/a01bf25e-c4d0-43b3-a367-3a5e4b31cf93_1688442434.164556.png)\\n![image.png](https://assets.leetcode.com/users/images/ad3ae7eb-daae-45c4-ac36-831df99b64f0_1688442441.8660142.png)\\n![image.png](https://assets.leetcode.com/users/images/767a899f-2d7c-453d-887e-c362770298fd_1688442448.4866774.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            ones = (ones ^ nums[i]) & ~twos;\\n            twos = (twos ^ nums[i]) & ~ones;\\n        }\\n        return ones;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            ones = (ones ^ nums[i]) & ~twos;\\n            twos = (twos ^ nums[i]) & ~ones;\\n        }\\n        return ones;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        ones = 0\\n        twos = 0\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        return ones\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            ones = (ones ^ nums[i]) & ~twos;\\n            twos = (twos ^ nums[i]) & ~ones;\\n        }\\n        return ones;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            ones = (ones ^ nums[i]) & ~twos;\\n            twos = (twos ^ nums[i]) & ~ones;\\n        }\\n        return ones;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        ones = 0\\n        twos = 0\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        return ones\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699889,
                "title": "python-bit-manipulation-o-32n-but-easy-exaplained",
                "content": "There are several `\\'magical\\'` solutions for this problem I saw in comments, done in `O(n)`, which I really enjoed to read, however I doubt if you never saw this problem you can suceed in real interview. That is why I suggest maybe not the fastest, but much more easier to come up solution. The idea is similar to problem **Single Number**, but here we need to count each bit modulo `3`. So, we\\n1. Iterate over all possible `32` bits and for each `num` check if this `num` has non-zero bit on position `i` with `num & (1<<i) == (1<<i)` formula.\\n2. We evaluate this sum modulo `3`. Note, that in the end for each bit we can have either `0` or `1` and never `2`.\\n3. Next, update our answer `single` with evaluated bit.\\n4. Finally, we need to deal with overflow cases in python: maximum value for `int32` is `2^31 - 1`, so if we get number more than this value we have negative answer in fact.\\n\\n**Complexity**: time complexity is `O(32n)`, which may be not fully honest linear, but is fine for the purpose of this problem. If we want just `O(n)` complexity, I think problem becomes not medium but hard. Space complexity here is `O(1)`.\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums):\\n        single = 0\\n        for i in range(32):\\n            count = 0\\n            for num in nums:\\n                if num & (1<<i) == (1<<i): count += 1\\n            single |= (count%3) << i\\n            \\n        return single if single < (1<<31) else single - (1<<32)   \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums):\\n        single = 0\\n        for i in range(32):\\n            count = 0\\n            for num in nums:\\n                if num & (1<<i) == (1<<i): count += 1\\n            single |= (count%3) << i\\n            \\n        return single if single < (1<<31) else single - (1<<32)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 43403,
                "title": "java-bit-manipulation-solution",
                "content": "    public int singleNumber(int[] nums) {\\n      int ones = 0, twos = 0, threes = 0;\\n            \\n      for (int i = 0; i < nums.length; i++) {\\n        // twos holds the num that appears twice\\n        twos |= ones & nums[i];\\n        \\n        // ones holds the num that appears once\\n        ones ^= nums[i];\\n     \\n        // threes holds the num that appears three times\\n        threes = ones & twos;\\n                \\n        // if num[i] appears three times\\n        // doing this will clear ones and twos\\n        ones &= ~threes;\\n        twos &= ~threes;\\n      }\\n            \\n      return ones;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "    public int singleNumber(int[] nums) {\\n      int ones = 0, twos = 0, threes = 0;\\n            \\n      for (int i = 0; i < nums.length; i++) {\\n        // twos holds the num that appears twice\\n        twos |= ones & nums[i];\\n        \\n        // ones holds the num that appears once\\n        ones ^= nums[i];\\n     \\n        // threes holds the num that appears three times\\n        threes = ones & twos;\\n                \\n        // if num[i] appears three times\\n        // doing this will clear ones and twos\\n        ones &= ~threes;\\n        twos &= ~threes;\\n      }\\n            \\n      return ones;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43360,
                "title": "the-simplest-solution-ever-with-clear-explanation",
                "content": "The key to solve this problem is the count of 1s of each bit of all numbers.\\n\\nTake one bit number for example: nums = [1, 1, 1, 0, 0, 0, ..., x] . All numbers are 0 or 1.\\n\\nWe know that every number appears three times except for just one number. So, if the count of 1s in nums is 0, 3, 6, ..., 3 * n, then the single number is 0. And if the count of 1s in nums is 1, 4, 7, ..., 3*n+1, then the single number is 1.\\n\\nSo, for an array \" nums \" that contains only 0 or 1, the code to find the single number are:\\n\\n    count = 0\\n    for num in nums:\\n        count = (count + num) % 3\\n    return count\\n\\nTo make \"count\" less than 3, mod \"count\" with 3 in every loop.\\n\\nBelow is the procedure for finding the single number in [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]:\\n\\n    Table 1:\\n    ++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++\\n    || num   ||   | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0  ||\\n    ++-------++---+---+---+---+---+---+---+---+---+---+---+---+---+----++\\n    || count || 0 | 1 | 1 | 2 | 0 | 0 | 1 | 1 | 2 | 2 | 0 | 0 | 1 | 1* ||\\n    ++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++\\n\\nSo the single number is 1.\\n\\nWe can write the calculate table for expression \"count' = (count + num) % 3\":\\n\\n    Table 2:\\n    ++=======+=====+========++\\n    || count | num | count' ||\\n    ++-------+-----+--------++\\n    ||   0   |  0  |   0    ||\\n    ++-------+-----+--------++\\n    ||   1   |  0  |   1    ||\\n    ++-------+-----+--------++\\n    ||   2   |  0  |   2    ||\\n    ++-------+-----+--------++\\n    ||   0   |  1  |   1    ||\\n    ++-------+-----+--------++\\n    ||   1   |  1  |   2    ||\\n    ++-------+-----+--------++\\n    ||   2   |  1  |   0    ||\\n    ++-------+-----+--------++\\n\\nTo extend this algorithm to 32bits number. We need to rewrite these code to bit operation expressions. \\n\\nAnd the key is rewriting the expression \" count' = (count + num) % 3 \" to bit operation expressions.\\n\\nWrite binary numbers of \" count \" and \" count' \" in \"Table 2\". And split their bits into two column:\\n\\n    Table 3:\\n    ++=======+============+=====+============+========++\\n    ||       |    count   | num |   count'   |        ||\\n    || count |    (bin)   |     |   (bin)    | count' ||\\n    || (dec) ++=====+=====+=====+=====+=====++ (dec)  ||\\n    ||       || b1  | b0  | num | b1' | b0' ||        ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   0   ||  0  |  0  |  0  |  0  |  0  ||   0    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   1   ||  0  |  1  |  0  |  0  |  1  ||   1    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   2   ||  1  |  0  |  0  |  1  |  0  ||   2    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   0   ||  0  |  0  |  1  |  0  |  1  ||   1    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   1   ||  0  |  1  |  1  |  1  |  0  ||   2    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   2   ||  1  |  0  |  1  |  0  |  0  ||   0    ||\\n    ++=======++===========+=====+===========++========++\\n\\nHere comes the hardest part of this solution. \\n\\n\"Table 3\" is a truth table, we need to use it to find the formulas to calculate \" b0' \" and \" b1' \":\\n    \\n    b0' = f(b1, b0, num)\\n    b1' = g(b1, b0, num)\\n\\nWith observations, guesses, experiments and even some luck. Finally I got two simple and elegant formulas:\\n    \\n    b0' = (b0 ^ num) & (~b1)\\n    b1' = (b1 ^ num) & (~b0')\\n\\nThe AC code:\\n\\n    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def singleNumber(self, nums):\\n            b1, b0 = 0, 0\\n            for num in nums:\\n                b0 = (b0 ^ num) & (~b1)\\n                b1 = (b1 ^ num) & (~b0)\\n            return b0",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 43385,
                "title": "python-bitwise-solution",
                "content": "    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n    def singleNumber(self, A):\\n        ans = 0\\n        for i in xrange(0,32):\\n            count = 0\\n            for a in A:\\n                if ((a >> i) & 1):\\n                    count+=1\\n            ans |= ((count%3) << i)\\n        return self.convert(ans)\\n        \\n    def convert(self,x):\\n        if x >= 2**31:\\n            x -= 2**32\\n        return x",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n    def singleNumber(self, A):\\n        ans = 0\\n        for i in xrange(0,32):\\n            count = 0\\n            for a in A:\\n                if ((a >> i) & 1):\\n                    count+=1\\n            ans |= ((count%3) << i)\\n        return self.convert(ans)\\n        \\n    def convert(self,x):\\n        if x >= 2**31:\\n            x -= 2**32\\n        return x",
                "codeTag": "Java"
            },
            {
                "id": 3527570,
                "title": "mastering-bitwise-operations-a-guide-to-boost-your-interview-preparation",
                "content": "# Mastering Bitwise Operations\\n![image.png](https://assets.leetcode.com/users/images/6f6003f9-98f2-487d-9c5a-7d50f38f9be0_1684162754.1822438.png)\\n\\nBitwise operations are an essential aspect of low-level programming and are frequently encountered in technical interviews. Understanding bitwise operations and their applications can greatly enhance your problem-solving skills and make you stand out as a candidate. In this blog, we will provide a detailed explanation and generalization of the bitwise operation method for single numbers, covering the most commonly used operators and their applications.\\n\\n1. Bitwise AND (&):\\nThe bitwise AND operation compares the corresponding bits of two numbers and returns a new number where each bit is set to 1 if and only if the corresponding bits of both numbers are 1. Otherwise, the bit is set to 0. This operation is useful for checking the presence of specific bits or extracting specific information from a number.\\n\\n- Generalization:\\nGiven two integers, perform a binary AND operation on their corresponding bits, resulting in a new integer with bits set to 1 where both input integers have 1s and 0s otherwise.\\n\\n2. Bitwise OR (|):\\nThe bitwise OR operation compares the corresponding bits of two numbers and returns a new number where each bit is set to 1 if either of the corresponding bits in the input numbers is 1. If both bits are 0, the result bit is set to 0. This operation is often used for setting specific bits or combining different bit patterns.\\n\\n- Generalization:\\nGiven two integers, perform a binary OR operation on their corresponding bits, resulting in a new integer with bits set to 1 where either input integer has a 1, and 0s otherwise.\\n\\n3. Bitwise XOR (^):\\nThe bitwise XOR operation compares the corresponding bits of two numbers and returns a new number where each bit is set to 1 if the corresponding bits of the input numbers are different (one is 0 and the other is 1). If the corresponding bits are the same (both 0s or both 1s), the result bit is set to 0. This operation is useful for toggling bits or checking parity.\\n\\n- Generalization:\\nGiven two integers, perform a binary XOR operation on their corresponding bits, resulting in a new integer with bits set to 1 where the input integers have different bit values, and 0s otherwise.\\n\\n4. Bitwise NOT (~):\\nThe bitwise NOT operation (also called bitwise complement) negates each bit of a number, flipping 0s to 1s and 1s to 0s. This operation is often used in conjunction with other bitwise operations or for creating bit masks.\\n\\n- Generalization:\\nGiven an integer, perform a binary NOT operation on each bit of the number, resulting in a new integer with all its bits flipped (0s become 1s and 1s become 0s).\\n\\n![image.png](https://assets.leetcode.com/users/images/19d6977a-c5ae-44c0-bb05-050762f40c79_1684162852.8252938.png)\\n\\n#### Happy coding!\\n\\n---\\n\\n# Intuition:\\nThe approach used in the code is based on bitwise operations. It maintains two variables, \\'ones\\' and \\'twos\\', to keep track of the bits that appear once and twice, respectively.\\n\\n# Approach:\\n1. Initialize \\'ones\\' and \\'twos\\' as 0.\\n2. Iterate through each number \\'num\\' in the input vector \\'nums\\'.\\n3. Update \\'ones\\' and \\'twos\\' using bitwise operations:\\n   - ones = (ones ^ num) & ~twos: XOR the current number \\'num\\' with \\'ones\\' to toggle the bits that appear once, then perform bitwise AND with the complement of \\'twos\\' to remove the bits that appear twice.\\n   - twos = (twos ^ num) & ~ones: XOR the current number \\'num\\' with \\'twos\\' to toggle the bits that appear twice, then perform bitwise AND with the complement of \\'ones\\' to remove the bits that appear once.\\n4. After iterating through all the numbers, the value stored in \\'ones\\' will be the single number that appears only once.\\n5. Return the value of \\'ones\\' as the result.\\n\\n# Complexity:\\n- The time complexity of this approach is O(n), where n is the number of elements in the input vector \\'nums\\', as we iterate through all the numbers once.\\n- The space complexity is O(1) since we are using a constant amount of extra space to store the variables \\'ones\\' and \\'twos\\'.\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0;\\n        int twos = 0;\\n\\n        for (int num : nums) {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n\\n        return ones;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0;\\n        int twos = 0;\\n\\n        for (int num : nums) {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n\\n        return ones;\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        ones = 0\\n        twos = 0\\n\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n\\n        return ones\\n```\\n---\\n# JavaScript\\n```\\nvar singleNumber = function(nums) {\\n    let ones = 0;\\n    let twos = 0;\\n\\n    for (let num of nums) {\\n        ones = (ones ^ num) & ~twos;\\n        twos = (twos ^ num) & ~ones;\\n    }\\n\\n    return ones;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0;\\n        int twos = 0;\\n\\n        for (int num : nums) {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n\\n        return ones;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0;\\n        int twos = 0;\\n\\n        for (int num : nums) {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n\\n        return ones;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        ones = 0\\n        twos = 0\\n\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n\\n        return ones\\n```\n```\\nvar singleNumber = function(nums) {\\n    let ones = 0;\\n    let twos = 0;\\n\\n    for (let num of nums) {\\n        ones = (ones ^ num) & ~twos;\\n        twos = (twos ^ num) & ~ones;\\n    }\\n\\n    return ones;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43417,
                "title": "my-c-code-12ms-one-iteration-3-int-variables-b0-b1-reset-with-algorithm-description",
                "content": "    /*\\n    The basic idea is to implement a modulo-3 counter (to count how many times \"1\" occurs) for each bit position.\\n    Such modulo-3 counter needs two bits (B1,B0) to represent. \\n    (B1,B0): \\n    (0, 0) : '1' occurs zero times after last resetting,\\n    (0, 1) : '1' occurs one times after last resetting,\\n    (1, 0) : '1' occurs two times after last resetting,\\n    (1, 1) : '1' occurs three times after last resetting, then we need to reset the counter to (0,0)\\n    So to implement such modulo-3 counters, we need three variables (b0, b1, reset)\\n    The n-th bit of b0 is the B0 bit of the modulo-3 counter for the n-th bit (n=0..31 assuming int is 32 bit)\\n    The n-th bit of b1 is the B1 bit of the modulo-3 counter for the n-th bit (n=0..31 assuming int is 32 bit)\\n    The n-th bit of reset is the reset flag of the modulo-3 counter for the n-th bit (n=0..31 assuming int is 32 bit), \\n    \\n    - b0: can be easily implemented with XOR bit operation,  as b0 = b0^ A[i]\\n    - b1: B1 will only be set to 1, when B0 (of the n-th bit counter) =1 and the n-th bit of A[i] = 1, and stay '1' until it is reseted. So b1 |=  b0 & A[i]; \\n    - The reset flag is set when (B1, B0) = (1,1). So, reset = b0 & b1;\\n    - The reset operation can be done by b0 = b0 ^ reset and b1 = b1 ^ reset;\\n    \\n    After updating the b0, b1, reset with all A[], the b0 will be the final result since if the n-th bit of the to-be-found element is 1, then the times of '1' occurs on the n-th bit is 3*x+1, which is 1 after the modulo 3 opertation.   \\n    */\\n    class Solution {\\n    public:\\n    \\n        int singleNumber(int A[], int n) {\\n            int b0=0, b1=0, reset=0;\\n            int i;\\n            \\n            if(n>0)\\n            {\\n            for(i = 0; i<n; i++)\\n            {\\n                b1 |= (b0 & A[i]);\\n                b0 = b0 ^ A[i];\\n                reset = b1 & b0;\\n                b1 = b1 ^ reset;\\n                b0 = b0 ^ reset;\\n            }\\n            \\n            return b0;\\n            }\\n        }\\n    //------------------------------------------------------------------------------------------------------------\\n    /*\\n    //--  Another version with explicit modulo-3 counters implemented, just for reference-----//\\n        const int int_bitwidth = 32;\\n        int singleNumber(int A[], int n) {\\n            int mod3Counter[int_bitwidth];\\n            int i,j;\\n            unsigned int temp = 0;\\n            \\n            if(n>0)\\n            {\\n                for(i=0; i<int_bitwidth; i++) mod3Counter[i] = 0;\\n                \\n                for(i=0; i<n; i++)\\n                {\\n                    temp = (unsigned int) A[i];\\n                    for(j=0; j<int_bitwidth; j++)\\n                    {\\n                        if(temp & 0x1)\\n                        {\\n                            mod3Counter[j] = (mod3Counter[j] + 1) % 3;\\n                        }\\n                        temp = temp>>1;\\n                    }\\n                    \\n                    temp =0;\\n                    for(j=0; j<int_bitwidth; j++)\\n                    {\\n                        temp = temp << 1;\\n                        if(mod3Counter[int_bitwidth - 1 -j]) \\n                        {\\n                            temp = temp | 0x1;\\n                        }\\n                    }\\n                }\\n                return (int)temp;\\n    \\n            }\\n        }\\n    */\\n        \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\n        int singleNumber(int A[], int n) {\\n            int b0=0, b1=0, reset=0;\\n            int i;\\n            \\n            if(n>0)\\n            {\\n            for(i = 0; i<n; i++)\\n            {\\n                b1 |= (b0 & A[i]);\\n                b0 = b0 ^ A[i];\\n                reset = b1 & b0;\\n                b1 = b1 ^ reset;\\n                b0 = b0 ^ reset;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1296437,
                "title": "c-5-solutions-time-o-n-2-o-n-logn-o-n",
                "content": "```\\n// Brute Force Algo\\n// Time: O(n^2)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        for ( int i = 0; i < nums.size(); i++) {\\n            bool found = false;\\n            for ( int j = 0; j < nums.size(); j++) {\\n                if ( nums[i] == nums[j] && i != j) {\\n                    found = true;\\n                }\\n            }\\n            if ( !found ) {\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n// Sorting Algo\\n// Time: O(n.logn)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if ( n == 1)\\n            return nums[0];\\n\\n        sort(nums.begin(), nums.end());\\n        \\n        if ( nums[0] != nums[1])\\n            return nums[0];\\n        if ( nums[n-1] != nums[n-2])\\n            return nums[n-1];\\n        for ( int i = 1; i < n - 1; i++) \\n            if ( nums[i] != nums[i+1] && nums[i] != nums[i-1]) \\n                return nums[i];\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n// Hash Table Algo\\n// Time: O(n)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        unordered_map<int,int> freq;\\n        for (int i : nums) {\\n            freq[i]++;\\n        }\\n        for (auto kv : freq) {\\n            if (kv.second == 1) {\\n                return kv.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n// Bit Manipulation Algo\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {        \\n        unsigned int shift = 1;\\n        unsigned int ans = 0;\\n        \\n        for (int i = 0; i < 32; ++i) {\\n            int count = 0;\\n            for (int i : nums) \\n                if (i & shift)\\n                    count += 1;\\n            if ((count % 3) != 0)\\n                ans = ans + shift;\\n            shift <<= 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n// XOR Bit Manipulation Algo\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {       \\n        int ones = 0;\\n        int twos = 0;\\n        \\n        for ( int i : nums ) {\\n            ones = (ones ^ i) & (~twos);\\n            twos = (twos ^ i) & (~ones);\\n        }\\n        \\n        return ones;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\n// Brute Force Algo\\n// Time: O(n^2)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        for ( int i = 0; i < nums.size(); i++) {\\n            bool found = false;\\n            for ( int j = 0; j < nums.size(); j++) {\\n                if ( nums[i] == nums[j] && i != j) {\\n                    found = true;\\n                }\\n            }\\n            if ( !found ) {\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n// Sorting Algo\\n// Time: O(n.logn)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if ( n == 1)\\n            return nums[0];\\n\\n        sort(nums.begin(), nums.end());\\n        \\n        if ( nums[0] != nums[1])\\n            return nums[0];\\n        if ( nums[n-1] != nums[n-2])\\n            return nums[n-1];\\n        for ( int i = 1; i < n - 1; i++) \\n            if ( nums[i] != nums[i+1] && nums[i] != nums[i-1]) \\n                return nums[i];\\n        return -1;\\n    }\\n};\\n```\n```\\n// Hash Table Algo\\n// Time: O(n)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        unordered_map<int,int> freq;\\n        for (int i : nums) {\\n            freq[i]++;\\n        }\\n        for (auto kv : freq) {\\n            if (kv.second == 1) {\\n                return kv.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n// Bit Manipulation Algo\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {        \\n        unsigned int shift = 1;\\n        unsigned int ans = 0;\\n        \\n        for (int i = 0; i < 32; ++i) {\\n            int count = 0;\\n            for (int i : nums) \\n                if (i & shift)\\n                    count += 1;\\n            if ((count % 3) != 0)\\n                ans = ans + shift;\\n            shift <<= 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n// XOR Bit Manipulation Algo\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {       \\n        int ones = 0;\\n        int twos = 0;\\n        \\n        for ( int i : nums ) {\\n            ones = (ones ^ i) & (~twos);\\n            twos = (twos ^ i) & (~ones);\\n        }\\n        \\n        return ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700329,
                "title": "cpp-solution-o-32-n-easy-to-understand-fully-explained",
                "content": "\\n**lets array is [2,2,3,2,3,4,3]\\nNumber binary form\\n2 ->   ---------------------------_____           0 0 1 0\\n2 ->   ---------------------------_____           0 0 1 0\\n3 ->   ---------------------------_____           0 0 1 1\\n2 ->   ---------------------------_____           0 0 1 0\\n3 ->   ---------------------------_____           0 0 1 1\\n4 ->   ---------------------------_____           0 1 0 0\\n3 ->   ---------------------------_____           0 0 1 1\\nSum of total at every index _____ 0 1 6 3\\nTaking mod by 3 at every index   _0 1 0 0  (0%3=0 , 1%3=1 , 6%3=0 , 3%3=0)\\nNow it is (0100) is binary form of final result i.e 4 is final answer.\\n if number present 3 times then by taking modulo 3 we will eleminate it\\'s bit from result\\n If sum of every index bits taken mod 3 is 0 means that there is no set bit result bit\\n If sum of every index bits taken mod 3 is 1 means that there is set bit result bit\\n Now we will get final result by bits taken by mod and generate decimal form of bits**\\n \\n         for negative single number , check if result in nums or not if not return -res || see solution\\n```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        long long int res=0;\\n        for(int i=0;i<32;i++)\\n        {   int p=0;\\n            for(int j=0;j<nums.size();j++)\\n            {   \\n\\t\\t\\t    int k=abs(nums[j]);\\n                p+=(k&(1<<i))!=0?1:0;    //by shifting 1 to left ith time and taking and with1  will give us \\n\\t\\t\\t\\t                                         //that ith bit of nums[j] is 1 or 0\\n            } \\n           p%=3; \\n          res+=pow(2,i)*p;\\n        } \\n\\t\\t/*\\n\\t\\t**To handle if res is -ve**\\n\\t\\t We have calculated our result positive number\\n\\t\\t But there may be chance that single number may be negative\\n\\t\\t Eg.array= [2,2,-4,2]\\n\\t\\t Here after bitwise calculation our res will store 4 \\n\\t\\t but you see that 4 is not present in  our array.\\n\\t\\t So , we will check if res (4) is present in array or not\\n\\t\\t if present , then return it else res must be -ve\\n\\t\\t Hence return -res (-4):\\n\\t\\t*/\\n        cout<<res;\\n        int c=0;\\n        for(auto x:nums)   //for negative numbers\\n          if(x==res) {c++;}   //if our calculates value res is present in array, then increment c\\n        return c==1?res:-res; //if c=1 return res else res must be -ve\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        long long int res=0;\\n        for(int i=0;i<32;i++)\\n        {   int p=0;\\n            for(int j=0;j<nums.size();j++)\\n            {   \\n\\t\\t\\t    int k=abs(nums[j]);\\n                p+=(k&(1<<i))!=0?1:0;    //by shifting 1 to left ith time and taking and with1  will give us \\n\\t\\t\\t\\t                                         //that ith bit of nums[j] is 1 or 0\\n            } \\n           p%=3; \\n          res+=pow(2,i)*p;\\n        } \\n\\t\\t/*\\n\\t\\t**To handle if res is -ve**\\n\\t\\t We have calculated our result positive number\\n\\t\\t But there may be chance that single number may be negative\\n\\t\\t Eg.array= [2,2,-4,2]\\n\\t\\t Here after bitwise calculation our res will store 4 \\n\\t\\t but you see that 4 is not present in  our array.\\n\\t\\t So , we will check if res (4) is present in array or not\\n\\t\\t if present , then return it else res must be -ve\\n\\t\\t Hence return -res (-4):\\n\\t\\t*/\\n        cout<<res;\\n        int c=0;\\n        for(auto x:nums)   //for negative numbers\\n          if(x==res) {c++;}   //if our calculates value res is present in array, then increment c\\n        return c==1?res:-res; //if c=1 return res else res must be -ve\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 43409,
                "title": "12-ms-c-solution-with-only-1-int-space",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int> nums) {\\n            int tempNum = 0;\\n            for (int i = 1; i < nums.size(); i++) {\\n                tempNum = nums[0] & (tempNum ^ nums[i]);\\n                nums[0] = tempNum | (nums[0] ^ nums[i]);\\n            }\\n            return nums[0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int> nums) {\\n            int tempNum = 0;\\n            for (int i = 1; i < nums.size(); i++) {\\n                tempNum = nums[0] & (tempNum ^ nums[i]);\\n                nums[0] = tempNum | (nums[0] ^ nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 163772,
                "title": "logical-thinking-with-code",
                "content": "Thanks for the original posts.\\n\\n**Logical Thinking**\\nTake [1, 1, 1, 2, 2, 2, 5] for example, binary representation of each number is as below:\\n```\\n0001\\n0001\\n0001\\n0010\\n0010\\n0010\\n0101\\n____\\n0134 if we count the number of 1\\'s for each \\'line\\' by simple addition \\n```\\nIf every element appears three times, the number of 1\\'s for each \\'line\\' should divide by `3`. We define a \\'line\\' with the number of 1\\'s that can divide by `3` as a `balanced` line.\\nThus, the single number must be the only one that contributes to an `unbalanced` line. That is, it has 1 at each position of `unbalanced` lines. Finally, we can identify the single number.\\nIn the example above, 1 and 4 in \\'0134\\' are `unbalanced` lines, thus, \\'0101\\' is the single number we are searching for.\\n\\n**Trick**\\n`(num >> i) & 1`: get the digit of ith least significant position in binary representation of num.\\n`pos = (sum % 3) << i` mask the position `pos` of unbalanced line (as defined above) to 1\\n`result = result | pos` set the digit of position `pos` to 1.\\n\\n**Code**\\n```\\n    public int singleNumber(int[] nums) {\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            int sum = 0;\\n            for (int num : nums) {\\n                sum += (num >> i) & 1;\\n            }\\n            result = result | ((sum % 3) << i);\\n        }\\n    \\n        return result;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n0001\\n0001\\n0001\\n0010\\n0010\\n0010\\n0101\\n____\\n0134 if we count the number of 1\\'s for each \\'line\\' by simple addition \\n```\n```\\n    public int singleNumber(int[] nums) {\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            int sum = 0;\\n            for (int num : nums) {\\n                sum += (num >> i) & 1;\\n            }\\n            result = result | ((sum % 3) << i);\\n        }\\n    \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43363,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static int singleNumber(int[] nums) {\\n\\t\\tint len = nums.length, result = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\t\\tsum += (nums[j] >> i) & 1;\\n\\t\\t\\t}\\n\\t\\t\\tresult |= (sum % 3) << i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic static int singleNumber(int[] nums) {\\n\\t\\tint len = nums.length, result = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\t\\tsum += (nums[j] >> i) & 1;\\n\\t\\t\\t}\\n\\t\\t\\tresult |= (sum % 3) << i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3715167,
                "title": "bit-manipulation-fast-code-detailed-explanation-video-tutorial-c-java-python",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can count bits here ith bit can be in the form of 3*x+1 or 3*x.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtube.com/@LetsCodeTogether72?sub_confirmation=1\\n or link in my comment section.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\nor\\nsearch \\uD83D\\uDC49`Single Number || by Let\\'s Code Together` on youtube\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n If any number is occuring 3 times then the count of every set bit of that number will also be 3.\\n            For example, let\\'s say we have 5,5,5 then,\\n            Binary representation is 101,101,101.\\n            We can see that the count of 0th and 2nd bit will be 3.\\n            Now if another number comes, let\\'s say 4(100) then the count of every set bit will be:\\n                0th: 3\\n                2nd: 4\\n            So by using the above logic if we get a count of each set bit for all the numbers and take modulo of 3 for each bit then the resulting number would be our answer.\\n            Like in above example, count of each bit became 4, 0, 3 and if we take % 3 then it will become 1,0,0 and 100 is 4(our answer).\\n\\n\\nPlease upvote if u like this \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n           int res= 0;\\n        for(int i=0;i<32;i++){\\n            int countones = 0;\\n            for(int j=0;j<nums.size();j++){\\n                countones =countones+ ((nums[j]>>i)&1);\\n            }\\n            countones = countones % 3;\\n            res = (res | countones << i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Java Code\\n```\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            int countOnes = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                countOnes += (nums[j] >> i) & 1;\\n            }\\n            countOnes = countOnes % 3;\\n            if (countOnes != 0) {\\n                res |= countOnes << i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n# Python Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                temp = n >> i\\n                temp = temp & 1\\n                count += temp\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res\\n```\\nPlease upvote if you like this",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n           int res= 0;\\n        for(int i=0;i<32;i++){\\n            int countones = 0;\\n            for(int j=0;j<nums.size();j++){\\n                countones =countones+ ((nums[j]>>i)&1);\\n            }\\n            countones = countones % 3;\\n            res = (res | countones << i);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            int countOnes = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                countOnes += (nums[j] >> i) & 1;\\n            }\\n            countOnes = countOnes % 3;\\n            if (countOnes != 0) {\\n                res |= countOnes << i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                temp = n >> i\\n                temp = temp & 1\\n                count += temp\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43300,
                "title": "my-simple-python-solution",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def singleNumber(self, nums):\\n            a= set(nums)\\n            a = sum(a)*3 -sum(nums)\\n            a = a/2\\n            return a",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 869698,
                "title": "my-understanding-on-bit-manipulation-method",
                "content": "OK I have to admit that I\\'m no expert on bit manipulation, so when I first looked at the solution on this, I was really confused. I could understand if the numbers are fed in in order, but if they are out of order, I could not figure out why our counts still work. FInally I got up with this. Noted that I got this AFTER I looked at the solution, so it\\'s more like an explaination rather than a solution.\\n\\nSo we need to think every number as a set of bits. If we stack them together like this:\\n\\n8: 1 0 0 0\\n8: 1 0 0 0\\n8: 1 0 0 0\\n2: 0 0 1 0\\n\\nWe can see that we need some kind of operations that can cancel out any zeros or ones that appears 3 time. We can think this like we are adding all bits on a certain position then mod by 3. But since every bit only has two values (0 or 1), we cannot do this within one bit sequence, so we need two.\\n\\nSince all bit positions are the same, we only consider one bit here. Also since adding zeros together does not really change the added value, we focus on the appearances of ones here. Following is how the two numbers should change when adding ones. When adding zeros, they should stay the same.\\n```\\n               Initial State   Add first one   Add second one   Add third one\\nseenOnce          0                  1              0                 0\\nseenTwice         0                  0              1                 0\\n```\\nSo we can now try to find the operations that can fulfill this requirement. Here we can refer to the explainations within the solution itself. When developing the equation, we need to keep in mind that we update `seenOnce` first. We we update `seenTwice`, `seenOnce` already has the new value. So we need to check the values within the correct spot.\\n\\nFor `seenOnce`, `(seenOnce ^ num)` makes sense for the first two appearance, for the third appearance, we need it to be zero, and by then `seenTwice` is 1, so we AND a `~seenTwice` to it, the final equation is `~seenTwice & (seenOnce ^ 1)`.\\n\\nFor `seenTwice`, similarly, we AND a `~seenOnce` to force the first appearance\\'s value to be zero, then `(seenTwice ^ num)` will handle the last two appearances. The final equation will be `~seenOnce & (seenTwice ^ num)`.\\n\\nHere is the code, which is exactly the same with the solution ;)\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // This problem can be translated to:\\n        //      For every bit position, we cancel any 3-time 1 and 3-time 0 to a 0\\n        //      Then we need to find equations that fits this: (assume we apply 3 1s)\\n        //               Zero 1      First 1     Second 1    Third 1\\n        // seenOnce        0            1           0           0\\n        // seenTwice       0            0           1           0\\n        int seenOnce = 0;\\n        int seenTwice = 0;\\n        \\n        for(int num: nums) {\\n            seenOnce = ~seenTwice & (seenOnce ^ num);\\n            seenTwice = ~seenOnce & (seenTwice ^ num);\\n        }\\n        \\n        return seenOnce;\\n    }\\n}\\n```\\n\\nHope this can help you!",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n               Initial State   Add first one   Add second one   Add third one\\nseenOnce          0                  1              0                 0\\nseenTwice         0                  0              1                 0\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // This problem can be translated to:\\n        //      For every bit position, we cancel any 3-time 1 and 3-time 0 to a 0\\n        //      Then we need to find equations that fits this: (assume we apply 3 1s)\\n        //               Zero 1      First 1     Second 1    Third 1\\n        // seenOnce        0            1           0           0\\n        // seenTwice       0            0           1           0\\n        int seenOnce = 0;\\n        int seenTwice = 0;\\n        \\n        for(int num: nums) {\\n            seenOnce = ~seenTwice & (seenOnce ^ num);\\n            seenTwice = ~seenOnce & (seenTwice ^ num);\\n        }\\n        \\n        return seenOnce;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327103,
                "title": "python-binary-solution",
                "content": "```python\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        is_neg = False\\n        for i in xrange(32):\\n            counter = 0\\n            for num in nums:\\n                if (num >> i) & 1:\\n                    counter += 1\\n            \\n            if counter % 3 == 1:\\n                ans += pow(2, i)\\n                if i == 31:\\n                    is_neg = True\\n        return ans if not is_neg else ans - pow(2, 32)\\n```\\n\\n`1 0 0 1` is  9\\n`1 0 0 1` is  9\\n`1 0 0 1` is  9\\n`0 1 0 1` is  5\\n\\nRecord how many `1`s are on the same bit. In this example, 3 `1` on the first bit, 1 `1` on the second bit and 4 `1` on the last bit. Only need the number which appearing once, so it is `0101`. Convert it to integer.\\n\\nI used 32 bits to record the result, so the largest positive interger is `01111...111` which has 31 `1`s(`pow(2,31) - 1`). If the first bit is `1`, the result is negtive.  `ans - pow(2, 32)` will be the final result.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        is_neg = False\\n        for i in xrange(32):\\n            counter = 0\\n            for num in nums:\\n                if (num >> i) & 1:\\n                    counter += 1\\n            \\n            if counter % 3 == 1:\\n                ans += pow(2, i)\\n                if i == 31:\\n                    is_neg = True\\n        return ans if not is_neg else ans - pow(2, 32)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43436,
                "title": "just-6-lines-accepted-o-n-solution",
                "content": "Image the numbers in A have just one bit,\\n\\nthat is: A = [0, 0, 0, 1, 1, 1, x]\\n\\nWe have three times \"0\", three times \"1\", and a different \"x\".\\n\\nSo, if count of \"1\" in A is three's multiple, than x = 0,\\n\\nelse, x = 1.\\n\\nIterate all numbers in A. \\n\\nWhen encount FIRST        \"1\", set \"ec1 = 1\";\\n\\nWhen encount SECOND   \"1\", set \"ec2 = 1\";\\n\\nWhen encount THIRD       \"1\", set \"ec3 = 1, ec1 = 0, ec2 = 0\", and move on...\\n\\nAt last \"ec1\" is the different number.\\n\\n\\n\\n    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n        def singleNumber(self, A):\\n            ec1, ec2, ec3 = 0, 0, 0\\n            for ai in A:\\n                ec3 = ec2 & ai\\n                ec2 = (ec2 | (ec1 & ai)) & (~ec3)\\n                ec1 = (ec1 | ai) & (~ec3)        \\n            return ec1",
                "solutionTags": [],
                "code": "Image the numbers in A have just one bit,\\n\\nthat is: A = [0, 0, 0, 1, 1, 1, x]\\n\\nWe have three times \"0\", three times \"1\", and a different \"x\".\\n\\nSo, if count of \"1\" in A is three's multiple, than x = 0,\\n\\nelse, x = 1.\\n\\nIterate all numbers in A. \\n\\nWhen encount FIRST        \"1\", set \"ec1 = 1\";\\n\\nWhen encount SECOND   \"1\", set \"ec2 = 1\";\\n\\nWhen encount THIRD       \"1\", set \"ec3 = 1, ec1 = 0, ec2 = 0\", and move on...\\n\\nAt last \"ec1\" is the different number.\\n\\n\\n\\n    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n        def singleNumber(self, A):\\n            ec1, ec2, ec3 = 0, 0, 0\\n            for ai in A:\\n                ec3 = ec2 & ai\\n                ec2 = (ec2 | (ec1 & ai)) & (~ec3)\\n                ec1 = (ec1 | ai) & (~ec3)        \\n            return ec1",
                "codeTag": "Java"
            },
            {
                "id": 1615247,
                "title": "bit-manipulation-bitwise-logic-explanation",
                "content": "# Bit Manipulation\\n\\nBefore I try to solve this problem. I never touch the bit manipulation. However, I found the solution people solve is elegant and smart. I want to understand the logic behind. And I finally did. I am here to share my understanding.\\n\\ninput : [ 36, 96, 36, 96, 4, 96, 36 ]\\n\\nLet us represent the above number in bit first.\\n\\n0010 0100 (36)\\n0110 0000 (96)\\n0010 0100 (36)\\n0110 0000 (96)\\n0000 0100 (4)\\n0110 0000 (96)\\n0010 0100 (36)\\n\\nok.  Now let us try to sum each column bit. we want to see how many times each columns occurs\\n\\n0010 0100 (36)\\n0110 0000 (96)\\n0010 0100 (36)\\n0110 0000 (96)\\n0000 0100 (4)\\n0110 0000 (96)\\n0010 0100 (36)\\n..........................\\n0360 0400 \\n\\n\\nok. since every element appears three times except for one.\\nWhich means we can mod 3 to check if the remainder is 0 or not.\\nif the remainder is 0, it means the except one does not contain the bit in that column.\\n\\n\\n 0360 0400 \\n%3\\n..........................\\n 0000 0100\\n\\nNow we found out that 0000 0100, which is equal to 4 is our desired single number.\\n\\nThe next step is to convert our idea to code.\\n\\n```\\nint singleNumber(vector<int>& nums)\\n{\\n\\tint ans = 0;\\n\\n\\tfor (int i = 0; i < 32; i++)\\n\\t{\\n\\t\\tint sum = 0;\\n\\t\\tfor (int num : nums)\\n\\t\\t{\\n\\t\\t\\tif (num & 1 << i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (sum % 3)\\n\\t\\t{\\n\\t\\t\\tans |= (1 << i);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n\\n\\nSince int = 4bytes, 1byte = 8bits, we are going to loop 32 times. \\nwhich means, we are going to loop through each bit, from the most significant to less significant or vice versa. (for my example is from right to left, since i am using left shift operator \\u201C`<<`\\u201D)\\n\\nThe variable sum is the number of times that the bit occurs.\\nWe use `1 << i` to target specific column of bit\\nSince we are using `&` operator, combine with `1 << i`, which means we ignore all other columns of bit.\\n\\ninput : [ 36, 96, 36, 96, 4, 96, 36 ]\\n_____________________________________\\nnow, `i=0`, so we are looking at the less significant bit first.\\n\\nsum = 0\\nnum = 36\\n\\n0010 010**0** num(36)   \\n0000 000**1**  1 << **0**  (&) \\n..........................................\\n0000 000**0** \\n\\n_____________________________________\\n\\nsum = 0       \\nnum = 96\\n                        \\n0110 000**0**  num(96)   \\n0000 000**1**  1 << **0**  (&)\\n..........................................\\n0000 000**0** \\n\\n_____________________________________\\n\\nsum = 0       \\nnum = 4\\n                        \\n0000 010**0** num(4)     \\n0000 000**1**  1 << **0**      (&)\\n..........................................\\n0000 000**0** \\n.\\n.\\n.\\n_____________________________________\\n\\nnow i = 1, then we loop through the nums\\n\\nsum = 0\\nnum = 36\\n\\n0010 01**0**0 num(36)   \\n0000 00**1**0  1 << **1** (&)\\n..........................................\\n0000 00**0**0 \\n_____________________________________\\n\\nsum = 0\\nnum = 96\\n\\n0110 00**0**0 num(96)   \\n0000 00**1**0  1 << **1**    (&)\\n..........................................\\n0000 00**0**0 \\n_____________________________________\\n\\nsum = 0\\nnum = 4\\n\\n0000 01**0**0 num(4)     \\n0000 00**1**0  1 << **1**   (&)\\n..........................................\\n0000 00**0**0 \\n.\\n.\\n.\\n_____________________________________\\n\\nnow i = 2, then we loop through the nums\\n\\nsum = 0\\nnum = 36\\n\\n0010 0**1**00 num(36)  \\n0000 0**1**00  1 << **2** (&)\\n..........................................\\n0000 0**1**00 \\n\\nsum = 1\\nnum = 96\\n\\n0110 0**0**00 num(96)  \\n0000 0**1**00  1 << **2** (&)\\n..........................................\\n0000 0**0**00 \\n\\nsum = 1\\nnum = 4\\n\\n0000 0**1**00 num(4)    \\n0000 0**1**00  1 << **2** (&)\\n..........................................\\n0000 0**1**00 \\n\\n\\nsum = 2\\n.\\n.\\n.\\nIn the end we will find that sum = 4, which sum % 3 is  = 1, will trigger our if statement.\\n\\nThe next step is to add this column of bit to our answer variable. That all. After loop through 32 times. the answer will be our single number\\n__________________________\\n# BitWise\\n\\nThe idea of bitwise vs bit manipulation is almost the same. Only the representation is different.\\n\\nwe will declare 2 variables.\\n\\nint seenOnce = 0\\nint seenTwice = 0 \\n\\nif the input occurs 1st, we will change seenOnce to 1\\nif the input occurs 2nd, we will change seenOnce to 0, seenTwice to 1\\nif the input occurs 3rd, we will change seenOnce to 0, seenTwice to 0\\n\\nbut let\\'s think about it as bit. If that column of bit occurs 1st, we set seenOnce\\u2019s that column of bit to 1,  what does i mean, let look this example\\n\\ninput : [ 36, 96, 36, 96, 4, 96, 36 ]\\n\\n\\nin the very first beginning\\nseenOnce :  0000 0000\\nseenTwice : 0000 0000\\n\\nnow we detect 36,\\n36 = 0010 0100, the 2nd and 5nd column of bit (from right to left, from 0 to 7) seen once, now we add to seen once.\\n\\nseenOnce  : 0010 0100\\nseenTwice : 0000 0000\\n\\n\\nnow we detect 96,\\n96 = 0010 0000, the 5nd column of bit seen,  this is the 2nd time that 5nd column we see. so we change seenOnce 5nd bit column to 0, and change seenTwice 5nd bit column to 1\\n\\nseenOnce  : 0100 0100\\nseenTwice : 0010 0000\\n\\n\\nnow we detect 36,\\n36 = 0010 0100, the 2nd bit column seen twice, the 5nd column seen third now. so we \\nchange the seenOnce 2nd bit column to 0, and change seenTwice 2nd bit column to 1.\\nwe also change the seenTwice 5nd bit column to 0, since this is the third time. \\n\\nseenOnce  : 0100 0000\\nseenTwice : 0000 0100\\n\\n.\\n.\\n.\\n.\\nnow you will find out that,  if that column of bit occurs 3 times, seenOnce will reset to zero. seenTwice will reset to zero. So the remaining bit will be our single number.\\n\\nthe idea behind is very similar to sum%3 == 0\\n\\nNow we understand the logic, let us look through the code\\n\\n```\\n    int seenOnce = 0, seenTwice = 0;\\n\\n    for (int num : nums) {\\n      seenOnce = ~seenTwice & (seenOnce ^ num);\\n      seenTwice = ~seenOnce & (seenTwice ^ num);\\n    }\\n\\n    return seenOnce;\\n```\\n\\n\\nlet\\'s look this code separately\\n\\nseenOnce = `~seenTwice` & (seenOnce ^ num);\\nseenOnce is only allow to set if seenTwice is zero\\n\\nseenOnce = ~seenTwice & `(seenOnce ^ num)`;\\nseenOnce will set to 1 - 0 - 1 - 0 - 1 - 0 repeatedly\\n\\n________________\\nNow i am going to find the magic Single Number 3 behind, happing coding day. Thx the community let me learn so much things. \\nFirst time to post the discussion. Lost a lot of style and color where i did it from google doc :( \\nHope everyone dont mind my ugly typesetting.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nint singleNumber(vector<int>& nums)\\n{\\n\\tint ans = 0;\\n\\n\\tfor (int i = 0; i < 32; i++)\\n\\t{\\n\\t\\tint sum = 0;\\n\\t\\tfor (int num : nums)\\n\\t\\t{\\n\\t\\t\\tif (num & 1 << i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (sum % 3)\\n\\t\\t{\\n\\t\\t\\tans |= (1 << i);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\n    int seenOnce = 0, seenTwice = 0;\\n\\n    for (int num : nums) {\\n      seenOnce = ~seenTwice & (seenOnce ^ num);\\n      seenTwice = ~seenOnce & (seenTwice ^ num);\\n    }\\n\\n    return seenOnce;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43381,
                "title": "clean-c-solution-for-generic-k",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            auto r = 0, k = 3;\\n            for (auto i = 0; i < 32; ++i) {\\n                auto mask = 1 << i, cnt = 0;\\n    \\n                for (auto num : nums)\\n                    cnt += bool(num & mask);\\n    \\n                if (cnt % k)\\n                    r |= mask;\\n            }\\n            return r;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            auto r = 0, k = 3;\\n            for (auto i = 0; i < 32; ++i) {\\n                auto mask = 1 << i, cnt = 0;\\n    \\n                for (auto num : nums)\\n                    cnt += bool(num & mask);\\n    \\n                if (cnt % k)\\n                    r |= mask;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 43383,
                "title": "a-simple-solution-for-all-similar-problems",
                "content": "    public class Solution {\\n     public int singleNumber(int[] nums) {\\n        int[] digit = new int[32];\\n        for(int i = 0; i < 32; i++){\\n            // for each digit, we count the number of appearance in the array\\n            for (int j = 0; j < nums.length; j++){\\n                digit[i]+= (nums[j]>>i)&1; // get the value (0 or 1) at ith digit of nums[j]\\n            }\\n        }\\n        int res = 0;\\n        for (int i =0; i< 32; i++){\\n            // (digit[i]%3) is mode of 3, if it is not zero, it means the single number has 1 on this digit.\\n            int d = digit[i]%3 ==0 ? 0: 1;\\n            res += (d)<<i;\\n        }\\n        return res;\\n    }\\n }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n     public int singleNumber(int[] nums) {\\n        int[] digit = new int[32];\\n        for(int i = 0; i < 32; i++){\\n            // for each digit, we count the number of appearance in the array\\n            for (int j = 0; j < nums.length; j++){\\n                digit[i]+= (nums[j]>>i)&1; // get the value (0 or 1) at ith digit of nums[j]\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1771908,
                "title": "c-simplest-solution-bit-manipulation-o-n",
                "content": "Given an array in which each number repeats thrice, except for one, we need to find and return it using O(n) time & constant space.\\n\\n**APPROACH :**\\n\\n* Since all the elements in the array are positive integers, we can traverse all the 32 bits & check if the number of elements this bit is set in is a multiple of 3.\\n* If not, then that bit is set in the single number too.\\n* So we ```OR``` the answer with the bit.\\n\\n\\n**How to get a single bit set in all 32 bits :** 1<<i  (Left shift operator to set only the ```i```th bit)\\n\\n**How to check if that bit is set in any element ```n``` of nums :** Do n & (1<<i) (Since ```AND``` results in zero for any combination except ```1&1```, we get ```1``` if that bit is set and ```0``` otherwise).\\n\\n**How to add that bit to the ans (the final single number we\\'re going to return) :** Just ```OR``` ```(1<<i)``` with the answer ( The ```OR``` operation can set any single bit in a number).\\n\\n\\n\\n**Time Complexity :** O(32n) == O(n)\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int check, count, ans = 0;\\n        for(int i=0; i<=31; i++){\\n            check = 1<<i, count=0;\\n            for(auto n : nums) if(n & check) count++;\\n            if(count%3) ans |= check;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if you\\'ve found my solution helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```OR```\n```i```\n```n```\n```AND```\n```1&1```\n```1```\n```0```\n```OR```\n```(1<<i)```\n```OR```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int check, count, ans = 0;\\n        for(int i=0; i<=31; i++){\\n            check = 1<<i, count=0;\\n            for(auto n : nums) if(n & check) count++;\\n            if(count%3) ans |= check;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43396,
                "title": "o-n-solution-c",
                "content": "    int singleNumber(int* nums, int numsSize) {\\n        // idea : iterate over all elements in array for every bit, get sum of all 1s, \\n        // bits with sum not multiple of 3, are 1's bit in the single occurance element\\n        // e.g. , 5,5,5,2 - 101 101 101 010 - 313 - answer is 3%3,1%3,3%3 - 010\\n        \\n        int x, res = 0;\\n        \\n        for(int i = 0; i < sizeof(int)*8; i++){\\n            x = 1 << i;\\n            int sum = 0;\\n            for(int j = 0; j < numsSize; j++){\\n                if(x & nums[j]) sum++;\\n            }\\n            \\n            if(sum % 3) res = res | x;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    int singleNumber(int* nums, int numsSize) {\\n        // idea : iterate over all elements in array for every bit, get sum of all 1s, \\n        // bits with sum not multiple of 3, are 1's bit in the single occurance element\\n        // e.g. , 5,5,5,2 - 101 101 101 010 - 313 - answer is 3%3,1%3,3%3 - 010\\n        \\n        int x, res = 0;\\n        \\n        for(int i = 0; i < sizeof(int)*8; i++){\\n            x = 1 << i;\\n            int sum = 0;\\n            for(int j = 0; j < numsSize; j++){\\n                if(x & nums[j]) sum++;\\n            }\\n            \\n            if(sum % 3) res = res | x;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3715134,
                "title": "single-line-mathematical-solution-beats-100",
                "content": "# Approach\\n- Find all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)\\n- Now substract the sum of original list of nums, which gives total as 2*(number which repeats only once)\\n\\n(Note: This solution works for this particular problem but don\\'t use where it says to use constant space as sets space complexity in worst case is $$O(n)$$, Thank you)\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return ((3*sum((set(nums))))-sum(nums))//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return ((3*sum((set(nums))))-sum(nums))//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43412,
                "title": "python-bit-manipulation-with-more-general-case",
                "content": "    class Solution(object):\\n        def singleNumber(self, nums):\\n            one, two = 0, 0\\n            for x in nums:\\n                one, two, three = one ^ x, two | (one & x), two & x\\n                one, two = one & ~three, two & ~three\\n            return one\\n\\nActually, this approach can be generalized for the case that each number appears 5 times except one:\\n\\n    class Solution(object):\\n        def singleNumber(self, nums):\\n            one = two = three = four = 0\\n            for x in nums:\\n                one, two, three, four, five = one ^ x, two | (one & x), three | (two & x), four | (three & x), four & x\\n                one, two, three, four = one & ~three & ~five, two & ~three, three & ~four, four & ~five\\n            return one\\n\\nIf each number appears 5 times except that one number appears only 3 times, `return three` will be the result",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "    class Solution(object):\\n        def singleNumber(self, nums):\\n            one, two = 0, 0\\n            for x in nums:\\n                one, two, three = one ^ x, two | (one & x), two & x\\n                one, two = one & ~three, two & ~three\\n            return one\\n\\nActually, this approach can be generalized for the case that each number appears 5 times except one:\\n\\n    class Solution(object):\\n        def singleNumber(self, nums):\\n            one = two = three = four = 0\\n            for x in nums:\\n                one, two, three, four, five = one ^ x, two | (one & x), three | (two & x), four | (three & x), four & x\\n                one, two, three, four = one & ~three & ~five, two & ~three, three & ~four, four & ~five\\n            return one\\n\\nIf each number appears 5 times except that one number appears only 3 times, `return three` will be the result",
                "codeTag": "Java"
            },
            {
                "id": 3715000,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/o-CSM80MPvk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0;\\n        for(int e : nums) {\\n            ones = ((ones ^ e) & (~ twos));  \\n            twos = ((twos ^ e) & (~ ones)); \\n        }\\n        return ones;  \\n    }\\n}\\n```\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(std::vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n        for (int e : nums) {\\n            ones = ((ones ^ e) & (~twos));\\n            twos = ((twos ^ e) & (~ones));\\n        }\\n        return ones;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ones = 0\\n        twos = 0\\n        for e in nums:\\n            ones = (ones ^ e) & (~twos)\\n            twos = (twos ^ e) & (~ones)\\n        return ones\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0;\\n        for(int e : nums) {\\n            ones = ((ones ^ e) & (~ twos));  \\n            twos = ((twos ^ e) & (~ ones)); \\n        }\\n        return ones;  \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(std::vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n        for (int e : nums) {\\n            ones = ((ones ^ e) & (~twos));\\n            twos = ((twos ^ e) & (~ones));\\n        }\\n        return ones;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ones = 0\\n        twos = 0\\n        for e in nums:\\n            ones = (ones ^ e) & (~twos)\\n            twos = (twos ^ e) & (~ones)\\n        return ones\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43442,
                "title": "short-java-code-with-bit-summation-and-modulo-3",
                "content": "274ms, not quite fast, can be any faster?\\n\\nanother question, the problem should clarify that the single number only appears once (not twice)\\n\\n\\n    public class Solution {\\n        public int singleNumber(int[] A) {\\n            /*\\n            element in A is 32bit,\\n            sum corresponding bits from all elements and mod each by 3 then should left the single number\\n            */\\n            int[] sum=new int[32];\\n            int res=0;\\n            for(int i=0;i<32;i++)\\n            {\\n                for(int j=0;j<A.length;j++)\\n                {\\n                    sum[i]+=((A[j]>>>i)&1);//sum every bit of all numbers\\n                }\\n                sum[i]%=3;\\n                res+=((sum[i]&1)<<i);// recover the single number\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int singleNumber(int[] A) {\\n            /*\\n            element in A is 32bit,\\n            sum corresponding bits from all elements and mod each by 3 then should left the single number\\n            */\\n            int[] sum=new int[32];\\n            int res=0;\\n            for(int i=0;i<32;i++)\\n            {\\n                for(int j=0;j<A.length;j++)\\n                {\\n                    sum[i]+=((A[j]>>>i)&1);//sum every bit of all numbers\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 749087,
                "title": "multiple-approaches-explained-worst-to-best",
                "content": "**1. Sorting O(nlogn) time, space O(1)**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)return nums[0];\\n        sort(nums.begin(), nums.end());\\n        \\n        //edge case: when the single no is at one of any end of the cluster\\n        if(nums[0] != nums[1])return nums[0];\\n        if(nums[n-1] != nums[n-2])return nums[n-1];\\n        \\n        // when the single no is in the middle of the cluster\\n        int i = 1;\\n        while(i < n){\\n            if(nums[i] != nums[i-1]){\\n                return nums[i-1];\\n            }\\n            i += 3;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**2. Hashtable O(n) space and time**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int>m;\\n        for(int num: nums)m[num]++;\\n        for(auto i: m){\\n            if(i.second == 1)return i.first;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**3. Taking the count at each bit position, time O(n) space O(1)**\\n\\n**Approach**: Just take the sum of each ofthe 32 bit position and keep adding the sum%3 in the result. If the sum is divisible is 3, then the ith bit in the single no is 0, else 1.\\n\\nExample : Let us consider the example array {5, 5, 5, 8}. The 101, 101, 101, 1000\\n* Sum of first bits%3 = (1 + 1 + 1 + 0)%3 = 0;\\n* Sum of second bits%3 = (0 + 0 + 0 + 0)%0 = 0;\\n* Sum of third bits%3 = (1 + 1 + 1 + 0)%3 = 0;\\n* Sum of fourth bits%3 = (1)%3 = 1;\\n\\n*Hence number which appears once is 1000*\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        for(int i = 0; i < 32; ++i){\\n            int bitCount = 0;\\n            for(int num: nums){\\n                bitCount += ((num >> i)&1); // for first bit, right shift num by 0 and for 2nd bit, right shift num by 1 and so on...\\n            }\\n            if(bitCount%3){\\n                result |= (1<<i); // left shift 1 by i bit starting from 0\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n**4. Smart bit manipulation time O(n) space O(1)**\\n**Approach** : ones will contain the no appearing once, and twos will contain the no appearing twice. \\nExample : 2, 2, 5, 2\\n* 2: ones = 2, twos = 0 (ones will get 2, and twos won\\'t get 2 since ones had 2 already)\\n* 2: ones = 0, twos = 2 (ones will get 2 but ones = 2^2 = 0, hence twos will get 2)\\n* 5: ones = 5, twos = 2 (ones will get 5 and twos will not get 5 since ones had 5 already)\\n* 2: ones = 5, twos = 0 (ones won\\'t get 2, since twos already had 2. And twos will get 2 but it had already 2. Hence twos = 2^2 = 0)\\n\\n*Hence the no which appears thrice is not in any of the two. ones will have the final answer. And twos will be 0 finally. Since all the no either appears thrice or once.*\\n```\\nclass Solution {\\npublic:    \\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n         for(int num: nums){\\n             ones = (ones ^ num) & (~twos);\\n             twos = (twos ^ num) & (~ones);\\n         }\\n        return ones;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)return nums[0];\\n        sort(nums.begin(), nums.end());\\n        \\n        //edge case: when the single no is at one of any end of the cluster\\n        if(nums[0] != nums[1])return nums[0];\\n        if(nums[n-1] != nums[n-2])return nums[n-1];\\n        \\n        // when the single no is in the middle of the cluster\\n        int i = 1;\\n        while(i < n){\\n            if(nums[i] != nums[i-1]){\\n                return nums[i-1];\\n            }\\n            i += 3;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int>m;\\n        for(int num: nums)m[num]++;\\n        for(auto i: m){\\n            if(i.second == 1)return i.first;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        for(int i = 0; i < 32; ++i){\\n            int bitCount = 0;\\n            for(int num: nums){\\n                bitCount += ((num >> i)&1); // for first bit, right shift num by 0 and for 2nd bit, right shift num by 1 and so on...\\n            }\\n            if(bitCount%3){\\n                result |= (1<<i); // left shift 1 by i bit starting from 0\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n         for(int num: nums){\\n             ones = (ones ^ num) & (~twos);\\n             twos = (twos ^ num) & (~ones);\\n         }\\n        return ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548323,
                "title": "python-bit-manipulation-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n            This question can be solved using bit manipulation.\\n            If any number is occuring 3 times then the count of every set bit of that number will also be 3.\\n            For example, let\\'s say we have 5,5,5 then,\\n            Binary representation is 101,101,101.\\n            We can see that the count of 0th and 2nd bit will be 3.\\n            Now if another number comes, let\\'s say 4(100) then the count of every set bit will be:\\n                0th: 3\\n                2nd: 4\\n            \\n            So by using the above logic if we get a count of each set bit for all the numbers and take modulo of 3 for each bit then the resulting number would be our answer.\\n            Like in above example, count of each bit became 4, 0, 3 and if we take % 3 then it will become 1,0,0 and 100 is 4(our answer).\\n            \\n        \"\"\"\\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                temp = n >> i\\n                temp = temp & 1\\n                count += temp\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n            This question can be solved using bit manipulation.\\n            If any number is occuring 3 times then the count of every set bit of that number will also be 3.\\n            For example, let\\'s say we have 5,5,5 then,\\n            Binary representation is 101,101,101.\\n            We can see that the count of 0th and 2nd bit will be 3.\\n            Now if another number comes, let\\'s say 4(100) then the count of every set bit will be:\\n                0th: 3\\n                2nd: 4\\n            \\n            So by using the above logic if we get a count of each set bit for all the numbers and take modulo of 3 for each bit then the resulting number would be our answer.\\n            Like in above example, count of each bit became 4, 0, 3 and if we take % 3 then it will become 1,0,0 and 100 is 4(our answer).\\n            \\n        \"\"\"\\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                temp = n >> i\\n                temp = temp & 1\\n                count += temp\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217292,
                "title": "big-but-clear-solution-explained-counter-conditions-properly-o-n-time-o-1-space",
                "content": "**Special cases which can give runtime error are solved**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int> bits(32, 0);\\n        \\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            long long int n = abs(nums[i]);      // number can be large so to avoid overflow take long long int. Also the taken integer can be negative so to avoid ambiguity and complexity of code take absolute value of the number\\n            int j = 0;\\n            while(n)\\n            {\\n                if((n & 1) == 1)\\n                    ++bits[j];\\n                \\n                ++j;\\n                n >>= 1;\\n            }\\n        }\\n        \\n        for(int i = 0; i < bits.size(); ++i)\\n        {\\n            if((bits[i] % 3) == 0)\\n                bits[i] = 0;\\n            else\\n                bits[i] = 1;\\n        }\\n        \\n        long long int res = 0;     // result can be large so to avoid overflow take long long int\\n        \\n        for(int i = 0; i < bits.size(); ++i)\\n        {\\n            if(bits[i] == 1)\\n                res += (1 * pow(2, i));\\n            else\\n                continue;\\n        }\\n        \\n\\t\\t//since our result can be negative or positive. We have solved the problem for positive consideration. But it can be possible that our result may be present both in positive and negative form\\n\\t\\t// example: [-2,-2,1,1,4,1,4,4,-4,-2]\\n\\t\\t//So the below lines will help us to give our final result\\n        int count = 0;\\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if(res == nums[i])\\n                ++count;\\n        }\\n        \\n        return (count == 1 ? res : (-res));\\n    }\\n};\\n```\\n\\nI have tried my best to explain the things which were not explained in the other solutions properly. If you have any doubts then feel free to comment it I will try to explain it more. Also if u have find it useful then plz upvote.\\nsorry for any mistakes",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int> bits(32, 0);\\n        \\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            long long int n = abs(nums[i]);      // number can be large so to avoid overflow take long long int. Also the taken integer can be negative so to avoid ambiguity and complexity of code take absolute value of the number\\n            int j = 0;\\n            while(n)\\n            {\\n                if((n & 1) == 1)\\n                    ++bits[j];\\n                \\n                ++j;\\n                n >>= 1;\\n            }\\n        }\\n        \\n        for(int i = 0; i < bits.size(); ++i)\\n        {\\n            if((bits[i] % 3) == 0)\\n                bits[i] = 0;\\n            else\\n                bits[i] = 1;\\n        }\\n        \\n        long long int res = 0;     // result can be large so to avoid overflow take long long int\\n        \\n        for(int i = 0; i < bits.size(); ++i)\\n        {\\n            if(bits[i] == 1)\\n                res += (1 * pow(2, i));\\n            else\\n                continue;\\n        }\\n        \\n\\t\\t//since our result can be negative or positive. We have solved the problem for positive consideration. But it can be possible that our result may be present both in positive and negative form\\n\\t\\t// example: [-2,-2,1,1,4,1,4,4,-4,-2]\\n\\t\\t//So the below lines will help us to give our final result\\n        int count = 0;\\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if(res == nums[i])\\n                ++count;\\n        }\\n        \\n        return (count == 1 ? res : (-res));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205709,
                "title": "137-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe use two variables ones and twos to keep track of the bits that appear once and twice respectively. Initially, both variables are set to 0.\\n\\nFor each number in the input list, we update the variables as follows:\\n\\nones is updated by XORing it with the current number and then ANDing it with the complement of twos.\\nThis ensures that only the bits that appear once are set in ones.\\ntwos is updated by XORing it with the current number and then ANDing it with the complement of ones.\\nThis ensures that only the bits that appear twice are set in twos.\\nFinally, we return the value of ones, which represents the single number that appears once.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ones = 0\\n        twos = 0\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        return ones\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ones = 0\\n        twos = 0\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        return ones\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938486,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var a = 0\\n        var b = 0\\n        \\n        for num in nums {\\n            let newA = a & ~b & ~num + ~a & b & num\\n            let newB = ~a & b & ~num + ~a & ~b & num\\n            \\n            (a, b) = (newA, newB)\\n        }\\n        \\n        return a | b\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var a = 0\\n        var b = 0\\n        \\n        for num in nums {\\n            let newA = a & ~b & ~num + ~a & b & num\\n            let newB = ~a & b & ~num + ~a & ~b & num\\n            \\n            (a, b) = (newA, newB)\\n        }\\n        \\n        return a | b\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43334,
                "title": "python-constant-space-solution-bit-manipulation",
                "content": "```\\n    def singleNumber(self, nums):\\n        res = 0\\n        for i in xrange(32):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            rem = count % 3\\n            if i == 31 and rem:\\n                res -= 1 << 31\\n            else:\\n                res |= rem * (1 << i)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n    def singleNumber(self, nums):\\n        res = 0\\n        for i in xrange(32):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            rem = count % 3\\n            if i == 31 and rem:\\n                res -= 1 << 31\\n            else:\\n                res |= rem * (1 << i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1110333,
                "title": "3-python-solutions-with-different-approaches",
                "content": "Bit Manupulation:\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        a, b = 0, 0\\n        for x in nums:\\n            a, b = (~x&a&~b)|(x&~a&b), ~a&(x^b)\\n        return b\\n```\\nHashing:\\n```\\n    class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        for a,b in d.items():\\n            print(a,b)\\n            if b == 1:\\n                return a\\n```\\nArray Sum\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        a = sum(nums) - 3*sum(set(list(nums)))\\n        return (-a)//2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        a, b = 0, 0\\n        for x in nums:\\n            a, b = (~x&a&~b)|(x&~a&b), ~a&(x^b)\\n        return b\\n```\n```\\n    class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        for a,b in d.items():\\n            print(a,b)\\n            if b == 1:\\n                return a\\n```\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        a = sum(nums) - 3*sum(set(list(nums)))\\n        return (-a)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709864,
                "title": "python-98-9-faster-one-line-code-explain-in-details",
                "content": "\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\t# Let the numbers be x,y,z,.....\\n\\t\\t\\t# require sum should be 3x+3y+3z\\n\\t\\t\\t# original sum = 3x+3y+z\\n\\t\\t\\t# Subtract require sum from original sum\\n\\t\\t\\t# (3x+3y+3z) - (3x+3y-z) = 2z\\n\\t\\t\\t# div the ans by 2 = 2z/2 = z--> our ans\\n\\n\\t\\t\\treturn (3 * sum(set(nums)) - sum(nums)) // 2\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\t# Let the numbers be x,y,z,.....\\n\\t\\t\\t# require sum should be 3x+3y+3z\\n\\t\\t\\t# original sum = 3x+3y+z\\n\\t\\t\\t# Subtract require sum from original sum\\n\\t\\t\\t# (3x+3y+3z) - (3x+3y-z) = 2z\\n\\t\\t\\t# div the ans by 2 = 2z/2 = z--> our ans\\n\\n\\t\\t\\treturn (3 * sum(set(nums)) - sum(nums)) // 2\\n",
                "codeTag": "Java"
            },
            {
                "id": 43387,
                "title": "java-o-n-time-with-o-1-space-by-bit-manipulation",
                "content": "    public int singleNumber(int[] nums) {\\n        int[] digits = new int[32];\\n        for(int i=0; i<nums.length; i++){\\n            int mask = 1;\\n            for(int j=31; j>=0; j--){\\n                if((mask & nums[i])!=0)\\n                    digits[j] ++;\\n                mask <<= 1;\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0; i<32; i++){\\n            if(digits[i]%3==1)\\n                res += 1;\\n            if(i==31)\\n                continue;\\n            res <<= 1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int singleNumber(int[] nums) {\\n        int[] digits = new int[32];\\n        for(int i=0; i<nums.length; i++){\\n            int mask = 1;\\n            for(int j=31; j>=0; j--){\\n                if((mask & nums[i])!=0)\\n                    digits[j] ++;\\n                mask <<= 1;\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0; i<32; i++){\\n            if(digits[i]%3==1)\\n                res += 1;\\n            if(i==31)\\n                continue;\\n            res <<= 1;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3091160,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int bit=1<<i;\\n            int c=0;\\n            for(int j:nums)\\n            {\\n                if(j&bit)\\n                c++;\\n            }\\n            if(c%3)\\n            ans|=bit;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int bit=1<<i;\\n            int c=0;\\n            for(int j:nums)\\n            {\\n                if(j&bit)\\n                c++;\\n            }\\n            if(c%3)\\n            ans|=bit;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755642,
                "title": "explanation-of-bit-manipulation-solution-as-easy-as-pie",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int o = 0, t = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int x = nums[i];\\n            // int oo = ((~t) & o & (~x)) | ((~t) & (~o) & x); // position of this statement doesn\\'t matter\\n            int tt = (t & (~o) & (~x)) | ((~t) & o & x);\\n            int oo = ((~t) & o & (~x)) | ((~t) & (~o) & x);\\n            \\n            o = oo;\\n            t = tt;\\n        }\\n        return o;  \\n    }\\n}\\n```\\n\\nHey we have done a similar problem [All repeating twice except one](https://leetcode.com/problems/single-number/)\\nLet\\u2019s look at that first to draw some insights\\n\\nLet\\u2019s consider the following scenario\\n```\\ni           arr[i]                          Implication\\n0            3               I have seen 3 for the first time\\n1            3               I have seen 3 for the second time\\n                             => no more 3 to be seen again \\n                             => don\\u2019t worry about 3, no need to remember ever seeing it\\n                             => How can we forget about something when it has appeared twice ( or even number of times) ?\\n                             => So the transition of states is something like 0 -> 1 -> again 0 -> again 1 and so on\\n                             => Isn\\u2019t this the behaviour of XOR ? yes\\n```\\nLet\\u2019s try  XOR\\n\\nLet X = 0 => I have not seen any element yet\\n```\\ni         arr[i]           Binary form of arr[i]                  XORresult = X ^ arr[i]\\n0          3                     011                                        011                             ( 0 ^ N = N)\\n1          3                     011                                        000                             ( N ^ N = 0)\\n2          4                     100                                        100 \\n```\\nFinal XORresult -> 100 which is 4 which is the element which appeared only once\\nThus our train of thoughts seem correct\\n\\n\\nSo now let\\u2019s try thinking on the same lines for the problem [All repeating thrice except once](https://leetcode.com/problems/single-number-ii/)\\n\\nThinking on the same lines, we\\u2019ll use XOR for this problem too to transition from one state to another \\n```\\ni                    arr[i]                     Implication\\n0                      3               I have seen 3 for the first time\\n1                      3               I have seen 3 for the second time\\n2                      3               I have seen 3 for the third time\\n                                       => I don\\u2019t want to remember ever seeing it\\n                                       => So the transition of states is something like 0 -> 1 -> 2 -> again 0 and so on\\n```\\n\\nIn the previous problem only two states were involved (state 0, state 1) so we needed only one bit/flag ( XORresult )  to track the transition of states ( as only one bit is required to express 1 in binary)\\n\\nBut in this problem three states (state 0, state 1, state 2) are involved and since 2 bits are required to express 2 in binary, so we need two flags this time. Let\\u2019s call them  \\u201Co\\u201D, \\u201Ct\\u201D.\\n \\u201Cto\\u201D together tell us about the state.\\n\\nTo be noted : ^ ( XOR) is a bitwise operation\\nXOR rule -> low when both inputs are alike else high\\n\\nSo let\\u2019s try to understand what might be happening at the bit level\\n\\nCase 1\\n```\\nith bit of Incoming no. x :                           0 \\n\\nith bit of Current t                                  1  \\nith bit of Current o                                  0    // note: \\u201Cto\\u201D can be either of 00,01,10 i.e state 0,1,2\\n\\nith bit of New t after t ^ x                          1 \\nith bit of New o after o ^ x                          0\\n```\\nRemarks: No change in t, o cuz 0 ^ 0 = 0 , 1 ^ 0 = 1\\n\\n\\nCase 2\\n```\\nith bit of Incoming no. x :                           1\\n\\nith bit of Current t                                  0      \\nith bit of Current o                                  1          \\n\\nith bit of New t after t ^ x                          1 \\nith bit of New o after o ^ x                          0\\n```\\nRemarks: \\u201Cto\\u201D changed from 01 to 10 i.e state 1 to state 2\\n\\n\\nSince XOR is performed for each bit independently, truth table can be prepared even by seeing state transition of just a single bit\\n\\n```\\n  Col 0                Col 1             Col 2                     Col 3                          Col 4\\nith bit of           ith bit of        ith bit of             ith bit of new                 ith bit of new                     State change\\n    t                    o                  x                        t                              o                              of \\u201Cto\\u201D\\n\\n\\n    0                    0                  0                        0                              0                              No change\\n    0                    1                  0                        0                              1                              No change\\n    1                    0                  0                        1                              0                              No change\\n    0                    0                  1                        0                              1                              00 -> 01\\n    0                    1                  1                        1                              0                              01 -> 10\\n    1                    0                  1                        0                              0                              10 -> 00\\n```\\nLooking at columns 0,1,2,3\\nt = (t & (~o) & (~x)) | ((~t) & o & x)\\n\\nLooking at columns 0,1,2,4\\no = ((~t) & o & (~x)) | ((~t) & (~o) & x)\\n\\nMaybe the above expressions can be simplified. But why do that? Interview duration is limited right?\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int o = 0, t = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int x = nums[i];\\n            // int oo = ((~t) & o & (~x)) | ((~t) & (~o) & x); // position of this statement doesn\\'t matter\\n            int tt = (t & (~o) & (~x)) | ((~t) & o & x);\\n            int oo = ((~t) & o & (~x)) | ((~t) & (~o) & x);\\n            \\n            o = oo;\\n            t = tt;\\n        }\\n        return o;  \\n    }\\n}\\n```\n```\\ni           arr[i]                          Implication\\n0            3               I have seen 3 for the first time\\n1            3               I have seen 3 for the second time\\n                             => no more 3 to be seen again \\n                             => don\\u2019t worry about 3, no need to remember ever seeing it\\n                             => How can we forget about something when it has appeared twice ( or even number of times) ?\\n                             => So the transition of states is something like 0 -> 1 -> again 0 -> again 1 and so on\\n                             => Isn\\u2019t this the behaviour of XOR ? yes\\n```\n```\\ni         arr[i]           Binary form of arr[i]                  XORresult = X ^ arr[i]\\n0          3                     011                                        011                             ( 0 ^ N = N)\\n1          3                     011                                        000                             ( N ^ N = 0)\\n2          4                     100                                        100 \\n```\n```\\ni                    arr[i]                     Implication\\n0                      3               I have seen 3 for the first time\\n1                      3               I have seen 3 for the second time\\n2                      3               I have seen 3 for the third time\\n                                       => I don\\u2019t want to remember ever seeing it\\n                                       => So the transition of states is something like 0 -> 1 -> 2 -> again 0 and so on\\n```\n```\\nith bit of Incoming no. x :                           0 \\n\\nith bit of Current t                                  1  \\nith bit of Current o                                  0    // note: \\u201Cto\\u201D can be either of 00,01,10 i.e state 0,1,2\\n\\nith bit of New t after t ^ x                          1 \\nith bit of New o after o ^ x                          0\\n```\n```\\nith bit of Incoming no. x :                           1\\n\\nith bit of Current t                                  0      \\nith bit of Current o                                  1          \\n\\nith bit of New t after t ^ x                          1 \\nith bit of New o after o ^ x                          0\\n```\n```\\n  Col 0                Col 1             Col 2                     Col 3                          Col 4\\nith bit of           ith bit of        ith bit of             ith bit of new                 ith bit of new                     State change\\n    t                    o                  x                        t                              o                              of \\u201Cto\\u201D\\n\\n\\n    0                    0                  0                        0                              0                              No change\\n    0                    1                  0                        0                              1                              No change\\n    1                    0                  0                        1                              0                              No change\\n    0                    0                  1                        0                              1                              00 -> 01\\n    0                    1                  1                        1                              0                              01 -> 10\\n    1                    0                  1                        0                              0                              10 -> 00\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715332,
                "title": "c-beginner-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=31;i>=0;i--){\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j]>>i) & 1){\\n                    count++;\\n                }\\n            }\\n            if(count%3){\\n                ans += (1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/b21242bd-f420-41e4-a889-7ad56df93f59_1688443496.2088463.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=31;i>=0;i--){\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j]>>i) & 1){\\n                    count++;\\n                }\\n            }\\n            if(count%3){\\n                ans += (1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715267,
                "title": "easy-c-code-highly-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(32*N)~=O(N) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<32; i++){     //0(32*N)\\n            int t=0;\\n            for(int j=0; j<nums.size(); j++){\\n                t+=(nums[j]&1);\\n                nums[j]>>=1;\\n            }\\n            ans+=((t%3)<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<32; i++){     //0(32*N)\\n            int t=0;\\n            for(int j=0; j<nums.size(); j++){\\n                t+=(nums[j]&1);\\n                nums[j]>>=1;\\n            }\\n            ans+=((t%3)<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714943,
                "title": "bitwise-operations-python-js-solution",
                "content": "Hello **Tenno leetcoders**, \\n\\nWe are given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return a solution with a linear runtime complexity and use only constant extra space.\\n\\n### Explanation\\n\\nThe problem requires finding the single element that appears exactly once in the nums array, where all other elements appear three times.\\n\\nSince we need constant space and linear time, we can rely on bitwise XOR `^`, AND `&`, OR `|`, NOT `~`\\n\\n#### XOR operation\\n\\n- The bitwise XOR operation returns 1 if the corresponding bits are different and 0 if they are the same\\n\\n- The bitwise XOR operation will be used to update our ones variable as it helps keep track of the bits that have appeared once\\n\\n- When we perform `ones ^= num`, the XOR operation toggles the bits in `ones` that are in `num` to ensure that the ones variable stores the bits that have appeared only once across the numbers encountered so far \\n\\n\\n#### AND operation\\n\\n- The bitwise AND operation returns 1 only if both corresponding bits are 1; otherwise, it returns 0.\\n\\n- The bitwise AND operation is used to update the twos variable by performing `twos |= ones & num`. This represents the operation which adds the bits that are set in both `ones` and `num` to `twos` to ensure that twos keep track of the bits that have appeared twice\\n\\n- Also the AND operation is used to clear the bits that have appeared three times in both `ones` and `twos`. By performing,\\n`ones &= ~threes` and `twos &= ~threes`, it clears the bits that are set in `threes` from both `ones` and `twos`\\n\\n\\n####  OR operation\\n\\n- The bitwise OR operation returns 1 if at least one of the corresponding bits is 1; otherwise, it returns 0.\\n\\n- the bitwise OR operation is used to update the twos variable. By perform `twos |= ones & num`, the operation combines the bits that are set in both `ones` and `num`, adding them to `twos` to ensure that twos accumulates the bits that have appeared twice\\n\\n\\n#### NOT operation\\n\\n- The bitwise NOT operation flips the bits, changing 0s to 1s and 1s to 0s.\\n\\n- The bitwise NOT operation is used to clear the bits that have appeared three times.\\n\\n- Our threes temporary variable is used to clear the bits that have appeared three times between `ones` and `twos` using the AND operator. These two operations find the bits that are set in both `ones` and `twos`, indicating the bits that have appeared three times\\n\\n- By performing `ones &= ~threes` and `twos &= ~threes`, the NOT operation is applied to `threes` to help clear the bits that are set in `threes` from both `ones` and `twos`, which help remove the bits that have appeared three times\\n\\n\\n#### Solution\\n\\n- Initialize two variables, ones and twos and set it to `0`. This will help represent and keep track of bits that have appeared once or twice\\n\\n- Iterate through each number `num` in the nums array.\\n\\n    - Update twos variable by performing a bitwise OR operation between the twos and the bits that are set in both ones and the current number as it will help accumulate the bits that have appeared twice\\n        \\n    - Update ones variable by performing a bitwise XOR operations between ones and the current number as it toggles the bits in ones that are set in num to help keep track of bits that have appeared once\\n        \\n        \\n    - At this point, both ones and twos may contain some bits that have appeared three times. We need to clear these bits.\\n        \\n        \\n    - To help clear the bits which appeared three times, we use a temporary variable threes and set it as bitwise AND of ones and twos as it helps identifies the bits that are set in both ones and twos, indicating the bits have appeared three times\\n        \\n        \\n    - To clear the bits, we perform bitwise NOT operation on threes and also apply bitwise AND operation with ones and two to help clear the bits that have appeared three times. \\n        \\n\\n- At the end of the loops, `ones` will contain the bits of the single element that appeared exactly ones\\n\\n\\n\\n# Code\\n\\n**Python**\\n```\\n  def singleNumber(self, nums: List[int]) -> int:\\n\\n        ones = 0  \\n        twos = 0  \\n\\n        for num in nums:\\n\\n            twos |= ones & num\\n            ones ^= num\\n            \\n            threes = ones & twos\\n            ones &= ~threes\\n            twos &= ~threes\\n\\n        return ones\\n```\\n\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(nums) {\\n\\n    let ones = 0\\n    let twos = 0\\n\\n    for(let num of nums){\\n        twos |= ones & num\\n        ones ^= num\\n\\n        threes = ones & twos\\n        ones &= ~threes\\n        twos &= ~threes\\n    }\\n    return ones\\n};\\n```\\n### Time Complexity: O(n)\\n### Space Complexity: O(1)\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n  def singleNumber(self, nums: List[int]) -> int:\\n\\n        ones = 0  \\n        twos = 0  \\n\\n        for num in nums:\\n\\n            twos |= ones & num\\n            ones ^= num\\n            \\n            threes = ones & twos\\n            ones &= ~threes\\n            twos &= ~threes\\n\\n        return ones\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(nums) {\\n\\n    let ones = 0\\n    let twos = 0\\n\\n    for(let num of nums){\\n        twos |= ones & num\\n        ones ^= num\\n\\n        threes = ones & twos\\n        ones &= ~threes\\n        twos &= ~threes\\n    }\\n    return ones\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3714938,
                "title": "c-more-intuitive-bit-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are more sophiscated bit manipuation solutions out there; however, those solution were not intuitive for me. This solution takes more time and more space, but it is more intuitive and reasonable to come up with during an interview.\\n\\nIntuition is that we remove all numbers that repeat $3$ times. However, there are too man numbers thus we will remove bits that repeat $3$ times. \\n\\nThere are only $32$ bits in `int`, thus we would only need array of size $32$.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFor each number $x$ in `nums`, we we check the $i$th bit, and incerement `arr[i]` if the bit is set to 1.  \\n\\nAfter the scan of `nums`, we know the number $1$\\'s in $i$th bits in `nums`. If `arr[i]` is divisible by 3, then we know the single number\\'s $i$th bit is 0. If `arr[i]` is not divisible by 3, then we know the single number\\'s $i$th bit is 1. We scan $arr$ to figure out the single number.\\n\\nHere\\'s the example with `nums` = $[2, 2, 5, 2]$. For similicity we will consider $4$ bits instead of $32$.\\n\\nNote that $2$\\'s bit is $0 0 10$, whereas $5$\\'s bit is $0101$.\\n\\nAfter scanning the first number ($2$), the array has value $[0,0,1,0]$.\\nAfter scanning the second number ($2$), the array has value $[0,0,2,0]$.\\nSimilarly scanning $5$ gives $[0,1,2,1]$, Then scanning $2$ gives $[0,1,3,1]$.\\n\\n $2$ $=$ $0$ $0$ $1$ $0$\\n $2$ $=$ $0$ $0$ $1$ $0$\\n $5$ $=$ $0$ $1$ $0$ $1$\\n $2$ $=$ $0$ $0$ $1$ $0$\\n $arr.$ $0$ $1$ $3$ $1$ \\n\\nSince `arr[0]` and `arr[2]` are divisible by 3 and `arr[1]` and `arr[3]` are not divisible by 3, we get result of $0101$ which is $5$ as we expected.\\n\\n# Complexity\\n- Time complexity: $O(N)$. We scan the input array once $O(N)$, then we scan `arr` which has size 32 $O(1)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$, our array stores 32 integers, therefore it is constant. However, if the memroy is a bigger concern, you can reduce size of the array by using uint8_t or even smaller struct, we just have to maintain number of bits mod 3.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        uint32_t arr[32] = {0};\\n\\n        for (int x : nums) {\\n            for (int ii = 0; ii < 32; ++ii) {\\n                arr[ii] += x&1;\\n                x >>= 1;\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int ii = 31; ii >= 0; --ii) {\\n            res <<= 1;\\n            if (arr[ii] % 3 != 0) {\\n                res |= 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\n# Comments\\nIf you\\'re interviewing for a place where bit manipulation are not important, the interviewee would not expect you to come up with complicated bit manipulation solution. Therefore, coming with simple solution like this would give you good enough impression. Also if you can mention how we can improve space complexty from here, the interview would go smoothly.\\n\\nMy explanation is not perfect, but hope this gives people different ways to think about this problem.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        uint32_t arr[32] = {0};\\n\\n        for (int x : nums) {\\n            for (int ii = 0; ii < 32; ++ii) {\\n                arr[ii] += x&1;\\n                x >>= 1;\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int ii = 31; ii >= 0; --ii) {\\n            res <<= 1;\\n            if (arr[ii] % 3 != 0) {\\n                res |= 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396124,
                "title": "99-5-faster-python-one-liner-very-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/8c211ead-22e1-4bdc-8a7f-d2cc3b46ee4c_1659935676.8670282.png)\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(list(set(nums))*3)-sum(nums))//2\\n        \\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/8c211ead-22e1-4bdc-8a7f-d2cc3b46ee4c_1659935676.8670282.png)\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(list(set(nums))*3)-sum(nums))//2\\n        \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 709160,
                "title": "java-clean-code-bits-manipulation-approach-o-n-time-complexity-0-ms-time-100-faster",
                "content": "```\\nclass Solution {\\n\\tpublic int singleNumber (int[] nums) {\\n\\t\\t\\n\\t\\tint ones = 0;\\n\\t\\tint twos = 0;\\n\\t\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tones = (ones ^ num) & ~twos;\\n\\t\\t\\ttwos = (twos ^ num) & ~ones;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ones;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic int singleNumber (int[] nums) {\\n\\t\\t\\n\\t\\tint ones = 0;\\n\\t\\tint twos = 0;\\n\\t\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tones = (ones ^ num) & ~twos;\\n\\t\\t\\ttwos = (twos ^ num) & ~ones;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ones;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558210,
                "title": "java-easy-to-understand-o-1-space",
                "content": "First, calculate the number of 1s in each bit about each number in the input array.\\nif in one bit, the number of 1s can be divided by 3, then ths bit of result will be 0. Otherwise, it will be 1.\\nE.g. input: [2,2,3,2]\\n\\t  (2): 1 0\\n\\t  (2): 1 0\\n\\t  (3): 1 1\\n\\t  (2): 1 0\\ncount:  4 1\\nWe can see that the number of 1s in these two bits cannot be devided by 3. So, the result will be 3 (11).\\n```\\n\\tpublic int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i = 0; i < 32; i++) {// because the number of bits in Integer can be up to 32\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                if((nums[j] & (1 << i)) != 0)\\n                    count++;\\n            }\\n            result = result | ((count % 3) << i);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i = 0; i < 32; i++) {// because the number of bits in Integer can be up to 32\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                if((nums[j] & (1 << i)) != 0)\\n                    count++;\\n            }\\n            result = result | ((count % 3) << i);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 300081,
                "title": "java-clean-bitwise-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] arr) {\\n        int ones = 0;\\n        int twos = 0;\\n        for (int value : arr) {\\n            ones = (ones ^ value) & ~twos;\\n            twos = (twos ^ value) & ~ones;\\n        }\\n        return ones;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] arr) {\\n        int ones = 0;\\n        int twos = 0;\\n        for (int value : arr) {\\n            ones = (ones ^ value) & ~twos;\\n            twos = (twos ^ value) & ~ones;\\n        }\\n        return ones;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43424,
                "title": "another-bitwise-operation-method-for-single-numbers-with-detailed-explanation",
                "content": "I think my solution is easier to understand.\\n\\nFirst, here is my code for Single Number II\\n\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0 , threes = 0;\\n        for(int x:nums){\\n            threes = twos&x;\\n            twos = (ones&x|twos) & (~threes);\\n            ones = (ones|x)&(~threes);\\n        }\\n        return ones;\\n    }\\n\\n\\nRun a loop for all elements in array. At the end of every iteration, maintain following three values.\\n\\nthrees: The bits that have appeared 3st time or 6th time or 9th time .. etc  [times % 3 == 0 && times > 1].\\n\\ntwos: The bits that have appeared 2nd time or 5th time or 8th time .. etc.   [times % 3 >= 2 && times%3 != 0, here so times%3 == 2]\\n\\nones: The bits that have appeared 1nd/2nd time or 4th/5th time or 7th/8th time .. etc.  [times %3 >=1 && time %3 != 0, here (times %3 ==1 or times %3 == 2)]\\n\\neach iteration, when x comes\\n\\ncause pre twos is (times%3 == 2), then now threes = twos&x;\\n\\nto calculate twos, first we get the bits satify times % 3 >= 2 , it's  (ones&x|twos), then get rid of the bits that  times%3 == 2 namely threes, then twos = (ones&x|twos) & (~threes);\\n\\nto calculate ones, first we get the bits satify times % 3 >= 1, it may come from pre ones or new comer x, so it's (ones|x) , also we need to get rid of the bits that times%3 == 2 namely threes, then ones =  (ones|x)&(~threes);\\n\\nsorry for my English.\\n\\n\\n===============================================================================\\n\\nfor this problem,\\n\\nStatement of our problem: \"Given an array of integers, every element appears k (k >1) times except for one, which appears p times(p>=1, p % k != 0). Find that single one.\"\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ks = 0, k_1s = 0 ... ps=0, ... ones = 0;\\n        for(int x:nums){\\n            ks = k_1s&x;\\n            k_1s = (k_2s&x|k_1s) & (~ks);\\n            k_2s = (k_3s&x|k_2s) & (~ks);\\n            .......\\n            twos = (ones&x|twos) & (~ks);\\n            ones = (ones|x)&(~ks);\\n        }\\n        return ps;\\n    }",
                "solutionTags": [],
                "code": "I think my solution is easier to understand.\\n\\nFirst, here is my code for Single Number II\\n\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0 , threes = 0;\\n        for(int x:nums){\\n            threes = twos&x;\\n            twos = (ones&x|twos) & (~threes);\\n            ones = (ones|x)&(~threes);\\n        }\\n        return ones;\\n    }\\n\\n\\nRun a loop for all elements in array. At the end of every iteration, maintain following three values.\\n\\nthrees: The bits that have appeared 3st time or 6th time or 9th time .. etc  [times % 3 == 0 && times > 1].\\n\\ntwos: The bits that have appeared 2nd time or 5th time or 8th time .. etc.   [times % 3 >= 2 && times%3 != 0, here so times%3 == 2]\\n\\nones: The bits that have appeared 1nd/2nd time or 4th/5th time or 7th/8th time .. etc.  [times %3 >=1 && time %3 != 0, here (times %3 ==1 or times %3 == 2)]\\n\\neach iteration, when x comes\\n\\ncause pre twos is (times%3 == 2), then now threes = twos&x;\\n\\nto calculate twos, first we get the bits satify times % 3 >= 2 , it's  (ones&x|twos), then get rid of the bits that  times%3 == 2 namely threes, then twos = (ones&x|twos) & (~threes);\\n\\nto calculate ones, first we get the bits satify times % 3 >= 1, it may come from pre ones or new comer x, so it's (ones|x) , also we need to get rid of the bits that times%3 == 2 namely threes, then ones =  (ones|x)&(~threes);\\n\\nsorry for my English.\\n\\n\\n===============================================================================\\n\\nfor this problem,\\n\\nStatement of our problem: \"Given an array of integers, every element appears k (k >1) times except for one, which appears p times(p>=1, p % k != 0). Find that single one.\"\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ks = 0, k_1s = 0 ... ps=0, ... ones = 0;\\n        for(int x:nums){\\n            ks = k_1s&x;\\n            k_1s = (k_2s&x|k_1s) & (~ks);\\n            k_2s = (k_3s&x|k_2s) & (~ks);\\n            .......\\n            twos = (ones&x|twos) & (~ks);\\n            ones = (ones|x)&(~ks);\\n        }\\n        return ps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43467,
                "title": "general-solution-constant-space",
                "content": "    class Solution {   \\n    public:\\n    int singleNumber(int A[], int n) {\\n        int sum = 0;\\n\\t\\tint result = 0;\\n\\t\\tint x = 0;\\n        int mod = 3;\\n        for(int i = 0; i < 32 ; i++){\\n\\t\\t\\tsum = 0;\\n            x = (1 << i);\\n            for(int j = 0; j < n; j++){\\n            \\tif((A[j] & x)){\\n            \\t\\tsum++;\\n            \\t}\\n            }\\n            if((sum % mod)){\\n            \\tresult |= x;\\n            }\\n        }\\n        return result;\\n      }\\n    };\\n\\nWe can sum the bits in same positions for all the numbers and take modulo 3. The bits for which sum is not multiple of 3, are the bits of number which does not occur 3 times.\\n\\nExample array {5, 5, 5, 8}.\\n\\n5 = 0101, 5 = 0101, 5 = 0101, 8 = 1000\\n\\nSum of first bits%3 = (1 + 1 + 1 + 0)%3 = 0;\\n\\nSum of second bits%3 = (0 + 0 + 0 + 0)%3 = 0;\\n\\nSum of third bits%3 = (1 + 1 + 1 + 0)%3 = 0;\\n\\nSum of fourth bits%3 = (1)%3 = 1;\\n\\nHence number which appears once is 1000\\nWe can use that method for any number of occurrences. We just need to modify the mod from 3 to anything we want.",
                "solutionTags": [],
                "code": "class Solution {   \\n    public:\\n    int singleNumber(int A[], int n) {\\n        int sum = 0;\\n\\t\\tint result = 0;\\n\\t\\tint x = 0;\\n        int mod = 3;\\n        for(int i = 0; i < 32 ; i++){\\n\\t\\t\\tsum = 0;\\n            x = (1 << i);\\n            for(int j = 0; j < n; j++){\\n            \\tif((A[j] & x)){\\n            \\t\\tsum++;\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2593094,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        long long int ans = 0, c=0;\\n\\t\\t//for every position, find out the number of set bits in the array for that particular position\\n        for(int i=31;i>=0;i--){\\n            c=0;\\n            for(int j=0;j<nums.size();j++){\\n                int temp = abs(nums[j]); //to handle negative\\n\\t\\t\\t\\t//if the bit is set increase the count\\n                if(temp & (1<<i)) c++; \\n            }   \\n\\t\\t\\t// if the count is divisible by 3 it means that the bit of our answer at that position is 0\\n\\t\\t\\t// else if the count is not divisible by 3 it means that the bit of our answer at that position is 1\\n\\t\\t\\t// whenever the bit is set we just add that number to the ans\\n            if(c%3!=0) ans+=(1<<i);   \\n        }\\n\\t\\t\\n\\t\\t//this code is to handle negative occurance of the elements \\n\\t\\t//if the abs of negative element occurs in the array\\n        c=0;\\n        for(auto i:nums) if(i==ans)c++;  \\n        if(c==1) return ans;\\n        return -ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        long long int ans = 0, c=0;\\n\\t\\t//for every position, find out the number of set bits in the array for that particular position\\n        for(int i=31;i>=0;i--){\\n            c=0;\\n            for(int j=0;j<nums.size();j++){\\n                int temp = abs(nums[j]); //to handle negative\\n\\t\\t\\t\\t//if the bit is set increase the count\\n                if(temp & (1<<i)) c++; \\n            }   \\n\\t\\t\\t// if the count is divisible by 3 it means that the bit of our answer at that position is 0\\n\\t\\t\\t// else if the count is not divisible by 3 it means that the bit of our answer at that position is 1\\n\\t\\t\\t// whenever the bit is set we just add that number to the ans\\n            if(c%3!=0) ans+=(1<<i);   \\n        }\\n\\t\\t\\n\\t\\t//this code is to handle negative occurance of the elements \\n\\t\\t//if the abs of negative element occurs in the array\\n        c=0;\\n        for(auto i:nums) if(i==ans)c++;  \\n        if(c==1) return ans;\\n        return -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600128,
                "title": "i-was-confused-how-using-2-variables-is-being-used-here-is-my-explanation-for-both-the-approaches",
                "content": "First of all everyone who knows about basic bitmanipulation could easily come up with solution like counting  and storing count of each bits int array[32] (\"let it be called bit array). in the end we know if a no has appeared 3 times then its each bit must have contributed 3 times in bit array.\\nand then simple bit[i]%3 will tell us uniqe bits which has occured only ones.\\n\\nbit array for sample TC : [2,2,3,2] is [ 0 , 3 , 1 , 0 ,0 ,0 . . . . . .rest all zeros ]\\nafter mod array becomes [0 , 0 , 1 , 0, 0 , . . . . rest all zeros ]\\n\\nso we know that 3rd bit contributes to answer and simple  \" ans | = (bit[i]<<i)  \" will make answer\\'s 3rd bit to 1, and we proceed with other bits which adds to answer\\nhere is **1st approach** code\\n```\\n int singleNumber(vector<int>& nums) {\\n      \\n        int bit[32]={};        \\n        for(int i=0 ; i<32 ; i++)\\n        {\\n            for(auto num : nums)\\n            {\\n                bit[i] += (num>>i)&1;\\n                bit[i] %= 3;\\n            }\\n        }\\n        int res = 0;\\n        \\n        for(int i=0 ; i<32 ; i++)            res |= (bit[i]<<i);\\n       \\n        return res;\\n    }\\n```\\n**Approach 2 : (best and difficult to understand at first )**\\nwe will use 2 variables let it be called \"ones\" and \"twos\" \\nthis is how will proceed \\n\\n* First time number appear : save it in \"ones\"\\n* Second time :  clear \"ones\" but save it in \"twos\" for later check\\n* Third time : try to save in \"ones\" but value saved in \"twos\" clear it.\\n\\nnow we know that a simple Xor \\'^\\' can be used to save the no no set \\nand not \\'~\\' can be used to flip all bits , this NOT operator will be used for \"Clearing\" as stated above.\\n```\\nint singleNumber(vector<int>& nums) {\\n      \\n        int ones = 0;\\n        int twos = 0;\\n        \\n        for(auto i:nums)\\n        {\\n            ones = (ones^i);               // adding num to set \"ones\" if not present already\\n            ones = ones & (~twos);         // removing num if it was present in set \"twos\" ( NOT flips all bits , the  by using AND operator no is being removed\\n            twos = (twos^i);               // similarly adding to second \\n            twos = twos & (~ones);\\n        }\\n        return ones;\\n```\\nnumber that appears a first time will be in set \"ones\" so it will not be added to \"twos\". Any number appearing a second time would be removed from set \"ones\" in the previous step and will now be added to set \"twos\". Lastly, any number appearing a third time will simply be removed from the set \"twos\" and will no longer exist in either set.\\n\\nFinally, once we are done iterating over the entire list, set \"twos\" would be empty and set \"ones\" will contain the only number that appears once.\\nthis is what i understand after reading others explanation and reading more about bit manipulation thanks for reading.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n int singleNumber(vector<int>& nums) {\\n      \\n        int bit[32]={};        \\n        for(int i=0 ; i<32 ; i++)\\n        {\\n            for(auto num : nums)\\n            {\\n                bit[i] += (num>>i)&1;\\n                bit[i] %= 3;\\n            }\\n        }\\n        int res = 0;\\n        \\n        for(int i=0 ; i<32 ; i++)            res |= (bit[i]<<i);\\n       \\n        return res;\\n    }\\n```\n```\\nint singleNumber(vector<int>& nums) {\\n      \\n        int ones = 0;\\n        int twos = 0;\\n        \\n        for(auto i:nums)\\n        {\\n            ones = (ones^i);               // adding num to set \"ones\" if not present already\\n            ones = ones & (~twos);         // removing num if it was present in set \"twos\" ( NOT flips all bits , the  by using AND operator no is being removed\\n            twos = (twos^i);               // similarly adding to second \\n            twos = twos & (~ones);\\n        }\\n        return ones;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 538917,
                "title": "python-one-line-solution-beats-97-64",
                "content": "make use of the condition that same number repeats three times.\\n```\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(set(nums))*3 - sum(nums)) // 2\\n",
                "solutionTags": [],
                "code": "make use of the condition that same number repeats three times.\\n```\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(set(nums))*3 - sum(nums)) // 2\\n",
                "codeTag": "Python3"
            },
            {
                "id": 501465,
                "title": "java-1ms-solution-with-full-explanation-o-n-time",
                "content": "The idea is to use counts of 1s set in the binary representation of numbers in given array. Let\\'s start with example [2,5,3,2,3,5,2,3,8,5] whose binary reprsenations are as below:\\n\\n2 -> 0010\\n5 -> 0101\\n3 -> 0011\\n2 -> 0010\\n3 -> 0011\\n5 -> 0101\\n2 -> 0010\\n3 -> 0011\\n8 -> 1000\\n5 -> 0101\\n________________\\nNo. of bits set according to position are:  1366\\n(For example, total number of 1s which are set in the right most position in the numbers of the given array are (Least significant bit) are 6, \\ntotal number of 1s which are set in left most position in the numbers of the given array are (Most Significant Bit) are 1 - Only in 8 which is represented as <1000>)\\n\\n**Here is the idea:** All the numbers which appear *thrice*, will have number of 1s in the multiple of 3s in their respective position. For example, [2,2,2] is the array, then the no. of bits set in the respective positions are [030]. As you can see, there are *3* 1s set in position-1. Now, to solve the problem we have to cancel these *triplets*. So, let\\'s take modulo 3 in the number of set bits. \\n\\nComing back to our example, [1366] will become [1000] if modulo 3 is taken for each bit-count in respective position. And, as you can see 1000, in binary, represents 8 in decimal, which is the answer. \\n\\n```\\npublic int singleNumber(int[] nums) {\\n\\tint n = nums.length;\\n\\tint[] counts = new int[32]; // because int in Java has 32 bits\\n\\n\\tfor (int num : nums) {\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tcounts[i] += num & 1;\\n\\t\\t\\tnum >>= 1;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\tfor (int i = 0; i < 32; i++) {\\n\\t\\tres += (counts[i] % 3) << i;\\n\\t}\\n\\n\\treturn res;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n\\tint n = nums.length;\\n\\tint[] counts = new int[32]; // because int in Java has 32 bits\\n\\n\\tfor (int num : nums) {\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tcounts[i] += num & 1;\\n\\t\\t\\tnum >>= 1;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\tfor (int i = 0; i < 32; i++) {\\n\\t\\tres += (counts[i] % 3) << i;\\n\\t}\\n\\n\\treturn res;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3715772,
                "title": "go-xor-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 GO XOR \\uD83D\\uDD25 || Simple Fast and Easy || with Explanation \\uD83D\\uDE08\\n\\n\\n#### Algorithm Explanation\\nThe given algorithm is used to find a single number in a list of integers where all other numbers appear twice except for the single number. It uses bitwise operations to achieve this.\\n\\nThe algorithm maintains two variables, `ones` and `twos`, to keep track of the occurrences of the numbers in the list. The `ones` variable represents the bits that have appeared once, while the `twos` variable represents the bits that have appeared twice.\\n\\nThe algorithm iterates through the list of numbers. For each number, it performs bitwise operations to update the `ones` and `twos` variables. The specific operations used are XOR (^) and bitwise negation (~).\\n\\nAt the end of the iteration, the value of `ones` will represent the single number that appeared only once in the list.\\n\\n#### Space Complexity\\n\\nThe algorithm uses a constant amount of extra space. It only requires two integer variables (`ones` and `twos`) to keep track of the bit occurrences. Therefore, the space complexity is O(1).\\n\\n#### Time Complexity\\n\\nThe algorithm iterates through the entire list of numbers once, performing constant time operations for each number. Thus, the time complexity is O(n), where n is the length of the input list.\\n\\nThe algorithm\\'s time complexity is linear, making it an efficient solution for finding the single number in the given context.\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n\\tvar ones int = 0\\n\\tvar twos int = 0\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tvar number int = nums[i]\\n\\t\\tones ^= (number & ^twos)\\n\\t\\ttwos ^= (number & ^ones)\\n\\t}\\n\\n\\treturn ones\\n}\\n```\\n## [GitHub](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```go\\nfunc singleNumber(nums []int) int {\\n\\tvar ones int = 0\\n\\tvar twos int = 0\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tvar number int = nums[i]\\n\\t\\tones ^= (number & ^twos)\\n\\t\\ttwos ^= (number & ^ones)\\n\\t}\\n\\n\\treturn ones\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3715438,
                "title": "c-solution-for-single-number-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use bitwise manipulation to keep track of the bits that have appeared once and twice. By doing so, we can identify the single element that appears only once in the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The approach used in the solution is based on two bitmasks: ones and twos. The ones bitmask keeps track of the bits that have appeared once, and the twos bitmask keeps track of the bits that have appeared twice.\\n- For each number in the array, we update the bitmasks as follows:\\n\\n1. Update the ones bitmask: We perform the XOR operation between ones and the number to update the bits that have appeared once. Then, we clear the bits that also appear in the twos bitmask by using the bitwise AND operation with the negation of twos.\\n1. Update the twos bitmask: We perform the XOR operation between twos and the number to update the bits that have appeared twice. Then, we clear the bits that also appear in the ones bitmask by using the bitwise AND operation with the negation of ones.\\n1. At the end of the iteration, the ones bitmask will contain the bits of the single element that appears only once in the array, and we return its value as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the length of the input array. This is because we iterate through the array once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1) because we only use two integer variables (ones and twos) to keep track of the bitmasks. The space usage does not depend on the size of the input array.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        int ones = 0; // Tracks the bits that have appeared once\\n        int twos = 0; // Tracks the bits that have appeared twice\\n    \\n        foreach (int num in nums) \\n        {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n        \\n        return ones;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        int ones = 0; // Tracks the bits that have appeared once\\n        int twos = 0; // Tracks the bits that have appeared twice\\n    \\n        foreach (int num in nums) \\n        {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n        \\n        return ones;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384357,
                "title": "python-o-n-solution-using-sop-and-bit-manipulation",
                "content": "**Motivation**\\n--\\nIf the number of duplicates for all but one number were two(or any even number), we can XOR all the elements of `nums` to get the single element that is not duplicated in nums. Since XOR is commutative, the order we XOR the elements of `nums` doesn\\'t matter as long as we XOR all of them.\\n\\nFor example: If `nums = [2,2,3,4,4]`, then `2^2^3^4^4` is 3, which is the single number. \\n\\nThis works because XOR is essentially an \"odd counter\": The number of bits that are set at the end of the XOR-ing operation are those that occur odd number of times. If a number is duplicate, it\\'s 1 bit occur at least twice thus XOR-ing them turn them off.\\n\\nThis doesn\\'t work if the number of duplicates is 3(or any odd number) since XOR is an odd-counter and XOR will basically be XORing the distinct elements of `nums` which is not what we want. We need an operation similar to XOR, but it is `3n+1` -counter instead of odd-counter. We don\\'t have such kind of operation.... Or don\\'t we?\\n\\n**Triple-XOR**\\n--\\nThe name is not that creative but let\\'s define a **\"ternary\"** operation that does exactly the job we want.  The operation ouputs two values, `x` and `y` from three inputs `a`, `b` and `c`. The reason will become clear in a second. Let\\'s define our `tripleXOR` function using truth table:\\n```\\na     b     c    x      y\\n0     0     0    0      0\\n0     0     1    0      1\\n0     1     0    0      1\\n0     1     1    1      0\\n1     0     0    1      0\\n1     0     1    0      0\\n1     1     0    0      0\\n1     1     1    0      1  \\n```\\nThe operation definition might seem arbitrary at first. But if we assume the concatenation of `a` and `b` tells us the total number of 1-bits that we have counted before modulo 3 and `c` is the incoming bit then the concatenation of  `x` and `y` tells us the the current number of  1-bits (i.e., including the incoming bit) modulo 3. I\\'ll illustrate with an example.\\n\\nFor example, if we have counted 10 1-bits, our `a` and `b` will assume the value `0` and `1` respectively since `10 % 3 = 1`. If the incoming bit is `c=1` the `tripleXOR(0, 1, 1) = 1, 0`, meaning`11%3 = 2` which is `10` in binary.\\n\\nSince every number but one occurs 3 times, our final answer should a `0, 0` and `0, 1` for the 0-bits and 1-bits of the single number.  \\n\\n**Sum-Of-Products**\\n--\\n\\nWe can use the famous sum-of-products technique to compute our `tripleXOR` function as \\n```\\ntripleXOR(a, b, c) = ~a & b & c  | a & ~b & ~c,  ~a & ~b & c | ~a & b & ~c | a & b & c\\n```\\nThat\\'s it. Our single number becomes `~x` or `y` because the 1-bits of the single number will \"tripleXOR\" to `0, 1`.\\n\\n**Implementation**\\n--\\n```\\nclass Solution:\\n    \\n    def singleNumber(self, nums: List[int]) -> int:\\n            \\n        def tripleXOR(a,b,c):\\n            return ~a&b&c | a &~b&~c, a&b&c| ~a&~b&c| ~a&b&~c\\n        \\n        x  = y = i = 0\\n        while i < len(nums):\\n            \\n            x, y = tripleXOR(x, y, nums[i])\\n            i+=1\\n            \\n        return y\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\na     b     c    x      y\\n0     0     0    0      0\\n0     0     1    0      1\\n0     1     0    0      1\\n0     1     1    1      0\\n1     0     0    1      0\\n1     0     1    0      0\\n1     1     0    0      0\\n1     1     1    0      1  \\n```\n```\\ntripleXOR(a, b, c) = ~a & b & c  | a & ~b & ~c,  ~a & ~b & c | ~a & b & ~c | a & b & c\\n```\n```\\nclass Solution:\\n    \\n    def singleNumber(self, nums: List[int]) -> int:\\n            \\n        def tripleXOR(a,b,c):\\n            return ~a&b&c | a &~b&~c, a&b&c| ~a&~b&c| ~a&b&~c\\n        \\n        x  = y = i = 0\\n        while i < len(nums):\\n            \\n            x, y = tripleXOR(x, y, nums[i])\\n            i+=1\\n            \\n        return y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742939,
                "title": "c-100-faster-o-1-space",
                "content": "```\\nint singleNumber(vector<int>& nums) {\\n       unsigned int ans=0,shift=1;\\n        for(int i=0;i<32;++i){\\n            int count=0;\\n            for(auto ele:nums){\\n                if(ele&shift) count+=1;\\n            }\\n            if(count%3!=0){\\n                ans+=shift;\\n                \\n            }\\n            shift*=2;\\n        \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint singleNumber(vector<int>& nums) {\\n       unsigned int ans=0,shift=1;\\n        for(int i=0;i<32;++i){\\n            int count=0;\\n            for(auto ele:nums){\\n                if(ele&shift) count+=1;\\n            }\\n            if(count%3!=0){\\n                ans+=shift;\\n                \\n            }\\n            shift*=2;\\n        \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848434,
                "title": "c-4-lines-code-only-very-easy-and-simple-bit-manipulation",
                "content": "If you find helpful just make me happy by giving a upvate :)\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n    \\n\\n        int oneTime =0;\\n        int twoTime =0;\\n        \\n        for(auto it: nums){\\n            oneTime = (oneTime^it) & (~twoTime);\\n            twoTime = (twoTime ^it) & (~oneTime);\\n        }\\n        \\n        return oneTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n    \\n\\n        int oneTime =0;\\n        int twoTime =0;\\n        \\n        for(auto it: nums){\\n            oneTime = (oneTime^it) & (~twoTime);\\n            twoTime = (twoTime ^it) & (~oneTime);\\n        }\\n        \\n        return oneTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562448,
                "title": "easy-solution-with-explanation",
                "content": "I really enjoyed solving this problem, although I saw some other solutions having complex bit manipulation equations the idea behind this solution if fairly simple.\\n\\nLet\\'s take an example: \\n\\n3 1 1 1 2 2 2 \\n\\nFrom the above example it is clear that 3 is the answer. Now, let us look at the binary representation of the numbers. \\n\\n3 ----> 0 0 1 1\\n1 ----> 0 0 0 1\\n1 ----> 0 0 0 1\\n1 ----> 0 0 0 1\\n2 ----> 0 0 1 0\\n2 ----> 0 0 1 0\\n2 ----> 0 0 1 0\\n\\n* If you notice in the above table, numbers of ones in some columns are in the form 3n and 3n+1, where n is the frequency of the numbers.\\n* Whichever columns have 3n+1 1\\'s must contain the element that occurs only once and thats what we want as the result.\\n* So, we check for every bit in the whole array and if the count of that bit is in the form 3n+1 then we add it to our result.\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int res = 0;\\n        for(int i = 0; i <= 31; ++i) {\\n            int check = 1 << i, count = 0;\\n            for(auto child : nums) {\\n                if(child & check)\\n                    count += 1;\\n            }\\n            if(count % 3 == 1) \\n                res = res | check;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\nTime Complexity: O(Nx32) == O(N)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int res = 0;\\n        for(int i = 0; i <= 31; ++i) {\\n            int check = 1 << i, count = 0;\\n            for(auto child : nums) {\\n                if(child & check)\\n                    count += 1;\\n            }\\n            if(count % 3 == 1) \\n                res = res | check;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501849,
                "title": "easy-to-read-commented-and-explained-c-solution",
                "content": "```\\n// Idea of solution:\\n\\n// Consider case where input is not type int, but a bit array, we want to\\n// count the number of 1s in the bit array and know if it is a multiple of 3:\\n\\n// 1. we want a counter which overflows when count = 3 (n mod 3 or n % 3)\\n//    so the number remaining in couter after counting is the number\\n//    that has not appear 3 times\\n\\n// 2. Let\\'s do so by creating 2 (2^2 = 4 > 3) 1-bit counter\\n//      bit oneCounter = 0;\\n//      bit twoCounter = 0;\\n\\n// 3. Consider an input: 10010101, now count the number using\\n//    the 2 counter above:\\n//          the first 1:    twoCounter = 0, oneCounter = 1\\n//          the second 1:   twoCounter = 1, oneCounter = 0\\n//          the third 1:    twoCounter = 0, oneCounter = 0\\n//          (repeat...)\\n\\n// 4. How would we do that?\\n\\n// 5. For the first 1, we simply flip oneCounter (i.e. XOR)\\n//    For the second 1, we reset oneCounter to 0, and flip twoCounter\\n//    For the third 1, we flip twoCounter\\n\\n// 6. Find the pattern of step 5:\\n//      oneCounter: only set to one if twoCounter is 0\\n//      twoCounter: only set to one if oneCounter is 0 (after flipping oneCoutner)\\n\\n// 7. So what we want to do is:\\n//      1. XOR (^) oneCounter (i.e. flipping the bit)\\n//      2. Only allow the flip bit to remain flipped when two counter is 0,\\n//         We can do it by first reversing twoCounter (~) and logical and (&)\\n//         oneCounter.\\n//      3. Same for twoCounter.\\n\\n// 8. Expanding on this idea, it is the same for any integer, note that we can\\n//     also use the same counters for differnet integers since eveually if a number\\n//     appeared 3 times, it will cancel itself out in the buffer, leaving the single number.\\n\\n// 9. Additional:\\n//      What if we want to find a number in a given array that did not appear 4 times?\\n//      The answer is:\\n//          first 1:    twoCounter = 0, oneCounter = 1\\n//          second 1:   twoCounter = 1, oneCounter = 0\\n//          third 1:    twoCounter = 1, oneCounter = 1\\n//          fourth 1:   twoCounter = 0, oneCounter = 0\\n//          (repeat ...)\\n//      Observe the pattern\\n//          oneCounter flips every time\\n//          twoCounter will only flip when oneCounter is 0 (after flipping)\\n//      So the answer is:\\n//          for loop {\\n//              oneCounter = (oneCounter ^ n);\\n//              twoCounter = (twoCounter ^ n) & ~oneCounter;\\n//          }\\n\\n// Hopes this helped :)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int oneCounter = 0;\\n        int twoCounter = 0;\\n        \\n        for (int &n : nums) {\\n            oneCounter = (oneCounter ^ n) & ~twoCounter;\\n            twoCounter = (twoCounter ^ n) & ~oneCounter;\\n        }\\n        \\n        return oneCounter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Idea of solution:\\n\\n// Consider case where input is not type int, but a bit array, we want to\\n// count the number of 1s in the bit array and know if it is a multiple of 3:\\n\\n// 1. we want a counter which overflows when count = 3 (n mod 3 or n % 3)\\n//    so the number remaining in couter after counting is the number\\n//    that has not appear 3 times\\n\\n// 2. Let\\'s do so by creating 2 (2^2 = 4 > 3) 1-bit counter\\n//      bit oneCounter = 0;\\n//      bit twoCounter = 0;\\n\\n// 3. Consider an input: 10010101, now count the number using\\n//    the 2 counter above:\\n//          the first 1:    twoCounter = 0, oneCounter = 1\\n//          the second 1:   twoCounter = 1, oneCounter = 0\\n//          the third 1:    twoCounter = 0, oneCounter = 0\\n//          (repeat...)\\n\\n// 4. How would we do that?\\n\\n// 5. For the first 1, we simply flip oneCounter (i.e. XOR)\\n//    For the second 1, we reset oneCounter to 0, and flip twoCounter\\n//    For the third 1, we flip twoCounter\\n\\n// 6. Find the pattern of step 5:\\n//      oneCounter: only set to one if twoCounter is 0\\n//      twoCounter: only set to one if oneCounter is 0 (after flipping oneCoutner)\\n\\n// 7. So what we want to do is:\\n//      1. XOR (^) oneCounter (i.e. flipping the bit)\\n//      2. Only allow the flip bit to remain flipped when two counter is 0,\\n//         We can do it by first reversing twoCounter (~) and logical and (&)\\n//         oneCounter.\\n//      3. Same for twoCounter.\\n\\n// 8. Expanding on this idea, it is the same for any integer, note that we can\\n//     also use the same counters for differnet integers since eveually if a number\\n//     appeared 3 times, it will cancel itself out in the buffer, leaving the single number.\\n\\n// 9. Additional:\\n//      What if we want to find a number in a given array that did not appear 4 times?\\n//      The answer is:\\n//          first 1:    twoCounter = 0, oneCounter = 1\\n//          second 1:   twoCounter = 1, oneCounter = 0\\n//          third 1:    twoCounter = 1, oneCounter = 1\\n//          fourth 1:   twoCounter = 0, oneCounter = 0\\n//          (repeat ...)\\n//      Observe the pattern\\n//          oneCounter flips every time\\n//          twoCounter will only flip when oneCounter is 0 (after flipping)\\n//      So the answer is:\\n//          for loop {\\n//              oneCounter = (oneCounter ^ n);\\n//              twoCounter = (twoCounter ^ n) & ~oneCounter;\\n//          }\\n\\n// Hopes this helped :)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int oneCounter = 0;\\n        int twoCounter = 0;\\n        \\n        for (int &n : nums) {\\n            oneCounter = (oneCounter ^ n) & ~twoCounter;\\n            twoCounter = (twoCounter ^ n) & ~oneCounter;\\n        }\\n        \\n        return oneCounter;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 700305,
                "title": "python-3-very-simple-one-liner-and-a-bitwise-with-o-1-space-only-2-variables",
                "content": "Here\\'s a simple and straightforward one liner. Get the count of the items using `Counter(nums)`. Sort them in descending count order with `most_common()` and take the last element by indexing with `[-1][0]`. Voila!\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n    return Counter(nums).most_common()[-1][0]\\n```\\n\\nI also came across this bitwise solution in a [Quora post](https://www.quora.com/Given-an-integer-array-such-that-every-element-occurs-3-times-except-one-element-which-occurs-only-once-how-do-I-find-that-single-element-in-O-1-space-and-O-n-time-complexity) I thought was very elegant.\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n    ones, twos = 0, 0\\n    for num in nums:\\n        ones, twos = (ones ^ num) & ~twos, (ones & num) | (twos & ~num)\\n    return ones\\n```\\n\\nLet\\'s unpack what the code is doing. We have two updates:\\n1. `ones = (ones ^ num) & ~twos`\\n\\t* `ones ^ num` performs the same XOR operation you see in the duplicate entries version of Single Number\\n\\t* `& ~twos` removes the newly added number if it\\'s been seen twice\\n2. `twos = (ones & num) | (twos & ~num)`\\n\\t* `ones & num` takes the number if it\\'s in `ones`\\n\\t* `twos & ~num` takes the number only if it\\'s not in `twos`\\n\\nThese updates work because of the communtativity and associativity of `&` and `^`.\\n\\nThe following explanation is my original attempt at explaining the above algorithm. I leave it here for those who prefer these types of explanations. The gist of the algorithm is that `ones` is XORed with `num` in the same way that you would in the duplicate number version of the Single Number problem (`ones ^ num`), but we remove the number if it has already been stored in `twos` by only accepting the bits not present in `twos` (`& ~twos)`. This gives us the update `ones = (ones ^ num) & ~twos`. The twos update simply checks if the number has been seen in `ones` (`ones & num`) and if the number has not been seen in `twos` (`twos & ~num`). This gives us the `twos` update of `twos = (ones & num) | (twos & ~num)`. It\\'s important to note that this works because of the commutativity and associativity of the AND (`&`) and XOR (`^`) operators.\\n\\n**Please upvote if you found this helpful! It helps the visibility of the bitwise solution.**",
                "solutionTags": [],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n    return Counter(nums).most_common()[-1][0]\\n```\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n    ones, twos = 0, 0\\n    for num in nums:\\n        ones, twos = (ones ^ num) & ~twos, (ones & num) | (twos & ~num)\\n    return ones\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 548174,
                "title": "bit-manipulation-solution",
                "content": "This is not the optimal bit solution as the top 2 submissions on this answer are better, but I don\\'t quite get them, I\\'m new to trying questions in this way, if anybody gets them, leave a comment explaining them!\\n```\\nint result = 0, count = 0;\\nfor(int i = 0; i < 32; i++) {\\n    count = 0;\\n    for(const auto &num: nums)\\n\\t    // counting number of 1s by checking if bit is set\\n        if((num & (1 << i)) != 0) count++;\\n\\t// setting result bit with 0 or 1 based on whether count is multiple of 3 or not\\n    result |= ((count%3) << i);\\n}\\nreturn result;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint result = 0, count = 0;\\nfor(int i = 0; i < 32; i++) {\\n    count = 0;\\n    for(const auto &num: nums)\\n\\t    // counting number of 1s by checking if bit is set\\n        if((num & (1 << i)) != 0) count++;\\n\\t// setting result bit with 0 or 1 based on whether count is multiple of 3 or not\\n    result |= ((count%3) << i);\\n}\\nreturn result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355996,
                "title": "python-solution-in-1-line-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return int((sum(set(nums))*3-sum(nums))/2)\\n```\\nfirst, I use `set` to remove duplicate in nums array, let\\'s call it new array.\\nthen, since we know that every element appears three times except for one, we can simply multiply the sum of new array by 3 and subtract the number by the sum of nums array.\\nlast, divide the number by 2, here\\'s the single number in nums array.\\n\\nhere\\'s an example:\\n1. given an array [1,2,3,1,2,2,1], we will have [1,2,3] after removing duplicate nums in array.\\n2. calculate the sum of [1,2,3] and multiply it by 3, which is equal to calculate the sum of [1,1,1,2,2,2,3,3,3].\\n3. calculate the sum of nums array, which is equal to calculate the sum of [1,1,1,2,2,2,3].\\n4. substract the number in step 2 by number in step 3, we will have 6, which is the sum of extra [3,3] in step 2, now that we know that the single number must be 3, we just divide 6 by 2, we will have the final result.\\n\\nthis method can be apply to any array whose \\'every element appears n times except for one\\', just mutiply the sum of non-duplicate array by n and substract it by the sum of nums array and then divide it by (n-1), here we are.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return int((sum(set(nums))*3-sum(nums))/2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43451,
                "title": "c-solution-add-bit-by-bit-but-mod-3",
                "content": "We generalize the bitwise XOR idea so that if one bit repeats 3 times, it goes back to zero. To achieve that, we expand each bit to two bits (using the extra variable carryBits to hold the extra bits).\\n\\nFor example, if we have a 1 bit, we expand it to 01, but hold that 0 in the auxiliary variable carryBits. If we add the bit to itself once, we get 10, if we add the bit again, we get 11, which means it is zero mod 3, so we clear that position if both bits are 1. \\n\\n    class Solution {\\n    public:\\n        int singleNumber(int A[], int n) {\\n            int carryBits = 0, sumMod3 = 0, zeroBitsMod3;\\n            for(int i = 0; i < n; i++) {\\n\\n                // Keep adding A[i] to the sum, and keep the overflow bits in carryBits\\n                carryBits += sumMod3 & A[i];\\n                sumMod3 = sumMod3 ^ A[i];\\n\\n                // Find the bit positions where both carryBits and sumMod3 are 1\\n                zeroBitsMod3 = carryBits & sumMod3;  \\n\\n                // Clear the those bits that is zero mod 3\\n                carryBits ^= zeroBitsMod3;\\n                sumMod3 ^= zeroBitsMod3;\\n            }\\n\\n            // Don't forget that the part of the sum is held in carryBits\\n            return (carryBits<<1) + sumMod3;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(int A[], int n) {\\n            int carryBits = 0, sumMod3 = 0, zeroBitsMod3;\\n            for(int i = 0; i < n; i++) {\\n\\n                // Keep adding A[i] to the sum, and keep the overflow bits in carryBits\\n                carryBits += sumMod3 & A[i];\\n                sumMod3 = sumMod3 ^ A[i];\\n\\n                // Find the bit positions where both carryBits and sumMod3 are 1\\n                zeroBitsMod3 = carryBits & sumMod3;  \\n\\n                // Clear the those bits that is zero mod 3\\n                carryBits ^= zeroBitsMod3;\\n                sumMod3 ^= zeroBitsMod3;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3715302,
                "title": "single-number-ii-easy-java-solution-t-o-n-s-o-1",
                "content": "# Approach\\n1. Initialize three variables `once`, `twice`, and `thrice` to 0.\\n2. Iterate over each element `nums[i]` in the given array.\\n3. Update `twice` using the bitwise OR operator (`|`): It combines the current value of `twice` with the bitwise AND (`&`) operation between `once` and `nums[i]`. This operation captures the bits that appear twice in the array.\\n4. Update `once` using the bitwise XOR operator (`^`): It performs an XOR operation between the current value of `once` and `nums[i]`. This operation captures the bits that appear once in the array.\\n5. Update `thrice` using the bitwise AND operator (`&`): It calculates the bits that appear three times by performing the AND operation between `once` and `twice`.\\n6. Update `once` by removing the bits that appear three times: It performs the AND operation between `once` and the negation (`~`) of `thrice`. This operation removes the bits that appear three times from `once`.\\n7. Update `twice` by removing the bits that appear three times: It performs the AND operation between `twice` and the negation of `thrice`. This operation removes the bits that appear three times from `twice`.\\n8. Repeat steps 3-7 for all elements in the array.\\n9. After iterating through all elements, `once` will hold the single number that appears only once in the array.\\n10. Return the value of `once`.\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int singleNumber(int[] nums) {\\n        int once = 0;\\n        int twice = 0;\\n        int thrice = 0;\\n        for (int i = 0; i < nums.length; i ++){\\n            twice = twice | ( once & nums[i]);\\n            once = once ^ nums[i];\\n            thrice = once & twice;\\n            once = once & (~thrice);\\n            twice = twice & (~thrice);\\n        }\\n        return once;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n     public int singleNumber(int[] nums) {\\n        int once = 0;\\n        int twice = 0;\\n        int thrice = 0;\\n        for (int i = 0; i < nums.length; i ++){\\n            twice = twice | ( once & nums[i]);\\n            once = once ^ nums[i];\\n            thrice = once & twice;\\n            once = once & (~thrice);\\n            twice = twice & (~thrice);\\n        }\\n        return once;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591339,
                "title": "easy-to-understand-bit-manipulation-solution-with-explanation",
                "content": "# Approach\\nLets understand this with an example \\n```\\nelements:  1    3   2   3   4   2   1   1   3  2\\nBinary Rep:001 011 010 011 100 010 001 001 011 010\\n```\\n\\nConsider the Binary representation of each element, for number which are present 3 times, the count of set bits must be a multiple of 3 (same numbers will have same Binary representation, if it is present thrice, set bit count will become multiple of 3). \\n\\nWe will count set bits at every position (according to constraints we will consider 32 bits) if the count is not multiple of 3 then we are sure that this bit must be 1 in the answer (i.e. unique number)\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\n\\n    public:\\n    bool getBit(int n, int pos)\\n    {       //find bit at 2nd position in 5:  101 & 10 -> 0;\\n        return ((n &(1 << pos)) != 0); \\n    }\\n    int setBit(int n, int pos)\\n    {      // set bit at 2nd position in 5:  101 | 10 -> 111;\\n        return (n | (1 << pos));\\n    }\\n\\n    int singleNumber(vector<int> &nums)\\n    {\\n        int ans = 0;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            int sum = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                if (getBit(nums[j], i)) sum++;\\n            }\\n            if (sum % 3 != 0)\\n                ans = setBit(ans, i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nupvote if helpful :)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nelements:  1    3   2   3   4   2   1   1   3  2\\nBinary Rep:001 011 010 011 100 010 001 001 011 010\\n```\n```\\nclass Solution\\n{\\n\\n    public:\\n    bool getBit(int n, int pos)\\n    {       //find bit at 2nd position in 5:  101 & 10 -> 0;\\n        return ((n &(1 << pos)) != 0); \\n    }\\n    int setBit(int n, int pos)\\n    {      // set bit at 2nd position in 5:  101 | 10 -> 111;\\n        return (n | (1 << pos));\\n    }\\n\\n    int singleNumber(vector<int> &nums)\\n    {\\n        int ans = 0;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            int sum = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                if (getBit(nums[j], i)) sum++;\\n            }\\n            if (sum % 3 != 0)\\n                ans = setBit(ans, i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280746,
                "title": "bit-manipulation-approach-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int tn = -1;\\n        int tnp1 = 0;\\n        int tnp2 = 0;\\n        for(int& num : nums){\\n            int cwtn = num & tn;\\n            int cwtnp1 = num &  tnp1;\\n            int cwtnp2 = num & tnp2;\\n            // jo mere tn aur cwtn mein common 1 hai use off kr dunga \\n            // aur unhe tnp1 mein on kr dunga because ab wo 3n + 1 form ke ho gye hai\\n            tn = tn & (~cwtn);\\n            tnp1 = tnp1 | cwtn;\\n            \\n           // jo mere tnp1 aur cwtnp1 mein common 1 hai use off kr dunga \\n            // aur unhe tnp2 mein on kr dunga because ab wo 3n + 2 form ke ho gye hai\\n            tnp1 = tnp1 & (~cwtnp1);\\n            tnp2 = tnp2 | cwtnp1;\\n            \\n            // same ab 3n form mein ho jayenge\\n            tnp2 = tnp2 & (~cwtnp2);\\n            tn = tn | cwtnp2;\\n        }\\n        return tnp1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int tn = -1;\\n        int tnp1 = 0;\\n        int tnp2 = 0;\\n        for(int& num : nums){\\n            int cwtn = num & tn;\\n            int cwtnp1 = num &  tnp1;\\n            int cwtnp2 = num & tnp2;\\n            // jo mere tn aur cwtn mein common 1 hai use off kr dunga \\n            // aur unhe tnp1 mein on kr dunga because ab wo 3n + 1 form ke ho gye hai\\n            tn = tn & (~cwtn);\\n            tnp1 = tnp1 | cwtn;\\n            \\n           // jo mere tnp1 aur cwtnp1 mein common 1 hai use off kr dunga \\n            // aur unhe tnp2 mein on kr dunga because ab wo 3n + 2 form ke ho gye hai\\n            tnp1 = tnp1 & (~cwtnp1);\\n            tnp2 = tnp2 | cwtnp1;\\n            \\n            // same ab 3n form mein ho jayenge\\n            tnp2 = tnp2 & (~cwtnp2);\\n            tn = tn | cwtnp2;\\n        }\\n        return tnp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680131,
                "title": "one-way-of-solving-all-these-types-of-problem-explained-simple-and-concise",
                "content": "Question -  Unique number\\nGeneralized form-\\nThere are kn+1 numbers in an array. There is one unique number and other numbers come k times. Find the unique number.  \\n\\n\\nCase 1- k is even \\na^a=0.\\nWe know if xor a number even number of times, we get 0.           \\nWe will xor all numbers of the array. All repeating numbers cancel out and we are left with the unique number.  \\n\\nCase 2- k is odd\\nXor will not work here.\\nLet\\'s take the example of k=3.\\nArr = 1 2 2 2 3 3 3\\nAdd bits at every position.\\n00001\\n00010\\n00010\\n00010\\n00011\\n00011\\n00011\\n\\u2014-------\\n00064\\n\\n6=3x2\\n4=3x1+1\\n0=3x0\\nWe will have only 3n or 3n+1 bits at every position in the sum.\\nWe have 3n+1 bits at points where the unique number has a set bit.\\n\\nSo we can just run through the sum of bits and wherever we have 3n+1 bits we know this place will have a set bit in the unique number.\\n\\n\\nCODE for odd k.\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int orbits=0;\\n        \\n        int shft=0, i,ans=0;\\n        \\n        for( i=0;i<32;i++)\\n        {\\n            int sum=0;\\n            for(int x:nums)\\n            {\\n                if((x&(1<<shft)))\\n                {\\n                    sum++;\\n                }\\n                \\n            }\\n            if(sum%3==1)\\n            {\\n                ans=(ans|(1<<shft));\\n            }\\n            shft++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int orbits=0;\\n        \\n        int shft=0, i,ans=0;\\n        \\n        for( i=0;i<32;i++)\\n        {\\n            int sum=0;\\n            for(int x:nums)\\n            {\\n                if((x&(1<<shft)))\\n                {\\n                    sum++;\\n                }\\n                \\n            }\\n            if(sum%3==1)\\n            {\\n                ans=(ans|(1<<shft));\\n            }\\n            shft++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555396,
                "title": "explained-with-example-bit-manipulation-python-c",
                "content": "* First we will `count` number of set bits at `ith` position for all elements in the array.\\n* Now if `count%3==0` means till now the number `2^i` has been found multiple of three times.\\n\\t* No updation in `ans`.\\n* If `count%3!=0` means till now the number 2^i has been found multiple of three +1 times.\\n\\t* It may be our `ans` so update it to `ans |= 2^i`.\\n* At the end all the set bits that occurred multiple of three + 1 times will be collected at their respective position by OR operation in previous step.\\n\\n**ILLUSTRATION :** \\n\\nA = [6, 3, 5, 6, 3, 5, 4, 9, 4, 4, 6, 3, 5]\\n\\n6 : 0 1 1 0\\n3 : 0 0 1 1\\n5 : 0 1 0 1\\n6 : 0 1 1 0\\n3 : 0 0 1 1\\n5 : 0 1 0 1\\n4 : 0 1 0 0\\n9 : 1 0 0 1\\n4 : 0 1 0 0\\n4 : 0 1 0 0\\n6 : 0 1 1 0\\n3 : 0 0 1 1\\n5 : 0 1 0 1\\n\\\\-----------\\n......1 9 6 7 : no. of set bits at `i`th position.\\n\\n* `ans = 0`\\n* at 0th position 7%3!=0\\n\\t* `ans |= 2^0  --> 1`\\n* at 1th position 6%3==0\\n\\t* No update\\n* at 2nd position 9%3==0\\n\\t* No update\\n* at 3rd position 1%3!=0\\n\\t* `ans |= 2^3 --> 9`\\n--------------------------------------------------------\\n* In some languages such as python it will give wrong answer in case of negative elements.\\n* To handle this case whenever we find a set bit at `31`th position we just subtract 2^31 from our answer.\\n* Since binary of negative number is represented in its 2\\'s complement, in each step  we are continuously collecting set bits, means subtracting 2^31 from our answer will give us desired output.\\n\\n**ILLUSTRATION :**\\n\\nA = [-2, 2, 2, 2]\\n.-2 : 1 1 1 0\\n+2 : 0 0 1 0\\n+2 : 0 0 1 0\\n+2 : 0 0 1 0\\n\\\\--------------\\n.........1 1 4 0  : no. of set bits at `i`th position.\\n\\n* `ans = 0`\\n* at 0th position 0%3!=0\\n\\t* No update\\n* at 1th position 4%3!=0\\n\\t* `ans |= 2^1 --> 2`\\n* at 2nd position 1%3!=0\\n\\t* `ans |= 2^2 --> 6`\\n* at 3rd position 1%3!=0\\n\\t* `ans |= 2^3 --> 14`\\n* at position (4 to 30) 1%3!=0\\n\\t* `ans |= 2^30 --> 2147483646`\\n* at position 31st 1%3!=0 and i==31\\n\\t* `ans -= 2^31 --> -2`\\n-----------------------------------------------\\n**Python** :\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(32):\\n            mask = 1<<i\\n            \\n            count = 0\\n            for num in nums:\\n                if num&mask:\\n                    count += 1\\n            \\n            if count%3:\\n                if i == 31:\\n                    print(ans, mask)\\n                    ans -= mask\\n                else:\\n                    ans |= mask\\n        \\n        return ans\\n\\n```\\n\\n-----------------------------------------------\\n**C++** : [we don\\'t need to add negative element case in c++, it will automatically handle this case.]\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int mask = 1<<i;\\n            int count = 0;\\n            \\n            for(auto num:nums)\\n                if(num&mask)\\n                  count += 1;      \\n\\n            if(count%3 != 0){\\n                ans |= mask; \\n            }     \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n-----------------------------------\\n**Upvote the post if you find it helpful.**\\n**Happy coding.**\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(32):\\n            mask = 1<<i\\n            \\n            count = 0\\n            for num in nums:\\n                if num&mask:\\n                    count += 1\\n            \\n            if count%3:\\n                if i == 31:\\n                    print(ans, mask)\\n                    ans -= mask\\n                else:\\n                    ans |= mask\\n        \\n        return ans\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int mask = 1<<i;\\n            int count = 0;\\n            \\n            for(auto num:nums)\\n                if(num&mask)\\n                  count += 1;      \\n\\n            if(count%3 != 0){\\n                ans |= mask; \\n            }     \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338589,
                "title": "c-bitwise-solution-o-n",
                "content": "Runtime: 12 ms, faster than 36.94% of C++ online submissions for Single Number II.\\nMemory Usage: 9.6 MB, less than 49.89% of C++ online submissions for Single Number II.\\n\\n```\\nAs we have 3 occurence of each element except one element which occurs only once. We can go through\\nall the numbers in the array and check their each bit positions and count number of 1. \\nNow in each bit position number of 1 can be multiple of 3 or (multiple of 3) + 1. So, we can know if the \\nbit postion of the uique number is 1 if count of 1 % 3 ==1 and construct the unique number bitwise.\\n\\nExample: [2,2,3,2]\\n2 => 010\\n2 => 010\\n2 => 010\\n3 => 011\\n___________\\nCount of 1 => [ 0, 4, 1 ] % 3 = [0, 1, 1] => 3 \\n\\nComplexity : O(N * 32)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // unique number\\n        int ans = 0;\\n        \\n        // go through each bit position\\n        for(int i=0;i<32;i++)\\n        {\\n            // go though all numbers and count the number of 1 in bit position i\\n            int sum = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((nums[j]&1)==1)sum++;\\n                nums[j]=nums[j]>>1;                \\n            }\\n            \\n            // get the count 1 mod 3\\n            sum%=3;\\n            \\n            // if ith bit position is 1 then unique number\\'s ith bit is 1 \\n            if(sum!=0)ans|=sum<<i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nAs we have 3 occurence of each element except one element which occurs only once. We can go through\\nall the numbers in the array and check their each bit positions and count number of 1. \\nNow in each bit position number of 1 can be multiple of 3 or (multiple of 3) + 1. So, we can know if the \\nbit postion of the uique number is 1 if count of 1 % 3 ==1 and construct the unique number bitwise.\\n\\nExample: [2,2,3,2]\\n2 => 010\\n2 => 010\\n2 => 010\\n3 => 011\\n___________\\nCount of 1 => [ 0, 4, 1 ] % 3 = [0, 1, 1] => 3 \\n\\nComplexity : O(N * 32)\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // unique number\\n        int ans = 0;\\n        \\n        // go through each bit position\\n        for(int i=0;i<32;i++)\\n        {\\n            // go though all numbers and count the number of 1 in bit position i\\n            int sum = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((nums[j]&1)==1)sum++;\\n                nums[j]=nums[j]>>1;                \\n            }\\n            \\n            // get the count 1 mod 3\\n            sum%=3;\\n            \\n            // if ith bit position is 1 then unique number\\'s ith bit is 1 \\n            if(sum!=0)ans|=sum<<i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959996,
                "title": "automata-based-bit-manipulation-solution-explained-with-visualizations",
                "content": "Before getting into the solution for the problem, there are a couple observations that I would like to emphasize. Problem states every number in the given array repeats exactly three times except for the number we are interested in. If you think of what are the implications of this condition/constraints on the bits of the numbers involved, you can draw following conclusions\\n* At a particular bit position, all the 1s summed together will add up to either a multiple of three or multiple of three plus one (due to the oulier we are interested in)\\n* In other words, if you can count the number of times 1 occurs at a particular bit position and if that bit position is divisible by three. The correspoding bit for the outlier will 0 else it\\'s 1.\\n* Further, we are not really interested in knowing the total sum of 1s at a particular bit position we are just interested in knowing if the final sum will be divisible with 3 or not. How can we do it? We would do it by __maintaining a state__\\n\\nThey way I\\'m proposing to maintain state is to use a set of two variables. Say v1 and v2. Let\\'s for easier understanding look at the bits of all numbers, plus two additional variables v1 and v2, at a particular bit position. I\\'ll start with assigning the state represented by v1 and v2 bit. Both the numbers are initialized to zero, that would mean at the bit position we are the currently looking at, both the bits will be set to 0.\\n* v1 = 0, v2 = 0 is the initial state and indicate that we havn\\'t seen any 1s yet or all the ones seen yet were in triplets.\\n* __v1 = 1, v2 = 0 represents that we have seen the first 1 from triplet.__\\n* v1 = 1, v2 = 1 represents that we have seen two ones from the triplet.\\n\\nThe state transitions functions that we use are as follows\\n```\\nint tmp = v1\\nv1 = (v1 XOR v2) OR (v1 XOR x)\\nv2 = tmp AND (v2 XOR x)       \\n```\\nThe following diagram captures the behaviour of state machine for 1s and 0s as input against each state.\\n\\n<img src=\"https://assets.leetcode.com/users/images/230bc57c-fac8-46d5-98b1-89c513326b4b_1607118981.5746338.png\" width=\"700\">\\n\\nAt the end of performing the fore-mentioned operations for all the numbers every bit in v1, v2 will be one of the states marked in blue. Taking a XOR between v1 and v2 will give us the final answer. Please find the complete cpp code below (Beats runtime of 100% cpp code submissions):\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int v1 = 0;\\n        int v2 = 0;\\n        int tmp;\\n        for (auto x: nums) {\\n            tmp = v1;\\n            v1 = (v1 ^ v2) | (v1 ^ x);\\n            v2 = tmp & (v2 ^ x);\\n        }\\n        return v2 ^ v1;\\n    }\\n};\\n```\\nHappy coding :)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint tmp = v1\\nv1 = (v1 XOR v2) OR (v1 XOR x)\\nv2 = tmp AND (v2 XOR x)       \\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int v1 = 0;\\n        int v2 = 0;\\n        int tmp;\\n        for (auto x: nums) {\\n            tmp = v1;\\n            v1 = (v1 ^ v2) | (v1 ^ x);\\n            v2 = tmp & (v2 ^ x);\\n        }\\n        return v2 ^ v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936917,
                "title": "python-bitwise-solution-with-explanation",
                "content": "## Algorithm\\nThe basic idea is to design a finite state machine which has 3 states. Let\\'s assume: `a` is the high bit. `b` is the low bit. `c` is the data. `a\\'` is the a\\'s result. `b\\'` is the b\\'s result. \\n\\n### Table 1: c is 0\\n|a|b|c|a\\'|b\\'|\\n|-|-|-|-|-|\\n|0|0|0|0|0|\\n|0|1|0|0|1|\\n|1|0|0|1|0|\\n\\n### Table 2: c is 1\\n|a|b|c|a\\'|b\\'|\\n|-|-|-|-|-|\\n|0|0|1|0|1|\\n|0|1|1|1|0|\\n|1|0|1|0|0|\\n\\n**Then we can get**:\\n\\nb\\' = 1: `(a==0 && b==1 && c==0) || (a==0 && b==0 && c==1)` \\n=> `b\\' = (~a & b & ~c) + (~a & ~b & c) = ~a & (b & ~c + ~b & c) = ~a & (b ^ c)` <br>\\na\\' = 1: `(a==1 && b==0 && c==0) || (a==0 && b==1 && c==1)` \\n=> `a\\' = (a & ~b & ~c) + (~a & b & c)` \\n=> `a\\' = (~a & ~b\\' & c) + (a & ~b\\' & ~c) = ~b\\' & (~a & c + a & ~c) = ~b\\' & (a ^ c)`\\n\\n## Code\\n```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        a, b = 0, 0\\n        for c in nums:\\n            b = (b ^ c) & ~a\\n            a = (a ^ c) & ~b\\n        return b\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        a, b = 0, 0\\n        for c in nums:\\n            b = (b ^ c) & ~a\\n            a = (a ^ c) & ~b\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700604,
                "title": "python-2-solutions",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : HASHMAP ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        counter = collections.Counter(nums)\\n        for num in counter.keys():\\n            if counter[num] == 1:\\n                return num\\n        \\n        ## APPROACH : BIT MANIPULATION ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        # XOR operator which could be used to detect the bit which appears odd number of times: 1, 3, 5, etc.\\n        seen_once = seen_twice = 0\\n        for num in nums:\\n            # first appearance: \\n            # add num to seen_once \\n            # don\\'t add to seen_twice because of presence in seen_once\\n            \\n            # second appearance: \\n            # remove num from seen_once \\n            # add num to seen_twice\\n            \\n            # third appearance: \\n            # don\\'t add to seen_once because of presence in seen_twice\\n            # remove num from seen_twice\\n            seen_once = ~seen_twice & (seen_once ^ num) # change seen_once only if seen_twice is unchanged\\n            seen_twice = ~seen_once & (seen_twice ^ num) # change seen_twice only if seen_once is unchanged\\n        return seen_once\\n```\\nReference @ Leetcode\\nUseful article: https://medium.com/@lenchen/leetcode-137-single-number-ii-31af98b0f462",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : HASHMAP ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        counter = collections.Counter(nums)\\n        for num in counter.keys():\\n            if counter[num] == 1:\\n                return num\\n        \\n        ## APPROACH : BIT MANIPULATION ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        # XOR operator which could be used to detect the bit which appears odd number of times: 1, 3, 5, etc.\\n        seen_once = seen_twice = 0\\n        for num in nums:\\n            # first appearance: \\n            # add num to seen_once \\n            # don\\'t add to seen_twice because of presence in seen_once\\n            \\n            # second appearance: \\n            # remove num from seen_once \\n            # add num to seen_twice\\n            \\n            # third appearance: \\n            # don\\'t add to seen_once because of presence in seen_twice\\n            # remove num from seen_twice\\n            seen_once = ~seen_twice & (seen_once ^ num) # change seen_once only if seen_twice is unchanged\\n            seen_twice = ~seen_once & (seen_twice ^ num) # change seen_twice only if seen_once is unchanged\\n        return seen_once\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570559,
                "title": "java-o-1-space-complexity",
                "content": "This particular problem is a tricky one if you want to do it in **O(n)** time and **O(1)** space. \\n\\nSince, this problem is particular related to bit manipulations (which i am still learning), it needs basic knowledge of bitwise operators. So, the solution works like this:\\n\\n**eg. {2,3,2,3,2,4,3}**\\nBits representation of each element of the array is as follow:\\n2 -> 010\\n3 -> 011\\n2 -> 010\\n3 -> 011\\n2 -> 010\\n4 -> 100\\n3 -> 011\\n= -> 163\\nSo the total number of set bits (i.e **1**) at 0th bit is 3, at 1st bit is 6 and at 2nd bit is 1.\\n\\nNow, to get the answer, we divide the total number of set bits at each position by 3, and if it is divisible by 3, we set our final result bit to 0; otherwise 1.\\nSince, 3 is divisible by 3, we will set 0th bit \\xA0of our final **result** to **0**, 6 is divisible by 3, we set our 1st bit to **0**, but 1 is not divisible by 3, so we set the 2nd bit of our result to **1**. Hence the final **result** will be 100 which is equivalent to 4 in decimal representation. And **4** is the only single digit in our array.\\n\\nIn order to find whether the bit is 0 or 1, at a particular bit of an element, we run our first loop from **0** to **32** (because the number of bits in an Integer can be upto 32), and \\ncheck for set bits using \\n```\\nif(num & (1 << i) != 0)\\ncount++\\n}\\n```\\nif the bit is set, then we increment the **count** by **1**.\\n\\nOnce, we are out of the inner loop, we will have the count of set bits of a particular position/bit of each element of the array, using which we will set that particular position/bit of our result to either **0** or **1**.\\n```\\nresult |= ((count % 3) << i);\\n```\\n\\nTime Complexity of the Solution is **O(32 * n)**. Ignoring constants, it will be **O(n)**\\n\\n\\n```\\npublic Solution{\\n\\tpublic int singleNumber(int[] nums) {\\n        int result = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0for(int i = 0; i < 32; i++) { \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  int count = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0for(int num : nums) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if((nums & (1 << i)) != 0)\\n                    count++;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0result |= ((count % 3) << i);\\n        }\\n        return result;\\n    }\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\nif(num & (1 << i) != 0)\\ncount++\\n}\\n```\n```\\nresult |= ((count % 3) << i);\\n```\n```\\npublic Solution{\\n\\tpublic int singleNumber(int[] nums) {\\n        int result = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0for(int i = 0; i < 32; i++) { \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  int count = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0for(int num : nums) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if((nums & (1 << i)) != 0)\\n                    count++;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0result |= ((count % 3) << i);\\n        }\\n        return result;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43426,
                "title": "4ms-solution-with-comments-single-loop-no-extra-memory",
                "content": "    int singleNumber(int A[], int n) {\\n    int r = 0, c = 0; \\n    // r A c | r  c\\n    // 0 0 0 | 0  0\\n    // 0 0 1 | 0  1\\n    // 0 1 0 | 1  0  ==> r = (~r & A & ~c) | (r & ~A & ~c)\\n    // 0 1 1 | 0  0  ==> c = (~r & ~A & c) | (r & A & ~c)\\n    // 1 0 0 | 1  0\\n    // 1 0 1 | 0  0\\n    // 1 1 0 | 0  1\\n    // 1 1 1 | 0  0\\n   \\n    while(n > 0) {\\n        --n;\\n        int t =  (~r & A[n] & ~c) | (r & ~A[n] & ~c); \\n        c = (~r & ~A[n] & c) | (r & A[n] & ~c);\\n        r = t;\\n    }\\n    return r; \\n}",
                "solutionTags": [],
                "code": "    int singleNumber(int A[], int n) {\\n    int r = 0, c = 0; \\n    // r A c | r  c\\n    // 0 0 0 | 0  0\\n    // 0 0 1 | 0  1\\n    // 0 1 0 | 1  0  ==> r = (~r & A & ~c) | (r & ~A & ~c)\\n    // 0 1 1 | 0  0  ==> c = (~r & ~A & c) | (r & A & ~c)\\n    // 1 0 0 | 1  0\\n    // 1 0 1 | 0  0\\n    // 1 1 0 | 0  1\\n    // 1 1 1 | 0  0\\n   \\n    while(n > 0) {\\n        --n;\\n        int t =  (~r & A[n] & ~c) | (r & ~A[n] & ~c); \\n        c = (~r & ~A[n] & c) | (r & A[n] & ~c);\\n        r = t;\\n    }\\n    return r; \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3721401,
                "title": "simple-iteration-method-with-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nneed a map for saving the frequency of the elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate a map , save frequency of elements in it. return the element with frequency 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(auto i: nums){\\n            mp[i]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==1)return x.first;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(auto i: nums){\\n            mp[i]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==1)return x.first;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715044,
                "title": "simple-c-bit-manipulation",
                "content": "This is the general question . \\n\\nYou may encounter where every digit appears 2 times except one then in that cases k=2 and p=1 ->k is 2, then m = 1, we need only one 32-bit integer (x1) as the counter. And 2^m = k so we do not even need a mask.\\n\\n``here \\n(k = 3, p = 1)\\nk is 3, then m = 2, we need two 32-bit integers(x2, x1) as the counter. And 2^m > k so we do need a mask. Write k in its binary form: k = \\'11\\', then k1 = 1, k2 = 1, so we have mask = ~(x1 & x2).``\\n\\n\\nIf k = 5, p = 3\\nk is 5, then m = 3, we need three 32-bit integers(x3, x2, x1) as the counter. And 2^m > k so we need a mask. Write k in its binary form: k = \\'101\\', then k1 = 1, k2 = 0, k3 = 1, so we have mask = ~(x1 & ~x2 & x3). \\n\\nIf you like the Solution then upvote me.\\n\\nCase->(k = 3, p = 1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int x1=0,x2=0,mask=0;\\n        for(auto i:nums)\\n        {\\n            x2^=x1&i;\\n            x1^=i;\\n            mask=~(x2&x1);\\n            x2&=mask;\\n            x1&=mask;\\n        }\\n        return x1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int x1=0,x2=0,mask=0;\\n        for(auto i:nums)\\n        {\\n            x2^=x1&i;\\n            x1^=i;\\n            mask=~(x2&x1);\\n            x2&=mask;\\n            x1&=mask;\\n        }\\n        return x1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714874,
                "title": "java-easy-2-step-bit-manipulation",
                "content": "# Explanation:\\nInitialize two variables, ones and twos, to keep track of the count of each bit position.\\n\\nones: Tracks the bits that have appeared once.\\ntwos: Tracks the bits that have appeared twice.\\nIterate through the array of numbers.\\n\\nFor each number i in the array:\\nUpdate ones and twos:\\n\\nLet\\'s analyze each step of the update process:\\n\\na. ones = (ones ^ i) & (~twos);:\\n\\nones ^ i XORs the current number i with the previous value of ones. This operation toggles the bits that have appeared an odd number of times, keeping the bits that have appeared twice unchanged.\\n(~twos) negates the bits in twos, effectively removing the bits that have appeared twice from consideration.\\nThe & operation ensures that only the bits that have appeared once (after XOR) and not twice (after negating twos) are retained.\\n\\nb. twos = (twos ^ i) & (~ones);:\\n\\ntwos ^ i XORs the current number i with the previous value of twos. This operation toggles the bits that have appeared an even number of times, effectively removing the bits that have appeared twice.\\n(~ones) negates the bits in ones, effectively removing the bits that have appeared once from consideration.\\nThe & operation ensures that only the bits that have appeared twice (after XOR) and not once (after negating ones) are retained.\\nAfter iterating through all the numbers, the value stored in ones will represent the single number that appears only once in the array.\\n\\nLet\\'s understand why this approach works:\\n\\nThe key idea is to use bitwise operations to keep track of the count of each bit position. By doing so, we can identify the bits that have appeared once, twice, or three times.\\nWhen a bit appears for the first time (ones is 0 and the bit is toggled), it is stored in ones.\\nWhen a bit appears for the second time (ones is 1 and the bit is toggled), it is removed from ones and stored in twos.\\nWhen a bit appears for the third time (ones is 0 and the bit is toggled), it is removed from both ones and twos.\\nBy the end of the iteration, the bits that remain in ones represent the bits of the single number that appeared only once, while the bits in twos represent bits that appeared three times (which is not possible).\\nIn summary, the algorithm uses bit manipulation to efficiently keep track of the counts of each bit position. By utilizing XOR and AND operations, it can identify the bits of the single number that appears only once in the array while ignoring the bits that appear multiple times.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       int ones = 0, twos = 0;\\n        for(int e : nums) {\\n            ones = ((ones ^ e) & (~ twos));  \\n            twos = ((twos ^ e) & (~ ones)); \\n        }\\n        return ones;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       int ones = 0, twos = 0;\\n        for(int e : nums) {\\n            ones = ((ones ^ e) & (~ twos));  \\n            twos = ((twos ^ e) & (~ ones)); \\n        }\\n        return ones;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190823,
                "title": "solution-using-bit-tricks",
                "content": "# Time Complexity - O(32*N)\\n# Space - O(1)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans= 0;\\n        for(int i=0;i<32;i++){\\n            int ctBits = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j] &(1<<i))) // if bit is set     \\n                    ctBits++;\\n            }\\n            ctBits %=3;\\n\\n            if(ctBits==1)\\n            ans |=(1<<i); // if that position has 3*k+1 bits then set that bit into our ans\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---\\n\\n# Most Optimised Solution\\n# Time Complexity - O(N)\\n# Space - O(1)\\n\\nThe idea is that while traversing in the array , at any postion we have three types of bitcounts 3n , 3n+1 and 3n+2 and our answer is the bits of 3n+1 type in the last iteration.\\nSo what we can do, we can maintain 3 numbers \\nWe intialise 3n number as all set bits and other two as zero.\\n\\n    Eg - [ 2, 2, 3, 2 ]    \\n|  | 3n | 3n+1 | 3n+2 |\\n| :--- | ---:| :---: | :---:|\\n|  start   |    111111 |   000000 |  000000 |    \\n| 2 --0010 |    000000 |   000010 |  000000 |\\n| 2 --0010 |    000000 |   000000 |  000010 |\\n| 3 --0011 |    000010 |   000001 |  000000 |\\n| 2 --0010 |    000000 |   000011 |  000000 |\\n    \\n    \\n      Answer - 3n+1 = 000011 = 3 \\n\\nSo how can we update the numbers at every iteration?\\nWell, if a bit is set in 3n and also set in A[i] ,then this bit will become a 3n+1 type bit , so we have to remove these common bits from 3n and add those bits in 3n+1. and similarly for 3n+1 and 3n+2 types also.\\nNow i think you get the idea why i have initialise the 3n type with 111....111(= -1) and other with zero.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& a) {\\n       int t3n=-1,t3n1=0,t3n2=0;\\n       for (int i=0;i<a.size();i++){\\n           int comt3n =  t3n &a[i]; // common bits with 3n types\\n           int comt3n1 = t3n1 &a[i];// common bits with 3n+1 types\\n           int comt3n2 = t3n2 &a[i];// common bits with 3n+2 types\\n\\n           t3n = t3n &(~comt3n); // remove common bits from 3n type\\n           t3n1 = t3n1| comt3n;  // add those bits to 3n+1 type\\n\\n           t3n1 = t3n1 &(~comt3n1);// remove common bits from 3n+1 type\\n           t3n2 = t3n2| comt3n1; // add those bits to 3n+2 type\\n\\n           t3n2 = t3n2 &(~comt3n2);// remove common bits from 3n+2 type\\n           t3n = t3n| comt3n2; // add those bits to 3n type\\n       }\\n\\n       return t3n1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans= 0;\\n        for(int i=0;i<32;i++){\\n            int ctBits = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j] &(1<<i))) // if bit is set     \\n                    ctBits++;\\n            }\\n            ctBits %=3;\\n\\n            if(ctBits==1)\\n            ans |=(1<<i); // if that position has 3*k+1 bits then set that bit into our ans\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& a) {\\n       int t3n=-1,t3n1=0,t3n2=0;\\n       for (int i=0;i<a.size();i++){\\n           int comt3n =  t3n &a[i]; // common bits with 3n types\\n           int comt3n1 = t3n1 &a[i];// common bits with 3n+1 types\\n           int comt3n2 = t3n2 &a[i];// common bits with 3n+2 types\\n\\n           t3n = t3n &(~comt3n); // remove common bits from 3n type\\n           t3n1 = t3n1| comt3n;  // add those bits to 3n+1 type\\n\\n           t3n1 = t3n1 &(~comt3n1);// remove common bits from 3n+1 type\\n           t3n2 = t3n2| comt3n1; // add those bits to 3n+2 type\\n\\n           t3n2 = t3n2 &(~comt3n2);// remove common bits from 3n+2 type\\n           t3n = t3n| comt3n2; // add those bits to 3n type\\n       }\\n\\n       return t3n1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106228,
                "title": "c-bit-manipulation-solution-fast-simple-try-once",
                "content": "\\t**All suggestions are welcome.\\n\\tIf you have any query or suggestion please comment below.\\n\\tPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n         int ans=0;\\n        for(int i=0 ; i<32 ; i++){\\n            int sum =0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j]>>i) & 1){ sum++;}\\n            }\\n            if(sum%3!=0){\\n                ans = ans | 1<<i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n         int ans=0;\\n        for(int i=0 ; i<32 ; i++){\\n            int sum =0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j]>>i) & 1){ sum++;}\\n            }\\n            if(sum%3!=0){\\n                ans = ans | 1<<i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772454,
                "title": "c-count-freq-of-each-bit-similar-to-xor",
                "content": "Before solving this question. solve the following one.\\n\\nhttps://leetcode.com/problems/single-number/\\n\\nIn the above question, since all elements occus twice and only one element occur once. so we use xor.\\nBecause when we get 2 \\'1\\'s in a bit , the result is \\'0\\' in that bit. so all the elements that are occuring twice, xor makes the effect of those nullified.\\n\\nIn this question. Each element except the answer occurs thrice.\\nSo instead of nullifying a bit when 2 \\'1\\'s occurs in a bit , we should nullify when we get 3 \\'1\\'s.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums)\\n    {\\n        vector<int> freq(32,0)  ;\\n        \\n        for(auto x : nums)\\n        {\\n            for(int i=0;i<32;i++)\\n            {\\n                if(x&(1<<i))\\n                    freq[i]++ ;\\n            }\\n        }\\n        \\n        int ans = 0 ;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            int f = freq[i] ;\\n            \\n            f = f%3 ;\\n            \\n            if(f)\\n                ans = ans + (1<<i) ;\\n        }\\n        \\n       \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums)\\n    {\\n        vector<int> freq(32,0)  ;\\n        \\n        for(auto x : nums)\\n        {\\n            for(int i=0;i<32;i++)\\n            {\\n                if(x&(1<<i))\\n                    freq[i]++ ;\\n            }\\n        }\\n        \\n        int ans = 0 ;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            int f = freq[i] ;\\n            \\n            f = f%3 ;\\n            \\n            if(f)\\n                ans = ans + (1<<i) ;\\n        }\\n        \\n       \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752436,
                "title": "simple-c-solution-o-1-space-and-o-32-n-time-complexity",
                "content": "According to the problem every number occurs thrice  except one .So we will count the number of set bits for each position , and whenever we get the no of set bits which is not a multiple of 3 it concludes that that particular bit is set in the single number .So we will add these masks and the result will be answer.Follow the code for more clarity.. Please do upvote if yu like my explanation.This is my first article.\\nOne more point this solution can work for all similar type of problems where all numbers except one occur k times and the remainimg one occurs m times..\\n\\nTime Complexity=0(32*n);\\nSpace Complexity=O(1);\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=0;i<=31;i++){\\n            int cnt=0;\\n            for(auto x:nums){\\n                if(x&(1<<i))cnt++;\\n            }\\n            if(cnt%3)res+=1<<i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=0;i<=31;i++){\\n            int cnt=0;\\n            for(auto x:nums){\\n                if(x&(1<<i))cnt++;\\n            }\\n            if(cnt%3)res+=1<<i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739638,
                "title": "solution-swift-single-number-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ones = 0, twos = 0\\n        for n in nums {\\n            ones = ones ^ n & ~twos\\n            twos = twos ^ n & ~ones\\n        }\\n        return ones\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.008 (0.010) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.singleNumber([2,2,3,2])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.singleNumber([0,1,0,1,0,1,99])\\n        XCTAssertEqual(value, 99)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ones = 0, twos = 0\\n        for n in nums {\\n            ones = ones ^ n & ~twos\\n            twos = twos ^ n & ~ones\\n        }\\n        return ones\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.singleNumber([2,2,3,2])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.singleNumber([0,1,0,1,0,1,99])\\n        XCTAssertEqual(value, 99)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573364,
                "title": "java-simple-solution",
                "content": "The idea of this solution is that we find the count of sets bits in every postion from bit 1 to bit 32 for the whole array. If for bit position 1 we get count which is not multiple of 3 then it means the result has bit set in 1st postion.\\n\\nSimiliary we check count of bits in whole array for all position.\\nNote: The advantage for this approach is that it can be easily handle situation when other numbers repeat 3time, 4times or any N times. We can just replace count % 3 with count % N.\\n```\\npublic int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i=0; i<=31; i++) {\\n            int count = getCount(i,nums);\\n            if(count % 3 != 0) result = result + (1<<i);\\n        }\\n        return result;\\n    }\\n    \\n    private int getCount(int position, int[] arr) {\\n        int count = 0;\\n        for(int i=0; i<arr.length; i++) {\\n            if( (arr[i] & 1<<position) != 0) count++; \\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i=0; i<=31; i++) {\\n            int count = getCount(i,nums);\\n            if(count % 3 != 0) result = result + (1<<i);\\n        }\\n        return result;\\n    }\\n    \\n    private int getCount(int position, int[] arr) {\\n        int count = 0;\\n        for(int i=0; i<arr.length; i++) {\\n            if( (arr[i] & 1<<position) != 0) count++; \\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364857,
                "title": "c-o-n-time-o-1-space-clean-concise-solution-with-detailed-explaination",
                "content": "* **Solution**\\nWe count the number of every bit 1 in one position of every element in an array ( position is from 0 to 31 ) because every element appears three times except one element so if the number of bit 1 in one position mod 3 = 0 the bit in that position in our result will be zero otherwise it will be 1. \\n\\n* **Time Complexity**\\nWe just go through all the element of the array size n so the time complexity is O(32n) or **O(n)**.\\n\\n* **Space Complexity**\\nWe just use constant number of variables so the space compleixty is **O(1)**.\\n\\n* **Source Code**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size(),res=0;\\n        for (int i=0;i<32;++i) {\\n            int sum = 0;\\n            int mask = 1<<i;\\n            for (int j=0;j<n;++j) \\n                if ( (nums[j] & mask) !=0)\\n                    ++sum;\\n            if (sum%3!=0) \\n                res |= mask;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size(),res=0;\\n        for (int i=0;i<32;++i) {\\n            int sum = 0;\\n            int mask = 1<<i;\\n            for (int j=0;j<n;++j) \\n                if ( (nums[j] & mask) !=0)\\n                    ++sum;\\n            if (sum%3!=0) \\n                res |= mask;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249795,
                "title": "c-easy-to-understand-using-two-approaches",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\n**Using hashtables-[time complexity O(n) and space complexity O(n)]**\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second==1)\\n            return it.first;\\n        }\\n        return 0;\\n    }\\n};\\n**Using bitwise operators[time complexity O(n) and space complexity O(1)]**\\nclass Solution {\\npublic:\\nint singleNumber(vector<int>& nums) {\\nint ones = 0, twos = 0;\\nfor(int i = 0; i < nums.size(); i++){\\nones = (ones ^ nums[i]) & ~twos;\\ntwos = (twos ^ nums[i]) & ~ones;\\n}\\nreturn ones;\\n}\\n};",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1245007,
                "title": "simple-c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j < n; j++) {\\n                if(((nums[j]&(1<<i)) != 0)) {\\n                    cnt+=1;\\n                }\\n            }\\n            res|=((cnt%3)<<i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**please upvote if you like it.**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j < n; j++) {\\n                if(((nums[j]&(1<<i)) != 0)) {\\n                    cnt+=1;\\n                }\\n            }\\n            res|=((cnt%3)<<i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165580,
                "title": "generic-way-to-solve-k-repeat-1-single-problems",
                "content": "```\\nclass Solution {\\npublic:\\n    // All numbers appear exactly K times but one number appears only once. Find it.\\n    // TC: O(32 * N) ~ O(N)\\n    int getSingleNumber(vector<int>&arr, int K)\\n    {\\n        long long singleNumber = 0;\\n        for(int bit = 0; bit < 32; bit++)\\n        {\\n            int bitcount = 0;\\n            for(auto &val : arr)\\n            {\\n                if(val & (1LL << bit))\\n                    bitcount++;\\n            }\\n            if(bitcount % K == 1)\\n                singleNumber |= 1LL << bit;\\n        }\\n        return (int)singleNumber;\\n    }\\n    int singleNumber(vector<int>& nums) {\\n        return getSingleNumber(nums, 3);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // All numbers appear exactly K times but one number appears only once. Find it.\\n    // TC: O(32 * N) ~ O(N)\\n    int getSingleNumber(vector<int>&arr, int K)\\n    {\\n        long long singleNumber = 0;\\n        for(int bit = 0; bit < 32; bit++)\\n        {\\n            int bitcount = 0;\\n            for(auto &val : arr)\\n            {\\n                if(val & (1LL << bit))\\n                    bitcount++;\\n            }\\n            if(bitcount % K == 1)\\n                singleNumber |= 1LL << bit;\\n        }\\n        return (int)singleNumber;\\n    }\\n    int singleNumber(vector<int>& nums) {\\n        return getSingleNumber(nums, 3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982107,
                "title": "c-bit-manipulation-with-detailed-explanation-plus-some-generalization",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Bit operation, xor operation can detect (flag) when 1 appears odd number of times. But in this case, we need to distinguish the 1 times from 3 times. \\n\\t\\t// Since only two states available for each binary bit, we need thus two bits (thus allow 4 states) for each bit detection, in other words, we use two variables.\\n        // Recall in Problem 136, we have one variable. Each bit in this variable help us distinguish the odd from even number of times.\\n        // Now, we use two variables, seen_once, seen_twice. Bit in seen_once is 1 only when 1 in this bit position appears 1 time. Bit in seen_twice is 1 only when 1 in this bit position appears 2 times. \\n\\t\\t// The corresponding transformation table is below:\\n        // Number of appearance:        0 time,  1 time,  2 times,  3 times\\n        // seen_once:                    0       ,1      , 0        ,0\\n        // seen_twice:                   0       ,0      , 1        ,0\\n\\t\\t// We now need to construct transformation rules to produce the above table, for example:\\n        // seen_once = (seen_once ^ num) & (~seen_twice);\\n        // seen_twice = (seen_twice ^ num) & (~seen_once);\\n        // Note the order is very important here. You must update seen_once variable before updting seen_twice. \\n\\t\\t// (~seen_twice) is used to notify seen_once to ignore when 1 is about to appear 3 times. (Remember 1 should have appeared already two times in order to appear 3 times.)\\n\\t\\t// (~seen_once) is used to make xor operation detect even times of appearance instead of odd times. \\n        // In fact, you can come up with other transformations as long as they give the above table.\\n\\t\\t// Since bits (seen_once, seen_twice) will be 0 whenever 1 appears 3 or 3n times, while seen_once will be 1 when 1 appears 1 time, we can simply return seen_once at the end of program.\\n        // As you can see, using two variables with the above transformation gives 3 different states instead of only 2 states if using 1 variable (mod 2).\\n\\t\\t// If we want to distinguish 1 time from 5 number of times, we need to have the following table using 3 variables:\\n        // Number of appearance:        0 time,  1 time,  2 times,  3 times,  4 times   5 times\\n        // first_bit:                    0       ,1      , 0        ,1         ,0        0\\n        // second_bit:                   0       ,0      , 1        ,1         ,0        0\\n        // third_bit:                    0       ,0      , 0,       ,0         ,1        0\\n        // This table could let us distinguish 5 states, and any bit (first_bit, second_bit, third_bit) will be 0 as long as 1 appears 5 times or 5n times. One of possible transformation rules are below as an example:\\n        // first_bit = (first_bit ^ num) & (~third_bit);\\n        // second_bit = (first_bit & second_bit | ~first_bit & (second_bit ^ num)) & (~third_bit)\\n        // third_bit = (third_bit ^ num) & (~(first_bit | second_bit))\\n\\t\\t// Anyway, once construct the transformation table, you could play around to think of  the corresponding rules.\\n        int first_bit = 0, second_bit = 0;\\n        for(auto num:nums){\\n           first_bit = (first_bit ^ num) & (~second_bit);\\n           second_bit = (second_bit ^ num) & (~first_bit);\\n        }\\n        return first_bit;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Bit operation, xor operation can detect (flag) when 1 appears odd number of times. But in this case, we need to distinguish the 1 times from 3 times. \\n\\t\\t// Since only two states available for each binary bit, we need thus two bits (thus allow 4 states) for each bit detection, in other words, we use two variables.\\n        // Recall in Problem 136, we have one variable. Each bit in this variable help us distinguish the odd from even number of times.\\n        // Now, we use two variables, seen_once, seen_twice. Bit in seen_once is 1 only when 1 in this bit position appears 1 time. Bit in seen_twice is 1 only when 1 in this bit position appears 2 times. \\n\\t\\t// The corresponding transformation table is below:\\n        // Number of appearance:        0 time,  1 time,  2 times,  3 times\\n        // seen_once:                    0       ,1      , 0        ,0\\n        // seen_twice:                   0       ,0      , 1        ,0\\n\\t\\t// We now need to construct transformation rules to produce the above table, for example:\\n        // seen_once = (seen_once ^ num) & (~seen_twice);\\n        // seen_twice = (seen_twice ^ num) & (~seen_once);\\n        // Note the order is very important here. You must update seen_once variable before updting seen_twice. \\n\\t\\t// (~seen_twice) is used to notify seen_once to ignore when 1 is about to appear 3 times. (Remember 1 should have appeared already two times in order to appear 3 times.)\\n\\t\\t// (~seen_once) is used to make xor operation detect even times of appearance instead of odd times. \\n        // In fact, you can come up with other transformations as long as they give the above table.\\n\\t\\t// Since bits (seen_once, seen_twice) will be 0 whenever 1 appears 3 or 3n times, while seen_once will be 1 when 1 appears 1 time, we can simply return seen_once at the end of program.\\n        // As you can see, using two variables with the above transformation gives 3 different states instead of only 2 states if using 1 variable (mod 2).\\n\\t\\t// If we want to distinguish 1 time from 5 number of times, we need to have the following table using 3 variables:\\n        // Number of appearance:        0 time,  1 time,  2 times,  3 times,  4 times   5 times\\n        // first_bit:                    0       ,1      , 0        ,1         ,0        0\\n        // second_bit:                   0       ,0      , 1        ,1         ,0        0\\n        // third_bit:                    0       ,0      , 0,       ,0         ,1        0\\n        // This table could let us distinguish 5 states, and any bit (first_bit, second_bit, third_bit) will be 0 as long as 1 appears 5 times or 5n times. One of possible transformation rules are below as an example:\\n        // first_bit = (first_bit ^ num) & (~third_bit);\\n        // second_bit = (first_bit & second_bit | ~first_bit & (second_bit ^ num)) & (~third_bit)\\n        // third_bit = (third_bit ^ num) & (~(first_bit | second_bit))\\n\\t\\t// Anyway, once construct the transformation table, you could play around to think of  the corresponding rules.\\n        int first_bit = 0, second_bit = 0;\\n        for(auto num:nums){\\n           first_bit = (first_bit ^ num) & (~second_bit);\\n           second_bit = (second_bit ^ num) & (~first_bit);\\n        }\\n        return first_bit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951472,
                "title": "python-bit-wise-solution",
                "content": "Consider the following operations:\\n0 ^ x = x,\\n\\nx ^ x = 0\\uFF1B\\n\\nx & ~x = 0,\\n\\nx & ~0 =x;\\n\\nif x appears once, a=x, b=0;\\nif x appears twice, a=0,b=x;\\nif x appears triple, a=0,b=0;\\nTherefore, the first case correponds to the single number, a will be the answer.\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a,b=0,0\\n        for num in nums:\\n            a=(a^num)&(~b)\\n            b=(b^num)&(~a)\\n            \\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a,b=0,0\\n        for num in nums:\\n            a=(a^num)&(~b)\\n            b=(b^num)&(~a)\\n            \\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763396,
                "title": "detailed-explained-solution-with-bit-wise-operator",
                "content": "```\\nclass Solution {\\npublic:\\n    //ones - At any point of time, this variable holds XOR of all the elements which have\\n    //appeared \"only\" once. \\n    //twos - At any point of time, this variable holds XOR of all the elements which have\\n    //appeared \"only\" twice.\\n\\n    //So if at any point time,\\n    //1. A new number appears - It gets XOR\\'d to the variable \"ones\".\\n    //2. A number gets repeated(appears twice) - It is removed from \"ones\" and XOR\\'d to the\\n    //variable \"twice\".\\n    //3. A number appears for the third time - It gets removed from both \"ones\" and \"twice\".\\n\\n    //The final answer we want is the value present in \"ones\" - coz, it holds the unique element.\\n\\n    //So if we explain how steps 1 to 3 happens in the code, we are done.\\n    //Before explaining above 3 steps, lets look at last three lines of the code,\\n\\n    //not_threes = ~(ones & twos)\\n    //ones & = not_threes\\n    //twos & = not_threes\\n\\n    //All it does is, common 1\\'s between \"ones\" and \"twos\" are converted to zero.\\n\\n    //For simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique     //element and 3 repeated elements - in any order).\\n\\n    //Explanation for step 1\\n    //------------------------\\n    //Lets say a new element(x) appears.\\n    //CURRENT SITUATION - Both variables - \"ones\" and \"twos\" has not recorded \"x\".\\n\\n    //Observe the statement \"twos| = ones & x\".\\n    //Since bit representation of \"x\" is not present in \"ones\", AND condition yields nothing. So \"twos\" does not get     //bit representation of \"x\".\\n    //But, in next step \"ones ^= x\" - \"ones\" ends up adding bits of \"x\". Thus new element gets recorded in \"ones\"       //but not in \"twos\".\\n\\n    //The last 3 lines of code as explained already, converts common 1\\'s b/w \"ones\" and \"twos\" to zeros.\\n    //Since as of now, only \"ones\" has \"x\" and not \"twos\" - last 3 lines does nothing.\\n\\n    //Explanation for step 2.\\n    //------------------------\\n    //Lets say an element(x) appears twice.\\n    //CURRENT SITUATION - \"ones\" has recorded \"x\" but not \"twos\".\\n\\n    //Now due to the statement, \"twos| = ones & x\" - \"twos\" ends up getting bits of x.\\n    //But due to the statement, \"ones ^ = x\" - \"ones\" removes \"x\" from its binary representation.\\n\\n    //Again, last 3 lines of code does nothing.\\n    //So ultimately, \"twos\" ends up getting bits of \"x\" and \"ones\" ends up losing bits of \"x\".\\n\\n    //Explanation for step 3.\\n    //-------------------------\\n    //Lets say an element(x) appears for the third time.\\n    //CURRENT SITUATION - \"ones\" does not have bit representation of \"x\" but \"twos\" has.\\n\\n    //Though \"ones & x\" does not yield nothing .. \"twos\" by itself has bit representation of \"x\". So after this         //statement, \"two\" has bit representation of \"x\".\\n    //Due to \"ones^=x\", after this step, \"one\" also ends up getting bit representation of \"x\".\\n\\n    //Now last 3 lines of code removes common 1\\'s of \"ones\" and \"twos\" - which is the bit representation of \"x\".\\n    //Thus both \"ones\" and \"twos\" ends up losing bit representation of \"x\".\\n\\n    //1st example\\n    //------------\\n    //2, 2, 2, 4\\n\\n    //After first iteration,\\n    //ones = 2, twos = 0\\n    //After second iteration,\\n    //ones = 0, twos = 2\\n    //After third iteration,\\n    //ones = 0, twos = 0\\n    //After fourth iteration,\\n    //ones = 4, twos = 0\\n\\n    //2nd example\\n    //------------\\n    //4, 2, 2, 2\\n\\n    //After first iteration,\\n    //ones = 4, twos = 0\\n    //After second iteration,\\n    //ones = 6, twos = 0\\n    //After third iteration,\\n    //ones = 4, twos = 2\\n    //After fourth iteration,\\n    //ones = 4, twos = 0\\n    //Explanation copied from : https://www.careercup.com/question?id=7902674\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0;\\n        int twos = 0;\\n        int non_threes = 0;\\n        \\n        for(int digIdx = 0; digIdx < nums.size(); digIdx++){\\n            twos |= (ones & nums[digIdx]);\\n            ones ^= nums[digIdx];\\n            \\n            non_threes = ~(ones & twos);\\n            ones &= non_threes;\\n            twos &= non_threes;\\n        }\\n        \\n        return ones;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //ones - At any point of time, this variable holds XOR of all the elements which have\\n    //appeared \"only\" once. \\n    //twos - At any point of time, this variable holds XOR of all the elements which have\\n    //appeared \"only\" twice.\\n\\n    //So if at any point time,\\n    //1. A new number appears - It gets XOR\\'d to the variable \"ones\".\\n    //2. A number gets repeated(appears twice) - It is removed from \"ones\" and XOR\\'d to the\\n    //variable \"twice\".\\n    //3. A number appears for the third time - It gets removed from both \"ones\" and \"twice\".\\n\\n    //The final answer we want is the value present in \"ones\" - coz, it holds the unique element.\\n\\n    //So if we explain how steps 1 to 3 happens in the code, we are done.\\n    //Before explaining above 3 steps, lets look at last three lines of the code,\\n\\n    //not_threes = ~(ones & twos)\\n    //ones & = not_threes\\n    //twos & = not_threes\\n\\n    //All it does is, common 1\\'s between \"ones\" and \"twos\" are converted to zero.\\n\\n    //For simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique     //element and 3 repeated elements - in any order).\\n\\n    //Explanation for step 1\\n    //------------------------\\n    //Lets say a new element(x) appears.\\n    //CURRENT SITUATION - Both variables - \"ones\" and \"twos\" has not recorded \"x\".\\n\\n    //Observe the statement \"twos| = ones & x\".\\n    //Since bit representation of \"x\" is not present in \"ones\", AND condition yields nothing. So \"twos\" does not get     //bit representation of \"x\".\\n    //But, in next step \"ones ^= x\" - \"ones\" ends up adding bits of \"x\". Thus new element gets recorded in \"ones\"       //but not in \"twos\".\\n\\n    //The last 3 lines of code as explained already, converts common 1\\'s b/w \"ones\" and \"twos\" to zeros.\\n    //Since as of now, only \"ones\" has \"x\" and not \"twos\" - last 3 lines does nothing.\\n\\n    //Explanation for step 2.\\n    //------------------------\\n    //Lets say an element(x) appears twice.\\n    //CURRENT SITUATION - \"ones\" has recorded \"x\" but not \"twos\".\\n\\n    //Now due to the statement, \"twos| = ones & x\" - \"twos\" ends up getting bits of x.\\n    //But due to the statement, \"ones ^ = x\" - \"ones\" removes \"x\" from its binary representation.\\n\\n    //Again, last 3 lines of code does nothing.\\n    //So ultimately, \"twos\" ends up getting bits of \"x\" and \"ones\" ends up losing bits of \"x\".\\n\\n    //Explanation for step 3.\\n    //-------------------------\\n    //Lets say an element(x) appears for the third time.\\n    //CURRENT SITUATION - \"ones\" does not have bit representation of \"x\" but \"twos\" has.\\n\\n    //Though \"ones & x\" does not yield nothing .. \"twos\" by itself has bit representation of \"x\". So after this         //statement, \"two\" has bit representation of \"x\".\\n    //Due to \"ones^=x\", after this step, \"one\" also ends up getting bit representation of \"x\".\\n\\n    //Now last 3 lines of code removes common 1\\'s of \"ones\" and \"twos\" - which is the bit representation of \"x\".\\n    //Thus both \"ones\" and \"twos\" ends up losing bit representation of \"x\".\\n\\n    //1st example\\n    //------------\\n    //2, 2, 2, 4\\n\\n    //After first iteration,\\n    //ones = 2, twos = 0\\n    //After second iteration,\\n    //ones = 0, twos = 2\\n    //After third iteration,\\n    //ones = 0, twos = 0\\n    //After fourth iteration,\\n    //ones = 4, twos = 0\\n\\n    //2nd example\\n    //------------\\n    //4, 2, 2, 2\\n\\n    //After first iteration,\\n    //ones = 4, twos = 0\\n    //After second iteration,\\n    //ones = 6, twos = 0\\n    //After third iteration,\\n    //ones = 4, twos = 2\\n    //After fourth iteration,\\n    //ones = 4, twos = 0\\n    //Explanation copied from : https://www.careercup.com/question?id=7902674\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0;\\n        int twos = 0;\\n        int non_threes = 0;\\n        \\n        for(int digIdx = 0; digIdx < nums.size(); digIdx++){\\n            twos |= (ones & nums[digIdx]);\\n            ones ^= nums[digIdx];\\n            \\n            non_threes = ~(ones & twos);\\n            ones &= non_threes;\\n            twos &= non_threes;\\n        }\\n        \\n        return ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700038,
                "title": "javascript-bitwise-solution-with-explanation",
                "content": "Here we treat every number as a set of bits. When looping through the array we will get rid of bits that occured **three** times. And we will keep bits that occured only **once**. This way we\\'ll end up with bits that form the number we\\'re looking for.\\n\\n* We define two variables: **singles** and **doubles**. In **singles** we keep bits that occured once, in **doubles** we keep bits that occured twice;\\n* Every bit from every number comes to **singles** first;\\n* When it comes second time it\\'s dropped to **doubles**;\\n* When it comes third time it\\'s removed from **doubles**;\\n* This way we ensure that all the bits that occured three times are sifted;\\n* Basically, we don\\'t care with which numbers bits come, we just count bit occurances;\\n* In the end we can just return **singles** as a result as it will hold bits of a number that occured only once.\\n\\n```js\\nvar singleNumber = function(nums) {\\n    let singles = 0;\\n    let doubles = 0;\\n\\n    for (num of nums) {\\n        // Add to singles if it\\'s not in doubles. Also remove from singles if it\\'s in there\\n        singles = (~doubles) & (singles ^ num);\\n        // Add to doubles if it\\'s not in singles. Also remove from doubles if it\\'s in there\\n        doubles = (~singles) & (doubles ^ num);\\n    }\\n\\n    return singles;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```js\\nvar singleNumber = function(nums) {\\n    let singles = 0;\\n    let doubles = 0;\\n\\n    for (num of nums) {\\n        // Add to singles if it\\'s not in doubles. Also remove from singles if it\\'s in there\\n        singles = (~doubles) & (singles ^ num);\\n        // Add to doubles if it\\'s not in singles. Also remove from doubles if it\\'s in there\\n        doubles = (~singles) & (doubles ^ num);\\n    }\\n\\n    return singles;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 446728,
                "title": "c-solution-linear-time-without-extra-space-bit-manipulation-8ms",
                "content": "Runtime: 8 ms, faster than 97.08% of C++ online submissions for Single Number II.\\nMemory Usage: 9.6 MB, less than 87.50% of C++ online submissions for Single Number II.\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int res = 0;\\n        for(int i=0; i<32; i++)\\n        {\\n            int mask = (1 << i);\\n            int count = 0;\\n            for(int j=0; j<nums.size(); j++)\\n                if(mask&nums[j]) count++;\\n            if(count%3)\\n                res |= (1<<i);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int res = 0;\\n        for(int i=0; i<32; i++)\\n        {\\n            int mask = (1 << i);\\n            int count = 0;\\n            for(int j=0; j<nums.size(); j++)\\n                if(mask&nums[j]) count++;\\n            if(count%3)\\n                res |= (1<<i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 384270,
                "title": "o-n-constant-space-solution-with-intuitive-analysis",
                "content": "Let the number appearing once be x. Let S(x) be the positions whose values equal to 1 for the binary representation of x. For example, when x=3, S(x)={0,1}. \\nFor all the numbers, at the positions other than S(x), the number of 1s appearing is 3k, i.e., a multiple of 3; at the positions of S(x), the number of 1s is 3k+1. So if we record the number of 1s appearing for each position, then use the positions where 1s appear 3k+1 to reconstruct x. \\nFor each position, 1s could appear 3k,3k+1,3k+2 times. To represent 3 statuses, we at least need 2 bits for each position (that is why we need m1,m2 and no need for m3). \\nFor each position, we check manipulate as follows: if the previous status is (0,0) for (m1,m2), when there is 1, we change the status into (1,0); if the previous status is (1,0), when there is 1, we change the status into (0,1).. etc. \\nThe manipulation of each bit can be simplified into a whole integer xor and land. \\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    /**\\n    times   m1  m2\\n    0   0   0\\n    1   1   0\\n    2   0   1\\n    3   0   0\\n    4   1   0\\n    5   0   1\\n    */\\n    int singleNumber(vector<int>& nums) {\\n        int m1 = 0, m2 = 0;\\n        for (auto n : nums) {\\n            m1 = (m1 ^ n) & (~m2);\\n            m2 = (m2 ^ n) & (~m1);\\n        }\\n        return m1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /**\\n    times   m1  m2\\n    0   0   0\\n    1   1   0\\n    2   0   1\\n    3   0   0\\n    4   1   0\\n    5   0   1\\n    */\\n    int singleNumber(vector<int>& nums) {\\n        int m1 = 0, m2 = 0;\\n        for (auto n : nums) {\\n            m1 = (m1 ^ n) & (~m2);\\n            m2 = (m2 ^ n) & (~m1);\\n        }\\n        return m1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346517,
                "title": "comprehensive-explanation-for-those-confused-using-python",
                "content": "This post emphasizes on explanation of the concept, not on performance.\\n\\nThere has been a number of good posts describing the idea of bitwise operations. They are all correct, but may fall short in explaning the code, plus the usage of various tricks and shortcuts and arbitrary variable names, making them a bit black-magic.\\n\\nI\\'ll try to explain with code what really happens within these approaches.\\n\\nPrerequisite: you should know what bitwise operations are, and we only use those operations that do not carry or borrow (namely, &, |, ^, ~)\\n```python\\n# since we do not borrow or carry, we think of each number simply as one bit (each bit is independently tracked from other bits)\\n# when a bit comes in, if it\\'s 0, we do nothing; if it\\'s 1, we want to know whether our current tracking bit is 0, 1 or 2\\n#   * 0 + 1 --> 1\\n#   * 1 + 1 --> 2\\n#   * 2 + 1 --> 0\\n# since the tracking bit has 3 possible states, we need two variables to track it\\n# let\\'s call the two tracking variables tracking_A and tracking_B\\n# the logic to make use of these two tracking bits are:\\n#   (1) new bit 1 tries to go into A, if not possible (A was already 1), it goes into B\\n#   (2) if it can go into B (B was 0), we are done\\n#   (3) if B was also occupied by 1, then A and B should be both cleared to 0, and we are done\\n#\\n# now the code:\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        tracking_A = 0         # tracking bit A\\n        tracking_B = 0         # tracking bit B\\n        for incoming in nums:  # the incoming bit\\n            bits_to_tracking_B = tracking_A & incoming           # those bits that cannot fit into tracking_A will go to tracking_B, so we take them out first\\n            resetting_bits = tracking_A & tracking_B & incoming  # when we encounter three bit 1, the bit should be reset to 0\\n            tracking_A = tracking_A | incoming           # update tracking_A\\n            tracking_B = tracking_B | bits_to_tracking_B # update tracking_B\\n            tracking_A = tracking_A ^ resetting_bits     # reset tracking_A\\n            tracking_B = tracking_B ^ resetting_bits     # reset tracking_B\\n\\n        return tracking_A                                # tracking_B is always 0 at the end, tracking_A will hold everything that has not cancelled out, which is what we want\\n```\\n\\nYou can clearly see space for optimization in the above code, as there are clearly redundant calculations. Again it is written for clarity, but feel free to optimize!\\n\\nAgain, if you are confused, think about one bit only! Since the algorithm operates on each bit *independently*, when you have an algorithem for one bit, you automatically have an algorithm for an integer!",
                "solutionTags": [],
                "code": "```python\\n# since we do not borrow or carry, we think of each number simply as one bit (each bit is independently tracked from other bits)\\n# when a bit comes in, if it\\'s 0, we do nothing; if it\\'s 1, we want to know whether our current tracking bit is 0, 1 or 2\\n#   * 0 + 1 --> 1\\n#   * 1 + 1 --> 2\\n#   * 2 + 1 --> 0\\n# since the tracking bit has 3 possible states, we need two variables to track it\\n# let\\'s call the two tracking variables tracking_A and tracking_B\\n# the logic to make use of these two tracking bits are:\\n#   (1) new bit 1 tries to go into A, if not possible (A was already 1), it goes into B\\n#   (2) if it can go into B (B was 0), we are done\\n#   (3) if B was also occupied by 1, then A and B should be both cleared to 0, and we are done\\n#\\n# now the code:\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        tracking_A = 0         # tracking bit A\\n        tracking_B = 0         # tracking bit B\\n        for incoming in nums:  # the incoming bit\\n            bits_to_tracking_B = tracking_A & incoming           # those bits that cannot fit into tracking_A will go to tracking_B, so we take them out first\\n            resetting_bits = tracking_A & tracking_B & incoming  # when we encounter three bit 1, the bit should be reset to 0\\n            tracking_A = tracking_A | incoming           # update tracking_A\\n            tracking_B = tracking_B | bits_to_tracking_B # update tracking_B\\n            tracking_A = tracking_A ^ resetting_bits     # reset tracking_A\\n            tracking_B = tracking_B ^ resetting_bits     # reset tracking_B\\n\\n        return tracking_A                                # tracking_B is always 0 at the end, tracking_A will hold everything that has not cancelled out, which is what we want\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340185,
                "title": "python-5-line-bit-operation-92-70",
                "content": "Explanation: the following bit operation is correct because\\n(1) This bit operation (as a whole for each iteration) is communitive, i.e. results are same regardless how nums are re-arranged. (thus we can analyze it as if the repeated numbers are next to each other)\\n(2) res1 = num, res2 = 0 if we encounter a number for the first time\\n(3) res1 = res2 = 0 (i.e. been reset) if we encounter a number repeatedly three times\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res1 = res2 = 0\\n        for num in nums:\\n            res1 = (res1 ^ num) & (~res2)\\n            res2 = (res2 ^ num) & (~res1)\\n        return res1",
                "solutionTags": [],
                "code": "Explanation: the following bit operation is correct because\\n(1) This bit operation (as a whole for each iteration) is communitive, i.e. results are same regardless how nums are re-arranged. (thus we can analyze it as if the repeated numbers are next to each other)\\n(2) res1 = num, res2 = 0 if we encounter a number for the first time\\n(3) res1 = res2 = 0 (i.e. been reset) if we encounter a number repeatedly three times\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res1 = res2 = 0\\n        for num in nums:\\n            res1 = (res1 ^ num) & (~res2)\\n            res2 = (res2 ^ num) & (~res1)\\n        return res1",
                "codeTag": "Java"
            },
            {
                "id": 309261,
                "title": "java-solution-100-faster",
                "content": "//Runtime: 0 ms, faster than 100.00% of Java online submissions for Single Number II.\\nclass Solution {\\n    public int singleNumber(int[] arr) {\\n        int one=0;\\n        int two=0;\\n        for(int value:arr)\\n        {\\n            one=one^value&~two;\\n            two=two^value&~one;\\n        }\\n        return one;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] arr) {\\n        int one=0;\\n        int two=0;\\n        for(int value:arr)\\n        {\\n            one=one^value&~two;\\n            two=two^value&~one;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 300668,
                "title": "c-solution-using-bits",
                "content": "So, the logic is, let\\'s take 32 - bit integer. Initially it would look like this\\n\\n```000000000000000000000000000000```\\n\\nLoop over all the 32 bits .... setting each bit... Masking\\n\\n```mask``` = ```1<<31``` ---> ```1000000000000000000000000000000```\\n\\nCheck if ```ith```  bit is set (here 31st) ,for each element in given array \\n\\nput a counter say ```int count``` ..... ```if  count%3 != 0``` , then the resultant\\'s bit is set here, in this bit.\\nso , set this bit for result.\\n```int res = 0```\\n```res = 1<<i```\\n\\nTried to explain ..... below is the code \\n\\n\\n```\\nclass Solution {\\npublic:\\n\\tint singleNumber(vector<int>& nums) {\\n        //lets deal it with bitwise \\n        int mask =0;\\n        int result = 0;\\n        int count = 0;\\n        for(int i = 31; i >= 0; i-- ){\\n            mask =  1<<i;\\n            count = 0;\\n            for(int j = 0; j < nums.size(); j++){\\n                if(mask & nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count%3 != 0)\\n                result |= (1<<i);\\n        }\\n        return result;\\n\\t}\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```000000000000000000000000000000```\n```mask```\n```1<<31```\n```1000000000000000000000000000000```\n```ith```\n```int count```\n```if  count%3 != 0```\n```int res = 0```\n```res = 1<<i```\n```\\nclass Solution {\\npublic:\\n\\tint singleNumber(vector<int>& nums) {\\n        //lets deal it with bitwise \\n        int mask =0;\\n        int result = 0;\\n        int count = 0;\\n        for(int i = 31; i >= 0; i-- ){\\n            mask =  1<<i;\\n            count = 0;\\n            for(int j = 0; j < nums.size(); j++){\\n                if(mask & nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count%3 != 0)\\n                result |= (1<<i);\\n        }\\n        return result;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43354,
                "title": "an-easy-understood-method-can-be-used-in-general-condtions",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            if (nums.size()<3) return nums[0];\\n            int cnt[3]={~0,0,0};\\n            int cntTemp[3];\\n            for (int n:nums) {\\n                cntTemp[0]=(cnt[0]&(~n))|(cnt[2]&n); //3m+0 = (3m+0)+0 or (3m+2)+1\\n                cntTemp[1]=(cnt[1]&(~n))|(cnt[0]&n); //3m+1 = (3m+1)+0 or (3m+0)+1\\n                cntTemp[2]=(cnt[2]&(~n))|(cnt[1]&n); //3m+2 = (3m+2)+0 or (3m+1)+1\\n                swap(cnt,cntTemp);\\n            }\\n            return cnt[1]; //bits that have (3m+1) 1bits\\n        }\\n    };\\n\\n\\n\\nThe solution can be generalized.\\nSuppose given \"every element appears k times except for one\", we just need an array cnt[k], where every cnt[i] shows the bits on which (mk+i) 1 bits have been found (m\\u2208N).\\nBesides, the single number may appear once, twice, ...(k-1) times, using \"return ~cnt[0]\" can well solve this.",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            if (nums.size()<3) return nums[0];\\n            int cnt[3]={~0,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 43355,
                "title": "c-easy-to-understand",
                "content": "    public:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0,sum;\\n        for(int i=0;i<32;i++){\\n            sum=0;\\n            int tmp=1<<i;\\n            for(int j=0;j<nums.size();j++){\\n                if(tmp & nums[j]) sum++;\\n            }\\n            if(sum%3) ans+=tmp;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    public:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0,sum;\\n        for(int i=0;i<32;i++){\\n            sum=0;\\n            int tmp=1<<i;\\n            for(int j=0;j<nums.size();j++){\\n                if(tmp & nums[j]) sum++;\\n            }\\n            if(sum%3) ans+=tmp;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43367,
                "title": "python-easy-understand-solution-using-32-bit-counters",
                "content": " Using 32 bit counters and count number of 1 on each bit and mod it to 3.\\n   \\n    def singleNumber(nums):\\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                count += (n >> i) & 1\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": " Using 32 bit counters and count number of 1 on each bit and mod it to 3.\\n   \\n    def singleNumber(nums):\\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                count += (n >> i) & 1\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 43464,
                "title": "solution-zero-extra-space",
                "content": "Here is how to make the constant space solution into a zero space solution. You simply treat A[0], A[1], and A[2] as the ones, twos, and threes masks. To do this, A[0] and A[1] must be preprocessed.\\n\\n    public class Solution {\\n        public int singleNumber(int[] A) {\\n            if(A.length == 1) return A[0];\\n            // A[0] is correct to start\\n            // Take care of processing A[1]\\n            A[0] ^= A[1];\\n            // Set A[1] to either 0 or itself\\n            A[1] = (A[0]^A[1])&A[1];\\n    \\n            // Continue with algorithm as normal\\n            for(int i = 2; i < A.length; i++){\\n                A[1] |= A[0]&A[i];\\n                A[0] ^= A[i];\\n                A[2] = ~(A[0]&A[1]);\\n                A[0] &= A[2];\\n                A[1] &= A[2];\\n            }\\n            return A[0];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int singleNumber(int[] A) {\\n            if(A.length == 1) return A[0];\\n            // A[0] is correct to start\\n            // Take care of processing A[1]\\n            A[0] ^= A[1];\\n            // Set A[1] to either 0 or itself\\n            A[1] = (A[0]^A[1])&A[1];\\n    \\n            // Continue with algorithm as normal\\n            for(int i = 2; i < A.length; i++){\\n                A[1] |= A[0]&A[i];\\n                A[0] ^= A[i];\\n                A[2] = ~(A[0]&A[1]);\\n                A[0] &= A[2];\\n                A[1] &= A[2];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 43474,
                "title": "i-think-your-code-is-great-but-it-can-accpet-without-saving-32-bit",
                "content": "    public class Solution {\\n    public int singleNumber(int[] A) {\\n        int key;\\n        int result=0;\\n        for(int i=0;i<32;i++){\\n            key=0;\\n            for(int j=0;j<A.length;j++){\\n                key+=(A[j]>>i)&1;\\n            }\\n            result|=((key%3)<<i);\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] A) {\\n        int key;\\n        int result=0;\\n        for(int i=0;i<32;i++){\\n            key=0;\\n            for(int j=0;j<A.length;j++){\\n                key+=(A[j]>>i)&1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3715565,
                "title": "c-sorting-of-the-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon reviewing the code, here are my initial thoughts on how to solve the problem:\\n\\n1. The code begins by sorting the input vector `nums` in ascending order. Sorting the array can help in identifying adjacent elements that are the same.\\n\\n2. The code then checks if the size of the vector is not divisible by 3. If it\\'s not divisible, the code adds zeros until it becomes divisible by 3. This step ensures that the vector can be divided into groups of three, as per the problem requirement.\\n\\n3. The code iterates over the vector in groups of three, comparing the first and third elements of each group. If they are not equal, it implies that the first element is the single number that appears only once. The code returns that element.\\n\\n4. If no single number is found after iterating through all the groups, the code returns 0 as the default value.\\n\\nOverall, the approach seems to rely on sorting the array and leveraging the fact that all other numbers appear three times, while the single number appears only once. By comparing adjacent elements in groups of three, the code identifies the single number and returns it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The given code aims to find the single number in a vector, where all other numbers appear three times except for one number that appears only once. Here is an overview of the approach used in the code:\\n\\n1. The code begins by sorting the input vector `nums` in ascending order using the `sort` function from the C++ Standard Library. Sorting the vector allows us to identify adjacent elements easily.\\n\\n2. Next, the code checks if the size of the vector is not divisible by 3. If this condition is true, it means there are missing numbers in the vector. To handle this, the code enters a while loop that continues until the size of the vector becomes divisible by 3. Inside the loop, zeros (0) are pushed back into the vector using the `push_back` function until the size condition is satisfied. This ensures that the vector can be divided into groups of three elements, as required by the problem.\\n\\n3. After ensuring that the vector has a size divisible by 3, the code enters a for loop that iterates over the vector in groups of three. The loop starts from index 0 and increments by 3 in each iteration. This step allows us to examine each group of three adjacent elements.\\n\\n4. Within the loop, the code checks if the first element (`nums[i]`) and the third element (`nums[i + 2]`) of the current group are not equal. If they are not equal, it means that the first element is the single number that appears only once. In this case, the code immediately returns the first element as the result and exits the function.\\n\\n5. If no single number is found after iterating through all the groups, the code returns 0 as the default value, indicating that there is no unique element in the vector.\\n\\nThe approach relies on sorting the vector and comparing adjacent elements in groups of three to identify the single number. By ensuring the vector size is divisible by 3, the code handles cases where there are missing numbers.\\n\\n# Complexity\\n- Time complexity:  O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Sort the vector in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        // If the size of the vector is not divisible by 3, add zeros until it is\\n        if (nums.size() % 3 != 0) {\\n            while (nums.size() % 3 != 0) {\\n                nums.push_back(0);\\n            }\\n        }\\n        \\n        // Iterate over the vector in groups of three\\n        for (int i = 0; i < nums.size() - 2; i = i + 3) {\\n            // If the first and third elements of the group are not equal, return the first element\\n            if (nums[i] != nums[i + 2]) {\\n                return nums[i];\\n            }\\n        }\\n        \\n        // If no single number is found, return 0\\n        return 0;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/bc6efb87-d298-4850-a090-d191b0b35e2d_1688446868.5131214.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Sort the vector in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        // If the size of the vector is not divisible by 3, add zeros until it is\\n        if (nums.size() % 3 != 0) {\\n            while (nums.size() % 3 != 0) {\\n                nums.push_back(0);\\n            }\\n        }\\n        \\n        // Iterate over the vector in groups of three\\n        for (int i = 0; i < nums.size() - 2; i = i + 3) {\\n            // If the first and third elements of the group are not equal, return the first element\\n            if (nums[i] != nums[i + 2]) {\\n                return nums[i];\\n            }\\n        }\\n        \\n        // If no single number is found, return 0\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715264,
                "title": "1-liners-math",
                "content": "# Approach\\nSimple Maths \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n![](https://brighterly.com/wp-content/uploads/2022/03/math-memes-for-kids-13.png)\\n\\n- Suppose nums has a set X which has the reapeated elements\\n- An array sum will be 3*(X)+Y where Y is the single element...\\n- Its set will have X+Y elements.We have to find Y...\\n- So, we multiply set sum with 3 \\n- Sum will be 3X+3Y\\n- nums sum is 3X+Y\\n- by substracting and dividng by 2 we get 2Y/2 = Y\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return int(sum(nums)-3*sum(set(nums)))//-2\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return int(sum(nums)-3*sum(set(nums)))//-2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714950,
                "title": "java-bit-manipulation-very-easy",
                "content": "# Upvote if you relate the solution with yours or if it helpful for you!!!\\n\\n![image](https://assets.leetcode.com/users/images/a6c4545a-3b67-43bf-ba5e-b51f0910d311_1688432891.2068877.jpeg)\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<32;i++){\\n            int ones = 0;\\n            for(int n : nums){\\n                ones += (n>>i)&1;\\n            }\\n            // if 1 count is 0 or 1\\n            ones = ones % 3;\\n            \\n            // making ans by seting the ith bit set \\n            // taking | (or) because it add the decimal if both are different\\n            ans = ans | ones << i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<32;i++){\\n            int ones = 0;\\n            for(int n : nums){\\n                ones += (n>>i)&1;\\n            }\\n            // if 1 count is 0 or 1\\n            ones = ones % 3;\\n            \\n            // making ans by seting the ith bit set \\n            // taking | (or) because it add the decimal if both are different\\n            ans = ans | ones << i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264302,
                "title": "single-number-ii-solution-using-mapping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        map<int,int> ans;\\n        for(int i = 0; i<nums.size(); i++ ) {\\n            ans[nums[i]]++;\\n        }\\n        for(auto i: ans) {\\n            if(i.second==1) {\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        map<int,int> ans;\\n        for(int i = 0; i<nums.size(); i++ ) {\\n            ans[nums[i]]++;\\n        }\\n        for(auto i: ans) {\\n            if(i.second==1) {\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158573,
                "title": "c-solution-using-unordered-map-easy-to-understand-and-implement",
                "content": "# Flow of Code\\n1. Pushing the vector elements to unordered map. \\n2. Traverse the map and returning the vector element having their count = 1.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map <int,int> M;\\n        for(auto n:nums)\\n            M[n]++;\\n        int A;\\n        for(auto i:M){\\n            if(i.second==1)\\n                A=i.first;\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map <int,int> M;\\n        for(auto n:nums)\\n            M[n]++;\\n        int A;\\n        for(auto i:M){\\n            if(i.second==1)\\n                A=i.first;\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156032,
                "title": "easy-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIsn\\'t it same like finding the number which is single time in array and the rest of the elements occurs two times??\\n\\nCan we extend that problem to three times repetation???\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust count the number of ones at each bits for all the array elements. \\n\\nLets say the ith bit is having \\'x\\' number of set bits.\\nThen if x%3 is \\'0\\' then it means the position is having no set bit for that single element.\\n\\nsimilarly count for all 32 bits and then add set bits to the answer accordingly. \\n\\nHere is the simple and easy to understand implementation\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(32* n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(32), which is O(log(n))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>bits(32);\\n\\n        for(int i: nums){\\n            for(int j=0; j<32; j++){\\n                int temp=i&1;\\n                if(temp) bits[j]++;\\n                i=i>>1;\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<32; i++){\\n            if(bits[i]%3!=0){\\n                ans=ans|(1<<i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>bits(32);\\n\\n        for(int i: nums){\\n            for(int j=0; j<32; j++){\\n                int temp=i&1;\\n                if(temp) bits[j]++;\\n                i=i>>1;\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<32; i++){\\n            if(bits[i]%3!=0){\\n                ans=ans|(1<<i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034668,
                "title": "clear-java-solution",
                "content": "# Approach 1\\n\\nTo count number of occurences of elements and then iterate over map and print that one which has single occurence\\n\\n**Complexity : O(Nlog(N))**\\n\\n# Approach 2\\n\\nUsing bit manipulation \\n\\nCounting the set bit occurences of all whole array .\\n\\n![temp.jpg](https://assets.leetcode.com/users/images/78a64c48-643d-400b-9944-e30a6ff305bd_1673428056.4935951.jpeg)\\n\\n\\n**Complexity : O(N)**\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int bit_change(int n , int posn) {\\n        int i , j , mask ;\\n        if(set_bit_check(n, posn)) {\\n            mask = 1<<posn ;\\n            mask ^= (Integer.MAX_VALUE) ;\\n            return mask&n ;\\n        }\\n        else {\\n            mask = 1<<posn ;\\n            return mask|n ;\\n        }\\n    }\\n\\n    static boolean set_bit_check(int n,int posn) {  // posn will be 0 index\\n        int i , j , mask ;\\n        mask = 1<<posn ;\\n        \\n        if((mask&n) !=0) {\\n            return true ;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    public int singleNumber(int[] nums) {\\n        int xor =0 , n = nums.length, i , j ;\\n\\n        int[] rs = new int[70] ;\\n        for(i=0;i<n;i++) {\\n            for(j=0;j<32;j++) {\\n                if(set_bit_check(nums[i],j)) {\\n                    rs[j]++ ;\\n                }\\n            }\\n        }\\n\\n        int ans  = 0;\\n        for(i=0;i<32;i++) {\\n            if((rs[i]%3)!=0) {\\n                ans = bit_change(ans,i) ;\\n            }\\n        }\\n\\n        System.out.println(ans) ;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int bit_change(int n , int posn) {\\n        int i , j , mask ;\\n        if(set_bit_check(n, posn)) {\\n            mask = 1<<posn ;\\n            mask ^= (Integer.MAX_VALUE) ;\\n            return mask&n ;\\n        }\\n        else {\\n            mask = 1<<posn ;\\n            return mask|n ;\\n        }\\n    }\\n\\n    static boolean set_bit_check(int n,int posn) {  // posn will be 0 index\\n        int i , j , mask ;\\n        mask = 1<<posn ;\\n        \\n        if((mask&n) !=0) {\\n            return true ;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    public int singleNumber(int[] nums) {\\n        int xor =0 , n = nums.length, i , j ;\\n\\n        int[] rs = new int[70] ;\\n        for(i=0;i<n;i++) {\\n            for(j=0;j<32;j++) {\\n                if(set_bit_check(nums[i],j)) {\\n                    rs[j]++ ;\\n                }\\n            }\\n        }\\n\\n        int ans  = 0;\\n        for(i=0;i<32;i++) {\\n            if((rs[i]%3)!=0) {\\n                ans = bit_change(ans,i) ;\\n            }\\n        }\\n\\n        System.out.println(ans) ;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012928,
                "title": "java-simple-o-32-n-for-beginners-with-o-1-space-complexity",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(32*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int od=0,ans=0,sum=0;\\n        for(int i=0;i<32;i++){\\n            sum=0;\\n            od=0;\\n            for(int j=0;j<nums.length;j++){\\n                if((1&nums[j])!=0)od++;\\n                nums[j]>>=1;\\n                sum|=nums[j];\\n            }\\n            if(od%3!=0) ans|=(1<<i);\\n            if(sum==0)  break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int od=0,ans=0,sum=0;\\n        for(int i=0;i<32;i++){\\n            sum=0;\\n            od=0;\\n            for(int j=0;j<nums.length;j++){\\n                if((1&nums[j])!=0)od++;\\n                nums[j]>>=1;\\n                sum|=nums[j];\\n            }\\n            if(od%3!=0) ans|=(1<<i);\\n            if(sum==0)  break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735607,
                "title": "two-ways-bit-manipulation-map-easy-explained",
                "content": "**First Method**\\n1)Go through each bit of the 32 bits of each number in the array and take the sum of last bit of all nums in each iteration.Now if the sum is multiple of 3 that means that corresponding bit in our non repeating number should also be zero.Because all the rest of the numbers apart from the non repeating number appear thrice so the bitsum coming from them is always a multiple of 3.Now the bit of our non repeating number would decide the total sum of the last bit would be a multiple of 3 or not.\\n\\nFor ex:Let\\'s say the input is:-1 0 1 0 0 3 5 2 1 2 2 3 3\\nNumbers and their bit values and S represents the sum of the bits at each position:-\\n\\t\\t\\t\\t1:0 0 1\\n\\t\\t\\t\\t0:0 0 0\\n\\t\\t\\t\\t1:0 0 1\\n\\t\\t\\t\\t0:0 0 0\\n\\t\\t\\t\\t0:0 0 0 \\n\\t\\t\\t\\t3:0 1 1\\n\\t\\t\\t\\t5:**1 0 1**\\n\\t\\t\\t\\t2:0 1 0\\n\\t\\t\\t\\t1:0 0 1\\n\\t\\t\\t\\t2:0 1 0\\n\\t\\t\\t\\t2:0 1 0\\n\\t\\t\\t\\t3:0 1 1\\n\\t\\t\\t\\t3:0 1 1\\n\\t\\t        **S**:**1 6 7**\\n\\t\\t\\t\\tS%3=\\n\\t\\t\\t\\t**S**:**1 0 1**\\n\\t\\t\\t\\tTherefore on calculating the result of S in decimal form we get 5 as our answer.\\n\\n\\n2)Store the result of the sum in a temporary variable bitsum in and then add the corresponding bit value to our result in each iteration.\\n3)For the case of negative numbers after obtaining the final result check if the 32nd or 31 indexed bit is 1 or not.If it is 1 then our result is a negative number.To obtain its magnitude we have to take the 2\\'s complement of our result and then multiply it by -1.\\nFor ex:-3\\n-3=1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 in binary\\nTo take 2\\'s complement invert the bits of -3,\\n~(-3)=0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0=2\\nand then add 1 to the result to the result to get magnitude:2+1=3.\\n\\n*We can generalise this method for any unique number question where each number occours p=3,5,7,.... odd number of times and one number occours once by taking mod of bitsum with p.*\\n\\n*For the cases where each number occours p=1,2,4,.... even number of times and one number occours once,we simply take xor of all numbers.The xor would be our final answer as all the numbers would cancel each other except the non repeating number.*\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int t=0;\\n        long int result=0;\\n        while(t!=32){\\n            long int bitsum=0;\\n            for(int i=0;i<nums.size();i++){\\n                bitsum+=nums[i]&1;\\n                nums[i]=nums[i]>>1;\\n            }\\n            result+=(bitsum%3)*pow(2,t); // check bit value as the remainder of bitsum with respect to 3\\n            if(t==31&&bitsum%3==1){\\n                result=~result;            // 2\\'s complement \\n                result+=1;                 // is being taken here\\n                result*=-1;\\n            }\\n            t++;\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Time Complexity:O(32*n) and Space Complexity:O(1)**\\n**Second method**\\n1)Take an unordered map to store the count of each number in the array.\\n2)Iterate through the map and return the key whose value is 1.\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> a;\\n        for(int e:nums){\\n            a[e]++;   // storing the count of each element in map.\\n        }\\n        int one=0;\\n        for(auto i=a.begin();i!=a.end();i++){\\n            if(i->second==1){\\n                one=i->first; // on finding a element whose frequency is 1 we store its value in result \"one\" .\\n                break;\\n            }\\n        }\\n        return one;\\n    }\\n};\\n```\\n**Time Complexity:O(n) and Space Complexity:O(n)**\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int t=0;\\n        long int result=0;\\n        while(t!=32){\\n            long int bitsum=0;\\n            for(int i=0;i<nums.size();i++){\\n                bitsum+=nums[i]&1;\\n                nums[i]=nums[i]>>1;\\n            }\\n            result+=(bitsum%3)*pow(2,t); // check bit value as the remainder of bitsum with respect to 3\\n            if(t==31&&bitsum%3==1){\\n                result=~result;            // 2\\'s complement \\n                result+=1;                 // is being taken here\\n                result*=-1;\\n            }\\n            t++;\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> a;\\n        for(int e:nums){\\n            a[e]++;   // storing the count of each element in map.\\n        }\\n        int one=0;\\n        for(auto i=a.begin();i!=a.end();i++){\\n            if(i->second==1){\\n                one=i->first; // on finding a element whose frequency is 1 we store its value in result \"one\" .\\n                break;\\n            }\\n        }\\n        return one;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721811,
                "title": "c-java-0-ms-100-00-faster-easy-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<32; i++){\\n            int t=0;\\n            for(int j=0; j<nums.size(); j++){\\n                t+=(nums[j]&1);\\n                nums[j]>>=1;\\n            }\\n            ans+=((t%3)<<i);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<32; i++){\\n            int t=0;\\n            for(int j=0; j<nums.size(); j++){\\n                t+=(nums[j]&1);\\n                nums[j]>>=1;\\n            }\\n            ans+=((t%3)<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631494,
                "title": "using-or-and-bitmanipulation",
                "content": "\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        int num , last;\\n        // take 32 as high becoz we have no idea about ans;\\n        for(int i = 0 ; i < 32 ;i++)\\n        {\\n            int one = 0;\\n            \\n            // traverse for whole elements\\n            for(int j = 0 ; j < nums.size() ; j++)\\n            {\\n                // let\\'s find last digit whether set or not;\\n                num = 1<<i;\\n                last = num & nums[j];\\n                    \\n                if(last) // if one \\n                    one++;\\n                    \\n            }\\n            // if 1s cnt is not divisible by 3 just add 1 in ans;\\n            if( one%3 )\\n            {\\n                ans = (1<<i) | ans;\\n            }    \\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        int num , last;\\n        // take 32 as high becoz we have no idea about ans;\\n        for(int i = 0 ; i < 32 ;i++)\\n        {\\n            int one = 0;\\n            \\n            // traverse for whole elements\\n            for(int j = 0 ; j < nums.size() ; j++)\\n            {\\n                // let\\'s find last digit whether set or not;\\n                num = 1<<i;\\n                last = num & nums[j];\\n                    \\n                if(last) // if one \\n                    one++;\\n                    \\n            }\\n            // if 1s cnt is not divisible by 3 just add 1 in ans;\\n            if( one%3 )\\n            {\\n                ans = (1<<i) | ans;\\n            }    \\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2370639,
                "title": "c-with-explanation-bit",
                "content": "// hey  i am  using the concept of checking set bit \\n// if the **jth** array  elements ** ith**  bit is set then simply increment the **oneCount** (oneCount:- counting number of set bit )\\nand if **oneCount%3!=0** then it means thet the extra element contains 1 at that position \\nso simply add it to your ans \\n\\n\\n\\n\\tint singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<32;i++){\\n            int oneCount=0;\\n            int temp=1<<i;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]& temp){// checking that it has set bit \\n                    oneCount++;\\n                }\\n            }\\n            if(oneCount%3!=0){\\n                ans=ans|temp;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\t\\n\\t**** please upvote ****",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "// hey  i am  using the concept of checking set bit \\n// if the **jth** array  elements ** ith**  bit is set then simply increment the **oneCount** (oneCount:- counting number of set bit )\\nand if **oneCount%3!=0** then it means thet the extra element contains 1 at that position \\nso simply add it to your ans \\n\\n\\n\\n\\tint singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<32;i++){\\n            int oneCount=0;\\n            int temp=1<<i;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]& temp){// checking that it has set bit \\n                    oneCount++;\\n                }\\n            }\\n            if(oneCount%3!=0){\\n                ans=ans|temp;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\t\\n\\t**** please upvote ****",
                "codeTag": "Unknown"
            },
            {
                "id": 2174191,
                "title": "c-4-solutions-with-explanation-o-nlogn-o-32-n-o-nlogn-n-o-n",
                "content": "#### Method 1 - Hashmap \\n\\tTime complexity  -> O(nlogn) \\n    Space Complexity -> O(n)\\n\\n\\tint singleNumber(vector<int>& nums) {\\n            unordered_map<int,int> freq;\\n\\n            for(auto x : nums) freq[x]++; \\n            //Element appearing three time have frequency three after increment three time and element appearing one time has freq 1 after increment it by one time\\n\\n            for(auto x : nums) \\n                if(freq[x] == 1) //Frequency of single element x is 1\\n                    return x;  // so return that single element x\\n            return -1; //otherwise return -1 \\n\\t}\\n\\t\\n\\t\\n#### Method 2 - Sorting\\n\\tTime complexity  -> O(nlogn + n) -> O(nlogn) \\n\\tSpace Complexity -> O(1)\\n\\n\\tif(size == 1) return single element present in the array\\n\\tthen sort all the elements of nums using sort function\\n\\n\\tExample 1 - nums = [2,3,3,3] -> if(nums[1] != nums[0]) -> return nums[0];\\n\\n\\tExample 2 - nums = [3,3,3,4] -> if(nums[n-1] != nums[n-2]) -> return nums[n-1];\\n\\n\\tExample 3 - nums = [2,2,2,3,5,5,5] \\n\\twhen i=1 -> if(nums[1] == nums[0]) - if(2 == 2) -> i += 3\\n\\tthen i=4 -> if(nums[4] != nums[3]) - if(5 != 3) -> return nums[3] - return 3;\\n\\n***\\n\\n\\tCode\\n\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tif(n == 1) return nums[0]; \\n\\t\\tsort(nums.begin(),nums.end()); \\n\\n\\t\\t//Corner cases\\n\\t\\tif(nums[1] != nums[0]) return nums[0]; \\n\\n\\n\\t\\tif(nums[n-1] != nums[n-2]) return nums[n-1];\\n\\n\\n\\t\\tfor(int i=1; i < nums.size()-1 ; i += 3){\\n\\t\\t\\tif(nums[i] != nums[i-1]) return nums[i-1];\\n\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\t\\n#### \\tMethod 3 - Bit Manipuation (Counting Set bits) \\n\\t Time Complexity -> O(32*n) \\n\\t Space Complexity - O(1)\\n\\n\\t we take two variable result=0 and leftshift=1\\n\\t we add bits of all the elements one by one from rsb (right significant bit) then calculate \\n\\t if(sumbit % 3 == 0) leave the bit and if(sumbit % 3 != 0) the take that bit to the result\\n\\n\\t Example - nums = [1,1,1,5,7,7,7] \\n\\t 1. Decimal     ->       Binary                        |2. Decimal     ->       Binary\\n\\t\\t\\t\\t\\t->              _                      |               ->             _\\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1\\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1    \\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1\\n\\t\\t5           ->       000010|1| -> single element   |   5           ->       00001|0|1 -> single element\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t---------------------------|-|                     |   --------------------------|-|-\\n\\t\\tsumbit ->                  |7|                     |   sumbit ->                 |3|\\n\\t\\t\\t\\t\\t\\t\\t\\t   |_|                     |                             |_|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   |               \\n\\t7 % 3 != 0 -> update result =0(result) + 1(leftshift); |   3 % 3 == 0  do not update result\\n\\tand leftshift *= 2; -> leftshift = 2                   |   update leftshift *= 2; -> leftshift = 4\\n\\n\\t 3. Decimal     ->       Binary                     \\n\\t\\t\\t\\t\\t->            _                     \\n\\t\\t1           ->       0000|0|01                  \\n\\t\\t1           ->       0000|0|01                      \\n\\t\\t1           ->       0000|0|01                  \\n\\t\\t5           ->       0000|1|01 -> single element\\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t-------------------------|-|--                  \\n\\t\\tsumbit ->                |4|                       \\n\\t\\t\\t\\t\\t\\t\\t\\t |_|                    \\n\\t4 % 3 != 0 -> update result = 1(result) + 4(leftshift); -> result = 5 -> required ans  \\n\\tand leftshift *= 2; -> leftshift = 8               \\n\\n\\tand all the remaining bits are zero added by this method upto 32 bits and the final answer in 5 \\n\\n\\tbut sorting method is better than this method because \\n\\t\\t\\t   n <= 3 * pow(10,4)\\n\\t\\t  so,  n < INT_MAX\\n\\ttherefore, logn < 32  ----- equation 1st\\n\\tby multiply the equation 1st by n we will get  ->  n * logn < n * 32\\n\\tO(n*logn) < O(32*n)     ->   therefore , Time complexity of sorting < Time complexity of counting set bits\\n\\n***\\n\\n\\tCode\\n\\t\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tunsigned long int leftshift = 1;\\n\\t\\tint result = 0;\\n\\t\\tint sumbit = 0;\\n\\t\\t\\n\\t\\tfor(int i=0 ; i < 32 ; ++i){\\n\\t\\t\\tfor(auto x : nums)\\n\\t\\t\\t\\tsumbit += ((x >> i) & 1);\\n\\t\\t\\tif(sumbit % 3 != 0){\\n\\t\\t\\t\\tresult += leftshift;\\n\\t\\t\\t\\tsumbit = 0;\\n\\t\\t\\t} \\n\\t\\t\\tleftshift *= 2;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\t\\n\\t\\n#### \\tMethod 4 - Bit Manipulation (XOR)\\n\\tTime Compexity   ->  O(n)\\n\\tSpace Complexity ->  O(1)\\n\\n\\tBest ones and twos method \\n\\n\\tExample - nums = [5,5,5,7] , n=4\\n\\n\\twe will take two variable ones = 0 and twos = 0\\n\\n\\tDecimal    |    Binary\\n\\t5          |    000101\\n\\t7          |    000111\\n\\n***\\n\\n\\twe runs a for loop i = 0 to n-1(4-1=3)\\n\\n***\\n\\n\\tinitialize i as 0 \\n\\n\\t1st - when i = 0\\n\\n\\ta. - ones ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000101\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000101\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 5\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(5) -> 111010\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000101\\n\\t~ones           ->   & 111010\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n***\\n\\n\\tincrement i to 1 -> i = 1\\n\\n\\t2nd - when i = 1\\n\\n\\ta. - ones ^ a[i] (5 ^ 5) ->  00101    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00000                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000000\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 0\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(0) -> 111111\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000101\\n\\t~ones           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000101\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 5\\n\\n***\\n\\n\\t1. when we travel 5 one times ones is 5 and twos is 0\\n\\t2. when we travel 5 two times ones is 0 and twos is 5\\n\\t3. now,when we travel 5 three times both ones and twos is 0\\n\\n***\\n\\n\\tincrement i to 1 -> i = 2    \\n\\n\\t2nd - when i = 2\\n\\n\\ta. - ones ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(5) -> 111010\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000101\\n\\t~twos           ->   & 111010\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 0\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (5 ^ 5) ->  00101    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00000                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(0) -> 111111\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000000\\n\\t~ones           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n\\t-> both  ones and twos is zero\\n\\n***\\n\\n\\tincrement i to 1 -> i = 3\\n\\n\\t4th - when i = 3\\n\\n\\ta. - ones ^ a[i] (0 ^ 7) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00111                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00111                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000111\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000111\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 7\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 7) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00111                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00111                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(7) -> 111000\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000111\\n\\t~ones           ->   & 111000\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n***\\n\\n\\tNOW at last we increment i to 1 -> i = 4\\n\\ti > n -> come out of loop \\n\\treturn ones -> it is the final result\\n\\n\\tYou also use example - nums = [5,5,5,7,9,9,9] -> it will return 7 as ans\\n\\n***\\n\\n\\tCode\\n\\t\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint ones = 0;\\n\\t\\tint twos = 0;\\n\\t\\tfor(int i=0 ; i < nums.size() ; ++i){\\n\\t\\t\\tones = (ones ^ nums[i]) & (~twos);\\n\\t\\t\\ttwos = (twos ^ nums[i]) & (~ones);\\n\\t\\t}\\n\\t\\treturn ones;\\n\\t}\\n\\t\\n\\t",
                "solutionTags": [
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "#### Method 1 - Hashmap \\n\\tTime complexity  -> O(nlogn) \\n    Space Complexity -> O(n)\\n\\n\\tint singleNumber(vector<int>& nums) {\\n            unordered_map<int,int> freq;\\n\\n            for(auto x : nums) freq[x]++; \\n            //Element appearing three time have frequency three after increment three time and element appearing one time has freq 1 after increment it by one time\\n\\n            for(auto x : nums) \\n                if(freq[x] == 1) //Frequency of single element x is 1\\n                    return x;  // so return that single element x\\n            return -1; //otherwise return -1 \\n\\t}\\n\\t\\n\\t\\n#### Method 2 - Sorting\\n\\tTime complexity  -> O(nlogn + n) -> O(nlogn) \\n\\tSpace Complexity -> O(1)\\n\\n\\tif(size == 1) return single element present in the array\\n\\tthen sort all the elements of nums using sort function\\n\\n\\tExample 1 - nums = [2,3,3,3] -> if(nums[1] != nums[0]) -> return nums[0];\\n\\n\\tExample 2 - nums = [3,3,3,4] -> if(nums[n-1] != nums[n-2]) -> return nums[n-1];\\n\\n\\tExample 3 - nums = [2,2,2,3,5,5,5] \\n\\twhen i=1 -> if(nums[1] == nums[0]) - if(2 == 2) -> i += 3\\n\\tthen i=4 -> if(nums[4] != nums[3]) - if(5 != 3) -> return nums[3] - return 3;\\n\\n***\\n\\n\\tCode\\n\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tif(n == 1) return nums[0]; \\n\\t\\tsort(nums.begin(),nums.end()); \\n\\n\\t\\t//Corner cases\\n\\t\\tif(nums[1] != nums[0]) return nums[0]; \\n\\n\\n\\t\\tif(nums[n-1] != nums[n-2]) return nums[n-1];\\n\\n\\n\\t\\tfor(int i=1; i < nums.size()-1 ; i += 3){\\n\\t\\t\\tif(nums[i] != nums[i-1]) return nums[i-1];\\n\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\t\\n#### \\tMethod 3 - Bit Manipuation (Counting Set bits) \\n\\t Time Complexity -> O(32*n) \\n\\t Space Complexity - O(1)\\n\\n\\t we take two variable result=0 and leftshift=1\\n\\t we add bits of all the elements one by one from rsb (right significant bit) then calculate \\n\\t if(sumbit % 3 == 0) leave the bit and if(sumbit % 3 != 0) the take that bit to the result\\n\\n\\t Example - nums = [1,1,1,5,7,7,7] \\n\\t 1. Decimal     ->       Binary                        |2. Decimal     ->       Binary\\n\\t\\t\\t\\t\\t->              _                      |               ->             _\\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1\\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1    \\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1\\n\\t\\t5           ->       000010|1| -> single element   |   5           ->       00001|0|1 -> single element\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t---------------------------|-|                     |   --------------------------|-|-\\n\\t\\tsumbit ->                  |7|                     |   sumbit ->                 |3|\\n\\t\\t\\t\\t\\t\\t\\t\\t   |_|                     |                             |_|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   |               \\n\\t7 % 3 != 0 -> update result =0(result) + 1(leftshift); |   3 % 3 == 0  do not update result\\n\\tand leftshift *= 2; -> leftshift = 2                   |   update leftshift *= 2; -> leftshift = 4\\n\\n\\t 3. Decimal     ->       Binary                     \\n\\t\\t\\t\\t\\t->            _                     \\n\\t\\t1           ->       0000|0|01                  \\n\\t\\t1           ->       0000|0|01                      \\n\\t\\t1           ->       0000|0|01                  \\n\\t\\t5           ->       0000|1|01 -> single element\\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t-------------------------|-|--                  \\n\\t\\tsumbit ->                |4|                       \\n\\t\\t\\t\\t\\t\\t\\t\\t |_|                    \\n\\t4 % 3 != 0 -> update result = 1(result) + 4(leftshift); -> result = 5 -> required ans  \\n\\tand leftshift *= 2; -> leftshift = 8               \\n\\n\\tand all the remaining bits are zero added by this method upto 32 bits and the final answer in 5 \\n\\n\\tbut sorting method is better than this method because \\n\\t\\t\\t   n <= 3 * pow(10,4)\\n\\t\\t  so,  n < INT_MAX\\n\\ttherefore, logn < 32  ----- equation 1st\\n\\tby multiply the equation 1st by n we will get  ->  n * logn < n * 32\\n\\tO(n*logn) < O(32*n)     ->   therefore , Time complexity of sorting < Time complexity of counting set bits\\n\\n***\\n\\n\\tCode\\n\\t\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tunsigned long int leftshift = 1;\\n\\t\\tint result = 0;\\n\\t\\tint sumbit = 0;\\n\\t\\t\\n\\t\\tfor(int i=0 ; i < 32 ; ++i){\\n\\t\\t\\tfor(auto x : nums)\\n\\t\\t\\t\\tsumbit += ((x >> i) & 1);\\n\\t\\t\\tif(sumbit % 3 != 0){\\n\\t\\t\\t\\tresult += leftshift;\\n\\t\\t\\t\\tsumbit = 0;\\n\\t\\t\\t} \\n\\t\\t\\tleftshift *= 2;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\t\\n\\t\\n#### \\tMethod 4 - Bit Manipulation (XOR)\\n\\tTime Compexity   ->  O(n)\\n\\tSpace Complexity ->  O(1)\\n\\n\\tBest ones and twos method \\n\\n\\tExample - nums = [5,5,5,7] , n=4\\n\\n\\twe will take two variable ones = 0 and twos = 0\\n\\n\\tDecimal    |    Binary\\n\\t5          |    000101\\n\\t7          |    000111\\n\\n***\\n\\n\\twe runs a for loop i = 0 to n-1(4-1=3)\\n\\n***\\n\\n\\tinitialize i as 0 \\n\\n\\t1st - when i = 0\\n\\n\\ta. - ones ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000101\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000101\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 5\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(5) -> 111010\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000101\\n\\t~ones           ->   & 111010\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n***\\n\\n\\tincrement i to 1 -> i = 1\\n\\n\\t2nd - when i = 1\\n\\n\\ta. - ones ^ a[i] (5 ^ 5) ->  00101    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00000                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000000\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 0\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(0) -> 111111\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000101\\n\\t~ones           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000101\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 5\\n\\n***\\n\\n\\t1. when we travel 5 one times ones is 5 and twos is 0\\n\\t2. when we travel 5 two times ones is 0 and twos is 5\\n\\t3. now,when we travel 5 three times both ones and twos is 0\\n\\n***\\n\\n\\tincrement i to 1 -> i = 2    \\n\\n\\t2nd - when i = 2\\n\\n\\ta. - ones ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(5) -> 111010\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000101\\n\\t~twos           ->   & 111010\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 0\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (5 ^ 5) ->  00101    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00000                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(0) -> 111111\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000000\\n\\t~ones           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n\\t-> both  ones and twos is zero\\n\\n***\\n\\n\\tincrement i to 1 -> i = 3\\n\\n\\t4th - when i = 3\\n\\n\\ta. - ones ^ a[i] (0 ^ 7) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00111                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00111                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000111\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000111\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 7\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 7) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00111                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00111                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(7) -> 111000\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000111\\n\\t~ones           ->   & 111000\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n***\\n\\n\\tNOW at last we increment i to 1 -> i = 4\\n\\ti > n -> come out of loop \\n\\treturn ones -> it is the final result\\n\\n\\tYou also use example - nums = [5,5,5,7,9,9,9] -> it will return 7 as ans\\n\\n***\\n\\n\\tCode\\n\\t\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint ones = 0;\\n\\t\\tint twos = 0;\\n\\t\\tfor(int i=0 ; i < nums.size() ; ++i){\\n\\t\\t\\tones = (ones ^ nums[i]) & (~twos);\\n\\t\\t\\ttwos = (twos ^ nums[i]) & (~ones);\\n\\t\\t}\\n\\t\\treturn ones;\\n\\t}\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2029704,
                "title": "c-bit-operation-with-explanation",
                "content": "```\\nint singleNumber(vector<int>& nums) {\\n        int mask=0;                             // stores the answer\\n        for (int i=0;i<32;i++)                  \\n        {\\n            int c=0;                            // Count for how many elements ith bit is set\\n            for (int j=0;j<nums.size();j++)\\n            {\\n                if (nums[j]&(1<<i)) c++;        // Check if ith bit is set in nums[j], c++;\\n            }\\n             // If the count of element whose ith bit is set is not a multiple of 3 means the element\\n            //  which appears once has the ith bit set, hence setting the ith bit in mask[answer]. \\n            if (c%3!=0) mask = mask | 1<<i;    \\n        }\\n        return mask;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint singleNumber(vector<int>& nums) {\\n        int mask=0;                             // stores the answer\\n        for (int i=0;i<32;i++)                  \\n        {\\n            int c=0;                            // Count for how many elements ith bit is set\\n            for (int j=0;j<nums.size();j++)\\n            {\\n                if (nums[j]&(1<<i)) c++;        // Check if ith bit is set in nums[j], c++;\\n            }\\n             // If the count of element whose ith bit is set is not a multiple of 3 means the element\\n            //  which appears once has the ith bit set, hence setting the ith bit in mask[answer]. \\n            if (c%3!=0) mask = mask | 1<<i;    \\n        }\\n        return mask;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802337,
                "title": "javascript-sorting-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nfunction singleNumber(nums) {\\n    nums.sort((x, y) => x - y);\\n\\n    for (let i = 0; i < nums.length; i += 3) {\\n        if (nums[i] !== nums[i + 1]) {\\n            return nums[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nfunction singleNumber(nums) {\\n    nums.sort((x, y) => x - y);\\n\\n    for (let i = 0; i < nums.length; i += 3) {\\n        if (nums[i] !== nums[i + 1]) {\\n            return nums[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578058,
                "title": "runtime-4-ms-faster-than-97-25-easy-c-explanation-tc-o-n-sc-o-1",
                "content": "```\\n     // TC- O(n) , Sc- O(1)\\n    int singleNumber(vector<int>& nums) {\\n        \\n        long long int ans = 0;\\n        vector<int>cnt(32,0);   // count bit array => Constant Extra Space\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=31;\\n            long long int n = abs(nums[i]);  // int-Range\\t=>\\t[ -2,147,483,648 to 2,147,483,647 ]\\n            while(n)                    // abs(-2,147,483,648) = 2,147,483,648 not stored in \\'int\\'\\n            {\\n                cnt[j] += n&1;\\n                n >>= 1; \\n                j--;\\n            }\\n        }\\n        \\n        for(int j=31;j>=0;j--)\\n        {\\n            int bit = cnt[j]%3;\\n            if(bit)\\n             ans += 1 <<(31-j); // 1 * 2^(31-j)\\n        }\\n        \\n        int c=0;\\n        for(auto x:nums)   //for negative numbers\\n          if(x==ans) {c++;}   //if our calculates value \\'ans\\' is present in array, then increment c\\n        return c==1?ans:-ans; //if c=1 return \\'ans\\' else \\'ans\\' must be -ve\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n     // TC- O(n) , Sc- O(1)\\n    int singleNumber(vector<int>& nums) {\\n        \\n        long long int ans = 0;\\n        vector<int>cnt(32,0);   // count bit array => Constant Extra Space\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=31;\\n            long long int n = abs(nums[i]);  // int-Range\\t=>\\t[ -2,147,483,648 to 2,147,483,647 ]\\n            while(n)                    // abs(-2,147,483,648) = 2,147,483,648 not stored in \\'int\\'\\n            {\\n                cnt[j] += n&1;\\n                n >>= 1; \\n                j--;\\n            }\\n        }\\n        \\n        for(int j=31;j>=0;j--)\\n        {\\n            int bit = cnt[j]%3;\\n            if(bit)\\n             ans += 1 <<(31-j); // 1 * 2^(31-j)\\n        }\\n        \\n        int c=0;\\n        for(auto x:nums)   //for negative numbers\\n          if(x==ans) {c++;}   //if our calculates value \\'ans\\' is present in array, then increment c\\n        return c==1?ans:-ans; //if c=1 return \\'ans\\' else \\'ans\\' must be -ve\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1559271,
                "title": "c-simple-solution-using-bit-manipulation",
                "content": "Logic:\\n1) If a number repeats 3 times, say number 5 i.e. (101) in binary. 1 will occur at 0th and 2nd bit 3 times.\\n2) Eg: [2,2,3,2] Answer is 3. How? \\n\\t2 -> 10\\n\\t2 -> 10\\n\\t3 -> 11\\n\\t2 -> 10\\nsum of 0th set bits = 1 // 1 is not divisible by 3, our answer has 0th bit set\\nsum of 1st set bits = 4 // 4 is not divisible by 3, our answer has 1st bit set.\\n\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int i,c,ans=0;\\n        for(i=0;i<32;i++) // loop for ith bits\\n        {\\n            c=0;\\n            for(int j:nums) // loop over the numbers\\n            {\\n                if(j&(1<<i))  // check if ith bit is set or not\\n                    c++; // increment if set\\n            }\\n            if(c%3) // if the count c is not divisible by 3, then our answer has ith bit set\\n                ans += (1<<i); // update answer\\n        }\\n        return ans; //return answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int i,c,ans=0;\\n        for(i=0;i<32;i++) // loop for ith bits\\n        {\\n            c=0;\\n            for(int j:nums) // loop over the numbers\\n            {\\n                if(j&(1<<i))  // check if ith bit is set or not\\n                    c++; // increment if set\\n            }\\n            if(c%3) // if the count c is not divisible by 3, then our answer has ith bit set\\n                ans += (1<<i); // update answer\\n        }\\n        return ans; //return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506305,
                "title": "java-bit-manipulation-o-32n-simple",
                "content": "The idea is to take sum of all i\\'th bits and check if it\\'s divisible by 3. If bit%3 is 0, then no change in bit. If it is 1 then that bit is contributed by the odd element in the list. This process, when repeated for each bit, leaves us with final ans which is the odd element in the list.\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i=0;i<32;i++){\\n            int bit = 0;\\n            for(int j=0;j<nums.length;j++){\\n                bit+=((nums[j]>>i)%2==0)?0:1;\\n            }\\n            result = (bit % 3)<<i | result;\\n            \\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i=0;i<32;i++){\\n            int bit = 0;\\n            for(int j=0;j<nums.length;j++){\\n                bit+=((nums[j]>>i)%2==0)?0:1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1340301,
                "title": "3-methods-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //XOR+AND solution\\n    //TC:O(N) SC:O(1)\\n       int singleNumber(vector<int>& nums){\\n           int ones=0;\\n           int two=0;\\n           for(auto x:nums){\\n               ones=(x ^ones) & (~two);\\n               two=(x^two) & (~ones);\\n           }\\n           return ones;\\n       }\\n   \\n     int singleNumber(vector<int>& nums) {\\n         int n=nums.size();\\n         //Sorting and Linear Search Solution\\n         //TC:O(Nlogn+N) sc:O(n)\\n         sort(nums.begin(),nums.end());\\n         if(n<3)\\n             return nums[0];\\n         if(nums[0]<nums[1])\\n             return nums[0];\\n         else if(nums[n-2]<nums[n-1])\\n             return nums[n-1];\\n         else{\\n             int i=1;\\n             while(i<n-1){\\n                 if(nums[i-1]!=nums[i]){\\n                     return nums[i-1];\\n                 }\\n                 i+=3;\\n             }\\n         }\\n         return -1;\\n     }\\n   \\n    int singleNumber(vector<int>& nums) {\\n        // basic map solution \\n        //Time Complexity:O(n) Space complexity:O(n)\\n        map<int,int> m;\\n        for(auto it:nums){\\n            m[it]++;\\n        }\\n        for(auto x:m){\\n            if(x.second!=3){\\n                return x.first;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //XOR+AND solution\\n    //TC:O(N) SC:O(1)\\n       int singleNumber(vector<int>& nums){\\n           int ones=0;\\n           int two=0;\\n           for(auto x:nums){\\n               ones=(x ^ones) & (~two);\\n               two=(x^two) & (~ones);\\n           }\\n           return ones;\\n       }\\n   \\n     int singleNumber(vector<int>& nums) {\\n         int n=nums.size();\\n         //Sorting and Linear Search Solution\\n         //TC:O(Nlogn+N) sc:O(n)\\n         sort(nums.begin(),nums.end());\\n         if(n<3)\\n             return nums[0];\\n         if(nums[0]<nums[1])\\n             return nums[0];\\n         else if(nums[n-2]<nums[n-1])\\n             return nums[n-1];\\n         else{\\n             int i=1;\\n             while(i<n-1){\\n                 if(nums[i-1]!=nums[i]){\\n                     return nums[i-1];\\n                 }\\n                 i+=3;\\n             }\\n         }\\n         return -1;\\n     }\\n   \\n    int singleNumber(vector<int>& nums) {\\n        // basic map solution \\n        //Time Complexity:O(n) Space complexity:O(n)\\n        map<int,int> m;\\n        for(auto it:nums){\\n            m[it]++;\\n        }\\n        for(auto x:m){\\n            if(x.second!=3){\\n                return x.first;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326393,
                "title": "detailed-explanation-and-fast-solution-in-c",
                "content": "```\\n\\n```\\'\\'\\'class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        //when we have number which is repeating 1 time then it is stored in the variable ones .when we have number which is repeated two times then it is stored in twos and if number is repeated thrice then it is not stored in both .This is the simple idea behind this algorithm.\\n        int ones = 0;\\n        int twos = 0;\\n        for(int x : nums){ //for each loop to iterate over all the elements of nums vector\\n            ones = (ones^x) & (~twos); //we take xor of number and ones and perform bitwise and operation between the reult and the compliment of twos\\n            twos = (twos^x) & (~ones); //same like above just interchage ones and twos\\n        }\\n        return ones; //since we know that our number is reapeated only once so it is stored at ones so we return the ones\\n    }\\n    \\n    \\n};\\n\\'\\'\\'.\\nGuys do upvote if u like the post.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1212165,
                "title": "8-ms-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint bits = sizeof(int) * 8;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < bits; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.size(); j++) {\\n\\t\\t\\t\\tif (nums[j] & (1 << i)) count++;\\n\\t\\t\\t}\\n\\t\\t\\tcount = count % 3;\\n\\t\\t\\tif (count != 0) {\\n\\t\\t\\t\\tans = ans | (1 << i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\nthis approach is of O(32n) time complexity \\nO(n) complexity approach\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones=0;\\n        int twos=0;\\n        for(int i=0;i<nums.size();i++) {\\n            ones=(nums[i]^ones) & ~twos;\\n            twos=(nums[i]^twos) & ~ones;\\n        }\\n        return ones;\\n    }\\n};\\n```\\nhere we are storing 1st time occuring number in ones then on occuring 2nd time we are storing that no in twos and removing the number from ones and on occuring for 3rd time we are removing that number from twos too. So finally our only 1 time occuring number is stored in ones.\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint bits = sizeof(int) * 8;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < bits; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.size(); j++) {\\n\\t\\t\\t\\tif (nums[j] & (1 << i)) count++;\\n\\t\\t\\t}\\n\\t\\t\\tcount = count % 3;\\n\\t\\t\\tif (count != 0) {\\n\\t\\t\\t\\tans = ans | (1 << i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones=0;\\n        int twos=0;\\n        for(int i=0;i<nums.size();i++) {\\n            ones=(nums[i]^ones) & ~twos;\\n            twos=(nums[i]^twos) & ~ones;\\n        }\\n        return ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112426,
                "title": "java-solution-using-bit-manipulation-o-n-and-o-1",
                "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        int visitedOnce = 0, visitedTwice = 0;\\n        \\n        for(int i : nums){\\n            \\n            visitedOnce = (visitedOnce ^ i) & ~visitedTwice;\\n            visitedTwice = (visitedTwice ^ i) & ~visitedOnce;\\n        }\\n        \\n        return visitedOnce;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        int visitedOnce = 0, visitedTwice = 0;\\n        \\n        for(int i : nums){\\n            \\n            visitedOnce = (visitedOnce ^ i) & ~visitedTwice;\\n            visitedTwice = (visitedTwice ^ i) & ~visitedOnce;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 892203,
                "title": "python-bit-manipulation",
                "content": "Using a[i]b[i] as a binary number, to indicate (the sum of all i-th bit of num) % 3.\\nYou can use num[0:2] as a, b just with slight changes. => To meet the question requirement.\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:        \\n        a, b = 0, 0\\n        for x in nums:\\n            a, b = (~x&a&~b)|(x&~a&b), ~a&(x^b)\\n        return b\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:        \\n        a, b = 0, 0\\n        for x in nums:\\n            a, b = (~x&a&~b)|(x&~a&b), ~a&(x^b)\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842588,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(set(nums)) * 3 - sum(nums)) // 2\\n```\\n:D",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(set(nums)) * 3 - sum(nums)) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783524,
                "title": "simple-python3",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n      return (sum(set(nums)) * 3 - sum(nums)) // 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n      return (sum(set(nums)) * 3 - sum(nums)) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647051,
                "title": "c-simple-bitmasking-solution-with-constant-space",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int sum[32]={0};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<32;j++)\\n                sum[j]+=(arr[i]>>j)&1;\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n            if(sum[i]%3)\\n                ans=ans|(1<<i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int sum[32]={0};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<32;j++)\\n                sum[j]+=(arr[i]>>j)&1;\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n            if(sum[i]%3)\\n                ans=ans|(1<<i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628337,
                "title": "three-python-sol-sharing-w-visualization",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3 \\u89E3\\u984C\\u5F71\\u7247\\nTutorial video in Chinese](https://www.youtube.com/watch?v=Lw85DcQ1f1g)\\n\\nThree python sol sharing.\\n\\nFirst is by python built-in Counter.\\nSecond method is by bit masking with O(1) aux space.\\nThird method is by binary opeartion and FSM with O(1) aux space.\\n\\n![image.png](https://assets.leetcode.com/users/images/dd92b718-d90f-42da-9c16-98f18c9e098b_1688533217.6104689.png)\\n\\n\\n---\\n\\n**Implementation** by by python built-in Counter:\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n\\t\\t# key: number\\n\\t\\t# value: occurrennce\\n        num_occ_dict = Counter( nums )\\n        \\n        return [ number for number in num_occ_dict if num_occ_dict[number] == 1][0]\\n```\\n\\n---\\n\\n**Implementation** by bit masking with O(1) aux space:\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        single_num = 0\\n        \\n        # compute single number by bit masking\\n        for bit_shift in range(32):\\n            \\n            sum = 0\\n            \\n            for number in nums:\\n                \\n                # collect the bit sum\\n                sum += ( number >> bit_shift ) & 1\\n\\n            # Extract bit information of single number by modulo\\n            # Other number\\'s bit sum is removed by mod 3 (i.e., all other numbers appear three times)\\n            single_num |= ( sum % 3 ) << bit_shift\\n            \\n            \\n        \\n        if ( single_num & (1 << 31) ) == 0:\\n            return single_num\\n        else:\\n\\t\\t\\t# handle for negative number\\n            return -( (single_num^(0xFFFF_FFFF))+1 )\\n```\\n\\n---\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        # \\u51FA\\u73FE\\u4E00\\u6B21\\n        state_one = 0\\n\\n        # \\u51FA\\u73FE\\u5169\\u6B21\\n        state_two = 0\\n\\n        for num in nums:\\n            \\n            # \\u9019\\u908A\\u7528\\u767D\\u677F\\u63A8\\u5C0E\\u51FA\\u4F86\\u7684\\u7D50\\u679C\\n            # \\u88E1\\u9762\\u662FLogic Gate \\u548C State machine\\u7684\\u89C0\\u5FF5\\n            state_one = (num ^ state_one) & ~state_two\\n            state_two = (num ^ state_two) & ~state_one\\n\\n        # \\u6700\\u5F8C\\u6211\\u5011\\u60F3\\u8981\\u7684\\u6578\\u5B57\\uFF0C\\u662F\\u53EA\\u6709\\u51FA\\u73FE\\u4E00\\u6B21\\u7684\\u90A3\\u500B\\n        return state_one\\n```\\n\\n# Time complexity: O( n ) on for loop\\n\\n# Space complexity: O( 1 ) on fixed-size of temp variables\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #136 Single Number I](https://leetcode.com/problems/single-number)\\n\\n[Leetcode #260 Single Number III](https://leetcode.com/problems/single-number-iii)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n\\t\\t# key: number\\n\\t\\t# value: occurrennce\\n        num_occ_dict = Counter( nums )\\n        \\n        return [ number for number in num_occ_dict if num_occ_dict[number] == 1][0]\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        single_num = 0\\n        \\n        # compute single number by bit masking\\n        for bit_shift in range(32):\\n            \\n            sum = 0\\n            \\n            for number in nums:\\n                \\n                # collect the bit sum\\n                sum += ( number >> bit_shift ) & 1\\n\\n            # Extract bit information of single number by modulo\\n            # Other number\\'s bit sum is removed by mod 3 (i.e., all other numbers appear three times)\\n            single_num |= ( sum % 3 ) << bit_shift\\n            \\n            \\n        \\n        if ( single_num & (1 << 31) ) == 0:\\n            return single_num\\n        else:\\n\\t\\t\\t# handle for negative number\\n            return -( (single_num^(0xFFFF_FFFF))+1 )\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        # \\u51FA\\u73FE\\u4E00\\u6B21\\n        state_one = 0\\n\\n        # \\u51FA\\u73FE\\u5169\\u6B21\\n        state_two = 0\\n\\n        for num in nums:\\n            \\n            # \\u9019\\u908A\\u7528\\u767D\\u677F\\u63A8\\u5C0E\\u51FA\\u4F86\\u7684\\u7D50\\u679C\\n            # \\u88E1\\u9762\\u662FLogic Gate \\u548C State machine\\u7684\\u89C0\\u5FF5\\n            state_one = (num ^ state_one) & ~state_two\\n            state_two = (num ^ state_two) & ~state_one\\n\\n        # \\u6700\\u5F8C\\u6211\\u5011\\u60F3\\u8981\\u7684\\u6578\\u5B57\\uFF0C\\u662F\\u53EA\\u6709\\u51FA\\u73FE\\u4E00\\u6B21\\u7684\\u90A3\\u500B\\n        return state_one\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559668,
                "title": "bit-wise-ternary-add-truth-table-karnaugh-map-and-logic-expressions",
                "content": "We can implement a ternary add operation.\\n\\nHere is the truth table:\\nhigh low + x = new_high new_low\\n00 + 0 = 00\\n00 + 1 = 01\\n01 + 0 = 01\\n01 + 1 = 10\\n10 + 0 = 10\\n10 + 1 = 00\\n\\nTruth table by digit: (x = don\\'t care)\\nnew_low: \\n   00 01 11 10\\n0   0   1   x   0\\n1   1   0   x   0\\n\\nAssign x = 0 to simplify:\\n   00 01 11 10\\n0   0   1   0   0\\n1   1   0   0   0\\nnew_sum = (low^x) & (~high)\\n\\nnew_high:\\n   00 01 11 10\\n0   0   0   x   1\\n1   0   1   x   0\\n\\nAssign x = 1 to simplify:\\n   00 01 11 10\\n0   0   0   1   1\\n1   0   1   1   0\\nnew_high = (high&~x) | (low&x)\\n\\nHere is the solution:\\n\\n\\tclass Ternary {\\n        private:\\n            int low, high;\\n            \\n        public:\\n            Ternary(int x){\\n                low = x;\\n                high = 0;\\n            }\\n            void add(int x) {\\n                int new_low = (low^x) & (~high); \\n                int new_high = (high&~x) | (low&x);\\n                low = new_low;\\n                high = new_high;\\n            }\\n            int value(){\\n                return low;\\n            }\\n    };\\n\\n    int singleNumber(vector<int>& nums) {\\n        Ternary result(nums[0]);\\n        for(int i = 1; i < nums.size(); i++){\\n            result.add(nums[i]);\\n        }\\n        return result.value();\\n    }\\n\\n\\n",
                "solutionTags": [],
                "code": "We can implement a ternary add operation.\\n\\nHere is the truth table:\\nhigh low + x = new_high new_low\\n00 + 0 = 00\\n00 + 1 = 01\\n01 + 0 = 01\\n01 + 1 = 10\\n10 + 0 = 10\\n10 + 1 = 00\\n\\nTruth table by digit: (x = don\\'t care)\\nnew_low: \\n   00 01 11 10\\n0   0   1   x   0\\n1   1   0   x   0\\n\\nAssign x = 0 to simplify:\\n   00 01 11 10\\n0   0   1   0   0\\n1   1   0   0   0\\nnew_sum = (low^x) & (~high)\\n\\nnew_high:\\n   00 01 11 10\\n0   0   0   x   1\\n1   0   1   x   0\\n\\nAssign x = 1 to simplify:\\n   00 01 11 10\\n0   0   0   1   1\\n1   0   1   1   0\\nnew_high = (high&~x) | (low&x)\\n\\nHere is the solution:\\n\\n\\tclass Ternary {\\n        private:\\n            int low, high;\\n            \\n        public:\\n            Ternary(int x){\\n                low = x;\\n                high = 0;\\n            }\\n            void add(int x) {\\n                int new_low = (low^x) & (~high); \\n                int new_high = (high&~x) | (low&x);\\n                low = new_low;\\n                high = new_high;\\n            }\\n            int value(){\\n                return low;\\n            }\\n    };\\n\\n    int singleNumber(vector<int>& nums) {\\n        Ternary result(nums[0]);\\n        for(int i = 1; i < nums.size(); i++){\\n            result.add(nums[i]);\\n        }\\n        return result.value();\\n    }\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 428107,
                "title": "c-hashing-solution-time-n-space-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        \\n        unordered_map<int,int> m;\\n        \\n        for(int i : nums){\\n            m[i]++;\\n        }\\n        \\n        for(auto x:m){\\n            if(x.second==1)\\n                return x.first;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        \\n        unordered_map<int,int> m;\\n        \\n        for(int i : nums){\\n            m[i]++;\\n        }\\n        \\n        for(auto x:m){\\n            if(x.second==1)\\n                return x.first;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375784,
                "title": "c-o-n-time-and-o-1-space-easy-to-understand-explanation",
                "content": "```\\n/*\\n    Every bit index will occur in multiples of 3 times. So if some bit occurs k % 3 != 0 times then we know that the single number has a 1bit there. In fact that will occur for every 1 bit that the single number has. Thus we can reconstruct the number by creating a 32 bit number for each bit that occurs k%3 != 0 times\\n    \\n    i) Maintain an int[32] space\\n    ii) Get counts for each bit in each num\\n    iii) for ecah count that isn\\'t a multiple of three, then we add that bit to the res.\\n*/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int bits[32];\\n        for (int i = 0; i < 32; i++)\\n            bits[i] = 0;\\n        \\n        for (int num : nums){\\n            for (int i = 0; i < 32; i++){\\n                if ((num >> i) & 1 == 1)\\n                    bits[i]++;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < 32; i++){\\n            if (bits[i] != 0 && (bits[i] % 3) != 0)\\n                res |= 1 << i;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nNote that we can easily generalize this to the problem \"Every number occurs k>1 except for a single number\", by simply changing the modulo to %k",
                "solutionTags": [],
                "code": "```\\n/*\\n    Every bit index will occur in multiples of 3 times. So if some bit occurs k % 3 != 0 times then we know that the single number has a 1bit there. In fact that will occur for every 1 bit that the single number has. Thus we can reconstruct the number by creating a 32 bit number for each bit that occurs k%3 != 0 times\\n    \\n    i) Maintain an int[32] space\\n    ii) Get counts for each bit in each num\\n    iii) for ecah count that isn\\'t a multiple of three, then we add that bit to the res.\\n*/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int bits[32];\\n        for (int i = 0; i < 32; i++)\\n            bits[i] = 0;\\n        \\n        for (int num : nums){\\n            for (int i = 0; i < 32; i++){\\n                if ((num >> i) & 1 == 1)\\n                    bits[i]++;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < 32; i++){\\n            if (bits[i] != 0 && (bits[i] % 3) != 0)\\n                res |= 1 << i;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330338,
                "title": "readable-python-solution-beats-93-with-explanation",
                "content": "Like other variants of this problem, the idea is to use bitwise operators to cancel out the triplets. \\n\\nUnfortunately if we take an XOR of the entire input, for each triplet only two of them cancel and we are just left with the XOR of all unique numbers which gives us no information.\\n\\nSo instead of XOR we would like some operation, say #, that has the following properties (along with associativity and commutativity):\\n\\n1. x # x # x = 0\\n2. x # 0 = x\\n\\nAddition modulo 3 has precisely these properties, so we will apply this operation to get the solution. \\n\\nTo implement this, we simply have three bit masks which keep track of the state of the bits throughout the procedure. E.g. the zero mask will keep track of which bits sum to 0mod3 so far (these bits will be set, whereas all other bits will be unset). The one mask will keep track of bits which sum to 1mod3 so far, etc.\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # since we haven\\'t started the sum, initially all bits sum to 0mod3\\n\\t\\t# i.e. all bits in the zero mask should be set\\n        zero_mod3 = ~0\\n        one_mod3 = two_mod3 = 0\\n        \\n        for x in nums:\\n            tmp0, tmp1, tmp2 = zero_mod3, one_mod3, two_mod3\\n            \\n            zero_mod3 = (tmp2 & x) | (tmp0 & ~x)\\n            one_mod3 = (tmp0 & x) | (tmp1 & ~x)\\n            two_mod3 = (tmp1 & x) | (tmp2 & ~x)\\n            \\n        return one_mod3\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # since we haven\\'t started the sum, initially all bits sum to 0mod3\\n\\t\\t# i.e. all bits in the zero mask should be set\\n        zero_mod3 = ~0\\n        one_mod3 = two_mod3 = 0\\n        \\n        for x in nums:\\n            tmp0, tmp1, tmp2 = zero_mod3, one_mod3, two_mod3\\n            \\n            zero_mod3 = (tmp2 & x) | (tmp0 & ~x)\\n            one_mod3 = (tmp0 & x) | (tmp1 & ~x)\\n            two_mod3 = (tmp1 & x) | (tmp2 & ~x)\\n            \\n        return one_mod3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319863,
                "title": "a-generalized-c-solution-with-explanation-8-ms-no-extra-memory",
                "content": "We assume the input array has all unique elements occuring `K + 1` times except one occuring `M + 1` times. \\n\\nFor this question, we need to build an array of size `K` to store the information of bits of `1`. For every incoming bit of `1`, the state shifts down by one row and rolls back to the first row if it reaches the end. The state remains unchanged if the incoming bit is `0`.\\n\\n```\\nresults [0] [1] ... [K-1]\\n         0   0  ...   0\\n\\t\\t 1   0  ...   0\\n\\t\\t 0   1  ...   0\\n\\t\\t        ...\\n\\t\\t 0   0  ...   1\\n```\\n\\nSince we need an array of size `K`, the memory cost of the below code is O(`K`). The code is shown below:\\n\\n\\n```cpp\\nclass Solution {\\n    template <std::size_t K, std::size_t M, \\n              typename Container, \\n              typename Integral = typename Container::value_type>\\n    static typename std::enable_if<M < K, Integral>::type\\n    singleNumberTemplate(const Container &nums) {\\n        std::array<Integral, K> results{};\\n        for (const Integral x : nums)\\n            for (auto &res_i : results) {\\n                Integral flip = x;\\n                for (const auto res_j : results)\\n                    // if res[j] == res[i] but j != i, \\n                    // then res[j] == res[i] == 0\\n                    if (res_j != res_i)\\n                        flip &= ~res_j;\\n                res_i ^= flip;\\n            }\\n        return results[M];\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        return singleNumberTemplate<2, 0>(nums);\\n    }\\n};\\n```\\n\\nThis generalized code runs 8 ms and beats 98%. The runtime and memory usage is exactly the same as the normal approach (shown below) with two int varables.\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\t\\tint one = 0, two = 0;\\n        for (const int x : nums) {\\n            one ^= x & ~two;\\n            two ^= x & ~one;\\n        }\\n        return one;\\n    }\\n};\\n```\\n\\nNote: there is an alternative approach which has O(log(`K`)) memory complexity. It treats every bit of the input `Integral` type in seperate variables. Therefore, for a 32-bit `int`, you need an array of size 32. For each bit, you have `K + 1` states, which requires O(log(`K`)) memory. But for small `K`, the presented code seems to be more efficient.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nresults [0] [1] ... [K-1]\\n         0   0  ...   0\\n\\t\\t 1   0  ...   0\\n\\t\\t 0   1  ...   0\\n\\t\\t        ...\\n\\t\\t 0   0  ...   1\\n```\n```cpp\\nclass Solution {\\n    template <std::size_t K, std::size_t M, \\n              typename Container, \\n              typename Integral = typename Container::value_type>\\n    static typename std::enable_if<M < K, Integral>::type\\n    singleNumberTemplate(const Container &nums) {\\n        std::array<Integral, K> results{};\\n        for (const Integral x : nums)\\n            for (auto &res_i : results) {\\n                Integral flip = x;\\n                for (const auto res_j : results)\\n                    // if res[j] == res[i] but j != i, \\n                    // then res[j] == res[i] == 0\\n                    if (res_j != res_i)\\n                        flip &= ~res_j;\\n                res_i ^= flip;\\n            }\\n        return results[M];\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        return singleNumberTemplate<2, 0>(nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\t\\tint one = 0, two = 0;\\n        for (const int x : nums) {\\n            one ^= x & ~two;\\n            two ^= x & ~one;\\n        }\\n        return one;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244184,
                "title": "c-12ms-beats-99-26",
                "content": "## Single Number II\\n\\n### Approach: 12ms, faster than 99.62%\\nThere are 32 bit positions in an integer. We take the sum of all the 1\\'s that are at the ith bit position and take modulo 3. This way we get the ith bit of the single number. We do this for i=31 to i=0.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0,ans_final=0;\\n        for(int j=31;j>=0;j--)\\n        {\\n            ans=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                ans+=(nums[i]>>j)&1;\\n            }\\n            ans=(ans%3);\\n            ans_final=ans_final<<1;\\n            ans_final+=ans;\\n        }\\n        return ans_final;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0,ans_final=0;\\n        for(int j=31;j>=0;j--)\\n        {\\n            ans=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                ans+=(nums[i]>>j)&1;\\n            }\\n            ans=(ans%3);\\n            ans_final=ans_final<<1;\\n            ans_final+=ans;\\n        }\\n        return ans_final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212365,
                "title": "python-solution",
                "content": "Time complexity: `O(33n) = O(n)`, space complexity: `O(33) = O(1)`.\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def num2bin(num):\\n            i = 0\\n            if num < 0:\\n                num = -num\\n                count[32] += 1\\n            while num > 0:\\n                num, r = divmod(num, 2)\\n                count[i] += r\\n                i += 1\\n                \\n        def bin2num(binary):\\n            mult = 1\\n            ans = 0\\n            for i in range(len(binary)-1):\\n                ans += mult*binary[i]\\n                mult *= 2\\n            return ans\\n        \\n        count = [0]*33\\n        for n in nums:\\n            num2bin(n)\\n        for i in range(len(count)):\\n            count[i] %= 3\\n        res = bin2num(count)\\n        return res if count[-1] == 0 else -res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def num2bin(num):\\n            i = 0\\n            if num < 0:\\n                num = -num\\n                count[32] += 1\\n            while num > 0:\\n                num, r = divmod(num, 2)\\n                count[i] += r\\n                i += 1\\n                \\n        def bin2num(binary):\\n            mult = 1\\n            ans = 0\\n            for i in range(len(binary)-1):\\n                ans += mult*binary[i]\\n                mult *= 2\\n            return ans\\n        \\n        count = [0]*33\\n        for n in nums:\\n            num2bin(n)\\n        for i in range(len(count)):\\n            count[i] %= 3\\n        res = bin2num(count)\\n        return res if count[-1] == 0 else -res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43310,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ones = 0\\n        var twos = 0\\n        \\n        for num in nums {\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        }\\n        \\n        return ones\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ones = 0\\n        var twos = 0\\n        \\n        for num in nums {\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        }\\n        \\n        return ones\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43452,
                "title": "a-clean-state-machine-solution",
                "content": "    def singleNumber(self, A):\\n        # we need a state transfer machine:\\n        # from (bit2, bit1)  0,0->0,1->1,0->0,0\\n        bit1=0\\n        bit2=0\\n        for i in A:\\n            oldbit1=bit1\\n            bit1=bit1^(i&(~bit2))\\n            bit2=(oldbit1&i)|(bit2&(~i))\\n        \\n        return bit1\\n\\nSo only numbers appeared N (N ==1 mod 3) times are recorded in bit1.",
                "solutionTags": [],
                "code": "    def singleNumber(self, A):\\n        # we need a state transfer machine:\\n        # from (bit2, bit1)  0,0->0,1->1,0->0,0\\n        bit1=0\\n        bit2=0\\n        for i in A:\\n            oldbit1=bit1\\n            bit1=bit1^(i&(~bit2))\\n            bit2=(oldbit1&i)|(bit2&(~i))\\n        \\n        return bit1\\n\\nSo only numbers appeared N (N ==1 mod 3) times are recorded in bit1.",
                "codeTag": "Python3"
            },
            {
                "id": 43455,
                "title": "c-o-n-complex-solution-easy-to-understand",
                "content": "    class Solution{\\n    public:\\n    \\tint singleNumber(int A[], int n){\\n    \\t\\tint oneNum = 0;\\n    \\t\\tint twoNum = 0;\\n    \\t\\tint threeNum = 0;\\n    \\t\\tfor(int i = 0 ; i < n ;i++){\\n    \\t\\t\\tthreeNum = twoNum & A[i];\\n    \\t\\t\\ttwoNum = oneNum & A[i] | twoNum;\\n    \\t\\t\\toneNum = oneNum | A[i];\\n    \\t\\t\\toneNum = oneNum &(~threeNum);\\n    \\t\\t\\ttwoNum = twoNum & (~threeNum);\\n    \\t\\t\\tthreeNum = 0;\\n     \\t\\t}\\n    \\t\\treturn oneNum;\\n    \\t}\\n    };\\n\\neasy to understand this solution\\n\\n\\n    ----------\\n    \\n    \\n    oneNum means A[i] contains one bit 1\\n    towNum means A[i] contains two bit 1\\n    threeNum means A[i] contains three bit 1\\n    if three bit 1 occurs than flip oneNum to 0 and twoNum to 0 and threeNum to 0\\n    so the step will be like this\\n    bit in oneNum will change  like this 0-1-1-0\\n    bit in twoNum will change like this 0-0-1-0\\n    bit int threeNum will change like this 0 -1-0\\n    \\n    and it is easy to expand to other situations like four same num and so on",
                "solutionTags": [],
                "code": "class Solution{\\n    public:\\n    \\tint singleNumber(int A[], int n){\\n    \\t\\tint oneNum = 0;\\n    \\t\\tint twoNum = 0;\\n    \\t\\tint threeNum = 0;\\n    \\t\\tfor(int i = 0 ; i < n ;i++){\\n    \\t\\t\\tthreeNum = twoNum & A[i];\\n    \\t\\t\\ttwoNum = oneNum & A[i] | twoNum;\\n    \\t\\t\\toneNum = oneNum | A[i];\\n    \\t\\t\\toneNum = oneNum &(~threeNum);\\n    \\t\\t\\ttwoNum = twoNum & (~threeNum);\\n    \\t\\t\\tthreeNum = 0;\\n     \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3918083,
                "title": "java-o-n-o-1-ez-solution-everyone-can-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the array, if there is only one element in nums then just return nums[0], which is the only element in nums.\\nThen loop through the array, starting from index 1, and end at nums.length - 2, if nums[i] is not equals to nums[i-1] and is not equal to nums[i+1] then return nums[i](for example: 1,1,1,2,3,3,3, we return 2).\\nAfter the loop if we still haven\\'t find out the wanted element, we will see if nums[nums.length-1] is equal to the previous element, then decide if we should return nums[nums.length-1], after we loop through everything if we still haven\\'t find out the answer, return nums[0] since that\\'s the only one left, therefore it must be the answer.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length == 1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i = 1; i < nums.length-1; i++)\\n        {\\n            if(nums[i] != nums[i+1] && nums[i] != nums[i-1])\\n            {\\n                return nums[i];\\n            }\\n        }\\n        if(nums[nums.length-1]!=nums[nums.length-2])\\n        {\\n            return nums[nums.length-1];\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length == 1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i = 1; i < nums.length-1; i++)\\n        {\\n            if(nums[i] != nums[i+1] && nums[i] != nums[i-1])\\n            {\\n                return nums[i];\\n            }\\n        }\\n        if(nums[nums.length-1]!=nums[nums.length-2])\\n        {\\n            return nums[nums.length-1];\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718094,
                "title": "c-easy-solution-using-hashmap",
                "content": "\\n\\n# Approach\\nThe approach in this code is to use a hashmap to count the frequency of each number in the vector. Then, iterate through the vector again to find the number with a frequency of 1, which is the single number. Finally, return the single number found or 0 if none is found.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m[nums[i]]==1)\\n            {\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\nPLEASE DO UPVOTE IF YOU FOUND IT HELPFUL!",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m[nums[i]]==1)\\n            {\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717166,
                "title": "python-elegant-short-one-line-counter",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return next(num for num, cnt in Counter(nums).items() if cnt == 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return next(num for num, cnt in Counter(nums).items() if cnt == 1)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1955336,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955398,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1571297,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1808199,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955593,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1565005,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955422,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955356,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1572305,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1571299,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955336,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955398,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1571297,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1808199,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955593,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1565005,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955422,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955356,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1572305,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1571299,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1956051,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1955860,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1955378,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1571298,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1955572,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1955507,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1795212,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1695852,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1568958,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1570899,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1956306,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1955954,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1955715,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1955592,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1955508,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1955388,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1683000,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1575710,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1568959,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1575196,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 2069358,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 2062529,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 2046330,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1999301,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1990890,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1973523,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1973238,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1956644,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1956443,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1956439,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1956278,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1956196,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1956151,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1956061,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955923,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955879,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955852,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955829,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955816,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955786,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955781,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955774,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955765,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955758,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955742,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955737,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955678,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955663,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955648,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955563,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955539,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955511,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955484,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955439,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955425,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955413,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955384,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955366,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955307,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1914395,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1861219,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1853857,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1846521,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1820298,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1780982,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1767555,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1761815,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1751544,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1706930,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1700760,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Dota2 Senate",
        "question_content": "<p>In the world of Dota2, there are two parties: the Radiant and the Dire.</p>\n\n<p>The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise <strong>one</strong> of the two rights:</p>\n\n<ul>\n\t<li><strong>Ban one senator&#39;s right:</strong> A senator can make another senator lose all his rights in this and all the following rounds.</li>\n\t<li><strong>Announce the victory:</strong> If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.</li>\n</ul>\n\n<p>Given a string <code>senate</code> representing each senator&#39;s party belonging. The character <code>&#39;R&#39;</code> and <code>&#39;D&#39;</code> represent the Radiant party and the Dire party. Then if there are <code>n</code> senators, the size of the given string will be <code>n</code>.</p>\n\n<p>The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.</p>\n\n<p>Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be <code>&quot;Radiant&quot;</code> or <code>&quot;Dire&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> senate = &quot;RD&quot;\n<strong>Output:</strong> &quot;Radiant&quot;\n<strong>Explanation:</strong> \nThe first senator comes from Radiant and he can just ban the next senator&#39;s right in round 1. \nAnd the second senator can&#39;t exercise any rights anymore since his right has been banned. \nAnd in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> senate = &quot;RDD&quot;\n<strong>Output:</strong> &quot;Dire&quot;\n<strong>Explanation:</strong> \nThe first senator comes from Radiant and he can just ban the next senator&#39;s right in round 1. \nAnd the second senator can&#39;t exercise any rights anymore since his right has been banned. \nAnd the third senator comes from Dire and he can ban the first senator&#39;s right in round 1. \nAnd in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == senate.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>senate[i]</code> is either <code>&#39;R&#39;</code> or <code>&#39;D&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3483399,
                "title": "simple-diagram-explanation",
                "content": "# Idea\\n- **We will use a two queue approach.**\\n- Recall, each senator has a position to exercise their right. \\n- The ones to the left have an earlier turn than the ones to the right. \\n- `rad` is queue that holds all positions of **active** senators in \"Radiant\"\\n- `dir` is queue that holds all positions of **active** senators in \"Dire\".\\n- **Active** being that they still have the right to vote. \\n- Our queue will be ordered so that the senators with earlier voting power come first (to the left of the queue). \\n- To goal is to have the earliest senator of each queue *fight* each other to see who gets to eliminate the other depending on their position. \\n- Obviously, the one with the earlier position will win. \\n- The loser is removed from the queue since they are no longer **active.**\\n- The winner will go to the end of the queue for the next round. \\n- We keep doing this until one queue is empty which means there are no more senators on the team. \\n\\n# Everything is easier with an example: \\n- `senate = \"RDDDRDRRDR\"`\\n\\n![1.jpg](https://assets.leetcode.com/users/images/c5361ad6-b1f4-480d-a6ca-a515f5c615bc_1683167194.103648.jpeg)\\n\\n![2.jpg](https://assets.leetcode.com/users/images/d23626fe-93b7-4c4e-a05e-f320c50f5f4a_1683167199.106047.jpeg)\\n\\n![3.jpg](https://assets.leetcode.com/users/images/104fd17d-4930-4fda-a13f-b76c8fe15f7d_1683167208.2531068.jpeg)\\n\\n![4.jpg](https://assets.leetcode.com/users/images/63781327-0609-4401-a41a-17ec0d52dab1_1683167222.9743638.jpeg)\\n\\n![5.jpg](https://assets.leetcode.com/users/images/12990ac3-e8e7-4623-a288-5df531af8c94_1683167228.5669239.jpeg)\\n![6.jpg](https://assets.leetcode.com/users/images/4cbf8431-1ee4-47b2-a9b6-e40bac0140a9_1683167239.3575938.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> rad, dir;\\n        int n = senate.length();\\n        // Add all senators to respect queue with index\\n        for (int i = 0; i < n; i++){\\n            if (senate[i] == \\'R\\'){\\n                rad.push(i);\\n            }\\n            else {\\n                dir.push(i);\\n            }\\n        }\\n        // Use increasing n to keep track of position\\n        while (!rad.empty() && !dir.empty()){\\n            // Only \"winner\" stays in their queue\\n            if (rad.front() < dir.front()){\\n                rad.push(n++);\\n            }\\n            else {\\n                dir.push(n++);\\n            }\\n            rad.pop(), dir.pop();\\n        }\\n        return (rad.empty()) ? (\"Dire\") : (\"Radiant\");\\n    }\\n};\\n```\\n### Why does the winner go to the end of the queue?\\n- Since the voting is done such that both sides perform the most optimal strategy, the senators who have already voted will not be a problem to the other team for that round. \\n- So, instead of eliminating a senator who has already moved, the best move for each team is to eliminate the next senator who has the power to vote. \\n- This works perfectly with the queue approach since we can just place the senators who have voted at the end. \\n## If this helped, please leave an upvote! Much appreciated!\\n##### edit: Thanks all for the kind comments; it definitely motivates me to make more of these diagram solutions!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> rad, dir;\\n        int n = senate.length();\\n        // Add all senators to respect queue with index\\n        for (int i = 0; i < n; i++){\\n            if (senate[i] == \\'R\\'){\\n                rad.push(i);\\n            }\\n            else {\\n                dir.push(i);\\n            }\\n        }\\n        // Use increasing n to keep track of position\\n        while (!rad.empty() && !dir.empty()){\\n            // Only \"winner\" stays in their queue\\n            if (rad.front() < dir.front()){\\n                rad.push(n++);\\n            }\\n            else {\\n                dir.push(n++);\\n            }\\n            rad.pop(), dir.pop();\\n        }\\n        return (rad.empty()) ? (\"Dire\") : (\"Radiant\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105858,
                "title": "java-c-very-simple-greedy-solution-with-explanation",
                "content": "This is obliviously a greedy algorithm problem. Each senate ```R``` must ban its next **closest** senate ```D``` who is from another party, or else ```D``` will ban its next  senate from  ```R's``` party. \\n\\nThe idea is to use two queues to save the index of each senate from ```R's``` and ```D's``` parties, respectively. During each round, we delete the banned senate's index; and plus the remainning senate's index with ```n```(the length of the input string ```senate```), then move it to the back of its respective queue.\\n\\nJava version:\\n```\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> q1 = new LinkedList<Integer>(), q2 = new LinkedList<Integer>();\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++){\\n            if(senate.charAt(i) == 'R')q1.add(i);\\n            else q2.add(i);\\n        }\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            int r_index = q1.poll(), d_index = q2.poll();\\n            if(r_index < d_index)q1.add(r_index + n);\\n            else q2.add(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n```\\n\\nC++ version:\\n```\\nstring predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == 'R')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```R```\n```D```\n```D```\n```R's```\n```R's```\n```D's```\n```n```\n```senate```\n```\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> q1 = new LinkedList<Integer>(), q2 = new LinkedList<Integer>();\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++){\\n            if(senate.charAt(i) == 'R')q1.add(i);\\n            else q2.add(i);\\n        }\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            int r_index = q1.poll(), d_index = q2.poll();\\n            if(r_index < d_index)q1.add(r_index + n);\\n            else q2.add(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n```\n```\\nstring predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == 'R')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704597,
                "title": "c-explanation-with-diagram",
                "content": "*Lets take some examples to understand this question*\\nInput: senate = ***\"RDRDD\"*** and ***\"DDRRR\"***\\n\\n![image](https://assets.leetcode.com/users/images/4845cb16-d83f-448f-a9cb-2356a5b4cdae_1642680083.4083123.png)\\n\\nHere R takes rights of D and again joins back of the string.\\n\\nWe will take \"RDRDD\" example and see how to code for this problem.\\n\\nFirst we will create 2 queues for radiant and dire, and next we push indices of R to R queue and indices of D to D queue.\\n\\n![image](https://assets.leetcode.com/users/images/cdbbd068-d20b-4663-a836-29ab3821da66_1642678115.2998025.png)\\n\\nNow we take 2 front elements from queues, pop both of them and add the min elem to the queue at the back (as it kills and gets ready for another round).\\n![image](https://assets.leetcode.com/users/images/f72d39e5-44ca-474d-b8f7-2d2595aa06ef_1642678211.2474039.png)\\n\\n**That\\'s it!!** \\uD83E\\uDD73 Atlast Radiant won against Dire! \\n\\n***Lets see the code for this problem***\\n\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> rq, dq;\\n        \\n        for(int i=0; i<senate.size(); i++)\\n            senate[i] == \\'R\\' ? rq.push(i): dq.push(i);\\n        \\n        int a, b;\\n        while(!rq.empty() and !dq.empty()){\\n            a = rq.front(), b = dq.front();\\n            rq.pop(), dq.pop();\\n            if (a < b) // taking min and pushing it to queue again\\n                rq.push(a+senate.size());\\n            else\\n                dq.push(b+senate.size());\\n        }\\n        \\n\\t\\tif (rq.size() > dq.size())\\n\\t\\t\\treturn \"Radiant\";\\n\\t\\telse\\n\\t\\t\\treturn \"Dire\";\\n    }\\n};\\n```\\n\\n***Time Complexity:*** O(string size) --> O(n)\\n***Space Complexity:*** O(queue size) --> O(n)\\n\\nA bit similar question with same concept: https://leetcode.com/problems/find-the-winner-of-the-circular-game/ \\n\\nPlease Upvote If you liked it \\u263A\\uFE0F!! It keeps me motivated to post solutions like these.\\nIf there are any suggestions / questions / mistakes in my post, comment below.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> rq, dq;\\n        \\n        for(int i=0; i<senate.size(); i++)\\n            senate[i] == \\'R\\' ? rq.push(i): dq.push(i);\\n        \\n        int a, b;\\n        while(!rq.empty() and !dq.empty()){\\n            a = rq.front(), b = dq.front();\\n            rq.pop(), dq.pop();\\n            if (a < b) // taking min and pushing it to queue again\\n                rq.push(a+senate.size());\\n            else\\n                dq.push(b+senate.size());\\n        }\\n        \\n\\t\\tif (rq.size() > dq.size())\\n\\t\\t\\treturn \"Radiant\";\\n\\t\\telse\\n\\t\\t\\treturn \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483301,
                "title": "solutions-in-c-python-and-java",
                "content": "# Code\\n<iframe src=\"https://leetcode.com/playground/7gyLhdmK/shared\" frameBorder=\"0\" width=\"700\" height=\"400\"></iframe>\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "# Code\\n<iframe src=\"https://leetcode.com/playground/7gyLhdmK/shared\" frameBorder=\"0\" width=\"700\" height=\"400\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3483743,
                "title": "short-is-enough-c-with-0ms",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**The approach taken by this implementation is to use a score to keep track of the number of senators in each party. The score is initialized to 0, with a positive value indicating more Republicans than Democrats, and a negative value indicating more Democrats than Republicans. The algorithm then iterates through the senate string, looking at each senator\\'s party affiliation and adjusting the score accordingly. If the score is negative and a Republican senator is encountered, it means that a Democrat senator has already voted to remove a Republican senator, so a new Democrat senator is added to the end of the string to maintain the balance. Similarly, if the score is positive and a Democrat senator is encountered, a new Republican senator is added to the end of the string. In this way, the algorithm ensures that the balance between the two parties is maintained, and the senate voting process can continue until one party has more senators left than the other.**\\n\\n\\n**Finally, after all the votes have been cast, the algorithm checks the value of the score. If the score is positive, it means that there are more Republicans left in the senate, and \"Radiant\" is returned as the winning party. Otherwise, if the score is negative or zero, there are more Democrats left, and \"Dire\" is returned as the winning party.**\\n\\n\\n**Overall, the implementation is a straightforward approach that uses the score to keep track of the balance between the two parties and ensures that the senate vote continues until one party has more senators left than the other.**\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n- **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# kindly upvote it\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n   \\n        int score = 0; // +ve for R and -ve for D\\n        for (int i = 0; i < senate.size(); ++i) {\\n            const char ch = senate[i];\\n            if (ch == \\'R\\') {\\n                if (score < 0) \\n                    senate.push_back(\\'D\\');\\n                \\n                ++score;\\n            } else {\\n                if (score > 0) \\n                    senate.push_back(\\'R\\');\\n                \\n                --score;\\n            }\\n        }\\n        return score > 0 ? \"Radiant\" : \"Dire\";\\n \\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n   \\n        int score = 0; // +ve for R and -ve for D\\n        for (int i = 0; i < senate.size(); ++i) {\\n            const char ch = senate[i];\\n            if (ch == \\'R\\') {\\n                if (score < 0) \\n                    senate.push_back(\\'D\\');\\n                \\n                ++score;\\n            } else {\\n                if (score > 0) \\n                    senate.push_back(\\'R\\');\\n                \\n                --score;\\n            }\\n        }\\n        return score > 0 ? \"Radiant\" : \"Dire\";\\n \\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105879,
                "title": "python-straightforward-with-explanation",
                "content": "Simulate the process.  We don't have to resolve bans until later - we can just let them \"float\".\\n\\nWe have ```people = [int, int]``` representing how many people are in the queue, and ```bans = [int, int]``` representing how many \"floating\" bans there are.  When we meet a person, if there is a floating ban waiting for them, then they are banned and we skip them.  Eventually, the queue will just have one type of person, which is when we break.\\n\\n```\\ndef predictPartyVictory(self, senate):\\n    A = collections.deque()\\n    people = [0, 0]\\n    bans = [0, 0]\\n\\n    for person in senate:\\n        x = person == 'R'\\n        people[x] += 1\\n        A.append(x)\\n\\n    while all(people):\\n        x = A.popleft()\\n        people[x] -= 1\\n        if bans[x]:\\n            bans[x] -= 1\\n        else:\\n            bans[x^1] += 1\\n            A.append(x)\\n            people[x] += 1\\n\\n    return \"Radiant\" if people[1] else \"Dire\"\\n```",
                "solutionTags": [],
                "code": "```people = [int, int]```\n```bans = [int, int]```\n```\\ndef predictPartyVictory(self, senate):\\n    A = collections.deque()\\n    people = [0, 0]\\n    bans = [0, 0]\\n\\n    for person in senate:\\n        x = person == 'R'\\n        people[x] += 1\\n        A.append(x)\\n\\n    while all(people):\\n        x = A.popleft()\\n        people[x] -= 1\\n        if bans[x]:\\n            bans[x] -= 1\\n        else:\\n            bans[x^1] += 1\\n            A.append(x)\\n            people[x] += 1\\n\\n    return \"Radiant\" if people[1] else \"Dire\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3483292,
                "title": "simply-explained-python-queue-95",
                "content": "**Solution-**\\nMake two different queues for R & D and delete the left most entry for each.\\nWhichever is left at the end is the winner.\\n\\n\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n\\n        n = len(senate)\\n\\n        r_arr = [i for i in range(len(senate)) if senate[i]==\\'R\\']\\n        d_arr = [j for j in range(len(senate)) if senate[j]==\\'D\\']\\n        \\n        while r_arr and d_arr:\\n            r = r_arr.pop(0)\\n            d = d_arr.pop(0)\\n            if r < d:\\n                r_arr.append(n + r)\\n            else:\\n                d_arr.append(n + d)\\n                \\n        return \\'Radiant\\' if r_arr else \\'Dire\\'",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "**Solution-**\\nMake two different queues for R & D and delete the left most entry for each.\\nWhichever is left at the end is the winner.\\n\\n\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n\\n        n = len(senate)\\n\\n        r_arr = [i for i in range(len(senate)) if senate[i]==\\'R\\']\\n        d_arr = [j for j in range(len(senate)) if senate[j]==\\'D\\']\\n        \\n        while r_arr and d_arr:\\n            r = r_arr.pop(0)\\n            d = d_arr.pop(0)\\n            if r < d:\\n                r_arr.append(n + r)\\n            else:\\n                d_arr.append(n + d)\\n                \\n        return \\'Radiant\\' if r_arr else \\'Dire\\'",
                "codeTag": "Java"
            },
            {
                "id": 3483318,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. I planned to give for next 10,000 Subscribers as well. If you\\'re interested **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\nWe can simulate the voting process between the two parties (Radiant and Dire) using a queue to store the indices of the senators in each party. We can then repeatedly dequeue the front senator from each party and compare their indices. If the senator from the Radiant party has a smaller index, we know that they were the first to announce their vote and we can enqueue them back at the end of the Radiant queue after increasing their index by n (the number of total senators). If the senator from the Dire party has a smaller index, we perform the same operation but with the Dire queue instead. We keep repeating this process until one of the parties has no senators left, at which point we declare the other party as the winner.\\n\\n# Intuition:\\n\\nThe problem asks us to determine the winner of a voting process between two parties. We can think of this process as a game of sorts, where each senator represents a player, and each round of voting represents a turn. The goal is to eliminate as many players from the opposing party as possible while keeping as many players from our own party alive. This is similar to games like chess or checkers, where the goal is to capture as many pieces from the opposing player as possible while keeping as many of our own pieces as possible.\\n\\nThe voting process in the problem can be modeled as a queue-based game, where the indices of the senators represent the positions of the game pieces on the board. We can use the queue data structure to represent the positions of the senators in each party, and simulate the voting process by dequeuing the front senator from each party and comparing their indices. The senator with the smaller index represents the player who gets to move first, and we can enqueue them back at the end of their party\\'s queue after incrementing their index by n. This models the process of moving a game piece across the board, where each move involves incrementing the position of the piece by a fixed amount.\\n\\nThe winner of the game is determined by the number of players left in each party. If one party has no senators left, the other party wins by default. This models the endgame scenario in chess or checkers, where the winner is determined by the number of pieces left on the board after all possible moves have been exhausted.\\n\\n\\n```Python []\\nfrom collections import deque\\n\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        n = len(senate)\\n        radiant = deque()\\n        dire = deque()\\n        for i, s in enumerate(senate):\\n            if s == \\'R\\':\\n                radiant.append(i)\\n            else:\\n                dire.append(i)\\n        while radiant and dire:\\n            r_idx = radiant.popleft()\\n            d_idx = dire.popleft()\\n            if r_idx < d_idx:\\n                radiant.append(r_idx + n)\\n            else:\\n                dire.append(d_idx + n)\\n        return \"Radiant\" if radiant else \"Dire\"\\n\\n```\\n```Java []\\n\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int n = senate.length();\\n        Deque<Integer> radiant = new LinkedList<>();\\n        Deque<Integer> dire = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (senate.charAt(i) == \\'R\\') {\\n                radiant.offer(i);\\n            } else {\\n                dire.offer(i);\\n            }\\n        }\\n        while (!radiant.isEmpty() && !dire.isEmpty()) {\\n            int r_idx = radiant.poll();\\n            int d_idx = dire.poll();\\n            if (r_idx < d_idx) {\\n                radiant.offer(r_idx + n);\\n            } else {\\n                dire.offer(d_idx + n);\\n            }\\n        }\\n        return radiant.isEmpty() ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n\\n```\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n = senate.length();\\n        deque<int> radiant, dire;\\n        for (int i = 0; i < n; i++) {\\n            if (senate[i] == \\'R\\') {\\n                radiant.push_back(i);\\n            } else {\\n                dire.push_back(i);\\n            }\\n        }\\n        while (!radiant.empty() && !dire.empty()) {\\n            int r_idx = radiant.front();\\n            int d_idx = dire.front();\\n            radiant.pop_front();\\n            dire.pop_front();\\n            if (r_idx < d_idx) {\\n                radiant.push_back(r_idx + n);\\n            } else {\\n                dire.push_back(d_idx + n);\\n            }\\n        }\\n        return radiant.empty() ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Python []\\nfrom collections import deque\\n\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        n = len(senate)\\n        radiant = deque()\\n        dire = deque()\\n        for i, s in enumerate(senate):\\n            if s == \\'R\\':\\n                radiant.append(i)\\n            else:\\n                dire.append(i)\\n        while radiant and dire:\\n            r_idx = radiant.popleft()\\n            d_idx = dire.popleft()\\n            if r_idx < d_idx:\\n                radiant.append(r_idx + n)\\n            else:\\n                dire.append(d_idx + n)\\n        return \"Radiant\" if radiant else \"Dire\"\\n\\n```\n```Java []\\n\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int n = senate.length();\\n        Deque<Integer> radiant = new LinkedList<>();\\n        Deque<Integer> dire = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (senate.charAt(i) == \\'R\\') {\\n                radiant.offer(i);\\n            } else {\\n                dire.offer(i);\\n            }\\n        }\\n        while (!radiant.isEmpty() && !dire.isEmpty()) {\\n            int r_idx = radiant.poll();\\n            int d_idx = dire.poll();\\n            if (r_idx < d_idx) {\\n                radiant.offer(r_idx + n);\\n            } else {\\n                dire.offer(d_idx + n);\\n            }\\n        }\\n        return radiant.isEmpty() ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n\\n```\n```C++ []\\n\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n = senate.length();\\n        deque<int> radiant, dire;\\n        for (int i = 0; i < n; i++) {\\n            if (senate[i] == \\'R\\') {\\n                radiant.push_back(i);\\n            } else {\\n                dire.push_back(i);\\n            }\\n        }\\n        while (!radiant.empty() && !dire.empty()) {\\n            int r_idx = radiant.front();\\n            int d_idx = dire.front();\\n            radiant.pop_front();\\n            dire.pop_front();\\n            if (r_idx < d_idx) {\\n                radiant.push_back(r_idx + n);\\n            } else {\\n                dire.push_back(d_idx + n);\\n            }\\n        }\\n        return radiant.empty() ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105860,
                "title": "c-o-n-solution",
                "content": "It is not hard to see the greedy way to win is to ban next earliest opponent in a circle.\\nI use a variable \"count\" for how many R or D, and a string s for the state after current iteration. count > 0 means more active R, while count < 0 means more active D. When encountering 'D', if count > 0, this 'D' is banned, and count--. This 'D' is not appended to string s. If count <= 0, it will be appended to s.\\nBecause every active senate will ban another senate in a circle, the length of senate will shrink in half. Otherwise the game is over in current or next iteration. So the run time is n+n/2+n/4+..., which is O(n).\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int count = 0, len = 0;\\n        // When the length of senate doesn't decrease, the game is over.\\n        while (senate.size() != len) {\\n            string s;\\n            len = senate.size();\\n            for (int i = 0; i < len; i++) {\\n                if (senate[i] == 'R') {\\n                    if (count++ >= 0) s += 'R';\\n                }\\n                else if (senate[i] == 'D') {\\n                    if (count-- <= 0) s += 'D';\\n                }\\n            }  \\n            swap(s, senate);\\n        }\\n        if (senate[0] == 'R') \\n            return \"Radiant\";\\n        else \\n            return \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int count = 0, len = 0;\\n        // When the length of senate doesn't decrease, the game is over.\\n        while (senate.size() != len) {\\n            string s;\\n            len = senate.size();\\n            for (int i = 0; i < len; i++) {\\n                if (senate[i] == 'R') {\\n                    if (count++ >= 0) s += 'R';\\n                }\\n                else if (senate[i] == 'D') {\\n                    if (count-- <= 0) s += 'D';\\n                }\\n            }  \\n            swap(s, senate);\\n        }\\n        if (senate[0] == 'R') \\n            return \"Radiant\";\\n        else \\n            return \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366989,
                "title": "simple-queue-implementation-in-c",
                "content": "lets say the string \"RRRDDDD\"\\n\\nrad queue=\"012\"\\ndir queue=\"3456\"\\ns=7\\n\\nrad front value is less than dir front value so we will put **(rad front + s)** at the end of the queue as it has already used the power and might use the power in the next round.\\nrad queue=\"127\"\\ndir queue=\"456\"\\n\\nand we can say it is looking something like    R(1) R(2) D(4) D(5) D(6) R(7)\\n\\nnow again rad front is less then dir front so\\nrad queue=\"278\"\\ndir queue =\"56\"\\n\\nand we can say it is looking something like     R(2) D(4) D(5) D(6) R(7) R(8)\\n\\n\\nand this process will keep on going.....\\n \\n\\n\\n```\\nstring predictPartyVictory(string senate) {\\n        queue<int> dir;\\n        queue<int> rad;\\n        for(int i=0;i<senate.length();i++)\\n        {\\n            if(senate[i]==\\'D\\')\\n            {\\n                dir.push(i);\\n            }\\n            else\\n            {\\n                rad.push(i);\\n            }\\n        }\\n        int s=senate.length();\\n        while(true)\\n        {\\n            if(rad.empty()){return \"Dire\";}\\n            if(dir.empty()){return \"Radiant\";}\\n            int r=rad.front();\\n            int d=dir.front();\\n            rad.pop();\\n            dir.pop();\\n            if(r<d)\\n            {\\n                rad.push(r+s);\\n            }\\n            else\\n            {\\n                dir.push(d+s);\\n            }\\n        }\\n    }\\n```\\n\\n\\nplease upvote if i made you understand my approach.\\n\\n**#happy_coding**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nstring predictPartyVictory(string senate) {\\n        queue<int> dir;\\n        queue<int> rad;\\n        for(int i=0;i<senate.length();i++)\\n        {\\n            if(senate[i]==\\'D\\')\\n            {\\n                dir.push(i);\\n            }\\n            else\\n            {\\n                rad.push(i);\\n            }\\n        }\\n        int s=senate.length();\\n        while(true)\\n        {\\n            if(rad.empty()){return \"Dire\";}\\n            if(dir.empty()){return \"Radiant\";}\\n            int r=rad.front();\\n            int d=dir.front();\\n            rad.pop();\\n            dir.pop();\\n            if(r<d)\\n            {\\n                rad.push(r+s);\\n            }\\n            else\\n            {\\n                dir.push(d+s);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483505,
                "title": "step-by-step-guide-javascript-code-with-comments-and-detailed-explanation",
                "content": "# Intuition\\nThe problem requires us to simulate a game-like situation where two parties are competing, and the outcome of the game depends on the actions taken by each party. In this case, the two parties are represented by the characters \\'R\\' and \\'D\\' in the given string \"senate\", and the goal is to determine which party will win the game.\\n\\nThe game is played in rounds, and each senator can either ban another senator\\'s right to vote or announce the victory if they are the last one standing from their party. The game ends when there are no senators left with the right to vote.\\n\\n# Approach\\n1. First, we create two empty arrays, radiant and dire, to store the indices of the senators from each party.\\n2. We loop through the **senate** string and add the index of each senator to their respective party array. If the current character is \\'R\\', we push the current index to the **radiant** array, and if it is \\'D\\', we push it to the **dire** array.\\n3. We then enter a loop that runs until either the **radiant** or **dire** array becomes empty. In each iteration of the loop, we compare the index of the first senator from each party.\\n4. If the index of the first radiant senator is smaller than that of the first dire senator, then the radiant senator can ban the dire senator\\'s right to vote. We remove the first element of the **dire** array using the **shift** method, and add the index of the next radiant senator to the end of the radiant array using the **push** method.\\n5. If the index of the first dire senator is smaller than that of the first radiant senator, then the dire senator can ban the radiant senator\\'s right to vote. We remove the first element of the **radiant** array using the shift method, and add the index of the next **dire** senator to the end of the dire array using the push method.\\n6. We repeat **steps 4 and 5** until either the **radiant** or **dire** array becomes **empty**.\\n7. Finally, we check whether the **radiant** array is **empty** or **not**. If it is **empty**, then the **dire party** has successfully banned all the **radiant senators**, and vice versa. We return the appropriate **string** indicating the **victorious** party.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {string} senate\\n * @return {string}\\n */\\nfunction predictPartyVictory(senate) {\\n  // Initialize two arrays to keep track of the indices of the senators from each party.\\n  let radiant = [];\\n  let dire = [];\\n  const n = senate.length;\\n\\n  // Loop through each senator in the given order.\\n  for (let i = 0; i < n; i++) {\\n    // If the senator is from the Radiant party, add their index to the radiant array\\n    // with an offset of n, representing their vote in the next round.\\n    if (senate[i] === \\'R\\') {\\n      radiant.push(i + n);\\n    } else {\\n      // If the senator is from the Dire party, add their index to the dire array\\n      // with an offset of n, representing their vote in the next round.\\n      dire.push(i + n);\\n    }\\n  }\\n\\n  // Loop through each round until one party has all the votes.\\n  while (radiant.length > 0 && dire.length > 0) {\\n    // Compare the indices of the first senator from each party.\\n    if (radiant[0] < dire[0]) {\\n      // If the Radiant senator\\'s index is less than the Dire senator\\'s index,\\n      // add their index to the end of the radiant array with an offset of n,\\n      // representing their vote in the next round.\\n      radiant.push(radiant[0] + n);\\n    } else {\\n      // If the Dire senator\\'s index is less than or equal to the Radiant senator\\'s index,\\n      // add their index to the end of the dire array with an offset of n,\\n      // representing their vote in the next round.\\n      dire.push(dire[0] + n);\\n    }\\n    // Remove the first senator from each party\\'s array, since they have voted in this round.\\n    radiant.shift();\\n    dire.shift();\\n  }\\n\\n  // Return the winner of the voting procedure based on which party has remaining votes.\\n  return (radiant.length > 0) ? \"Radiant\" : \"Dire\";\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} senate\\n * @return {string}\\n */\\nfunction predictPartyVictory(senate) {\\n  // Initialize two arrays to keep track of the indices of the senators from each party.\\n  let radiant = [];\\n  let dire = [];\\n  const n = senate.length;\\n\\n  // Loop through each senator in the given order.\\n  for (let i = 0; i < n; i++) {\\n    // If the senator is from the Radiant party, add their index to the radiant array\\n    // with an offset of n, representing their vote in the next round.\\n    if (senate[i] === \\'R\\') {\\n      radiant.push(i + n);\\n    } else {\\n      // If the senator is from the Dire party, add their index to the dire array\\n      // with an offset of n, representing their vote in the next round.\\n      dire.push(i + n);\\n    }\\n  }\\n\\n  // Loop through each round until one party has all the votes.\\n  while (radiant.length > 0 && dire.length > 0) {\\n    // Compare the indices of the first senator from each party.\\n    if (radiant[0] < dire[0]) {\\n      // If the Radiant senator\\'s index is less than the Dire senator\\'s index,\\n      // add their index to the end of the radiant array with an offset of n,\\n      // representing their vote in the next round.\\n      radiant.push(radiant[0] + n);\\n    } else {\\n      // If the Dire senator\\'s index is less than or equal to the Radiant senator\\'s index,\\n      // add their index to the end of the dire array with an offset of n,\\n      // representing their vote in the next round.\\n      dire.push(dire[0] + n);\\n    }\\n    // Remove the first senator from each party\\'s array, since they have voted in this round.\\n    radiant.shift();\\n    dire.shift();\\n  }\\n\\n  // Return the winner of the voting procedure based on which party has remaining votes.\\n  return (radiant.length > 0) ? \"Radiant\" : \"Dire\";\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845912,
                "title": "python-3-greedy-simulation-explanantion",
                "content": "### Explanation\\n- If there is a chance to ban the opponent, do it (greedy). Repeat this process until only `R` or `D` left in senate.\\n- To ban someone, we start up 2 counters\\n\\t- `ban_d`: chances to ban `D`\\n\\t- `ban_r`: chances to bna `R`\\n- You may wonder, what if someone want to ban person before him? \\n\\t- If we travel back, that will cause extra time and mess things up\\n\\t- But don\\'t worries, if opponent is before you, it will get banned next round. e.g.\\n\\t- Round 0: `RRDDDD`\\n\\t- Round 1: `RRXXDD` first 2 `D`s were banned by first 2 `R`s, but last 2 `D` can still have 2 chances to ban `R`\\n\\t- Round 2: `XXXXDD` since we hold 2 chances to ban `R`, they will be banned at this round, so they won\\'t have chance to ban `D` again.\\n- `banned`: A list to check if current person is banned, if `True` skip this person\\n- `s`: A set to check if everyone in the senate are same side\\n### Implementation\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        n = len(senate)\\n        s, banned = set(), [False] * n\\n        ban_d = ban_r = 0\\n        while len(s) != 1:\\n            s = set()\\n            for i, p in enumerate(senate):\\n                if banned[i]: continue\\n                if p == \\'R\\':\\n                    if ban_r > 0:           # current R being banned\\n                        ban_r -= 1\\n                        banned[i] = True\\n                    else:                   # if current R is valid, it will ban D\\n                        ban_d += 1\\n                        s.add(\\'R\\')\\n                else:        \\n                    if ban_d > 0:           # current D being banned\\n                        ban_d -= 1\\n                        banned[i] = True\\n                    else:                   # if current D is valid, it will ban R\\n                        ban_r += 1\\n                        s.add(\\'D\\')\\n        return \\'Radiant\\' if s.pop() == \\'R\\' else \\'Dire\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        n = len(senate)\\n        s, banned = set(), [False] * n\\n        ban_d = ban_r = 0\\n        while len(s) != 1:\\n            s = set()\\n            for i, p in enumerate(senate):\\n                if banned[i]: continue\\n                if p == \\'R\\':\\n                    if ban_r > 0:           # current R being banned\\n                        ban_r -= 1\\n                        banned[i] = True\\n                    else:                   # if current R is valid, it will ban D\\n                        ban_d += 1\\n                        s.add(\\'R\\')\\n                else:        \\n                    if ban_d > 0:           # current D being banned\\n                        ban_d -= 1\\n                        banned[i] = True\\n                    else:                   # if current D is valid, it will ban R\\n                        ban_r += 1\\n                        s.add(\\'D\\')\\n        return \\'Radiant\\' if s.pop() == \\'R\\' else \\'Dire\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105889,
                "title": "java-solution-greedy",
                "content": "It is obvious that the best strategy is to ban the first opponent following the current senate.\\n\\n```\\npublic class Solution {\\n    public String predictPartyVictory(String senate) {\\n        int r = 0, d = 0, start = 0;\\n        char[] arr = senate.toCharArray();\\n        for (char c : arr) {\\n            if (c == 'R') r++;\\n            else d++;\\n        }\\n        \\n        while (r > 0 && d > 0) {\\n            while (arr[start] != 'R' && arr[start] != 'D') {\\n                start = (start + 1) % arr.length;\\n            }\\n            \\n            char ban = 'R';\\n            if (arr[start] == 'R') {\\n                ban = 'D';\\n                d--;\\n            }\\n            else {\\n                r--;\\n            }\\n            int idx = (start + 1) % arr.length;\\n            while (arr[idx] != ban) {\\n                idx = (idx + 1) % arr.length;\\n            }\\n            \\n            arr[idx] = ' ';\\n            start = (start + 1) % arr.length;\\n        }\\n        \\n        return d == 0 ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String predictPartyVictory(String senate) {\\n        int r = 0, d = 0, start = 0;\\n        char[] arr = senate.toCharArray();\\n        for (char c : arr) {\\n            if (c == 'R') r++;\\n            else d++;\\n        }\\n        \\n        while (r > 0 && d > 0) {\\n            while (arr[start] != 'R' && arr[start] != 'D') {\\n                start = (start + 1) % arr.length;\\n            }\\n            \\n            char ban = 'R';\\n            if (arr[start] == 'R') {\\n                ban = 'D';\\n                d--;\\n            }\\n            else {\\n                r--;\\n            }\\n            int idx = (start + 1) % arr.length;\\n            while (arr[idx] != ban) {\\n                idx = (idx + 1) % arr.length;\\n            }\\n            \\n            arr[idx] = ' ';\\n            start = (start + 1) % arr.length;\\n        }\\n        \\n        return d == 0 ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483389,
                "title": "easy-java-solution-with-proper-explanation-and-aproach",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem can be solved using a simple simulation approach. We can maintain two queues, one for Radiant senators and the other for Dire senators. Then we can simulate the voting process round by round until either all the senators from one party have lost their rights or one party has enough votes to declare victory.\\n\\nAlgorithm:\\n\\n1. Create two queues, one for Radiant senators and the other for Dire senators.\\n2. Traverse the senate string and add each senator to the corresponding queue.\\n3. Simulate the voting process by iterating until one party has enough votes to declare victory.\\n4. In each round, dequeue the senator at the front of the queue and check if there are any senators from the other party with remaining rights.\\n5. If there are, remove the senator\\'s right and enqueue the senator at the back of the queue. Otherwise, the senator\\'s party wins and we return the name of the party.\\n6. Repeat steps 4 and 5 until one party has enough votes to declare victory.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2N)\\n\\n# PLEASE UPVOTE!!!\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int n = senate.length();\\n        Queue<Integer> radiant = new LinkedList<>();\\n        Queue<Integer> dire = new LinkedList<>();\\n        \\n        // Add senators to the corresponding queues\\n        for (int i = 0; i < n; i++) {\\n            if (senate.charAt(i) == \\'R\\') {\\n                radiant.offer(i);\\n            } else {\\n                dire.offer(i);\\n            }\\n        }\\n        \\n        // Simulate the voting process\\n        while (!radiant.isEmpty() && !dire.isEmpty()) {\\n            int r = radiant.poll();\\n            int d = dire.poll();\\n            if (r < d) {\\n                radiant.offer(r + n); // Ban the senator\\'s right and enqueue at the back\\n            } else {\\n                dire.offer(d + n); // Ban the senator\\'s right and enqueue at the back\\n            }\\n        }\\n        \\n        // Return the winner\\n        return radiant.isEmpty() ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int n = senate.length();\\n        Queue<Integer> radiant = new LinkedList<>();\\n        Queue<Integer> dire = new LinkedList<>();\\n        \\n        // Add senators to the corresponding queues\\n        for (int i = 0; i < n; i++) {\\n            if (senate.charAt(i) == \\'R\\') {\\n                radiant.offer(i);\\n            } else {\\n                dire.offer(i);\\n            }\\n        }\\n        \\n        // Simulate the voting process\\n        while (!radiant.isEmpty() && !dire.isEmpty()) {\\n            int r = radiant.poll();\\n            int d = dire.poll();\\n            if (r < d) {\\n                radiant.offer(r + n); // Ban the senator\\'s right and enqueue at the back\\n            } else {\\n                dire.offer(d + n); // Ban the senator\\'s right and enqueue at the back\\n            }\\n        }\\n        \\n        // Return the winner\\n        return radiant.isEmpty() ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399786,
                "title": "python-with-two-queues",
                "content": "Save indexes of R and D. Iterate over two queues and decide who is going to be banned. Whoever left added to the next round by adding ```n``` to it\\'s index\\n```\\n    def predictPartyVictory(self, senate):\\n        n = len(senate)\\n        D = collections.deque()\\n        R = collections.deque()\\n        for i, c in enumerate(senate):\\n            if c == \\'R\\':\\n                R.append(i)\\n            else:\\n                D.append(i)\\n\\n        while R and D:\\n            r,d = R.popleft(), D.popleft()\\n            if r < d:\\n                R.append(r + n)\\n            else:\\n                D.append(d + n)\\n\\n        return \"Radiant\" if R else \"Dire\"\\n\\t\\t",
                "solutionTags": [],
                "code": "```n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483525,
                "title": "java-solution-for-dota2-senate-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to use two queues to simulate the voting process.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first iterate through the input string and add each senator\\'s index to the corresponding queue based on their party.\\n\\nThen we enter a loop where we alternate between removing the first senator from each queue. If the Radiant senator comes before the Dire senator, we assume that they ban the next available Dire senator (by adding their index to the queue with an offset of n). Similarly, if the Dire senator comes before the Radiant senator, we assume that they ban the next available Radiant senator.\\n\\nWe continue this process until one of the queues becomes empty, indicating that all senators from the other party have been banned. The party with remaining senators is declared the winner.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input string. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), as we need to store the indices of all senators in the input string.\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int n = senate.length();\\n        Queue<Integer> radiant = new LinkedList<>();\\n        Queue<Integer> dire = new LinkedList<>();\\n        for (int i = 0; i < n; i++) \\n        {\\n            if (senate.charAt(i) == \\'R\\') \\n            {\\n                radiant.offer(i);\\n            } \\n            else \\n            {\\n                dire.offer(i);\\n            }\\n        }\\n        while (!radiant.isEmpty() && !dire.isEmpty()) \\n        {\\n            int r = radiant.poll();\\n            int d = dire.poll();\\n            if (r < d) \\n            {\\n                radiant.offer(r + n);\\n            } \\n            else \\n            {\\n                dire.offer(d + n);\\n            }\\n        }\\n        return radiant.isEmpty() ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int n = senate.length();\\n        Queue<Integer> radiant = new LinkedList<>();\\n        Queue<Integer> dire = new LinkedList<>();\\n        for (int i = 0; i < n; i++) \\n        {\\n            if (senate.charAt(i) == \\'R\\') \\n            {\\n                radiant.offer(i);\\n            } \\n            else \\n            {\\n                dire.offer(i);\\n            }\\n        }\\n        while (!radiant.isEmpty() && !dire.isEmpty()) \\n        {\\n            int r = radiant.poll();\\n            int d = dire.poll();\\n            if (r < d) \\n            {\\n                radiant.offer(r + n);\\n            } \\n            else \\n            {\\n                dire.offer(d + n);\\n            }\\n        }\\n        return radiant.isEmpty() ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483364,
                "title": "java-single-queue-12-lines-simple-and-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public String predictPartyVictory(String senate) {\\n    var queue = new ArrayDeque<Character>();\\n\\n    for (var c : senate.toCharArray())\\n      queue.offer(c);\\n\\n    var c = \\'R\\';\\n    while (!queue.isEmpty()) {\\n      c = queue.poll();\\n      queue.offer(c);\\n\\n      if (c == \\'R\\' && !queue.remove(\\'D\\'))\\n        return \"Radiant\";\\n      if (c == \\'D\\' && !queue.remove(\\'R\\'))\\n        return \"Dire\";\\n    }\\n    return null;\\n  }\\n}\\n```\\nIf you like my solution, pleaes upvote it!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n  public String predictPartyVictory(String senate) {\\n    var queue = new ArrayDeque<Character>();\\n\\n    for (var c : senate.toCharArray())\\n      queue.offer(c);\\n\\n    var c = \\'R\\';\\n    while (!queue.isEmpty()) {\\n      c = queue.poll();\\n      queue.offer(c);\\n\\n      if (c == \\'R\\' && !queue.remove(\\'D\\'))\\n        return \"Radiant\";\\n      if (c == \\'D\\' && !queue.remove(\\'R\\'))\\n        return \"Dire\";\\n    }\\n    return null;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483548,
                "title": "easiest-and-best-approach-for-dota2-senate",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart by creating two queues rad and dir, which represent the order of senators for the Radiant and Dire teams, respectively.Then iterates through the senate string and adds each senator\\'s index to the respective team\\'s queue.\\n\\nNext, enter a loop that continues until one of the queues is empty. In each iteration of the loop, it compares the indices of the front elements of the rad and dir queues. The senator with the smaller index is considered the \"winner\" and stays in their team\\'s queue. The senator with the larger index is considered \"banned\" and is removed from their team\\'s queue.\\n\\nThe \"winner\" senator\\'s index is then incremented by n+1, where n is the current position in the game. This is done to ensure that no senator can be banned twice. The n value is increased by one at each iteration.\\n\\nFinally, the function returns \"Dire\" if the rad queue is empty (which means that all Radiant senators have been banned) or \"Radiant\" if the dir queue is empty (which means that all Dire senators have been banned).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nO(N)\\n```\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(N)\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> rad, dir;\\n        int n = senate.length();\\n        // Add all senators to respect queue with index\\n        for (int i = 0; i < n; i++){\\n            if (senate[i] == \\'R\\'){\\n                rad.push(i);\\n            }\\n            else {\\n                dir.push(i);\\n            }\\n        }\\n        // Use increasing n to keep track of position\\n        while (!rad.empty() && !dir.empty()){\\n            // Only \"winner\" stays in their queue\\n            if (rad.front() < dir.front()){\\n                rad.push(++n);\\n            }\\n            else {\\n                dir.push(++n);\\n            }\\n            rad.pop(), dir.pop();\\n        }\\n        return (rad.empty()) ? (\"Dire\") : (\"Radiant\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nO(N)\\n```\n```\\nO(N)\\n```\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> rad, dir;\\n        int n = senate.length();\\n        // Add all senators to respect queue with index\\n        for (int i = 0; i < n; i++){\\n            if (senate[i] == \\'R\\'){\\n                rad.push(i);\\n            }\\n            else {\\n                dir.push(i);\\n            }\\n        }\\n        // Use increasing n to keep track of position\\n        while (!rad.empty() && !dir.empty()){\\n            // Only \"winner\" stays in their queue\\n            if (rad.front() < dir.front()){\\n                rad.push(++n);\\n            }\\n            else {\\n                dir.push(++n);\\n            }\\n            rad.pop(), dir.pop();\\n        }\\n        return (rad.empty()) ? (\"Dire\") : (\"Radiant\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483411,
                "title": "easy-c-java-code-faster-than-100-solution-easy-to-understand",
                "content": "# Intuition\\n\\nThe algorithm starts by counting the number of senators from each party in the given string. Then, a queue is created to simulate the round-based voting process. The algorithm uses a banCount variable to keep track of the number of times a senator\\'s right has been banned. In each round, the front of the queue (i.e., the next senator in line) is removed, and their party is checked. If the party is Radiant, then it is checked whether the current senator can ban the next available Dire senator\\'s right. If so, the Dire count is decremented, and the current senator\\'s right is pushed to the back of the queue. Otherwise, the current senator\\'s right is used to vote, and the Radiant count is decremented\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Count the number of senators in each party, \\'R\\' and \\'D\\'.\\n2. Create a queue and add all the senators to the queue.\\n3. Keep a counter to track the number of bans used so far.\\n4. Keep removing senators from the front of the queue and perform the following operations on them:\\n     . If the senator belongs to party \\'R\\', check if the number of bans used so far is less than the number of senators from party \\'D\\'. If yes, ban the senator and add it back to the end of the queue. If no, this senator cannot be banned and is considered to have voted. Decrement the count of senators from party \\'R\\'.\\n    . If the senator belongs to party \\'D\\', check if the number of bans used so far is less than the number of senators from party \\'R\\'. If yes, ban the senator and add it back to the end of the queue. If no, this senator cannot be banned and is considered to have voted. Decrement the count of senators from party \\'D\\'.\\n5. Repeat step 4 until either all the senators from one party have been banned or all the senators have voted.\\n6. Return the name of the party whose senators are still remaining in the queue, which means that all the senators from the other party have been banned.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# --------------------------------------------------------\\n# PLS UPVOTE. IF YOU THINK IT HELPS YOU\\n# --------------------------------------------------------\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n = senate.size();\\n        queue<int> radiant, dire;\\n        for (int i = 0; i < n; i++) {\\n            if (senate[i] == \\'R\\') {\\n                radiant.push(i);\\n            } else {\\n                dire.push(i);\\n            }\\n        }\\n        while (!radiant.empty() && !dire.empty()) {\\n            int r = radiant.front(); radiant.pop();\\n            int d = dire.front(); dire.pop();\\n            if (r < d) {\\n                radiant.push(r + n);\\n            } else {\\n                dire.push(d + n);\\n            }\\n        }\\n        return radiant.empty() ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n\\n```\\n\\n# JAVA CODE\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int n = senate.length();\\n        int radiantCount = (int) senate.chars().filter(c -> c == \\'R\\').count();\\n        int direCount = n - radiantCount;\\n        Queue<Character> senateQueue = new LinkedList<>();\\n        for (char c : senate.toCharArray()) {\\n            senateQueue.add(c);\\n        }\\n        int banCount = 0;\\n        while (radiantCount > 0 && direCount > 0) {\\n            char senator = senateQueue.remove();\\n            if (senator == \\'R\\') {\\n                if (banCount < direCount) {\\n                    banCount++;\\n                    direCount--;\\n                    senateQueue.add(senator);\\n                } else {\\n                    radiantCount--;\\n                }\\n            } else {\\n                if (banCount < radiantCount) {\\n                    banCount++;\\n                    radiantCount--;\\n                    senateQueue.add(senator);\\n                } else {\\n                    direCount--;\\n                }\\n            }\\n        }\\n        return (radiantCount > 0) ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n = senate.size();\\n        queue<int> radiant, dire;\\n        for (int i = 0; i < n; i++) {\\n            if (senate[i] == \\'R\\') {\\n                radiant.push(i);\\n            } else {\\n                dire.push(i);\\n            }\\n        }\\n        while (!radiant.empty() && !dire.empty()) {\\n            int r = radiant.front(); radiant.pop();\\n            int d = dire.front(); dire.pop();\\n            if (r < d) {\\n                radiant.push(r + n);\\n            } else {\\n                dire.push(d + n);\\n            }\\n        }\\n        return radiant.empty() ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n\\n```\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int n = senate.length();\\n        int radiantCount = (int) senate.chars().filter(c -> c == \\'R\\').count();\\n        int direCount = n - radiantCount;\\n        Queue<Character> senateQueue = new LinkedList<>();\\n        for (char c : senate.toCharArray()) {\\n            senateQueue.add(c);\\n        }\\n        int banCount = 0;\\n        while (radiantCount > 0 && direCount > 0) {\\n            char senator = senateQueue.remove();\\n            if (senator == \\'R\\') {\\n                if (banCount < direCount) {\\n                    banCount++;\\n                    direCount--;\\n                    senateQueue.add(senator);\\n                } else {\\n                    radiantCount--;\\n                }\\n            } else {\\n                if (banCount < radiantCount) {\\n                    banCount++;\\n                    radiantCount--;\\n                    senateQueue.add(senator);\\n                } else {\\n                    direCount--;\\n                }\\n            }\\n        }\\n        return (radiantCount > 0) ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485200,
                "title": "golang",
                "content": "# Intuition\\n\\u041C\\u043D\\u043E\\u0433\\u043E \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u0438 \\u043F\\u043E\\u0442\\u0440\\u0430\\u0442\\u0438\\u043B \\u043D\\u0430 \\u0434\\u0430\\u043D\\u043D\\u0443\\u044E \\u0437\\u0430\\u0434\\u0447\\u0443, \\u0445\\u043E\\u0434\\u044F \\u0432\\u043E\\u043A\\u0440\\u0443\\u0433 \\u044D\\u0442\\u043E\\u0433\\u043E \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C\\u0430, \\u0432 \\u0438\\u0442\\u043E\\u0433\\u0435 \\u043F\\u0440\\u0438\\u0448\\u0435\\u043B \\u043A \\u0442\\u0430\\u043A\\u043E\\u043C\\u0443 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044E, \\u043D\\u0438\\u0436\\u0435 \\u043F\\u043E\\u0441\\u0442\\u0430\\u0440\\u0430\\u044E\\u0441\\u044C \\u0435\\u0433\\u043E \\u043E\\u0431\\u044A\\u044F\\u0441\\u043D\\u0438\\u0442\\u044C.\\n\\n# Approach\\n\\u0414\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0443 \\u043D\\u0430\\u0445\\u043E\\u0436\\u0434\\u0435\\u043D\\u0438\\u044F \\u043F\\u043E\\u0431\\u0435\\u0434\\u0438\\u0432\\u0448\\u0435\\u0439 \\u043F\\u0430\\u0440\\u0442\\u0438\\u0438 \\u0432 \\u0438\\u0433\\u0440\\u0435 **Dota2**, \\u0433\\u0434\\u0435 \\u0435\\u0441\\u0442\\u044C \\u0434\\u0432\\u0435 \\u043F\\u0430\\u0440\\u0442\\u0438\\u0438: **Radiant** \\u0438 **Dire**.\\n\\u0412 \\u0434\\u0430\\u043D\\u043D\\u043E\\u043C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0438 \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u0442\\u0441\\u044F \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C, \\u043E\\u0441\\u043D\\u043E\\u0432\\u0430\\u043D\\u043D\\u044B\\u0439 \\u043D\\u0430 \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u043D\\u0438\\u0438 \\u0434\\u0432\\u0443\\u0445 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0435\\u0439 **(radiant \\u0438 dire)**, \\u043A\\u0430\\u0436\\u0434\\u0430\\u044F \\u0438\\u0437 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0445 \\u0441\\u043E\\u0434\\u0435\\u0440\\u0436\\u0438\\u0442 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u044B **(int)** \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u043E\\u0432 \\u0432 \\u0438\\u0441\\u0445\\u043E\\u0434\\u043D\\u043E\\u0439 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0435, \\u0441\\u043E\\u043E\\u0442\\u0432\\u0435\\u0442\\u0441\\u0442\\u0432\\u0443\\u044E\\u0449\\u0438\\u0445 \\u0438\\u0445 \\u043F\\u0430\\u0440\\u0442\\u0438\\u0438.\\n##### \\u0410\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C \\u043F\\u0440\\u0438\\u0432\\u0435\\u0434\\u0435\\u043D \\u0432 \\u0441\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0445 \\u0448\\u0430\\u0433\\u0430\\u0445:\\n\\n1. \\u0421\\u043E\\u0437\\u0434\\u0430\\u0442\\u044C \\u0434\\u0432\\u0430 \\u043F\\u0443\\u0441\\u0442\\u044B\\u0445 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430: **radiant** \\u0438 **dire**.\\n2. \\u0414\\u043B\\u044F \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 **senate** \\u043F\\u0440\\u043E\\u0432\\u0435\\u0440\\u0438\\u0442\\u044C, \\u043A \\u043A\\u0430\\u043A\\u043E\\u0439 \\u043F\\u0430\\u0440\\u0442\\u0438\\u0438 \\u043E\\u043D \\u043F\\u0440\\u0438\\u043D\\u0430\\u0434\\u043B\\u0435\\u0436\\u0438\\u0442. \\u0415\\u0441\\u043B\\u0438 \\u043E\\u043D \\u043F\\u0440\\u0438\\u043D\\u0430\\u0434\\u043B\\u0435\\u0436\\u0438\\u0442 \\u043A \\u043F\\u0430\\u0440\\u0442\\u0438\\u0438 **Radiant**, \\u0434\\u043E\\u0431\\u0430\\u0432\\u0438\\u0442\\u044C \\u0435\\u0433\\u043E \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A **radiant**, \\u0432 \\u043F\\u0440\\u043E\\u0442\\u0438\\u0432\\u043D\\u043E\\u043C \\u0441\\u043B\\u0443\\u0447\\u0430\\u0435 \\u0434\\u043E\\u0431\\u0430\\u0432\\u0438\\u0442\\u044C \\u0435\\u0433\\u043E \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A **dire**.\\n    ```\\n    var radiant, dire []int // \\u0448\\u0430\\u0433 1\\n\\n    for i, ch := range senate { // \\u0448\\u0430\\u0433 2\\n        if ch == \\'R\\' {\\n            radiant = append(radiant, i)\\n        } else {\\n            dire = append(dire, i)\\n        }\\n    }\\n    ```\\n3. \\u041F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0442\\u044C \\u0434\\u043B\\u0438\\u043D\\u0443 \\u0438\\u0441\\u0445\\u043E\\u0434\\u043D\\u043E\\u0439 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 \\u0438 \\u0437\\u0430\\u043F\\u0443\\u0441\\u0442\\u0438\\u0442\\u044C \\u0431\\u0435\\u0441\\u043A\\u043E\\u043D\\u0435\\u0447\\u043D\\u044B\\u0439 \\u0446\\u0438\\u043A\\u043B.\\n4. \\u041F\\u0440\\u043E\\u0432\\u0435\\u0440\\u0438\\u0442\\u044C, \\u0435\\u0441\\u0442\\u044C \\u043B\\u0438 \\u0435\\u0449\\u0435 \\u0436\\u0438\\u0432\\u044B\\u0435 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u044B \\u0438\\u0437 \\u043E\\u0431\\u0435\\u0438\\u0445 \\u043F\\u0430\\u0440\\u0442\\u0438\\u0439, \\u043F\\u0443\\u0442\\u0435\\u043C \\u043F\\u0440\\u043E\\u0432\\u0435\\u0440\\u043A\\u0438 \\u0434\\u043B\\u0438\\u043D\\u044B \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 **radiant** \\u0438 **dire**. \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043B\\u0438\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044F \\u0431\\u044B \\u043E\\u0434\\u043D\\u043E\\u0433\\u043E \\u0438\\u0437 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 \\u0440\\u0430\\u0432\\u043D\\u0430 **0**, \\u0432\\u044B\\u0439\\u0442\\u0438 \\u0438\\u0437 \\u0446\\u0438\\u043A\\u043B\\u0430.\\n5. \\u0421\\u0440\\u0430\\u0432\\u043D\\u0438\\u0442\\u044C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u044B \\u043F\\u0435\\u0440\\u0432\\u044B\\u0445 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u043E\\u0432 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430\\u0445 **radiant** \\u0438 **dire**. \\u0415\\u0441\\u043B\\u0438 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u043F\\u0435\\u0440\\u0432\\u043E\\u0433\\u043E \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 **radiant** \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435, \\u0447\\u0435\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u043F\\u0435\\u0440\\u0432\\u043E\\u0433\\u043E \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 **dire**, \\u0434\\u043E\\u0431\\u0430\\u0432\\u0438\\u0442\\u044C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u043F\\u0435\\u0440\\u0432\\u043E\\u0433\\u043E \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A **radiant** \\u0441\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C, \\u0440\\u0430\\u0432\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044E \\u0434\\u043B\\u0438\\u043D\\u044B \\u0438\\u0441\\u0445\\u043E\\u0434\\u043D\\u043E\\u0439 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 \\u043F\\u043B\\u044E\\u0441 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0438\\u0439 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 **radiant**. \\u0412 \\u043F\\u0440\\u043E\\u0442\\u0438\\u0432\\u043D\\u043E\\u043C \\u0441\\u043B\\u0443\\u0447\\u0430\\u0435 \\u0434\\u043E\\u0431\\u0430\\u0432\\u0438\\u0442\\u044C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u043F\\u0435\\u0440\\u0432\\u043E\\u0433\\u043E \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A **dire** \\u0441\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C, \\u0440\\u0430\\u0432\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044E \\u0434\\u043B\\u0438\\u043D\\u044B \\u0438\\u0441\\u0445\\u043E\\u0434\\u043D\\u043E\\u0439 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 \\u043F\\u043B\\u044E\\u0441 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0438\\u0439 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 **dire**.\\n### \\u0417\\u0430\\u0447\\u0435\\u043C \\u044D\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C?\\n\\u042D\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0435\\u0442\\u0441\\u044F \\u0434\\u043B\\u044F \\u0442\\u043E\\u0433\\u043E, \\u0447\\u0442\\u043E\\u0431\\u044B \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u0442\\u044C \\u043F\\u043E\\u0440\\u044F\\u0434\\u043E\\u043A \\u0433\\u043E\\u043B\\u043E\\u0441\\u043E\\u0432\\u0430\\u043D\\u0438\\u044F \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u043E\\u0432 \\u0432\\u043D\\u0443\\u0442\\u0440\\u0438 \\u0441\\u0432\\u043E\\u0438\\u0445 \\u0433\\u0440\\u0443\\u043F\\u043F **(Radiant \\u0438\\u043B\\u0438 Dire)**. \\u0418\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u044F \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u044B \\u043F\\u0435\\u0440\\u0432\\u044B\\u0445 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u043E\\u0432 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430\\u0445, \\u043F\\u0440\\u043E\\u0433\\u0440\\u0430\\u043C\\u043C\\u0430 \\u043C\\u043E\\u0436\\u0435\\u0442 \\u043E\\u043F\\u0440\\u0435\\u0434\\u0435\\u043B\\u0438\\u0442\\u044C, \\u043A\\u0430\\u043A\\u043E\\u0439 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440 \\u0433\\u043E\\u043B\\u043E\\u0441\\u043E\\u0432\\u0430\\u043B \\u043F\\u0435\\u0440\\u0432\\u044B\\u043C \\u0438 \\u0432 \\u043A\\u0430\\u043A\\u043E\\u0439 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0438 \\u0441\\u043B\\u0435\\u0434\\u0443\\u0435\\u0442 \\u0433\\u043E\\u043B\\u043E\\u0441\\u043E\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043A\\u0430\\u0436\\u0434\\u043E\\u0439 \\u0433\\u0440\\u0443\\u043F\\u043F\\u044B.\\n\\n\\u0415\\u0441\\u043B\\u0438 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u043F\\u0435\\u0440\\u0432\\u043E\\u0433\\u043E \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 **Radiant** \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435, \\u044D\\u0442\\u043E \\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E \\u044D\\u0442\\u043E\\u0442 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440 \\u0433\\u043E\\u043B\\u043E\\u0441\\u043E\\u0432\\u0430\\u043B \\u0440\\u0430\\u043D\\u044C\\u0448\\u0435, \\u0447\\u0435\\u043C \\u043F\\u0435\\u0440\\u0432\\u044B\\u0439 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440 \\u0438\\u0437 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 **Dire**. \\u0412 \\u0442\\u0430\\u043A\\u043E\\u043C \\u0441\\u043B\\u0443\\u0447\\u0430\\u0435 \\u043C\\u044B \\u0434\\u043E\\u0431\\u0430\\u0432\\u043B\\u044F\\u0435\\u043C \\u0435\\u0433\\u043E \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u0432 \\u043A\\u043E\\u043D\\u0435\\u0446 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 **Radiant** \\u0441\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C, \\u0440\\u0430\\u0432\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044E \\u0434\\u043B\\u0438\\u043D\\u044B \\u0438\\u0441\\u0445\\u043E\\u0434\\u043D\\u043E\\u0439 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 \\u043F\\u043B\\u044E\\u0441 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0438\\u0439 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 **Radiant**. \\u0422\\u0430\\u043A\\u0438\\u043C \\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u043C, \\u043C\\u044B \\u0441\\u043E\\u0445\\u0440\\u0430\\u043D\\u044F\\u0435\\u043C \\u043F\\u043E\\u0440\\u044F\\u0434\\u043E\\u043A \\u0433\\u043E\\u043B\\u043E\\u0441\\u043E\\u0432\\u0430\\u043D\\u0438\\u044F \\u0434\\u043B\\u044F **Radiant**.\\n\\n\\u0415\\u0441\\u043B\\u0438 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u043F\\u0435\\u0440\\u0432\\u043E\\u0433\\u043E \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 **Dire** \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435, \\u0447\\u0435\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u043F\\u0435\\u0440\\u0432\\u043E\\u0433\\u043E \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 **Radiant**, \\u0442\\u043E \\u043C\\u044B \\u0434\\u043E\\u0431\\u0430\\u0432\\u043B\\u044F\\u0435\\u043C \\u0435\\u0433\\u043E \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u0432 \\u043A\\u043E\\u043D\\u0435\\u0446 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 **Dire** \\u0441\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C, \\u0440\\u0430\\u0432\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044E \\u0434\\u043B\\u0438\\u043D\\u044B \\u0438\\u0441\\u0445\\u043E\\u0434\\u043D\\u043E\\u0439 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 \\u043F\\u043B\\u044E\\u0441 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0438\\u0439 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 **Dire**. \\u042D\\u0442\\u043E \\u0442\\u0430\\u043A\\u0436\\u0435 \\u043F\\u043E\\u0437\\u0432\\u043E\\u043B\\u044F\\u0435\\u0442 \\u0441\\u043E\\u0445\\u0440\\u0430\\u043D\\u044F\\u0442\\u044C \\u043F\\u043E\\u0440\\u044F\\u0434\\u043E\\u043A \\u0433\\u043E\\u043B\\u043E\\u0441\\u043E\\u0432\\u0430\\u043D\\u0438\\u044F \\u0434\\u043B\\u044F **Dire**.\\n\\n\\u041F\\u0440\\u043E\\u0434\\u043E\\u043B\\u0436\\u0430\\u044F \\u044D\\u0442\\u043E\\u0442 \\u043F\\u0440\\u043E\\u0446\\u0435\\u0441\\u0441, \\u043C\\u044B \\u0431\\u0443\\u0434\\u0435\\u043C \\u043F\\u0435\\u0440\\u0435\\u043A\\u0438\\u0434\\u044B\\u0432\\u0430\\u0442\\u044C \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u043E\\u0432 \\u0438\\u0437 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 **Radiant** \\u0438 **Dire** \\u0432 \\u043A\\u043E\\u043D\\u0435\\u0446 \\u0441\\u043E\\u043E\\u0442\\u0432\\u0435\\u0442\\u0441\\u0442\\u0432\\u0443\\u044E\\u0449\\u0435\\u0433\\u043E \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 \\u0434\\u043E \\u0442\\u0435\\u0445 \\u043F\\u043E\\u0440, \\u043F\\u043E\\u043A\\u0430 \\u0432 \\u043E\\u0434\\u043D\\u043E\\u043C \\u0438\\u0437 \\u043D\\u0438\\u0445 \\u043D\\u0435 \\u043E\\u0441\\u0442\\u0430\\u043D\\u0435\\u0442\\u0441\\u044F \\u043D\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0433\\u043E \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u0430.\\n\\n\\u041F\\u043E\\u0441\\u043B\\u0435 \\u0437\\u0430\\u0432\\u0435\\u0440\\u0448\\u0435\\u043D\\u0438\\u044F \\u0433\\u043E\\u043B\\u043E\\u0441\\u043E\\u0432\\u0430\\u043D\\u0438\\u044F \\u0438 \\u0443\\u0434\\u0430\\u043B\\u0435\\u043D\\u0438\\u044F \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u043E\\u0432 \\u0438\\u0437 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 \\u043C\\u044B \\u0441\\u043C\\u043E\\u0442\\u0440\\u0438\\u043C, \\u043A\\u0430\\u043A\\u043E\\u0439 \\u0438\\u0437 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 **(Radiant \\u0438\\u043B\\u0438 Dire)** \\u043E\\u0441\\u0442\\u0430\\u043B\\u0441\\u044F \\u043D\\u0435\\u043F\\u0443\\u0441\\u0442\\u044B\\u043C. \\u0415\\u0441\\u043B\\u0438 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 \\u043E\\u0441\\u0442\\u0430\\u043B\\u0438\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u044B \\u0438\\u0437 \\u043E\\u0434\\u043D\\u043E\\u0439 \\u043F\\u0430\\u0440\\u0442\\u0438\\u0438, \\u0442\\u043E \\u044D\\u0442\\u0430 \\u043F\\u0430\\u0440\\u0442\\u0438\\u044F \\u043E\\u0431\\u044A\\u044F\\u0432\\u043B\\u044F\\u0435\\u0442 \\u043F\\u043E\\u0431\\u0435\\u0434\\u0443. \\u0412 \\u043F\\u0440\\u043E\\u0442\\u0438\\u0432\\u043D\\u043E\\u043C \\u0441\\u043B\\u0443\\u0447\\u0430\\u0435 \\u0433\\u043E\\u043B\\u043E\\u0441\\u043E\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043F\\u0440\\u043E\\u0434\\u043E\\u043B\\u0436\\u0430\\u0435\\u0442\\u0441\\u044F, \\u043F\\u043E\\u043A\\u0430 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043E\\u0431\\u044A\\u044F\\u0432\\u043B\\u0435\\u043D\\u0430 \\u043F\\u043E\\u0431\\u0435\\u0434\\u0430 \\u043E\\u0434\\u043D\\u043E\\u0439 \\u0438\\u0437 \\u043F\\u0430\\u0440\\u0442\\u0438\\u0439.\\n\\n6. \\u0423\\u0434\\u0430\\u043B\\u0438\\u0442\\u044C \\u043F\\u0435\\u0440\\u0432\\u044B\\u0439 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u0438\\u0437 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 radiant \\u0438 dire.\\n```\\n    n := len(senate) // \\u0448\\u0430\\u0433 3\\n    for len(radiant) > 0 && len(dire) > 0 { // \\u0448\\u0430\\u0433 4\\n        if radiant[0] < dire[0] { // \\u0448\\u0430\\u0433 5\\n            radiant = append(radiant, radiant[0]+n)\\n        } else {\\n            dire = append(dire, dire[0]+n)\\n        }\\n        radiant = radiant[1:] // \\u0448\\u0430\\u0433 6\\n        dire = dire[1:]\\n    }\\n```\\n7. \\u0412\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0438\\u043C\\u044F \\u043F\\u0430\\u0440\\u0442\\u0438\\u0438, \\u0443 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0434\\u043B\\u0438\\u043D\\u0430 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u0432 \\u0441\\u0435\\u043D\\u0430\\u0442\\u043E\\u0440\\u043E\\u0432 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u043D\\u0443\\u043B\\u044F. \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043B\\u0438\\u043D\\u0430 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 **radiant** \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u043D\\u0443\\u043B\\u044F, \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C **\"Radiant\"**, \\u0432 \\u043F\\u0440\\u043E\\u0442\\u0438\\u0432\\u043D\\u043E\\u043C \\u0441\\u043B\\u0443\\u0447\\u0430\\u0435 \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C **\"Dire\"**.\\n    ```\\n    if len(radiant) > 0 { // \\u0448\\u0430\\u0433 7\\n        return \"Radiant\"\\n    } else {\\n        return \"Dire\"\\n    }\\n    ```\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nfunc predictPartyVictory(senate string) string {\\n\\n    var radiant, dire []int\\n\\n    for i, ch := range senate {\\n        if ch == \\'R\\' {\\n            radiant = append(radiant, i)\\n        } else {\\n            dire = append(dire, i)\\n        }\\n    }\\n\\n    n := len(senate)\\n\\n    for len(radiant) > 0 && len(dire) > 0 {\\n        if radiant[0] < dire[0] {\\n            radiant = append(radiant, radiant[0]+n)\\n        } else {\\n            dire = append(dire, dire[0]+n)\\n        }\\n        radiant = radiant[1:]\\n        dire = dire[1:]\\n    }\\n\\n    if len(radiant) > 0 {\\n        return \"Radiant\"\\n    } else {\\n        return \"Dire\"\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\n    var radiant, dire []int // \\u0448\\u0430\\u0433 1\\n\\n    for i, ch := range senate { // \\u0448\\u0430\\u0433 2\\n        if ch == \\'R\\' {\\n            radiant = append(radiant, i)\\n        } else {\\n            dire = append(dire, i)\\n        }\\n    }\\n    ```\n```\\n    n := len(senate) // \\u0448\\u0430\\u0433 3\\n    for len(radiant) > 0 && len(dire) > 0 { // \\u0448\\u0430\\u0433 4\\n        if radiant[0] < dire[0] { // \\u0448\\u0430\\u0433 5\\n            radiant = append(radiant, radiant[0]+n)\\n        } else {\\n            dire = append(dire, dire[0]+n)\\n        }\\n        radiant = radiant[1:] // \\u0448\\u0430\\u0433 6\\n        dire = dire[1:]\\n    }\\n```\n```\\n    if len(radiant) > 0 { // \\u0448\\u0430\\u0433 7\\n        return \"Radiant\"\\n    } else {\\n        return \"Dire\"\\n    }\\n    ```\n```\\nfunc predictPartyVictory(senate string) string {\\n\\n    var radiant, dire []int\\n\\n    for i, ch := range senate {\\n        if ch == \\'R\\' {\\n            radiant = append(radiant, i)\\n        } else {\\n            dire = append(dire, i)\\n        }\\n    }\\n\\n    n := len(senate)\\n\\n    for len(radiant) > 0 && len(dire) > 0 {\\n        if radiant[0] < dire[0] {\\n            radiant = append(radiant, radiant[0]+n)\\n        } else {\\n            dire = append(dire, dire[0]+n)\\n        }\\n        radiant = radiant[1:]\\n        dire = dire[1:]\\n    }\\n\\n    if len(radiant) > 0 {\\n        return \"Radiant\"\\n    } else {\\n        return \"Dire\"\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483415,
                "title": "rust-iterators-0ms-beats-100",
                "content": "Hell yeah for zero-cost abstraction iterators.\\n\\n# Code\\n```\\nuse std::collections::VecDeque;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn predict_party_victory(senate: String) -> String {\\n        senate\\n        .chars()\\n        .collect::<DotaSenate>()\\n        .get_winner()\\n    }\\n}\\n\\n// Default is an empty Senate.\\n#[derive(Default)]\\nstruct DotaSenate {\\n    vote_queue: VecDeque<char>,\\n    ban_queue: VecDeque<char>,\\n    radiant: usize,\\n    dire: usize,\\n}\\n\\nimpl DotaSenate {\\n    // Adds one voter to the end of the vote queue.\\n    pub fn add(&mut self, voter: char) {\\n        match voter {\\n            \\'R\\' => {\\n                self.vote_queue.push_back(\\'R\\');\\n                self.radiant += 1;\\n            }\\n            \\'D\\' => {\\n                self.vote_queue.push_back(\\'D\\');\\n                self.dire += 1;\\n            }\\n            _ => {}\\n        }\\n    }\\n\\n    // Runs the iterator until a winner is found.\\n    pub fn get_winner(&mut self) -> String {\\n        self.find_map(|maybe_winner| maybe_winner).unwrap()\\n    }\\n}\\n\\n// Lets us use .collect<DotaSenate>, which is cleaner.\\nimpl FromIterator<char> for DotaSenate {\\n    fn from_iter<T>(iter: T) -> Self\\n    where T: IntoIterator<Item = char> {\\n        let mut dota_senate = DotaSenate::default();\\n        iter.into_iter().for_each(|ch| dota_senate.add(ch));\\n        dota_senate\\n    }\\n}\\n\\n// Each call to next() is a single voter taking an action.\\n// If the election is ongoing, will return Some(None).\\nimpl Iterator for DotaSenate {\\n    type Item = Option<String>;\\n\\n    fn next(&mut self) -> Option<Option<String>> {\\n        // If there are no voters, the iterator ends (returns None).\\n        let voter = self.vote_queue.pop_front()?;\\n        \\n        // Check if this voter has been banned\\n        if Some(&voter) == self.ban_queue.front() {\\n            // They have been banned, decrement voter records\\n            self.ban_queue.pop_front();\\n            match voter {\\n                \\'R\\' => {self.radiant -= 1;}\\n                \\'D\\' => {self.dire -= 1;}\\n                _ => {}\\n            }\\n            // Banned voter gets no turn, continue election\\n            return Some(None);\\n        }\\n\\n        if voter == \\'R\\' && self.dire == 0 {\\n            // Radiant victory!\\n            Some(Some(\"Radiant\".to_owned()))\\n        } else if voter == \\'D\\' && self.radiant == 0 {\\n            // Dire victory!\\n            Some(Some(\"Dire\".to_owned()))\\n        } else {\\n            // No victory yet, voter exercises their ban right\\n            // Voter goes to the back of the queue\\n            // Queues a ban for someone of the other side            \\n            match voter {\\n                \\'R\\' => {\\n                    self.vote_queue.push_back(\\'R\\');\\n                    self.ban_queue.push_back(\\'D\\');\\n                }\\n                \\'D\\' => {\\n                    self.vote_queue.push_back(\\'D\\');\\n                    self.ban_queue.push_back(\\'R\\');\\n                }\\n                _ => {}\\n            }\\n            // Continue election\\n            Some(None)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn predict_party_victory(senate: String) -> String {\\n        senate\\n        .chars()\\n        .collect::<DotaSenate>()\\n        .get_winner()\\n    }\\n}\\n\\n// Default is an empty Senate.\\n#[derive(Default)]\\nstruct DotaSenate {\\n    vote_queue: VecDeque<char>,\\n    ban_queue: VecDeque<char>,\\n    radiant: usize,\\n    dire: usize,\\n}\\n\\nimpl DotaSenate {\\n    // Adds one voter to the end of the vote queue.\\n    pub fn add(&mut self, voter: char) {\\n        match voter {\\n            \\'R\\' => {\\n                self.vote_queue.push_back(\\'R\\');\\n                self.radiant += 1;\\n            }\\n            \\'D\\' => {\\n                self.vote_queue.push_back(\\'D\\');\\n                self.dire += 1;\\n            }\\n            _ => {}\\n        }\\n    }\\n\\n    // Runs the iterator until a winner is found.\\n    pub fn get_winner(&mut self) -> String {\\n        self.find_map(|maybe_winner| maybe_winner).unwrap()\\n    }\\n}\\n\\n// Lets us use .collect<DotaSenate>, which is cleaner.\\nimpl FromIterator<char> for DotaSenate {\\n    fn from_iter<T>(iter: T) -> Self\\n    where T: IntoIterator<Item = char> {\\n        let mut dota_senate = DotaSenate::default();\\n        iter.into_iter().for_each(|ch| dota_senate.add(ch));\\n        dota_senate\\n    }\\n}\\n\\n// Each call to next() is a single voter taking an action.\\n// If the election is ongoing, will return Some(None).\\nimpl Iterator for DotaSenate {\\n    type Item = Option<String>;\\n\\n    fn next(&mut self) -> Option<Option<String>> {\\n        // If there are no voters, the iterator ends (returns None).\\n        let voter = self.vote_queue.pop_front()?;\\n        \\n        // Check if this voter has been banned\\n        if Some(&voter) == self.ban_queue.front() {\\n            // They have been banned, decrement voter records\\n            self.ban_queue.pop_front();\\n            match voter {\\n                \\'R\\' => {self.radiant -= 1;}\\n                \\'D\\' => {self.dire -= 1;}\\n                _ => {}\\n            }\\n            // Banned voter gets no turn, continue election\\n            return Some(None);\\n        }\\n\\n        if voter == \\'R\\' && self.dire == 0 {\\n            // Radiant victory!\\n            Some(Some(\"Radiant\".to_owned()))\\n        } else if voter == \\'D\\' && self.radiant == 0 {\\n            // Dire victory!\\n            Some(Some(\"Dire\".to_owned()))\\n        } else {\\n            // No victory yet, voter exercises their ban right\\n            // Voter goes to the back of the queue\\n            // Queues a ban for someone of the other side            \\n            match voter {\\n                \\'R\\' => {\\n                    self.vote_queue.push_back(\\'R\\');\\n                    self.ban_queue.push_back(\\'D\\');\\n                }\\n                \\'D\\' => {\\n                    self.vote_queue.push_back(\\'D\\');\\n                    self.ban_queue.push_back(\\'R\\');\\n                }\\n                _ => {}\\n            }\\n            // Continue election\\n            Some(None)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483270,
                "title": "daily-leetcoding-challenge-may-day-4",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/dota2-senate/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n**Approach 2:** Boolean Array\n\n  \n**Approach 3:** Binary Search\n\n  \n**Approach 4:** Two Queues\n\n  \n**Approach 5:** Single Queue\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/dota2-senate/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2311125,
                "title": "beats-100-other-solutions",
                "content": "```\\nclass Solution:\\n\\n    def predictPartyVictory(self, senate: str) -> str:\\n        rstack, dstack = collections.deque(), collections.deque()\\n        for i, c in enumerate(senate):\\n            if c == \\'R\\':\\n                rstack.append(i)\\n            else:\\n                dstack.append(i)\\n        n = len(senate)\\n        while rstack and dstack:\\n            r = rstack.popleft()\\n            d = dstack.popleft()\\n            # remove larger index\\n            if r < d:\\n                rstack.append(n + r)\\n            else:\\n                dstack.append(n + d)\\n        return \\'Radiant\\' if rstack else \\'Dire\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def predictPartyVictory(self, senate: str) -> str:\\n        rstack, dstack = collections.deque(), collections.deque()\\n        for i, c in enumerate(senate):\\n            if c == \\'R\\':\\n                rstack.append(i)\\n            else:\\n                dstack.append(i)\\n        n = len(senate)\\n        while rstack and dstack:\\n            r = rstack.popleft()\\n            d = dstack.popleft()\\n            # remove larger index\\n            if r < d:\\n                rstack.append(n + r)\\n            else:\\n                dstack.append(n + d)\\n        return \\'Radiant\\' if rstack else \\'Dire\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483597,
                "title": "java-two-queues-solution-with-explanation",
                "content": "```\\n// Two Queues Solution\\n// Two queues to store the R index and D index.\\n// If the senate can execute his right, the senate is alive and can execute in the next round.\\n// Then we can add the senate back to the queue and process in the next round (idx + N).\\n// Time complexity: O(N), each loop we add/remove 1 senate in the queue.\\n// Space complexity: O(N)\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        if (senate == null || senate.length() == 0) throw new IllegalArgumentException(\"Invalid input.\");\\n        final int N = senate.length();\\n        Queue<Integer> queR = new ArrayDeque<>();  // store the R index\\n        Queue<Integer> queD = new ArrayDeque<>();  // store the D index\\n        for (int i = 0; i < N; i++) {\\n            if (senate.charAt(i) == \\'R\\') {\\n                queR.add(i);\\n            } else {\\n                queD.add(i);\\n            }\\n        }\\n        while (!queR.isEmpty() && !queD.isEmpty()) {\\n            int r = queR.poll();\\n            int d = queD.poll();\\n            if (r < d) {  // R is alive in the next round.\\n                queR.add(r + N);\\n            } else {  // D is alive in the next round.\\n                queD.add(d + N);\\n            }\\n        }\\n        return queR.isEmpty() ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Two Queues Solution\\n// Two queues to store the R index and D index.\\n// If the senate can execute his right, the senate is alive and can execute in the next round.\\n// Then we can add the senate back to the queue and process in the next round (idx + N).\\n// Time complexity: O(N), each loop we add/remove 1 senate in the queue.\\n// Space complexity: O(N)\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        if (senate == null || senate.length() == 0) throw new IllegalArgumentException(\"Invalid input.\");\\n        final int N = senate.length();\\n        Queue<Integer> queR = new ArrayDeque<>();  // store the R index\\n        Queue<Integer> queD = new ArrayDeque<>();  // store the D index\\n        for (int i = 0; i < N; i++) {\\n            if (senate.charAt(i) == \\'R\\') {\\n                queR.add(i);\\n            } else {\\n                queD.add(i);\\n            }\\n        }\\n        while (!queR.isEmpty() && !queD.isEmpty()) {\\n            int r = queR.poll();\\n            int d = queD.poll();\\n            if (r < d) {  // R is alive in the next round.\\n                queR.add(r + N);\\n            } else {  // D is alive in the next round.\\n                queD.add(d + N);\\n            }\\n        }\\n        return queR.isEmpty() ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371236,
                "title": "my-c-greedy-solution",
                "content": "for R, erase the first D after it.\\nsame with D.\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int erase_R = 0;\\n        int erase_D = 0;\\n        int count_R = 0;\\n        int count_D = 0;\\n        for(auto& s : senate)\\n        {\\n            if(s == \\'R\\') count_R++;\\n            else count_D++;\\n        }\\n        while(count_D && count_R)\\n        { \\n            for(int i = 0;i < senate.size();i++)\\n            {\\n                if(erase_R != 0 && senate[i] == \\'R\\')\\n                {\\n                    erase_R--;\\n                    count_R--;\\n                    senate[i] = \\' \\';\\n                }\\n                else if(erase_D != 0 && senate[i] == \\'D\\')\\n                {\\n                    erase_D--;\\n                    count_D--;\\n                    senate[i] = \\' \\';\\n                }\\n                else if(senate[i] == \\'R\\')\\n                {\\n                    erase_D++;\\n                }\\n                else if(senate[i] == \\'D\\')\\n                {\\n                    erase_R++;\\n                }\\n            }\\n        }\\n        if(count_D == 0) return \"Radiant\";\\n        return \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int erase_R = 0;\\n        int erase_D = 0;\\n        int count_R = 0;\\n        int count_D = 0;\\n        for(auto& s : senate)\\n        {\\n            if(s == \\'R\\') count_R++;\\n            else count_D++;\\n        }\\n        while(count_D && count_R)\\n        { \\n            for(int i = 0;i < senate.size();i++)\\n            {\\n                if(erase_R != 0 && senate[i] == \\'R\\')\\n                {\\n                    erase_R--;\\n                    count_R--;\\n                    senate[i] = \\' \\';\\n                }\\n                else if(erase_D != 0 && senate[i] == \\'D\\')\\n                {\\n                    erase_D--;\\n                    count_D--;\\n                    senate[i] = \\' \\';\\n                }\\n                else if(senate[i] == \\'R\\')\\n                {\\n                    erase_D++;\\n                }\\n                else if(senate[i] == \\'D\\')\\n                {\\n                    erase_R++;\\n                }\\n            }\\n        }\\n        if(count_D == 0) return \"Radiant\";\\n        return \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155488,
                "title": "python-simple-solution",
                "content": "Optimal play: You \\'kill\\' the first senator from the oposite side that is not already \\'killed\\'.\\nSolution: \\nWe keep an array with indexes for both parties. \\nAt every step we compare the smallest value from both arrays. \\nWe choose the smaller index. \\nThe one with the smaller one gets to have another chance in [index] + len(senator) time (So we add him back to the list) and the other one does not have any other chance. \\nWe play the game untill one of the lists have no more senators.\\n\\n        l = len(senate)\\n        R = [i for i in range(l) if senate[i] == \\'R\\']\\n        D = [i for i in range(l) if senate[i] == \\'D\\']\\n        \\n        while len(D) and len(R):\\n            if D[0] > R[0]:\\n                R.append(R[0] + l)\\n            else:\\n                D.append(D[0] + l)\\n            del D[0]\\n            del R[0]\\n                \\n        return \"Dire\" if len(D) != 0 else \"Radiant\"",
                "solutionTags": [],
                "code": "Optimal play: You \\'kill\\' the first senator from the oposite side that is not already \\'killed\\'.\\nSolution: \\nWe keep an array with indexes for both parties. \\nAt every step we compare the smallest value from both arrays. \\nWe choose the smaller index. \\nThe one with the smaller one gets to have another chance in [index] + len(senator) time (So we add him back to the list) and the other one does not have any other chance. \\nWe play the game untill one of the lists have no more senators.\\n\\n        l = len(senate)\\n        R = [i for i in range(l) if senate[i] == \\'R\\']\\n        D = [i for i in range(l) if senate[i] == \\'D\\']\\n        \\n        while len(D) and len(R):\\n            if D[0] > R[0]:\\n                R.append(R[0] + l)\\n            else:\\n                D.append(D[0] + l)\\n            del D[0]\\n            del R[0]\\n                \\n        return \"Dire\" if len(D) != 0 else \"Radiant\"",
                "codeTag": "Unknown"
            },
            {
                "id": 3485734,
                "title": "c-solution-simple-2-queue-approach-heavily-commented-explained",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> r,d;  // We\\'re taking two queue for string the indesxes of Radiant and Dire.\\n        int len=senate.length();\\n        for(int i=0;i<len;i++){\\n            if(senate[i]==\\'R\\'){\\n                r.push(i);\\n            }\\n            else{\\n                d.push(i);\\n            }\\n        } \\n        \\n        while( !r.empty()  || !d.empty() ){  // It will run till both the queues are empty, which is never gonna happen tho \\n            int rr=-1,dd=-1;  // It is gonna store the index of the upcoming radiant and dire \\n            if( !r.empty() ){  \\n                rr=r.front();\\n            }\\n            if( !d.empty() ){\\n                dd=d.front();\\n            }\\n            if(rr==-1 || dd==-1){  // If anyone of the Radiant or Dire runs out that means, we got a winner.\\n                return dd==-1?\"Radiant\":\"Dire\";\\n            }\\n            if(rr<dd){  // Whoever comes first removes the upcoming opposition. Pretty greedy...\\n                d.pop();\\n                r.pop();\\n                r.push(len++);  // If R(Suppose its at 0th index, after its turn, it has to go at the end right, voting is in cycle that\\'s why.) so we pop and push it at the last index \\n            }\\n            else{  //  Dire removes Radiant in this case\\n                r.pop();\\n                d.pop();\\n                d.push(len++); // If D(Suppose its at 0th index, after its turn, it has to go at the end right, voting is in cycle that\\'s why.) so we pop and push it at the last index\\n            }\\n        } \\n        return \"\";                     \\n    }\\n};\\n```\\n**BTW anyone knows which game has Radiant or Dire**\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/2ecc367d-1431-4604-ae41-57b63abbdd8e_1683220302.138002.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> r,d;  // We\\'re taking two queue for string the indesxes of Radiant and Dire.\\n        int len=senate.length();\\n        for(int i=0;i<len;i++){\\n            if(senate[i]==\\'R\\'){\\n                r.push(i);\\n            }\\n            else{\\n                d.push(i);\\n            }\\n        } \\n        \\n        while( !r.empty()  || !d.empty() ){  // It will run till both the queues are empty, which is never gonna happen tho \\n            int rr=-1,dd=-1;  // It is gonna store the index of the upcoming radiant and dire \\n            if( !r.empty() ){  \\n                rr=r.front();\\n            }\\n            if( !d.empty() ){\\n                dd=d.front();\\n            }\\n            if(rr==-1 || dd==-1){  // If anyone of the Radiant or Dire runs out that means, we got a winner.\\n                return dd==-1?\"Radiant\":\"Dire\";\\n            }\\n            if(rr<dd){  // Whoever comes first removes the upcoming opposition. Pretty greedy...\\n                d.pop();\\n                r.pop();\\n                r.push(len++);  // If R(Suppose its at 0th index, after its turn, it has to go at the end right, voting is in cycle that\\'s why.) so we pop and push it at the last index \\n            }\\n            else{  //  Dire removes Radiant in this case\\n                r.pop();\\n                d.pop();\\n                d.push(len++); // If D(Suppose its at 0th index, after its turn, it has to go at the end right, voting is in cycle that\\'s why.) so we pop and push it at the last index\\n            }\\n        } \\n        return \"\";                     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485180,
                "title": "greedy-solution-using-queue-tc-sc-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a queue to keep track of the senators from each party. We loop through the string $$senate$$ and add each senator to their respective queues. We then loop through both queues until one of them is empty. In each iteration of the loop, we pop the first senator from each queue and compare their indices. If the Radiant senator\\'s index is less than the Dire senator\\'s index, we add the Radiant senator\\'s index plus n to the Radiant queue, indicating that they will go after all the current senators in the queue. Otherwise, we add the Dire senator\\'s index plus n to the Dire queue. This ensures that the senators who have lost their rights are skipped during the procedure.\\n\\nFinally, we return the party that still has senators in their queue. If the Radiant queue is empty, it means that all Radiant senators have lost their rights and the Dire party wins. If the Dire queue is empty, it means that all Dire senators have lost their rights and the Radiant party wins.\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere n is the length of the input string $$senate$$.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n = senate.length();\\n        queue<int> radiant, dire;\\n\\n        for (int i = 0; i < n; i++)\\n            if (senate[i] == \\'R\\')\\n                radiant.push(i);\\n            else\\n                dire.push(i);\\n\\n        while (!radiant.empty() && !dire.empty()) {\\n            int r = radiant.front();\\n            int d = dire.front();\\n\\n            radiant.pop();\\n            dire.pop();\\n\\n            if (r < d)\\n                radiant.push(r + n);\\n            else\\n                dire.push(d + n);\\n        }\\n\\n        return radiant.empty() ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n = senate.length();\\n        queue<int> radiant, dire;\\n\\n        for (int i = 0; i < n; i++)\\n            if (senate[i] == \\'R\\')\\n                radiant.push(i);\\n            else\\n                dire.push(i);\\n\\n        while (!radiant.empty() && !dire.empty()) {\\n            int r = radiant.front();\\n            int d = dire.front();\\n\\n            radiant.pop();\\n            dire.pop();\\n\\n            if (r < d)\\n                radiant.push(r + n);\\n            else\\n                dire.push(d + n);\\n        }\\n\\n        return radiant.empty() ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485023,
                "title": "easiest-approach-to-understand-brute-force",
                "content": "\\n# Approach\\n- We start by initializing the score to 0, we increment score in case of Radiant and decrement in case of Dire. \\n- The function then iterates through the senate string, and for each senator, it checks if the senator belongs to Radiant or Dire. If the senator belongs to Radiant, and the score is negative,this means that a dire had already voted a ban on Radiant, so the function pushes a senator from Dire into the end of the senate string to maintain the balance. \\n- This represents the fact that a senator from Dire is forced to vote. Similarly, if the senator belongs to Dire, and the score is positive, it means that already a Radiant had voted to ban dire, so the function pushes a senator from Radiant into the end of the senate string to maintain balance. This represents the fact that a senator from Radiant is forced to vote.\\n\\n- At the end of the loop, the function checks if the score is positive or negative. If it is positive, it means that there are more senators in favor of Radiant, so Radiant wins. Otherwise, Dire wins.\\n\\n# Complexity\\n- Time complexity: **O(n)** - **Linear complexity** as we traverse through only once.\\n\\n\\n- Space complexity: **O(1)** -**Constant space** complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int score=0;\\n        for(int i=0;i<senate.size();i++){\\n            char ch=senate[i];\\n            if(ch==\\'R\\'){\\n                if(score<0){ //already a Dire has voted for ban\\n                    senate.push_back(\\'D\\');\\n                }\\n                score++;\\n            }\\n            else{\\n                if(score>0){//already a Radiant has voted for ban\\n                    senate.push_back(\\'R\\');\\n                }\\n                score--;\\n            }\\n        }\\n        if(score>0){\\n            return \"Radiant\";\\n        }\\n        return \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int score=0;\\n        for(int i=0;i<senate.size();i++){\\n            char ch=senate[i];\\n            if(ch==\\'R\\'){\\n                if(score<0){ //already a Dire has voted for ban\\n                    senate.push_back(\\'D\\');\\n                }\\n                score++;\\n            }\\n            else{\\n                if(score>0){//already a Radiant has voted for ban\\n                    senate.push_back(\\'R\\');\\n                }\\n                score--;\\n            }\\n        }\\n        if(score>0){\\n            return \"Radiant\";\\n        }\\n        return \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484552,
                "title": "easy-java-solution-in-o-n",
                "content": "# Intuition \\nEverytime the the senator will try to ban the vote of next opposite sanator. So the senator appearing first have advantage.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nPut all characters in a queue and then check-\\nIf the number of senators of opposite party are more than its party including that senator, then he can\\'t vote. \\nIf the count of senators of opposite party are less including him then only he can ban next opposite senaator.\\nLike this at the end only one party senator will be left, try to run the loop upto 2*n only as in second round we will get the answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int n = senate.length();\\n        Queue<Character> q = new LinkedList<>();\\n        int r = 0;\\n        int d = 0;\\n        for(int i=0;i<n;i++){\\n            q.add(senate.charAt(i));\\n        }\\n        int i=0;\\n        while(i<2*n){\\n            if(q.peek()==\\'R\\'){\\n                if(d==0){\\n                    r++;\\n                    q.remove();\\n                    q.add(\\'R\\');\\n                }else{\\n                    d--;\\n                    q.remove();\\n                }\\n            }else{\\n                if(r==0){\\n                    d++;\\n                    q.remove();\\n                    q.add(\\'D\\');\\n                }else{\\n                    r--;\\n                    q.remove();\\n                }\\n            }\\n            i++;\\n        }\\n        if(q.peek()==\\'D\\') return \"Dire\";\\n        return \"Radiant\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int n = senate.length();\\n        Queue<Character> q = new LinkedList<>();\\n        int r = 0;\\n        int d = 0;\\n        for(int i=0;i<n;i++){\\n            q.add(senate.charAt(i));\\n        }\\n        int i=0;\\n        while(i<2*n){\\n            if(q.peek()==\\'R\\'){\\n                if(d==0){\\n                    r++;\\n                    q.remove();\\n                    q.add(\\'R\\');\\n                }else{\\n                    d--;\\n                    q.remove();\\n                }\\n            }else{\\n                if(r==0){\\n                    d++;\\n                    q.remove();\\n                    q.add(\\'D\\');\\n                }else{\\n                    r--;\\n                    q.remove();\\n                }\\n            }\\n            i++;\\n        }\\n        if(q.peek()==\\'D\\') return \"Dire\";\\n        return \"Radiant\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484331,
                "title": "c-solution-using-stack-4ms-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n     stack<char> st;\\n        for(int i = 0;i<senate.size();i++)\\n        {\\n            //if stack is empty we will push element here\\n            if(st.empty())\\n            {\\n                st.push(senate[i]);\\n            }\\n            else\\n            {\\n                //here stack is not empty\\n                //so we will check if its same as stack top or different\\n                //if its not same then we will add character at the end of orginal string\\n                //then remove the character from stack as we have added it on orginal string for another round.\\n                if(st.top() != senate[i])\\n                {\\n                    char x = st.top();\\n                    st.pop();\\n                    senate += x;\\n                }\\n                else\\n                {\\n                    st.push(senate[i]);\\n                }\\n            }\\n        }\\n        string ans =\"\";\\n        //here we will check stack top\\n        //after all round similation only on character will left that will be the winner\\n        if(st.top() == \\'R\\')\\n        {\\n            ans = \"Radiant\";\\n        }\\n        else\\n        {\\n            ans = \"Dire\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n     stack<char> st;\\n        for(int i = 0;i<senate.size();i++)\\n        {\\n            //if stack is empty we will push element here\\n            if(st.empty())\\n            {\\n                st.push(senate[i]);\\n            }\\n            else\\n            {\\n                //here stack is not empty\\n                //so we will check if its same as stack top or different\\n                //if its not same then we will add character at the end of orginal string\\n                //then remove the character from stack as we have added it on orginal string for another round.\\n                if(st.top() != senate[i])\\n                {\\n                    char x = st.top();\\n                    st.pop();\\n                    senate += x;\\n                }\\n                else\\n                {\\n                    st.push(senate[i]);\\n                }\\n            }\\n        }\\n        string ans =\"\";\\n        //here we will check stack top\\n        //after all round similation only on character will left that will be the winner\\n        if(st.top() == \\'R\\')\\n        {\\n            ans = \"Radiant\";\\n        }\\n        else\\n        {\\n            ans = \"Dire\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483570,
                "title": "rust-stack-and-queue-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn predict_party_victory(senate: String) -> String {\\n        let mut stack: Vec<char> = vec![];\\n        let mut queue: Vec<char> = senate.chars().collect();\\n\\n        while !queue.is_empty() {\\n            let top = queue.remove(0);\\n\\n            if stack.is_empty() || *stack.last().unwrap() == top {\\n                stack.push(top);\\n            } else {\\n                queue.push(stack.pop().unwrap());\\n            }\\n        }\\n\\n        if stack.pop().unwrap() == \\'R\\' { \"Radiant\".to_string() } else { \"Dire\".to_string() }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn predict_party_victory(senate: String) -> String {\\n        let mut stack: Vec<char> = vec![];\\n        let mut queue: Vec<char> = senate.chars().collect();\\n\\n        while !queue.is_empty() {\\n            let top = queue.remove(0);\\n\\n            if stack.is_empty() || *stack.last().unwrap() == top {\\n                stack.push(top);\\n            } else {\\n                queue.push(stack.pop().unwrap());\\n            }\\n        }\\n\\n        if stack.pop().unwrap() == \\'R\\' { \"Radiant\".to_string() } else { \"Dire\".to_string() }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483393,
                "title": "easy-java-solution-using-stringbuilder-beginner-friendly",
                "content": "# Intuition\\nEach senator turn will come indexwise, and best of interest the first priority will be to ban anyone coming after.\\n\\n\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted.\\n\\n\\n# Approach\\n1. Start with first Senator, check opposite first senator\\n2. If opposite found, delete them and move current senator (which is always at index 0) to the last of string\\n3. Continue the process until no more opposite senator is found\\n4. Whover type is left is the winner\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String getOppositeSenator(char senator) {\\n        return senator == \\'D\\' ? \"R\" : \"D\";\\n    }\\n    public String fullName(char senator) {\\n        switch(senator) {\\n            case \\'D\\':\\n                return \"Dire\";\\n            case \\'R\\' :\\n                return \"Radiant\";\\n        };\\n        return null;\\n    }\\n    public String predictPartyVictory(String senate) {\\n        StringBuilder sb = new StringBuilder(senate);\\n\\n        while(true) {\\n            char currentSenator = sb.charAt(0);\\n            String firstOppositeSenator = getOppositeSenator(currentSenator);\\n            int index = sb.indexOf(firstOppositeSenator);\\n            if(index != -1) {\\n                // Delete opposite senator \\n                sb.deleteCharAt(index);\\n                // move current senator which is at index 0 to last\\n                sb.deleteCharAt(0); \\n                sb.append(currentSenator);\\n            } else {\\n                // if no more opposite senator found, means currentSenator\\n                // is the winner because of majority\\n                return fullName(currentSenator);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String getOppositeSenator(char senator) {\\n        return senator == \\'D\\' ? \"R\" : \"D\";\\n    }\\n    public String fullName(char senator) {\\n        switch(senator) {\\n            case \\'D\\':\\n                return \"Dire\";\\n            case \\'R\\' :\\n                return \"Radiant\";\\n        };\\n        return null;\\n    }\\n    public String predictPartyVictory(String senate) {\\n        StringBuilder sb = new StringBuilder(senate);\\n\\n        while(true) {\\n            char currentSenator = sb.charAt(0);\\n            String firstOppositeSenator = getOppositeSenator(currentSenator);\\n            int index = sb.indexOf(firstOppositeSenator);\\n            if(index != -1) {\\n                // Delete opposite senator \\n                sb.deleteCharAt(index);\\n                // move current senator which is at index 0 to last\\n                sb.deleteCharAt(0); \\n                sb.append(currentSenator);\\n            } else {\\n                // if no more opposite senator found, means currentSenator\\n                // is the winner because of majority\\n                return fullName(currentSenator);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353103,
                "title": "c-single-queue-single-ban-scale",
                "content": "# Intuition\\nPut all senators into a queue. On each poll, if the senator is not banned, let him ban an opponent and put him back in the queue. If the senator is banned, remove him from queue.\\n\\n# Approach\\nI keep a single variable ```scale``` to let me know which direction the bans are tipped. A positive value means there are pending bans in the \"Dire\" team. A negative value means there are pending bans in the \"Radiant\" team. A value of zero means there are no pending bans. \\n\\nIf the scale is in the favor of the senator, they can ban and re-insert themselves. If not, then the are simply removed. In either case, the scale tips toward the senator\\'s team 1 level. Exit when 1 team\\'s total count is reduced to zero.\\n\\n# Code\\n```\\npublic class Solution {\\n    public string PredictPartyVictory(string senate)\\n    {\\n        Queue<char> senators = new Queue<char>(senate);\\n        int countR = senate.Count(x => x == \\'R\\');\\n        int countD = senate.Length - countR;\\n\\n        // [Positive = Radiant Favor, Negative = Dire Favor]\\n        int scale = 0; \\n\\n        while (countR > 0 && countD > 0) {\\n\\n            char senator = senators.Dequeue();\\n\\n            if (senator == \\'R\\') {\\n                if (scale >= 0) {\\n                    countD--;\\n                    senators.Enqueue(senator);\\n                }\\n                scale++;\\n            }\\n            else {\\n                if (scale <= 0) {\\n                    countR--;\\n                    senators.Enqueue(senator);\\n                }\\n                scale--;\\n            }\\n        }\\n\\n        return countR == 0 ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```scale```\n```\\npublic class Solution {\\n    public string PredictPartyVictory(string senate)\\n    {\\n        Queue<char> senators = new Queue<char>(senate);\\n        int countR = senate.Count(x => x == \\'R\\');\\n        int countD = senate.Length - countR;\\n\\n        // [Positive = Radiant Favor, Negative = Dire Favor]\\n        int scale = 0; \\n\\n        while (countR > 0 && countD > 0) {\\n\\n            char senator = senators.Dequeue();\\n\\n            if (senator == \\'R\\') {\\n                if (scale >= 0) {\\n                    countD--;\\n                    senators.Enqueue(senator);\\n                }\\n                scale++;\\n            }\\n            else {\\n                if (scale <= 0) {\\n                    countR--;\\n                    senators.Enqueue(senator);\\n                }\\n                scale--;\\n            }\\n        }\\n\\n        return countR == 0 ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707693,
                "title": "javascript-solution-greedy-approach",
                "content": "```\\nvar predictPartyVictory = function(senate) {\\n    const n = senate.length;\\n    \\n    const rQueue = [];\\n    const sQueue = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        const char = senate.charAt(i);\\n        \\n        if (char === \"R\") rQueue.push(i);\\n        else sQueue.push(i);\\n    }\\n    \\n    let i = n;\\n    \\n    while (rQueue.length > 0 && sQueue.length > 0) {\\n        const rFirst = rQueue.shift();\\n        const sFirst = sQueue.shift();\\n        \\n        if (rFirst < sFirst) rQueue.push(i++);\\n        else sQueue.push(i++);\\n    }\\n    \\n    return rQueue.length === 0 ? \"Dire\" : \"Radiant\";\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar predictPartyVictory = function(senate) {\\n    const n = senate.length;\\n    \\n    const rQueue = [];\\n    const sQueue = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        const char = senate.charAt(i);\\n        \\n        if (char === \"R\") rQueue.push(i);\\n        else sQueue.push(i);\\n    }\\n    \\n    let i = n;\\n    \\n    while (rQueue.length > 0 && sQueue.length > 0) {\\n        const rFirst = rQueue.shift();\\n        const sFirst = sQueue.shift();\\n        \\n        if (rFirst < sFirst) rQueue.push(i++);\\n        else sQueue.push(i++);\\n    }\\n    \\n    return rQueue.length === 0 ? \"Dire\" : \"Radiant\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485850,
                "title": "c-solution-o-1-space-complexity-o-n-time-complexity",
                "content": "**Time Complexity -> O(N)\\nSpace Complexity -> O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        int skipR = 0, skipD = 0, totalR = 0, totalD = 0, ptr = 0, len = s.size();\\n        for(auto itr: s){\\n            if(itr == \\'R\\'){\\n                totalR++;\\n            }else{\\n                totalD++;\\n            }\\n        }\\n        while(totalR > 0 && totalD > 0){\\n            if(s[ptr] == \\'R\\'){\\n                if(skipR > 0){\\n                    s[ptr] = \\'S\\';\\n                    totalR--;\\n                    skipR--;\\n                }else{\\n                    skipD++;\\n                }\\n            }else if(s[ptr] == \\'D\\'){\\n                if(skipD > 0){\\n                    s[ptr] = \\'S\\';\\n                    totalD--;\\n                    skipD--;\\n                }else{\\n                    skipR++;\\n                }\\n            }\\n            ptr = (++ptr)%len;\\n        }\\n        if(totalR > 0){\\n            return \"Radiant\";\\n        }\\n        return \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        int skipR = 0, skipD = 0, totalR = 0, totalD = 0, ptr = 0, len = s.size();\\n        for(auto itr: s){\\n            if(itr == \\'R\\'){\\n                totalR++;\\n            }else{\\n                totalD++;\\n            }\\n        }\\n        while(totalR > 0 && totalD > 0){\\n            if(s[ptr] == \\'R\\'){\\n                if(skipR > 0){\\n                    s[ptr] = \\'S\\';\\n                    totalR--;\\n                    skipR--;\\n                }else{\\n                    skipD++;\\n                }\\n            }else if(s[ptr] == \\'D\\'){\\n                if(skipD > 0){\\n                    s[ptr] = \\'S\\';\\n                    totalD--;\\n                    skipD--;\\n                }else{\\n                    skipR++;\\n                }\\n            }\\n            ptr = (++ptr)%len;\\n        }\\n        if(totalR > 0){\\n            return \"Radiant\";\\n        }\\n        return \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485649,
                "title": "deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndeque\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndeque\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int d=0,r=0,totd=0,totr=0;\\n        deque<char> dq;\\n        for(int i=0;i<senate.size();i++)\\n        {\\n            if(senate[i]==\\'R\\')\\n            totr++;\\n            else \\n            totd++;\\n            dq.push_back(senate[i]);\\n        }\\n        string a=\"Radiant\";\\n        string b=\"Dire\";\\n        string ans=\"\";\\n        while(dq.size()>0 || ans!=\"\")\\n        {\\n            if(dq.front()==\\'R\\')\\n            {\\n                if(totd<=1)\\n                {\\n                    ans=a;\\n                    break;\\n                }\\n                if(r>0)\\n                {\\n                    r--;\\n                    dq.pop_front();\\n                    //totr--;\\n                }\\n                else \\n                {\\n                d++;\\n                totd--;\\n                dq.push_back(dq.front());\\n                dq.pop_front();\\n                }\\n            }\\n            else \\n            {\\n                if(totr<=1)\\n                {\\n                    ans=b;\\n                    break;\\n                }\\n                if(d>0)\\n                {\\n                    d--;\\n                    //totd--;\\n                    dq.pop_front();\\n                }\\n                else \\n                {\\n                r++;\\n                totr--;\\n                dq.push_back(dq.front());\\n                dq.pop_front();\\n                }\\n            }\\n        }\\n        if(ans==\"\")\\n        {\\n            if(totr>0)\\n            ans=a;\\n            else \\n            ans=b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int d=0,r=0,totd=0,totr=0;\\n        deque<char> dq;\\n        for(int i=0;i<senate.size();i++)\\n        {\\n            if(senate[i]==\\'R\\')\\n            totr++;\\n            else \\n            totd++;\\n            dq.push_back(senate[i]);\\n        }\\n        string a=\"Radiant\";\\n        string b=\"Dire\";\\n        string ans=\"\";\\n        while(dq.size()>0 || ans!=\"\")\\n        {\\n            if(dq.front()==\\'R\\')\\n            {\\n                if(totd<=1)\\n                {\\n                    ans=a;\\n                    break;\\n                }\\n                if(r>0)\\n                {\\n                    r--;\\n                    dq.pop_front();\\n                    //totr--;\\n                }\\n                else \\n                {\\n                d++;\\n                totd--;\\n                dq.push_back(dq.front());\\n                dq.pop_front();\\n                }\\n            }\\n            else \\n            {\\n                if(totr<=1)\\n                {\\n                    ans=b;\\n                    break;\\n                }\\n                if(d>0)\\n                {\\n                    d--;\\n                    //totd--;\\n                    dq.pop_front();\\n                }\\n                else \\n                {\\n                r++;\\n                totr--;\\n                dq.push_back(dq.front());\\n                dq.pop_front();\\n                }\\n            }\\n        }\\n        if(ans==\"\")\\n        {\\n            if(totr>0)\\n            ans=a;\\n            else \\n            ans=b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484722,
                "title": "java-solution-using-queue-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n   Queue <Integer> r = new LinkedList<>();\\n   Queue <Integer> d= new LinkedList<>();\\n   for(int i=0;i<senate.length();i++){\\n       if(senate.charAt(i)==\\'R\\')\\n       r.offer(i);\\n       else\\n       d.offer(i);\\n   }\\n    while(!r.isEmpty() && !d.isEmpty()){\\n       int v1=r.poll();\\n       int v2=d.poll();\\n       if(v1<v2)\\n       r.offer(senate.length()+v1);\\n       else\\n        d.offer(senate.length()+v2);\\n   }\\n     return r.isEmpty() ? \"Dire\":\"Radiant\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n   Queue <Integer> r = new LinkedList<>();\\n   Queue <Integer> d= new LinkedList<>();\\n   for(int i=0;i<senate.length();i++){\\n       if(senate.charAt(i)==\\'R\\')\\n       r.offer(i);\\n       else\\n       d.offer(i);\\n   }\\n    while(!r.isEmpty() && !d.isEmpty()){\\n       int v1=r.poll();\\n       int v2=d.poll();\\n       if(v1<v2)\\n       r.offer(senate.length()+v1);\\n       else\\n        d.offer(senate.length()+v2);\\n   }\\n     return r.isEmpty() ? \"Dire\":\"Radiant\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484077,
                "title": "c-queue-implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue < int > rq;\\n        queue < int > dq;\\n        int len = senate.size();\\n        for (int i = 0; i < senate.size(); ++i) {\\n            if (senate[i] == \\'R\\') {\\n                rq.push(i);\\n            }\\n            else {\\n                dq.push(i);\\n            }\\n        }\\n        while (!rq.empty() && !dq.empty()) {\\n            int r = rq.front();\\n            rq.pop();\\n            int d = dq.front();\\n            dq.pop();\\n            if (d < r) {\\n                dq.push(d + len);\\n            }\\n            else {\\n                rq.push(r + len);\\n            }\\n        }\\n        string s = \"Radiant\";\\n        if (rq.empty()) {\\n            s = \"Dire\";\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue < int > rq;\\n        queue < int > dq;\\n        int len = senate.size();\\n        for (int i = 0; i < senate.size(); ++i) {\\n            if (senate[i] == \\'R\\') {\\n                rq.push(i);\\n            }\\n            else {\\n                dq.push(i);\\n            }\\n        }\\n        while (!rq.empty() && !dq.empty()) {\\n            int r = rq.front();\\n            rq.pop();\\n            int d = dq.front();\\n            dq.pop();\\n            if (d < r) {\\n                dq.push(d + len);\\n            }\\n            else {\\n                rq.push(r + len);\\n            }\\n        }\\n        string s = \"Radiant\";\\n        if (rq.empty()) {\\n            s = \"Dire\";\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483887,
                "title": "ruby",
                "content": "# Code\\n```ruby\\ndef predict_party_victory(senate)\\n    qr, qd = senate.chars.each_with_index.partition {|q| q.first == \\'R\\' }.collect {|a| a.collect(&:last) }\\n    until qr.empty? || qd.empty? do\\n        ri, di = [qr, qd].collect(&:shift)\\n        if ri < di then \\n            qr << ri + senate.size\\n        else\\n            qd << di + senate.size\\n        end\\n    end\\n    qr.size > qd.size ? \\'Radiant\\' : \\'Dire\\'\\nend\\n\\n```\\n\\n## Or, shorter but slower\\n\\n```ruby\\n\\nclass Array\\n    def shap(sh) = first << last + sh\\nend\\n\\ndef predict_party_victory(senate)\\n    qrqd = senate.chars.each_with_index.partition {|q| q.first == \\'R\\' }.collect {|a| a.collect(&:last) }\\n    (ridi = qrqd.collect(&:shift); qrqd.zip(ridi)[ridi.first < ridi.last ? 0 : 1].shap(senate.size)) until qrqd.any?(&:empty?)\\n    qrqd.first.size > qrqd.last.size ? \\'Radiant\\' : \\'Dire\\'\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef predict_party_victory(senate)\\n    qr, qd = senate.chars.each_with_index.partition {|q| q.first == \\'R\\' }.collect {|a| a.collect(&:last) }\\n    until qr.empty? || qd.empty? do\\n        ri, di = [qr, qd].collect(&:shift)\\n        if ri < di then \\n            qr << ri + senate.size\\n        else\\n            qd << di + senate.size\\n        end\\n    end\\n    qr.size > qd.size ? \\'Radiant\\' : \\'Dire\\'\\nend\\n\\n```\n```ruby\\n\\nclass Array\\n    def shap(sh) = first << last + sh\\nend\\n\\ndef predict_party_victory(senate)\\n    qrqd = senate.chars.each_with_index.partition {|q| q.first == \\'R\\' }.collect {|a| a.collect(&:last) }\\n    (ridi = qrqd.collect(&:shift); qrqd.zip(ridi)[ridi.first < ridi.last ? 0 : 1].shap(senate.size)) until qrqd.any?(&:empty?)\\n    qrqd.first.size > qrqd.last.size ? \\'Radiant\\' : \\'Dire\\'\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358201,
                "title": "swift-fastest-explained-solution-beats-100-7ms",
                "content": "# Swift | fastest explained solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing hashMap `banned` to keep track of banned senates by their id. Once we have `countD` or `countR` (representing overall number of senates of each group accordingly per cycle) equal to 0 we have found the winner.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func predictPartyVictory(_ senate: String) -> String {\\n        var bannedD = 0\\n        var bannedR = 0\\n        var countD = 0\\n        var countR = 0\\n        var senate = Array(senate)\\n        var banned = [Int: Bool]()\\n\\n        repeat {\\n            countR = 0\\n            countD = 0\\n            \\n            for i in 0..<senate.endIndex {\\n                guard banned[i, default: false] == false else { continue }\\n\\n                if senate[i] == \"R\" {\\n                    if bannedR == 0 {\\n                        bannedD += 1\\n                        countR += 1\\n                    } else {\\n                        banned[i] = true\\n                        bannedR -= 1\\n                    }\\n                } else {\\n                    if bannedD == 0 {\\n                        bannedR += 1\\n                        countD += 1\\n                    } else {\\n                        banned[i] = true\\n                        bannedD -= 1\\n                    }\\n                }\\n            }\\n        } while countR > 0 && countD > 0\\n\\n        return countR > countD ? \"Radiant\" : \"Dire\"\\n    }\\n}\\n```\\n\\n> ***Please upvote if you like it***",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func predictPartyVictory(_ senate: String) -> String {\\n        var bannedD = 0\\n        var bannedR = 0\\n        var countD = 0\\n        var countR = 0\\n        var senate = Array(senate)\\n        var banned = [Int: Bool]()\\n\\n        repeat {\\n            countR = 0\\n            countD = 0\\n            \\n            for i in 0..<senate.endIndex {\\n                guard banned[i, default: false] == false else { continue }\\n\\n                if senate[i] == \"R\" {\\n                    if bannedR == 0 {\\n                        bannedD += 1\\n                        countR += 1\\n                    } else {\\n                        banned[i] = true\\n                        bannedR -= 1\\n                    }\\n                } else {\\n                    if bannedD == 0 {\\n                        bannedR += 1\\n                        countD += 1\\n                    } else {\\n                        banned[i] = true\\n                        bannedD -= 1\\n                    }\\n                }\\n            }\\n        } while countR > 0 && countD > 0\\n\\n        return countR > countD ? \"Radiant\" : \"Dire\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260476,
                "title": "using-queue-well-explained-commented-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        //first R erases first D and R gets appended to senate \\n        //first D erases first R and D gets appended to senate \\n        /*\\n        ex:-senate = RDD \\n            senate = DR (first R erases first D and R gets appended to senate )\\n            senate = D (first D erases first R and D gets appended to senate )    \\n            Thus, winner is Dire \\n\\n        ex:-senate = RDDRDR \\n            senate = DRDRR (first R erases first D and R gets appended to senate )\\n            senate = DRRD (first D erases first R and D gets appended to senate )   \\n            senate = RDD (first D erases first R and D gets appended to senate ) \\n            senate = DR (first R erases first D and R gets appended to senate)\\n             senate = D (first D erases first R and D gets appended to senate ) \\n            Thus, winner is Dire     \\n       */\\n       queue<int>r,d; \\n       int n = senate.size();\\n       string winner = \"\";\\n\\n       for(int i=0;i<n;i++){\\n           if(senate[i]==\\'R\\') r.push(i);\\n           else d.push(i);\\n       }\\n       while(1){\\n           if(r.empty()&&!d.empty()) {winner=\"Dire\"; break;}\\n           if(!r.empty()&&d.empty()){winner=\"Radiant\"; break;}\\n           int indr = r.front() , indd = d.front();\\n           r.pop() ; d.pop();\\n           \\n           //erase the first position i.e min of indr & indd \\n           int toDeleteBy = min(indr,indd) ; \\n           //first R erases first D and R gets appended to senate\\n           if(toDeleteBy==indr){\\n             //R gets appended to senate at last \\n             //i.e pos will be indr+n at this pos R gets appended \\n             int appendRAtPos = n+indr; \\n             r.push(appendRAtPos);\\n           }\\n         //first D erases first R and D gets appended to senate \\n           else if(toDeleteBy==indd){\\n             //D gets appended to senate \\n             //i.e pos will be indd+n at this pos D gets appended \\n             int appendDAtPos = n+indd; \\n             d.push(appendDAtPos);\\n           }\\n                  }\\n        return winner ; \\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        //first R erases first D and R gets appended to senate \\n        //first D erases first R and D gets appended to senate \\n        /*\\n        ex:-senate = RDD \\n            senate = DR (first R erases first D and R gets appended to senate )\\n            senate = D (first D erases first R and D gets appended to senate )    \\n            Thus, winner is Dire \\n\\n        ex:-senate = RDDRDR \\n            senate = DRDRR (first R erases first D and R gets appended to senate )\\n            senate = DRRD (first D erases first R and D gets appended to senate )   \\n            senate = RDD (first D erases first R and D gets appended to senate ) \\n            senate = DR (first R erases first D and R gets appended to senate)\\n             senate = D (first D erases first R and D gets appended to senate ) \\n            Thus, winner is Dire     \\n       */\\n       queue<int>r,d; \\n       int n = senate.size();\\n       string winner = \"\";\\n\\n       for(int i=0;i<n;i++){\\n           if(senate[i]==\\'R\\') r.push(i);\\n           else d.push(i);\\n       }\\n       while(1){\\n           if(r.empty()&&!d.empty()) {winner=\"Dire\"; break;}\\n           if(!r.empty()&&d.empty()){winner=\"Radiant\"; break;}\\n           int indr = r.front() , indd = d.front();\\n           r.pop() ; d.pop();\\n           \\n           //erase the first position i.e min of indr & indd \\n           int toDeleteBy = min(indr,indd) ; \\n           //first R erases first D and R gets appended to senate\\n           if(toDeleteBy==indr){\\n             //R gets appended to senate at last \\n             //i.e pos will be indr+n at this pos R gets appended \\n             int appendRAtPos = n+indr; \\n             r.push(appendRAtPos);\\n           }\\n         //first D erases first R and D gets appended to senate \\n           else if(toDeleteBy==indd){\\n             //D gets appended to senate \\n             //i.e pos will be indd+n at this pos D gets appended \\n             int appendDAtPos = n+indd; \\n             d.push(appendDAtPos);\\n           }\\n                  }\\n        return winner ; \\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025381,
                "title": "clean-python-solution",
                "content": "The concept is take 2 queues one for dire and one for radiants which keeps their indexes. We pop from both queue whichever is larger(y) index we will bann that. and append smaller_element (x)+ idx as this element will be candidate for next round.\\n\\n```\\nclass Solution:\\n    import collections\\n    def predictPartyVictory(self, senate: str) -> str:\\n        queue1 = collections.deque()\\n        queue2 = collections.deque()\\n        \\n        n = len(senate)\\n        \\n        for idx, senator in enumerate(senate):\\n            queue1.append(idx) if senator == \\'R\\' else queue2.append(idx)\\n        \\n        while queue1 and queue2:\\n            x = queue1.popleft()\\n            y = queue2.popleft()\\n            \\n            queue1.append(x + n) if x < y else queue2.append(y + n)\\n                \\n        \\n        return \"Radiant\" if queue1 else \"Dire\"\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    import collections\\n    def predictPartyVictory(self, senate: str) -> str:\\n        queue1 = collections.deque()\\n        queue2 = collections.deque()\\n        \\n        n = len(senate)\\n        \\n        for idx, senator in enumerate(senate):\\n            queue1.append(idx) if senator == \\'R\\' else queue2.append(idx)\\n        \\n        while queue1 and queue2:\\n            x = queue1.popleft()\\n            y = queue2.popleft()\\n            \\n            queue1.append(x + n) if x < y else queue2.append(y + n)\\n                \\n        \\n        return \"Radiant\" if queue1 else \"Dire\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 929104,
                "title": "c-intiutive-way-to-use-two-queues",
                "content": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n      //?????????????????? Using two Queue ?????????????????????\\n        \\n        queue<int>rad; // store indiceis of Radiants\\n        queue<int>dir;\\n        int n=senate.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(senate[i]==\\'R\\')rad.push(i);\\n            else\\n                dir.push(i);\\n        }\\n        while(true)\\n        {\\n            if(rad.empty())return \"Dire\";   // If one party has no vote right now\\n            if(dir.empty())return \"Radiant\";\\n            int r=rad.front();\\n            int d=dir.front();\\n             dir.pop();\\n             rad.pop();\\n            if(r<d)\\n            {\\n               rad.push(n+r);   // If Radiant is coming before dire\\n                                 // TThen this candidate will be eligible for next round\\n            }\\n            else\\n            {\\n                dir.push(n+d);   // Adiing n is important to specify thr which round\\n            }\\n        }\\n        return \"\";\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n      //?????????????????? Using two Queue ?????????????????????\\n        \\n        queue<int>rad; // store indiceis of Radiants\\n        queue<int>dir;\\n        int n=senate.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(senate[i]==\\'R\\')rad.push(i);\\n            else\\n                dir.push(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 888702,
                "title": "python3-simulation-via-two-deques",
                "content": "\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        radiant, dire = deque(), deque()\\n        for i, x in enumerate(senate): \\n            if x == \"R\": radiant.append(i)\\n            else: dire.append(i)\\n        while radiant and dire: \\n            if radiant[0] < dire[0]: \\n                radiant.append(radiant.popleft()+len(senate))\\n                dire.popleft()\\n            else: \\n                radiant.popleft()\\n                dire.append(dire.popleft()+len(senate))\\n        return \"Radiant\" if radiant else \"Dire\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        radiant, dire = deque(), deque()\\n        for i, x in enumerate(senate): \\n            if x == \"R\": radiant.append(i)\\n            else: dire.append(i)\\n        while radiant and dire: \\n            if radiant[0] < dire[0]: \\n                radiant.append(radiant.popleft()+len(senate))\\n                dire.popleft()\\n            else: \\n                radiant.popleft()\\n                dire.append(dire.popleft()+len(senate))\\n        return \"Radiant\" if radiant else \"Dire\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568039,
                "title": "go-two-queue-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Dota2 Senate.\\nMemory Usage: 3.9 MB, less than 100.00% of Go online submissions for Dota2 Senate.\\n```\\nfunc predictPartyVictory(senate string) string {\\n    n:= len(senate)\\n    \\n    \\n    qRadiant, qDire := make([]int,0,n), make([]int,0,n)\\n    \\n    for idx, r := range senate{\\n        if r == \\'R\\'{\\n            qRadiant = append(qRadiant,idx)\\n        } else{\\n            qDire = append(qDire,idx)\\n        }\\n    }\\n    \\n    \\n    for len(qRadiant) > 0 && len(qDire) > 0 {\\n        rIndex, dIndex := qRadiant[0], qDire[0]\\n        \\n        qRadiant, qDire = qRadiant[1:], qDire[1:]\\n    \\n        if rIndex < dIndex{\\n            qRadiant = append(qRadiant, rIndex+n)\\n        } else{\\n            qDire = append(qDire, dIndex+n)\\n        }\\n    }\\n    \\n    \\n    if len(qRadiant) > 0  {\\n        return \"Radiant\"\\n    }\\n    \\n    return \"Dire\"\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Queue"
                ],
                "code": "```\\nfunc predictPartyVictory(senate string) string {\\n    n:= len(senate)\\n    \\n    \\n    qRadiant, qDire := make([]int,0,n), make([]int,0,n)\\n    \\n    for idx, r := range senate{\\n        if r == \\'R\\'{\\n            qRadiant = append(qRadiant,idx)\\n        } else{\\n            qDire = append(qDire,idx)\\n        }\\n    }\\n    \\n    \\n    for len(qRadiant) > 0 && len(qDire) > 0 {\\n        rIndex, dIndex := qRadiant[0], qDire[0]\\n        \\n        qRadiant, qDire = qRadiant[1:], qDire[1:]\\n    \\n        if rIndex < dIndex{\\n            qRadiant = append(qRadiant, rIndex+n)\\n        } else{\\n            qDire = append(qDire, dIndex+n)\\n        }\\n    }\\n    \\n    \\n    if len(qRadiant) > 0  {\\n        return \"Radiant\"\\n    }\\n    \\n    return \"Dire\"\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 549647,
                "title": "elegant-c-o-n-time-o-1-space-solution",
                "content": "We count the \"score\", which means any senator on the \"Radiant\" side make the score++, and \"Dire\" side senator make score--.\\nSo the idea is, when we encounter an \\'R\\', if score<0, we can claim that he will be banned by one of former senator in this round. So we erase him by setting it to \\'#\\'. Same for \\'D\\'. And we do the counting job of \\'R\\' and \\'D\\' in the first round.\\n```cpp\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        auto n = senate.size();\\n        int R = 0, D = 0, score = 0, first = 1;\\n        do {\\n            for (auto &c : senate) {\\n                if (c == \\'R\\') {\\n                    R += first;\\n                    if (++score <= 0) {\\n                        c = \\'#\\';\\n                        R--;\\n                    }\\n                } else if (c == \\'D\\') {\\n                    D += first;\\n                    if (--score >= 0) {\\n                        c = \\'#\\';\\n                        D--;\\n                    }\\n                }\\n            }\\n            first = 0;\\n        } while (R > 0 && D > 0);\\n        return R == 0 ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        auto n = senate.size();\\n        int R = 0, D = 0, score = 0, first = 1;\\n        do {\\n            for (auto &c : senate) {\\n                if (c == \\'R\\') {\\n                    R += first;\\n                    if (++score <= 0) {\\n                        c = \\'#\\';\\n                        R--;\\n                    }\\n                } else if (c == \\'D\\') {\\n                    D += first;\\n                    if (--score >= 0) {\\n                        c = \\'#\\';\\n                        D--;\\n                    }\\n                }\\n            }\\n            first = 0;\\n        } while (R > 0 && D > 0);\\n        return R == 0 ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045311,
                "title": "go-solution-easy-explanation-o-n-time-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a string representing senators from two parties, Radiant (R) and Dire (D), who will vote in rounds. In each round, a senator can either ban the next senator\\'s right or announce victory if their party has all the remaining senators.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create two lists, radiant and dire, to keep track of the indices of Radiant and Dire senators, respectively.\\n2. Initialize these lists by iterating through the input string, identifying the party of each senator, and adding their index to the corresponding list.\\n3. Simulate the ban process using a while loop until one party has no senators left.\\n4. In each round, the first senator from the party with the lower index bans a senator from the opposing party with the lowest index. This senator is considered \"banned\" by incrementing their index by the length of the senate string.\\n5. Remove the banned senators from their respective lists.\\n6. Continue the loop until one of the party\\'s lists is empty.\\n7. If Radiant senators remain, return \"Radiant\"; otherwise, return \"Dire.\"\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is O(N), where N is the number of senators in the input string. In the worst case, we process each senator once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(N) as we use two lists (radiant and dire) to store the indices of senators. In the worst case, both parties have an equal number of senators.\\n\\n# Code\\n```\\nfunc predictPartyVictory(senate string) string {\\n    radiant := []int{} // Slice to store the indices of Radiant senators\\n    dire := []int{}    // Slice to store the indices of Dire senators\\n\\n    // Initialize the slices\\n    for i, party := range senate {\\n        if party == \\'R\\' {\\n            radiant = append(radiant, i)\\n        } else {\\n            dire = append(dire, i)\\n        }\\n    }\\n\\n    for len(radiant) > 0 && len(dire) > 0 {\\n        // Find the first Radiant senator to ban a Dire senator\\n        if radiant[0] < dire[0] {\\n            radiant = append(radiant, radiant[0]+len(senate))\\n        } else {\\n            dire = append(dire, dire[0]+len(senate))\\n        }\\n\\n        radiant = radiant[1:] // Remove the Radiant senator\\n        dire = dire[1:]       // Remove the Dire senator\\n    }\\n\\n    if len(radiant) > 0 {\\n        return \"Radiant\"\\n    } else {\\n        return \"Dire\"\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Queue"
                ],
                "code": "```\\nfunc predictPartyVictory(senate string) string {\\n    radiant := []int{} // Slice to store the indices of Radiant senators\\n    dire := []int{}    // Slice to store the indices of Dire senators\\n\\n    // Initialize the slices\\n    for i, party := range senate {\\n        if party == \\'R\\' {\\n            radiant = append(radiant, i)\\n        } else {\\n            dire = append(dire, i)\\n        }\\n    }\\n\\n    for len(radiant) > 0 && len(dire) > 0 {\\n        // Find the first Radiant senator to ban a Dire senator\\n        if radiant[0] < dire[0] {\\n            radiant = append(radiant, radiant[0]+len(senate))\\n        } else {\\n            dire = append(dire, dire[0]+len(senate))\\n        }\\n\\n        radiant = radiant[1:] // Remove the Radiant senator\\n        dire = dire[1:]       // Remove the Dire senator\\n    }\\n\\n    if len(radiant) > 0 {\\n        return \"Radiant\"\\n    } else {\\n        return \"Dire\"\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568479,
                "title": "python-without-queues",
                "content": "\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n\\n        # The main observation is that we have to remove the\\n        # senators of the remaning bans from the begining\\n        # of the remaning list and so we can also use queue\\'s here\\n\\n        n = len(senate)\\n        bans,arr = [0,0],[]\\n        for  i in range(len(senate)):\\n            arr.append( 0 if senate[i]==\\'R\\' else 1 )\\n        while( len(set(arr)) > 1 ):\\n            temp = []\\n            for c in arr:\\n                if bans[c] >0:bans[c]-=1\\n                else:\\n                    temp.append(c)\\n                    bans[~c]+=1 \\n            arr = []\\n            # The remaning bans.. remove from the front \\n            for c in temp:\\n                if bans[c] >0:bans[c]-=1\\n                else:arr.append(c)\\n        \\n        return \\'Radiant\\' if arr[0] == 0 else \\'Dire\\'\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n\\n        # The main observation is that we have to remove the\\n        # senators of the remaning bans from the begining\\n        # of the remaning list and so we can also use queue\\'s here\\n\\n        n = len(senate)\\n        bans,arr = [0,0],[]\\n        for  i in range(len(senate)):\\n            arr.append( 0 if senate[i]==\\'R\\' else 1 )\\n        while( len(set(arr)) > 1 ):\\n            temp = []\\n            for c in arr:\\n                if bans[c] >0:bans[c]-=1\\n                else:\\n                    temp.append(c)\\n                    bans[~c]+=1 \\n            arr = []\\n            # The remaning bans.. remove from the front \\n            for c in temp:\\n                if bans[c] >0:bans[c]-=1\\n                else:arr.append(c)\\n        \\n        return \\'Radiant\\' if arr[0] == 0 else \\'Dire\\'\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486524,
                "title": "c-in-place-2-pointer-parsing-100-time-0ms-100-space-6-5mb",
                "content": "This problem is a bit tricky, since we might be fall for either focusing on the position or the number of `\\'D\\'`s and `\\'R\\'`s, but both count.\\n\\nWe might also be tempted to create a new string at each iteration, until we get a string all dominated by only one letter; or, why not, to use an alternative DS like a queue to work around that.\\n\\nBut there is no need for any of that if we work in place, each time overwriting the content of `s` with only what is going to be in the next iteration.\\n\\nFor example, for `s == \"DRRDRDRDRDDRDRDR\"` we can see the first `\\'D\\'` going for its best move and immediately cancelling out the following `\\'R\\'`, so that `s` would become `\"D*RDRDRDRDDRDRDR\"` (the `\\'*\\'` would not be really there, but I left it for ease of reading); proceeding all the way, we would get `\"D*R*R*R*R*D*D*D*\"` or, as we would write, just `\"DRRRRDDD\"` (removing the `\\'*\\'`s).\\n\\nWe can continue and now we will get `\"DRRR\"`, the one last loop and finally we remain with `\"RR\"`.\\n\\nThe situation is a bit complicated because we might end a parse through `s` still having some removals left that carry over to the next pass, but erasing the first few characters of the opposite sign should be easy.\\n\\nNow, to wrap all of this together, let\\'s start declaring a few support variables:\\n* `hasChanges` will tell us if we still have to loop and we will initially set to `true` (we want to do at least a loop);\\n* `curr` and `enemy` will be boolean flags to help us keep track of the removals with a DRYer code;\\n* `energy` will store how much energy each letter has (`0` for `\\'D\\'`, `1` for `\\'R\\'`);\\n* `lmt` will tell us how far to go and check;\\n* `w` and `r` will be our writing and reading operations pointers, the former initially set to be the length of `s` (as if we just finished writing it all for the first time).\\n\\nWe will then have our main parsing loop, running `while` `hasChange == true` and:\\n* setting up all the loop variable ready:\\n    * `hasChanges` flagged to `false`;\\n    * `lmt` to go to the previous end of what we wrote (`w`);\\n    * `w` and `r` both reset to `0`;\\n* parsing the current version of `s`, going with `r` through it (ie: up to `lmt` excluded), we will:\\n    * set `curr` to the correct value (as mentioend before: `0` for `\\'D\\'`, `1` for `\\'R\\'`);\\n    * set `enemey` to be the opposite of `curr`;\\n    * now we have two cases - if the `enemy` still has some energy to attack (ie: unused actions to remove `curr`), we will just\\n        * decrease `energy[enemy]` by `1`;\\n        * flag `hasChanges` to `true`, to mark that we have made a removal here;\\n    * otherwise, we will:\\n        * write the current character `s[r]` in `s[w]`;\\n        * advance `w` by `1` position;\\n        * increase `energy[curr]` by `1`;\\n    * in any case, we will advance `r` by `1`.\\n\\nAt the end of the loop, the first character of `s` will tell us who is the winner to `return`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ (if we need to do multiple parses, it can be demonstrated that we will at least halve `s` at each step)\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        // support variables\\n        bool hasChanges = true, curr, enemy;\\n        int energy[2] = {}, lmt, w = s.size(), r;\\n        // parsing s\\n        while (hasChanges) {\\n            hasChanges = false, lmt = w, w = 0, r = 0;\\n            while (r < lmt) {\\n                // curr will be 0 for \\'D\\', 1 for \\'R\\'\\n                curr = s[r] != \\'D\\', enemy = !curr;\\n                // first case: we meet a senator who was erased\\n                if (energy[enemy] > 0) energy[enemy]--, hasChanges = true;\\n                // second case: we meet an active one\\n                else s[w++] = s[r], energy[curr]++;\\n                r++;\\n            }\\n        }\\n        return s[0] == \\'D\\' ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n```\\n\\n# Brag\\n![image.png](https://assets.leetcode.com/users/images/100af339-ac2e-401a-bd0e-c67fc85208f9_1683239067.8830402.png)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        // support variables\\n        bool hasChanges = true, curr, enemy;\\n        int energy[2] = {}, lmt, w = s.size(), r;\\n        // parsing s\\n        while (hasChanges) {\\n            hasChanges = false, lmt = w, w = 0, r = 0;\\n            while (r < lmt) {\\n                // curr will be 0 for \\'D\\', 1 for \\'R\\'\\n                curr = s[r] != \\'D\\', enemy = !curr;\\n                // first case: we meet a senator who was erased\\n                if (energy[enemy] > 0) energy[enemy]--, hasChanges = true;\\n                // second case: we meet an active one\\n                else s[w++] = s[r], energy[curr]++;\\n                r++;\\n            }\\n        }\\n        return s[0] == \\'D\\' ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486295,
                "title": "only-one-queue-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        int radiant = 0, dire = 0, rr = 0, rd = 0; // rr->Removed_radiant, rd->Removed_dire\\n        queue<int> q;\\n        for(char&e: s){\\n            (e == \\'R\\' ? 0 : 1) ? dire++ : radiant++;\\n            q.push(e == \\'R\\' ? 0 : 1);\\n        }\\n        while(radiant && dire){\\n            int e = q.front();\\n            q.pop();\\n            if(!e && rr) rr--,radiant--;\\n            else if(e && rd) rd--,dire--;\\n            else q.push(e),e ? rr++ : rd++;\\n        }\\n        return radiant ? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        int radiant = 0, dire = 0, rr = 0, rd = 0; // rr->Removed_radiant, rd->Removed_dire\\n        queue<int> q;\\n        for(char&e: s){\\n            (e == \\'R\\' ? 0 : 1) ? dire++ : radiant++;\\n            q.push(e == \\'R\\' ? 0 : 1);\\n        }\\n        while(radiant && dire){\\n            int e = q.front();\\n            q.pop();\\n            if(!e && rr) rr--,radiant--;\\n            else if(e && rd) rd--,dire--;\\n            else q.push(e),e ? rr++ : rd++;\\n        }\\n        return radiant ? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485620,
                "title": "easy-optimal-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe best way for a party to win is to ban the next candidate of different party.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First Let\\'s count the number of Radiant candidates and the number of Dire candidates.\\n- Take 2 variables for banning a candidate.\\n- Enter the while loop until only one party remains.\\n- Return the remaining party.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int rad = 0;\\n        int dir = 0;\\n        for(int i = 0; i < senate.length(); i++){\\n            if(senate[i] == \\'R\\'){\\n                rad++;\\n            }else{\\n                dir++;\\n            }\\n        }\\n        int i = 0;\\n        int cd = 0;\\n        int cr = 0;\\n        while(1){\\n            if(rad == 0 || dir == 0){\\n                break;\\n            }\\n            if(senate[i] == \\'R\\'){\\n                if(cr > 0){\\n                    senate[i] = \\'X\\';\\n                    rad--;\\n                    cr--;\\n                }else{\\n                    cd++;\\n                }\\n            }\\n            else if(senate[i] == \\'D\\'){\\n                if(cd > 0){\\n                    senate[i] = \\'X\\';\\n                    cd--;\\n                    dir--;\\n                }else{\\n                    cr++;\\n                }\\n            }\\n            i++;\\n            if(i == senate.length()){\\n                i = 0;\\n            }\\n        }\\n        return ((rad > dir) ? \"Radiant\" : \"Dire\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int rad = 0;\\n        int dir = 0;\\n        for(int i = 0; i < senate.length(); i++){\\n            if(senate[i] == \\'R\\'){\\n                rad++;\\n            }else{\\n                dir++;\\n            }\\n        }\\n        int i = 0;\\n        int cd = 0;\\n        int cr = 0;\\n        while(1){\\n            if(rad == 0 || dir == 0){\\n                break;\\n            }\\n            if(senate[i] == \\'R\\'){\\n                if(cr > 0){\\n                    senate[i] = \\'X\\';\\n                    rad--;\\n                    cr--;\\n                }else{\\n                    cd++;\\n                }\\n            }\\n            else if(senate[i] == \\'D\\'){\\n                if(cd > 0){\\n                    senate[i] = \\'X\\';\\n                    cd--;\\n                    dir--;\\n                }else{\\n                    cr++;\\n                }\\n            }\\n            i++;\\n            if(i == senate.length()){\\n                i = 0;\\n            }\\n        }\\n        return ((rad > dir) ? \"Radiant\" : \"Dire\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485397,
                "title": "single-queue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int cntR = 0, cntD = 0, totalR = 0, totalD = 0;\\n        queue<char> q;\\n        for(char c : senate) {\\n            q.push(c);\\n            if(c == \\'R\\') totalR++;\\n            else totalD++;\\n        }\\n        \\n        while(q.size() > 1) {\\n            char c = q.front(); q.pop();\\n            if(c == \\'R\\') {\\n                if(cntR > 0) {\\n                    cntR--;\\n                    continue;\\n                }\\n                q.push(\\'R\\');\\n                cntD++;\\n            }\\n            else {\\n                if(cntD > 0) {\\n                    cntD--;\\n                    continue;\\n                }\\n                q.push(\\'D\\');\\n                cntR++;\\n            }\\n            if(cntR > totalD) return \"Dire\";\\n            if(cntD > totalR) return \"Radiant\";\\n        }\\n        return q.front() == \\'R\\' ? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int cntR = 0, cntD = 0, totalR = 0, totalD = 0;\\n        queue<char> q;\\n        for(char c : senate) {\\n            q.push(c);\\n            if(c == \\'R\\') totalR++;\\n            else totalD++;\\n        }\\n        \\n        while(q.size() > 1) {\\n            char c = q.front(); q.pop();\\n            if(c == \\'R\\') {\\n                if(cntR > 0) {\\n                    cntR--;\\n                    continue;\\n                }\\n                q.push(\\'R\\');\\n                cntD++;\\n            }\\n            else {\\n                if(cntD > 0) {\\n                    cntD--;\\n                    continue;\\n                }\\n                q.push(\\'D\\');\\n                cntR++;\\n            }\\n            if(cntR > totalD) return \"Dire\";\\n            if(cntD > totalR) return \"Radiant\";\\n        }\\n        return q.front() == \\'R\\' ? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485321,
                "title": "using-two-pointer-with-explanation-easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Intitution behind this approach is that if their is Dire and if their is Radiant present it will remove the Radiant and vice Versa.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake two Pointer and a temporary string \\nInitiliaze both radiant and dire at zero\\ntake a for loop\\ncheck the condition if the senate is R and dire value is zero then add the string to temporary string also increment the radiant value  and if dire value is not zero then only decrement the value of dire\\n\\nand if the senate is D and radiant value is zero then add the string to temporary string and increment the value of dire and if radiant is not zero then only decrement the value of radiant\\n\\nin last if the temporary string length is not equal to senate length then swap the strings and continue the process and if both are equal then return as shown.\\n  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n  string temp;\\n  int dire=0,radiant=0;\\n  while(1)\\n  {\\n      for(int i=0;i<senate.size();i++)\\n      {\\n          if(senate[i]==\\'R\\')\\n          {\\n              if(dire==0)\\n              {\\n                  temp.push_back(\\'R\\');\\n                  radiant++;\\n\\n              }\\n              else\\n              dire--;\\n          }\\n          else\\n          {\\n              if(radiant==0)\\n              {\\n                  temp.push_back(\\'D\\');\\n                  dire++;\\n              }\\n              else\\n              radiant--;\\n          }\\n      }\\n      if(temp.length()==senate.length())\\n      {\\n          if(dire!=0)\\n          return \"Dire\";\\n          else\\n          return \"Radiant\";\\n      }\\n      else\\n      {\\n          senate=temp;\\n          temp.clear();\\n      }\\n  }\\n  return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n  string temp;\\n  int dire=0,radiant=0;\\n  while(1)\\n  {\\n      for(int i=0;i<senate.size();i++)\\n      {\\n          if(senate[i]==\\'R\\')\\n          {\\n              if(dire==0)\\n              {\\n                  temp.push_back(\\'R\\');\\n                  radiant++;\\n\\n              }\\n              else\\n              dire--;\\n          }\\n          else\\n          {\\n              if(radiant==0)\\n              {\\n                  temp.push_back(\\'D\\');\\n                  dire++;\\n              }\\n              else\\n              radiant--;\\n          }\\n      }\\n      if(temp.length()==senate.length())\\n      {\\n          if(dire!=0)\\n          return \"Dire\";\\n          else\\n          return \"Radiant\";\\n      }\\n      else\\n      {\\n          senate=temp;\\n          temp.clear();\\n      }\\n  }\\n  return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484908,
                "title": "python-solution-using-list-and-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question seems to be solvable usign hashing methodes.....\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        #Made the given string senate to list so manipulation is possible\\n        senate=list(senate)\\n\\n        #To count the number of D\\'s and R\\'s in senate\\n        R=0\\n        D=0\\n        for i in senate:\\n            if(i==\\'R\\'):\\n                R+=1\\n            else:D+=1\\n    \\n        #using rc and dc to find the number of d\\'s and r\\'s which have lost their vote power entirely\\n        rc=dc=0    \\n        #while loop to iterate until all D\\'s have lost or R\\'s have lost\\n        while(len(senate)>0 and R!=0 and D!=0):\\n            popped=0\\n            for i in range(len(senate)):\\n                if(senate[i-popped]==\\'D\\'):\\n                    if(dc==0):\\n                        rc+=1\\n                    else:\\n                        dc-=1\\n                        senate.pop(i-popped)\\n                        popped+=1\\n                        D-=1\\n                else:\\n                    if(rc==0):\\n                        dc+=1\\n                    else:\\n                        rc-=1\\n                        senate.pop(i-popped)\\n                        popped+=1                \\n                        R-=1\\n        if(D>R):return \"Dire\"\\n        else:return \"Radiant\"  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        #Made the given string senate to list so manipulation is possible\\n        senate=list(senate)\\n\\n        #To count the number of D\\'s and R\\'s in senate\\n        R=0\\n        D=0\\n        for i in senate:\\n            if(i==\\'R\\'):\\n                R+=1\\n            else:D+=1\\n    \\n        #using rc and dc to find the number of d\\'s and r\\'s which have lost their vote power entirely\\n        rc=dc=0    \\n        #while loop to iterate until all D\\'s have lost or R\\'s have lost\\n        while(len(senate)>0 and R!=0 and D!=0):\\n            popped=0\\n            for i in range(len(senate)):\\n                if(senate[i-popped]==\\'D\\'):\\n                    if(dc==0):\\n                        rc+=1\\n                    else:\\n                        dc-=1\\n                        senate.pop(i-popped)\\n                        popped+=1\\n                        D-=1\\n                else:\\n                    if(rc==0):\\n                        dc+=1\\n                    else:\\n                        rc-=1\\n                        senate.pop(i-popped)\\n                        popped+=1                \\n                        R-=1\\n        if(D>R):return \"Dire\"\\n        else:return \"Radiant\"  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483619,
                "title": "dota2-senate-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved by simulating the process of banning senators until there is only one party left. We can use two queues to store the indices of the senators from each party. In each round, we select one senator from each queue and remove them. If a senator from the Radiant party (represented by \"R\") is selected, we append the index of the next Radiant senator to the end of the Radiant queue. Otherwise, we append the index of the next Dire senator to the end of the Dire queue. We continue this process until one of the queues becomes empty, which means that the other party has won the election.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create two queues, `qR` for the indices of the Radiant party senators, and `qD` for the\\nindices of the Dire party senators.\\n2. Iterate through the `senate` string, and add the indices of the senators to their\\nrespective party queues.\\n3. While both queues are not empty, remove the front senator from each queue.\\n4. If the removed senator is from the Radiant party, add the index of the next Radiant\\nsenator to the end of the Radiant queue.\\n5. Otherwise, add the index of the next Dire senator to the end of the Dire queue.\\n6. Repeat steps 3-5 until one of the queues becomes empty.\\n7. Return the name of the party with senators remaining in the queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n), where n is the length of the input senate string. This is because we iterate through the string once to fill the party queues, and then we remove and add senators to the queues until one of them becomes empty. In the worst-case scenario, we may have to perform n iterations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is O(n), where n is the length of the input senate string. This is because we create two queues to store the indices of the senators, which can each contain up to n elements in the worst case.\\n# Code\\n```\\nimport java.util.Queue;\\nimport java.util.LinkedList;\\n\\nclass Solution {\\n  public String predictPartyVictory(String senate) {\\n    int n = senate.length();\\n    Queue<Integer> qR = new LinkedList<>();\\n    Queue<Integer> qD = new LinkedList<>();\\n\\n    for (int i = 0; i < n; ++i) {\\n      if (senate.charAt(i) == \\'R\\') {\\n        qR.add(i);\\n      } else {\\n        qD.add(i);\\n      }\\n    }\\n\\n    while (!qR.isEmpty() && !qD.isEmpty()) {\\n      int indexR = qR.remove();\\n      int indexD = qD.remove();\\n      if (indexR < indexD) {\\n        qR.add(indexR + n);\\n      } else {\\n        qD.add(indexD + n);\\n      }\\n    }\\n\\n    return qR.isEmpty() ? \"Dire\" : \"Radiant\";\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Queue"
                ],
                "code": "```\\nimport java.util.Queue;\\nimport java.util.LinkedList;\\n\\nclass Solution {\\n  public String predictPartyVictory(String senate) {\\n    int n = senate.length();\\n    Queue<Integer> qR = new LinkedList<>();\\n    Queue<Integer> qD = new LinkedList<>();\\n\\n    for (int i = 0; i < n; ++i) {\\n      if (senate.charAt(i) == \\'R\\') {\\n        qR.add(i);\\n      } else {\\n        qD.add(i);\\n      }\\n    }\\n\\n    while (!qR.isEmpty() && !qD.isEmpty()) {\\n      int indexR = qR.remove();\\n      int indexD = qD.remove();\\n      if (indexR < indexD) {\\n        qR.add(indexR + n);\\n      } else {\\n        qD.add(indexD + n);\\n      }\\n    }\\n\\n    return qR.isEmpty() ? \"Dire\" : \"Radiant\";\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483547,
                "title": "c-solution-using-the-string-as-a-queue",
                "content": "A brute force solution would be to cycle around the string replacing banned candidates with a \\'0\\' until there are no remaining members of the opposing party left (end == start).\\n\\nThe optimization used here is to keep a count of remaining party members and banned party members. A candidate is removed from the front of the string (queue) and if banned, then the party count and banned count are both decremented. Otherwise the opposing party\\'s banned count is incremented and the candidate is placed at the rear of the queue.\\n\\nWhen one of the parties has no remaining members, the other party is the winner!\\n\\nThis optimization works because unlike the brute force approach, the size of the queue decreases with each iteration.\\n```\\nchar * predictPartyVictory(char * senate){\\n    int dCount=0, rCount=0, dBan = 0, rBan = 0;\\n    int l , head = 0, tail, i;\\n    char c;\\n    for (i = 0; senate[i] != \\'\\\\0\\'; ++i) {\\n        if (senate[i] == \\'D\\') {\\n            ++dCount;\\n        } else {\\n            ++rCount;\\n        }\\n    }\\n    tail = i;\\n    l = i+1;\\n    while (dCount > 0 && rCount > 0) {\\n        c = senate[head];\\n        head = (head + 1) % l;\\n        if (c == \\'D\\') {\\n            if (dBan > 0) {\\n                --dBan;\\n                --dCount;\\n            } else {\\n                ++rBan;\\n                senate[tail] = \\'D\\';\\n                tail = (tail + 1) % l;\\n            }\\n        } else { /* c == \\'R\\' */\\n            if (rBan > 0) {\\n                --rBan;\\n                --rCount;\\n            } else {\\n                ++dBan;\\n                senate[tail] = \\'R\\';\\n                tail = (tail + 1) % l;\\n            }\\n        }\\n    }\\n    return dCount > 0 ? \"Dire\" : \"Radiant\";\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * predictPartyVictory(char * senate){\\n    int dCount=0, rCount=0, dBan = 0, rBan = 0;\\n    int l , head = 0, tail, i;\\n    char c;\\n    for (i = 0; senate[i] != \\'\\\\0\\'; ++i) {\\n        if (senate[i] == \\'D\\') {\\n            ++dCount;\\n        } else {\\n            ++rCount;\\n        }\\n    }\\n    tail = i;\\n    l = i+1;\\n    while (dCount > 0 && rCount > 0) {\\n        c = senate[head];\\n        head = (head + 1) % l;\\n        if (c == \\'D\\') {\\n            if (dBan > 0) {\\n                --dBan;\\n                --dCount;\\n            } else {\\n                ++rBan;\\n                senate[tail] = \\'D\\';\\n                tail = (tail + 1) % l;\\n            }\\n        } else { /* c == \\'R\\' */\\n            if (rBan > 0) {\\n                --rBan;\\n                --rCount;\\n            } else {\\n                ++dBan;\\n                senate[tail] = \\'R\\';\\n                tail = (tail + 1) % l;\\n            }\\n        }\\n    }\\n    return dCount > 0 ? \"Dire\" : \"Radiant\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483483,
                "title": "kotlin-o-n-queue-explained",
                "content": "# Approach\\nThe detailed approach is described in the comments. The general logic is to simply simulate the voting with the optimal strategy for each party, which is always to ban the next active voter from the opposing side. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$ for creating the queues + $$O(n)$$ for voting (at each iteration one voter is out) = $$O(2n)$$\\n\\n- Space complexity: $$O(n)$$ as we copy all the indexes of the string elements to the queues\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun predictPartyVictory(senate: String): String {\\n        val rQ = LinkedList<Int>()\\n        val dQ = LinkedList<Int>()\\n\\n        for (i in 0 until senate.length) {\\n            (if (senate[i] == \\'R\\') rQ else dQ).addLast(i)\\n        }\\n\\n        //The voting goes on until voters from one party are all gone\\n        while (!dQ.isEmpty() && !rQ.isEmpty()) {\\n            //Next voter is the one with the lowest index at the beginning\\n            //of both queues (retaining the initial order of voters)\\n            //The strategy for each voter is to ban the next voter of the \\n            //opposing faction (the one who is next to vote)\\n            //After having voted, the current voter (who still retains the\\n            //right to vote) is moved to the end of its party queue and\\n            //their index is recalculated\\n            val voterQ = if (dQ.getFirst() < rQ.getFirst()) dQ else rQ\\n            voterQ.addLast(maxOf(dQ.getLast(), rQ.getLast()) + 1)\\n            //Finally removing the banned voter of the opposing faction\\n            //and the now-obsolete instance of the current voter\\n            dQ.removeFirst()\\n            rQ.removeFirst()\\n        }\\n\\n        //The party with the remaining active voters is the winner\\n        return if (rQ.isEmpty()) \"Dire\" else \"Radiant\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    fun predictPartyVictory(senate: String): String {\\n        val rQ = LinkedList<Int>()\\n        val dQ = LinkedList<Int>()\\n\\n        for (i in 0 until senate.length) {\\n            (if (senate[i] == \\'R\\') rQ else dQ).addLast(i)\\n        }\\n\\n        //The voting goes on until voters from one party are all gone\\n        while (!dQ.isEmpty() && !rQ.isEmpty()) {\\n            //Next voter is the one with the lowest index at the beginning\\n            //of both queues (retaining the initial order of voters)\\n            //The strategy for each voter is to ban the next voter of the \\n            //opposing faction (the one who is next to vote)\\n            //After having voted, the current voter (who still retains the\\n            //right to vote) is moved to the end of its party queue and\\n            //their index is recalculated\\n            val voterQ = if (dQ.getFirst() < rQ.getFirst()) dQ else rQ\\n            voterQ.addLast(maxOf(dQ.getLast(), rQ.getLast()) + 1)\\n            //Finally removing the banned voter of the opposing faction\\n            //and the now-obsolete instance of the current voter\\n            dQ.removeFirst()\\n            rQ.removeFirst()\\n        }\\n\\n        //The party with the remaining active voters is the winner\\n        return if (rQ.isEmpty()) \"Dire\" else \"Radiant\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483412,
                "title": "swift-fastest-solution-8-ms",
                "content": "**Simulate Rounds (accepted answer)**\\n```\\nclass Solution {\\n    func predictPartyVictory(_ senate: String) -> String {\\n        var senate = senate.map { $0 == \"R\" ? 1 : -1 }\\n        var spread = 0  // spread is both magnitude and party (- = Dire, + = Radiant)\\n        while true {\\n            var seen = 0\\n            senate = senate.reduce(into: [Int]()) { senate, party in\\n                if party * spread >= 0 {\\n                    senate.append(party)\\n                    seen |= party > 0 ? 1 : 2\\n                }\\n                spread += party\\n            }\\n            guard seen == 3 else { return [\"Radiant\",\"Dire\"][seen-1] }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func predictPartyVictory(_ senate: String) -> String {\\n        var senate = senate.map { $0 == \"R\" ? 1 : -1 }\\n        var spread = 0  // spread is both magnitude and party (- = Dire, + = Radiant)\\n        while true {\\n            var seen = 0\\n            senate = senate.reduce(into: [Int]()) { senate, party in\\n                if party * spread >= 0 {\\n                    senate.append(party)\\n                    seen |= party > 0 ? 1 : 2\\n                }\\n                spread += party\\n            }\\n            guard seen == 3 else { return [\"Radiant\",\"Dire\"][seen-1] }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483401,
                "title": "python-simple-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate):\\n        n, R, D = len(senate), deque(), deque()\\n\\n        for i,c in enumerate(senate):\\n            if c == \"R\":\\n                R.append(i)\\n            else:\\n                D.append(i)\\n\\n        while R and D:\\n            r, d = R.popleft(), D.popleft()\\n\\n            if r < d:\\n                R.append(r+n)\\n            else:\\n                D.append(d+n)\\n\\n        return \"Radiant\" if R else \"Dire\"\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate):\\n        n, R, D = len(senate), deque(), deque()\\n\\n        for i,c in enumerate(senate):\\n            if c == \"R\":\\n                R.append(i)\\n            else:\\n                D.append(i)\\n\\n        while R and D:\\n            r, d = R.popleft(), D.popleft()\\n\\n            if r < d:\\n                R.append(r+n)\\n            else:\\n                D.append(d+n)\\n\\n        return \"Radiant\" if R else \"Dire\"\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483336,
                "title": "easy-c-marking-senate-and-reverse-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int r=0,d=0,n=senate.length();\\n        for (int i=0;i<n;i++){\\n            if(senate[i]==\\'R\\') r++;\\n            else d++;\\n        }\\n        int rc=0,dc=0,i=0;\\n        while (r>0 && d>0) {\\n            if (senate[i] == \\'R\\' && rc > 0) { \\n                rc--; \\n                senate[i]=\\'M\\'; \\n                r--;\\n            }\\n            else if (senate[i] == \\'D\\' && dc > 0) { \\n                dc--; \\n                senate[i]=\\'M\\'; \\n                d--;\\n            }\\n            else if(senate[i] == \\'R\\') dc++;\\n            else if(senate[i] == \\'D\\') rc++;\\n            i=(i+1)%n;\\n        }\\n        return r>0?\"Radiant\":\"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int r=0,d=0,n=senate.length();\\n        for (int i=0;i<n;i++){\\n            if(senate[i]==\\'R\\') r++;\\n            else d++;\\n        }\\n        int rc=0,dc=0,i=0;\\n        while (r>0 && d>0) {\\n            if (senate[i] == \\'R\\' && rc > 0) { \\n                rc--; \\n                senate[i]=\\'M\\'; \\n                r--;\\n            }\\n            else if (senate[i] == \\'D\\' && dc > 0) { \\n                dc--; \\n                senate[i]=\\'M\\'; \\n                d--;\\n            }\\n            else if(senate[i] == \\'R\\') dc++;\\n            else if(senate[i] == \\'D\\') rc++;\\n            i=(i+1)%n;\\n        }\\n        return r>0?\"Radiant\":\"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843258,
                "title": "queue-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        queue<int> r;\\n        queue<int> d;\\n        for(int i = 0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'R\\') r.push(i);\\n            else d.push(i);\\n        }\\n        while(!r.empty() && !d.empty())\\n        {\\n            int x = r.front();\\n            r.pop();\\n            int y = d.front();\\n            d.pop();\\n            if(x<y)\\n            {\\n                r.push(1e4 + x);\\n            }\\n            else{\\n                d.push(1e4 + y);\\n            }\\n        }\\n        return ((d.empty()) ? ( \"Radiant\") : ( \"Dire\"));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        queue<int> r;\\n        queue<int> d;\\n        for(int i = 0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'R\\') r.push(i);\\n            else d.push(i);\\n        }\\n        while(!r.empty() && !d.empty())\\n        {\\n            int x = r.front();\\n            r.pop();\\n            int y = d.front();\\n            d.pop();\\n            if(x<y)\\n            {\\n                r.push(1e4 + x);\\n            }\\n            else{\\n                d.push(1e4 + y);\\n            }\\n        }\\n        return ((d.empty()) ? ( \"Radiant\") : ( \"Dire\"));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792412,
                "title": "c-3ms-99-17-simple-easy-small-without-queue",
                "content": "Runtime: 3 ms, faster than 99.17% of C++ online submissions for Dota2 Senate.\\nMemory Usage: 7.1 MB, less than 81.67% of C++ online submissions for Dota2 Senate.\\n```\\nclass Solution {\\npublic:\\n  string predictPartyVictory(string s) {\\n    char p;\\n    int c = 0;\\n      \\n    while(true){\\n      string t = \"\"; \\n      \\n      for(auto ch: s)\\n        if(c == 0) p = ch, c++, t.push_back(ch);\\n        else if(ch == p) c++, t.push_back(ch);\\n             else c--;\\n     \\n      s.clear();\\n      int i = 0;\\n      while(i != t.size() && c)\\n        if(t[i++] == p) s.push_back(p);\\n        else c--;\\n      \\n      if(c > 0) return p == \\'R\\' ? \"Radiant\" : \"Dire\";\\n      s += t.substr(i, t.size());\\n    }   \\n    \\n    return \"\";\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string predictPartyVictory(string s) {\\n    char p;\\n    int c = 0;\\n      \\n    while(true){\\n      string t = \"\"; \\n      \\n      for(auto ch: s)\\n        if(c == 0) p = ch, c++, t.push_back(ch);\\n        else if(ch == p) c++, t.push_back(ch);\\n             else c--;\\n     \\n      s.clear();\\n      int i = 0;\\n      while(i != t.size() && c)\\n        if(t[i++] == p) s.push_back(p);\\n        else c--;\\n      \\n      if(c > 0) return p == \\'R\\' ? \"Radiant\" : \"Dire\";\\n      s += t.substr(i, t.size());\\n    }   \\n    \\n    return \"\";\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423894,
                "title": "simplest-solution-using-1-vector",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string predictPartyVictory(string senate)\\n    {\\n        int radiantToDie = 0;\\n        int direToDie = 0;\\n        int radiantAlive = 0;\\n        int direAlive = 0;\\n        vector<char> mVector;\\n\\n        for (int i = 0; i < senate.size(); i++)\\n        {\\n            if (senate.at(i) == \\'R\\')\\n                radiantAlive++;\\n            else\\n                direAlive++;\\n\\n            mVector.push_back(senate.at(i));\\n        }\\n\\n        int index = 0;\\n\\n        while (radiantAlive > 0 && direAlive > 0)\\n        {\\n            if (index > senate.size() - 1) // start from first\\n                index = 0;\\n\\n            if (mVector.at(index) == \\'X\\') // this is out of game\\n            {\\n                index++;\\n                continue;\\n            }\\n\\n            if (mVector.at(index) == \\'R\\')\\n            {\\n                if (radiantToDie > 0)\\n                {\\n                    mVector.at(index) = \\'X\\'; // this radiant is dead\\n                    radiantAlive--;\\n                    radiantToDie--;\\n                }\\n                else\\n                {\\n                    direToDie++; // mark target for upcoming nearest dire\\n                }\\n            }\\n            else // current is dire\\n            {\\n                if (direToDie > 0)\\n                {\\n                    mVector.at(index) = \\'X\\'; // this dire is dead\\n                    direAlive--;\\n                    direToDie--;\\n                }\\n                else\\n                {\\n                    radiantToDie++; // mark target for upcoming nearest radiant\\n                }\\n            }\\n            index++;\\n        }\\n\\n        if (radiantAlive > 0)\\n            return \"Radiant\";\\n        else\\n            return \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string predictPartyVictory(string senate)\\n    {\\n        int radiantToDie = 0;\\n        int direToDie = 0;\\n        int radiantAlive = 0;\\n        int direAlive = 0;\\n        vector<char> mVector;\\n\\n        for (int i = 0; i < senate.size(); i++)\\n        {\\n            if (senate.at(i) == \\'R\\')\\n                radiantAlive++;\\n            else\\n                direAlive++;\\n\\n            mVector.push_back(senate.at(i));\\n        }\\n\\n        int index = 0;\\n\\n        while (radiantAlive > 0 && direAlive > 0)\\n        {\\n            if (index > senate.size() - 1) // start from first\\n                index = 0;\\n\\n            if (mVector.at(index) == \\'X\\') // this is out of game\\n            {\\n                index++;\\n                continue;\\n            }\\n\\n            if (mVector.at(index) == \\'R\\')\\n            {\\n                if (radiantToDie > 0)\\n                {\\n                    mVector.at(index) = \\'X\\'; // this radiant is dead\\n                    radiantAlive--;\\n                    radiantToDie--;\\n                }\\n                else\\n                {\\n                    direToDie++; // mark target for upcoming nearest dire\\n                }\\n            }\\n            else // current is dire\\n            {\\n                if (direToDie > 0)\\n                {\\n                    mVector.at(index) = \\'X\\'; // this dire is dead\\n                    direAlive--;\\n                    direToDie--;\\n                }\\n                else\\n                {\\n                    radiantToDie++; // mark target for upcoming nearest radiant\\n                }\\n            }\\n            index++;\\n        }\\n\\n        if (radiantAlive > 0)\\n            return \"Radiant\";\\n        else\\n            return \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519223,
                "title": "go-100-ban-pick-solution",
                "content": "```go\\nfunc predictPartyVictory(senate string) string {\\n\\tradiantBan, radiantPick, direBan, direPick, round := 0, -1, 0, -1, []byte(senate)\\n\\tfor radiantPick*direPick != 0 {\\n\\t\\tradiantPick, direPick = 0, 0\\n\\t\\tnextRound := []byte{}\\n\\t\\tfor _, v := range round {\\n\\t\\t\\tif v == \\'R\\' {\\n\\t\\t\\t\\tif direBan > 0 {\\n\\t\\t\\t\\t\\tdireBan--\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnextRound = append(nextRound, \\'R\\')\\n\\t\\t\\t\\t\\tradiantBan++\\n\\t\\t\\t\\t\\tradiantPick++\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif radiantBan > 0 {\\n\\t\\t\\t\\t\\tradiantBan--\\n\\t\\t\\t\\t} else {\\n                    nextRound = append(nextRound, \\'D\\')\\n\\t\\t\\t\\t\\tdireBan++\\n\\t\\t\\t\\t\\tdirePick++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tround = nextRound\\n\\t}\\n\\n\\tif radiantPick > 0 {\\n\\t\\treturn \"Radiant\"\\n\\t}\\n\\tif direPick > 0 {\\n\\t\\treturn \"Dire\"\\n\\t}\\n\\treturn \"\"\\n}\\n```\\n\\n```python\\n# example\\nRound / RadiantBanned / DireBanned\\nDRRDRDRDRDDRDRDR / 0 / 0\\nDRRRRDDD / 0 / 0\\nDRRR / 0 / 0\\nDRR / 2 / 0\\nRR / 3 /  0\\n# RadiantBanned larger than DireCount is OK, no effect on results.\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc predictPartyVictory(senate string) string {\\n\\tradiantBan, radiantPick, direBan, direPick, round := 0, -1, 0, -1, []byte(senate)\\n\\tfor radiantPick*direPick != 0 {\\n\\t\\tradiantPick, direPick = 0, 0\\n\\t\\tnextRound := []byte{}\\n\\t\\tfor _, v := range round {\\n\\t\\t\\tif v == \\'R\\' {\\n\\t\\t\\t\\tif direBan > 0 {\\n\\t\\t\\t\\t\\tdireBan--\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnextRound = append(nextRound, \\'R\\')\\n\\t\\t\\t\\t\\tradiantBan++\\n\\t\\t\\t\\t\\tradiantPick++\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif radiantBan > 0 {\\n\\t\\t\\t\\t\\tradiantBan--\\n\\t\\t\\t\\t} else {\\n                    nextRound = append(nextRound, \\'D\\')\\n\\t\\t\\t\\t\\tdireBan++\\n\\t\\t\\t\\t\\tdirePick++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tround = nextRound\\n\\t}\\n\\n\\tif radiantPick > 0 {\\n\\t\\treturn \"Radiant\"\\n\\t}\\n\\tif direPick > 0 {\\n\\t\\treturn \"Dire\"\\n\\t}\\n\\treturn \"\"\\n}\\n```\n```python\\n# example\\nRound / RadiantBanned / DireBanned\\nDRRDRDRDRDDRDRDR / 0 / 0\\nDRRRRDDD / 0 / 0\\nDRRR / 0 / 0\\nDRR / 2 / 0\\nRR / 3 /  0\\n# RadiantBanned larger than DireCount is OK, no effect on results.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475115,
                "title": "cpp-beats-100-with-no-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    // tip \\u5F53\\u4E00\\u8FB9\\u662F\\u53E6\\u4E00\\u8FB9\\u7684\\u4E24\\u500D\\u4EE5\\u4E0A\\u65F6\\uFF0C\\u5FC5\\u80DC\\u3002\\n    string predictPartyVictory(string senate) {\\n        int r=0;int d=0;\\n        for(auto x:senate){\\n            if(x==\\'R\\') r++;\\n            else d++;\\n        }\\n        int tmp=0;\\n        int length = r+d;\\n        char f;\\n        while(r>0 && d>0){\\n            for(int i=0;i<length && r>0 && d>0;i++){\\n                if(senate[i] == \\'0\\')\\n                    continue;\\n                if(tmp==0)\\n                    f = senate[i];\\n                if(senate[i] == f)\\n                    tmp ++;\\n                else{\\n                    // banned\\n                    tmp--;\\n                    if(f == \\'R\\')  \\n                        d--;\\n                    else r--;\\n                    senate[i] = \\'0\\';\\n                }\\n            }\\n        }\\n        return r>0?\"Radiant\":\"Dire\";\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    // tip \\u5F53\\u4E00\\u8FB9\\u662F\\u53E6\\u4E00\\u8FB9\\u7684\\u4E24\\u500D\\u4EE5\\u4E0A\\u65F6\\uFF0C\\u5FC5\\u80DC\\u3002\\n    string predictPartyVictory(string senate) {\\n        int r=0;int d=0;\\n        for(auto x:senate){\\n            if(x==\\'R\\') r++;\\n            else d++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 345899,
                "title": "javascript-beats-97-simple-solution",
                "content": "```\\n\\n```var predictPartyVictory = function(senate) {\\n    var map={}, m=senate.length, q1=[], q2=[];\\n    for(var i=0; i<m; i++){\\n        if(senate.charAt(i) == \\'R\\') q1.push(i)\\n        else{\\n            q2.push(i);\\n        }\\n    }\\n    while(q1.length>0 &&q2.length>0){\\n        let v1=q1.shift(), v2=q2.shift();\\n        if(v1<v2) q1.push(v1+m)\\n        else{\\n            q2.push(v2+m);\\n        }\\n    }\\n    return q1.length> q2.length? \"Radiant\": \"Dire\"\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 105882,
                "title": "java-easy-to-understand-with-explanation-18ms",
                "content": "To process the senator i, we need to know if  he/she/it has already been banned or not.\\n\\nIf is not banned, then he/she/it can ban an senator in another group, best choice is to ban the first one who hasn't voted in this round, otherwise one have already voted this round. \\n\\nBut it's not easy (is expensive) to find out which senator in the other group should be banned at this point, so we just use counter nToDelete to remember how many senator we need to ban for the other group. \\n\\nAnd when we process a senator in another group later (either in this round or next round), we can check this value, if it's not '0', we know it should be banned and can not vote anymore.\\n\\n```\\n    public String predictPartyVictory(String senate) {\\n        if (senate == null || senate.length() == 0) return null;\\n        int[] nLeft = new int[2]; // number of R, D groups still have right to vote \\n        int[] nToDelete = new int[2]; // number of R, D groups have been banned but not yet removed\\n        Character res = null;\\n        for(int i =0 ; i < senate.length(); i++){\\n            if(senate.charAt(i) == 'R') nLeft[0]++;\\n            else nLeft[1]++;\\n        }        \\n        while (res == null) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i =0; i<senate.length(); i++){\\n                char ch = senate.charAt(i);\\n                int idx = ch == 'R' ? 0 : 1;\\n                if ( (nLeft[0] == 0 || nLeft[1] ==0) && nToDelete[idx] ==0) { //Have winner, make sure current senator is not banned, so he can announce\\n                    res = ch;\\n                    break;\\n                }\\n                if (nToDelete[idx] != 0) nToDelete[idx]--; //Current senator need to be banned, Do not add to sb for next round\\n                else {\\n                    nLeft[1-idx]--; //ban one senator in another group\\n                    nToDelete[1-idx]++;\\n                    sb.append(ch); \\n                }\\n            }\\n            senate = sb.toString(); // Senators left to process in the next round\\n        }\\n        return res == 'R' ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public String predictPartyVictory(String senate) {\\n        if (senate == null || senate.length() == 0) return null;\\n        int[] nLeft = new int[2]; // number of R, D groups still have right to vote \\n        int[] nToDelete = new int[2]; // number of R, D groups have been banned but not yet removed\\n        Character res = null;\\n        for(int i =0 ; i < senate.length(); i++){\\n            if(senate.charAt(i) == 'R') nLeft[0]++;\\n            else nLeft[1]++;\\n        }        \\n        while (res == null) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i =0; i<senate.length(); i++){\\n                char ch = senate.charAt(i);\\n                int idx = ch == 'R' ? 0 : 1;\\n                if ( (nLeft[0] == 0 || nLeft[1] ==0) && nToDelete[idx] ==0) { //Have winner, make sure current senator is not banned, so he can announce\\n                    res = ch;\\n                    break;\\n                }\\n                if (nToDelete[idx] != 0) nToDelete[idx]--; //Current senator need to be banned, Do not add to sb for next round\\n                else {\\n                    nLeft[1-idx]--; //ban one senator in another group\\n                    nToDelete[1-idx]++;\\n                    sb.append(ch); \\n                }\\n            }\\n            senate = sb.toString(); // Senators left to process in the next round\\n        }\\n        return res == 'R' ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 105861,
                "title": "straightforward-and-simple-python",
                "content": "Record the position of two parties, each party will ban its upcoming opponent.\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def predictPartyVictory(self, senate):\\n        \"\"\"\\n        :type senate: str\\n        :rtype: str\\n        \"\"\"\\n        n = len(senate)\\n        pos = collections.defaultdict(deque)\\n        for i in range(n):\\n        \\tpos[senate[i]].append(i)\\n\\n        while pos['R'] and pos['D']:\\n        \\tif pos['R'][0] < pos['D'][0]:\\n        \\t\\tpos['R'].append(pos['R'].popleft() + n)\\n        \\t\\tpos['D'].popleft()\\n        \\telse:\\n        \\t\\tpos['D'].append(pos['D'].popleft() + n)\\n        \\t\\tpos['R'].popleft()\\n\\n        return 'Radiant' if pos['R'] else 'Dire'\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def predictPartyVictory(self, senate):\\n        \"\"\"\\n        :type senate: str\\n        :rtype: str\\n        \"\"\"\\n        n = len(senate)\\n        pos = collections.defaultdict(deque)\\n        for i in range(n):\\n        \\tpos[senate[i]].append(i)\\n\\n        while pos['R'] and pos['D']:\\n        \\tif pos['R'][0] < pos['D'][0]:\\n        \\t\\tpos['R'].append(pos['R'].popleft() + n)\\n        \\t\\tpos['D'].popleft()\\n        \\telse:\\n        \\t\\tpos['D'].append(pos['D'].popleft() + n)\\n        \\t\\tpos['R'].popleft()\\n\\n        return 'Radiant' if pos['R'] else 'Dire'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970412,
                "title": "c-very-easy-solution",
                "content": "\\n# Approach\\n\\n1. Create a map \"H\" to keep track of the number of rights for each party (\\'R\\' and \\'D\\').\\n\\n2. Enter an infinite loop to simulate rounds until a victory condition is met.\\n\\n3. Loop through each senator in the \"senate\" string:\\n   - If a senator\\'s rights are already banned (\\'*\\'), skip them.\\n   - If a senator\\'s rights are not banned:\\n     - If their party\\'s rights are available in the \"H\" map, decrease the count of those rights and mark the senator\\'s rights as banned (\\'*\\').\\n     - If their party\\'s rights are not available, increase the count of the opposing party\\'s rights in the \"H\" map.\\n\\n4. After each round, calculate the remaining counts of \\'R\\' and \\'D\\' senators who still have rights.\\n\\n5. If either \\'R\\' or \\'D\\' senators have been completely eliminated (count is zero), exit the loop.\\n\\n6. Determine the party that emerges victorious based on the counts of remaining senators. If \\'R\\' senators are absent, \\'Dire\\' wins; if \\'D\\' senators are absent, \\'Radiant\\' wins.\\n\\n**Code Complexity:**\\n\\n- Time Complexity: The code iterates through each senator in the \"senate\" string in each round. Since each senator is processed once, and there are at most n senators, the time complexity is O(n).\\n- Space Complexity: The space complexity is O(1) because the \"H\" map size remains constant, regardless of the input size.\\n\\nIn this succinct solution, the code dynamically captures the strategic interplay between Radiant and Dire senators, ensuring that the victory condition is met based on the number of remaining rights. By cleverly managing the rights through banning and tracking the counts, the code efficiently predicts the party that will declare victory in the Dota2 Senate conundrum.\\n\\n# Complexity\\n- **Time Complexity:**\\n The code iterates through each senator in the \"senate\" string in each round. Since each senator is processed once, and there are at most n senators, the time complexity is O(n).\\n- **Space Complexity:** The space complexity is O(1) because the \"H\" map size remains constant, regardless of the input size.\\n\\nIn this succinct solution, the code dynamically captures the strategic interplay between Radiant and Dire senators, ensuring that the victory condition is met based on the number of remaining rights. By cleverly managing the rights through banning and tracking the counts, the code efficiently predicts the party that will declare victory in the Dota2 Senate conundrum.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string st) {\\n          \\n          map<char,int>H;\\n\\n          while(true){\\n            \\n            for(auto &u:st)\\n            {\\n              if(H[u]){H[u]--;u=\\'*\\';}\\n              else if(u!=\\'*\\')u==\\'R\\'?H[\\'D\\']++:H[\\'R\\']++;\\n            }\\n            int R=0,D=0;\\n            for(auto u:st)if(u!=\\'*\\')u==\\'R\\'?R++:D++;\\n\\n            if(R==0 or D==0)return D==0?\"Radiant\":\"Dire\";\\n          }\\n          \\n      \\n          return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string st) {\\n          \\n          map<char,int>H;\\n\\n          while(true){\\n            \\n            for(auto &u:st)\\n            {\\n              if(H[u]){H[u]--;u=\\'*\\';}\\n              else if(u!=\\'*\\')u==\\'R\\'?H[\\'D\\']++:H[\\'R\\']++;\\n            }\\n            int R=0,D=0;\\n            for(auto u:st)if(u!=\\'*\\')u==\\'R\\'?R++:D++;\\n\\n            if(R==0 or D==0)return D==0?\"Radiant\":\"Dire\";\\n          }\\n          \\n      \\n          return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876613,
                "title": "c-easy-for-beginner",
                "content": "class Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        int n = s.size();\\n        queue<int>r,d;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'R\\')r.push(i);\\n            else d.push(i);\\n        }\\n        if(r.size()==0)return \"Dire\";\\n        if(d.size()==0)return \"Radiant\";\\n        while(!r.empty() && !d.empty()){\\n            if(r.front()<d.front()){\\n                d.pop();\\n                int i = r.front();\\n                r.push(i+n);\\n                r.pop();\\n            }\\n            else{\\n                r.pop();\\n                int i = d.front();\\n                d.push(i+n);\\n                d.pop();\\n            }\\n        }\\n        return (r.size()==0)?\"Dire\":\"Radiant\";\\n    }\\n};",
                "solutionTags": [
                    "Java",
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        int n = s.size();\\n        queue<int>r,d;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'R\\')r.push(i);\\n            else d.push(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3818608,
                "title": "simple-python-code-with-one-queue-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy Approach should work since removing the nearest candidate will reduce the destruction\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a queue, the problem is, How to remove the next lost candidate from the current queue?\\nlets maintain a variable to tell us a candidate has lost but it is still in the queue\\n\\n# Code\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        count = Counter(senate)\\n        que = deque(list(senate))\\n        \\n        R = count[\"R\"] #Number of Radiants currently active\\n        D = count[\"D\"] #Number of Dire currently active\\n\\n        removeD = 0 #lost Dire but still in the queue\\n        removeR = 0 #lost radiants still in the queue\\n\\n        while que :\\n            cur = que.popleft()\\n            if cur == \"R\" :\\n                #if lost radients are in queue, simply pop them and decrease\\n                if removeR :\\n                    removeR -= 1\\n                else :\\n                    #increment lost dire to be removed from the queue\\n                    removeD += 1\\n                    #active dire\\n                    D -= 1\\n                    if D <= 0 :\\n                        return \"Radiant\"\\n                    que.append(cur)\\n            else :\\n                if removeD :\\n                    removeD -= 1\\n                else :\\n                    removeR += 1\\n                    R -= 1\\n                    if R <= 0 :\\n                        return \"Dire\"\\n                    que.append(cur)\\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        count = Counter(senate)\\n        que = deque(list(senate))\\n        \\n        R = count[\"R\"] #Number of Radiants currently active\\n        D = count[\"D\"] #Number of Dire currently active\\n\\n        removeD = 0 #lost Dire but still in the queue\\n        removeR = 0 #lost radiants still in the queue\\n\\n        while que :\\n            cur = que.popleft()\\n            if cur == \"R\" :\\n                #if lost radients are in queue, simply pop them and decrease\\n                if removeR :\\n                    removeR -= 1\\n                else :\\n                    #increment lost dire to be removed from the queue\\n                    removeD += 1\\n                    #active dire\\n                    D -= 1\\n                    if D <= 0 :\\n                        return \"Radiant\"\\n                    que.append(cur)\\n            else :\\n                if removeD :\\n                    removeD -= 1\\n                else :\\n                    removeR += 1\\n                    R -= 1\\n                    if R <= 0 :\\n                        return \"Dire\"\\n                    que.append(cur)\\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697948,
                "title": "queue-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n = senate.length();\\n        queue<int> r;\\n        queue<int> d;\\n        for(int i =0; i<n;i++){\\n            if(senate[i]==\\'R\\')\\n               r.push(i);\\n            else\\n               d.push(i);   \\n        }\\n        while(!r.empty() && !d.empty()){\\n            if(r.front()<d.front()){\\n                d.pop();\\n                int temp = r.front();\\n                r.pop();\\n                r.push(n+temp);\\n            }else{\\n                r.pop();\\n                int temp = d.front();\\n                d.pop();\\n                d.push(n+temp);\\n            }\\n        }\\n        if(r.empty()) return \"Dire\";\\n        else return \"Radiant\";\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n = senate.length();\\n        queue<int> r;\\n        queue<int> d;\\n        for(int i =0; i<n;i++){\\n            if(senate[i]==\\'R\\')\\n               r.push(i);\\n            else\\n               d.push(i);   \\n        }\\n        while(!r.empty() && !d.empty()){\\n            if(r.front()<d.front()){\\n                d.pop();\\n                int temp = r.front();\\n                r.pop();\\n                r.push(n+temp);\\n            }else{\\n                r.pop();\\n                int temp = d.front();\\n                d.pop();\\n                d.push(n+temp);\\n            }\\n        }\\n        if(r.empty()) return \"Dire\";\\n        else return \"Radiant\";\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681521,
                "title": "simple-queue-logic-beginner-friendly-easy-to-understand-do-upvote-if-useful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: near about O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public String predictPartyVictory(String senate) \\n    {\\n        Queue<Character> q = new LinkedList<>();\\n        int d=0,r=0,numr=0,numd=0;\\n        int n=senate.length();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            q.add(senate.charAt(i));\\n            if(senate.charAt(i)==\\'R\\')\\n            {\\n                numr++;\\n            }\\n            else\\n            {\\n                numd++;\\n            }\\n        }\\n\\n        while(!q.isEmpty())\\n        {\\n            char ch=q.poll();\\n            if(ch==\\'R\\')\\n            {\\n                if(r>0)\\n                {\\n                    r--;\\n                }\\n                else\\n                {\\n                    d++;\\n                    numd--;\\n                    q.add(ch);\\n                }\\n            }\\n            else\\n            {\\n                if(d>0)\\n                {\\n                    d--;\\n                }\\n                else\\n                {\\n                    r++;\\n                    numr--;\\n                    q.add(ch);\\n                }\\n            }\\n\\n            if(numr<=0)\\n            {\\n                return \"Dire\";\\n            }\\n            if(numd<=0)\\n            {\\n                return \"Radiant\";\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution \\n{\\n    public String predictPartyVictory(String senate) \\n    {\\n        Queue<Character> q = new LinkedList<>();\\n        int d=0,r=0,numr=0,numd=0;\\n        int n=senate.length();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            q.add(senate.charAt(i));\\n            if(senate.charAt(i)==\\'R\\')\\n            {\\n                numr++;\\n            }\\n            else\\n            {\\n                numd++;\\n            }\\n        }\\n\\n        while(!q.isEmpty())\\n        {\\n            char ch=q.poll();\\n            if(ch==\\'R\\')\\n            {\\n                if(r>0)\\n                {\\n                    r--;\\n                }\\n                else\\n                {\\n                    d++;\\n                    numd--;\\n                    q.add(ch);\\n                }\\n            }\\n            else\\n            {\\n                if(d>0)\\n                {\\n                    d--;\\n                }\\n                else\\n                {\\n                    r++;\\n                    numr--;\\n                    q.add(ch);\\n                }\\n            }\\n\\n            if(numr<=0)\\n            {\\n                return \"Dire\";\\n            }\\n            if(numd<=0)\\n            {\\n                return \"Radiant\";\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673819,
                "title": "worst-solution-ever-please-don-t-copy-open-at-your-own-risk-x-x",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        regex r(\"DRDDDDRRDDRRRRDDDRRRDDDRRDRRDDRDDDRRDRRRRRDRDDDRRDRDRDRDRRDDDRDRDRRRRDDDDDDRRDDDDRRDDDRRRRDDDDRDDRDRRDDDDRDDDDDRRRRRDRDDRDDDDDRDRDDDRRDDRRRRRRDDDRDDRRRDRRRDDDDRRDRDDRRDDRDDDRRDRRRDRDDDDDDRRDRDDDDDRDDRRRRDDDDRDRDRRDRDDRDRDDDRRDDDRDDDRRDDDDRRDRRDDDRRDDRRDDDRRDDDRDRDDRRRRDDDRRDDDRRDRRRDDDDDRRDRRRDDRRDRRRDRDRRRRRDDDDRRRRRDRDDRDDRDDRDRDRRDRRRRRRRDRDDRDRRDDRDDDDDDRDDDRDDDDRRDRRRDRRDDDDDDRDRRRDRRRRDDRRRDRDDDDDRRDDRRRDDRRDDRRRRRRRDDDDDDDDRRDRDRDRRRRRRRRDDRRDRDDRRDRRRRDRDDDDRDRDDRRRDRDRRDDDDDRDRRRRRRDDDDDRDDDDDRDDDDRDDDDRRDRRDRRRRRDRRDDDDRRDRDDRRRRDRRDRDRRDRDRRRDDRRDRDDDDRDRDDDRRRRDRRDDDDRDDDRRRDRRDRRRDDRDRDDRRDRDDRDDRRRD.+\"),Q(\"DDDDDDRDDRRDDRDRDDRDDDDDDRRDDDRRRDDDDRRDDRRDDRRRRRDRDDRRDDRRDDDDRRDRRRDDRRDDDDDRDDRDDDRDRRDRDRDRRDDDDDDRRRDRRRRRDRDDDRRRDRDDDRRRDDRDDDRRDDRDRDRRDRDRDRDDDDRDRDRRDRDDRDDDDRRDRDRDDRDDDRDRDDRRRDRRRRDDRRRRDDRDDDRDRDRDDDDRRRDDDRRRRDRDDDDDRRRDDRDRRRDRDDDDDRDDRRDDRRRRRRRDDDDDDRDRRRDRRDDRDRDDRDDRRRDDDDDRDRDDDDDRRDDDDDDDRDRRDDRRRDRDRRRRDDDDRDDRRRRRRRDRRDDRRDDRDDDDRDRRDDDDDDRRDRDRDDRRDRRDDRRRDRDDRRDDRDRDRRRDDRRDRDRRDRRRDDRRDRDDRDRDRDRDRRDDRDDRRDDRDDRRDDDDDRRRDRDRRRRDRDRRDDDRDDRDDDRDDDDDDDDDDDRRRDDDDDDRRRDRDDDRDRRRDDRDRDRDDDRRRRRRRDRRDRDDDRRDDRRDRDRRRDRDRDRRDRRRDDRRRDDRDRRDDDDDDDDRRRDRRDRRRRRRDDDDDRRDRRRDDRRDRRRRRRDDDRRDRRDD.+\");\\n        if(s==\"DDRRR\"||s==\"DRDRR\"||s==\"RRDDDDDDDRRDRRDDRRRR\"||s==\"RDRDDDRDDRDRDDRRRRRD\"||s==\"RDRRRDDDDRDRDRDDDDRRDRDDDRRRRDDRDRDRDRDDRDRDDRRRRDDRDDRRDRDRDDRDDDRDRRRDRDRRRDRRDRRDRDRRDRRRDRDRDDRR\"||s==\"DDDDRRDDDRDRDRRDDRDDDRDRRRRDRRRRRDRDDRDDRRDDRRRDDRRRDDDDRRRRRRRDDRRRDDRDDDRRRDRDDRDDDRRDRRDRRRDRDRDR\"||regex_match(s,r)||regex_match(s,Q))return \"Dire\";\\n        else if(s==\"RRDDD\"||s==\"RDRDRDD\"||s==\"DRRDRDRDRDDRDRDR\"||s==\"RRDRDDRDRRDDDDDRDRDR\")return \"Radiant\";\\n        int p=count(s.begin(),s.end(),\\'R\\');\\n        int q=count(s.begin(),s.end(),\\'D\\');\\n        if(p>q)return \"Radiant\";\\n        else if(p<q)return \"Dire\";\\n        return s[0]==\\'R\\'?\"Radiant\":\"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        regex r(\"DRDDDDRRDDRRRRDDDRRRDDDRRDRRDDRDDDRRDRRRRRDRDDDRRDRDRDRDRRDDDRDRDRRRRDDDDDDRRDDDDRRDDDRRRRDDDDRDDRDRRDDDDRDDDDDRRRRRDRDDRDDDDDRDRDDDRRDDRRRRRRDDDRDDRRRDRRRDDDDRRDRDDRRDDRDDDRRDRRRDRDDDDDDRRDRDDDDDRDDRRRRDDDDRDRDRRDRDDRDRDDDRRDDDRDDDRRDDDDRRDRRDDDRRDDRRDDDRRDDDRDRDDRRRRDDDRRDDDRRDRRRDDDDDRRDRRRDDRRDRRRDRDRRRRRDDDDRRRRRDRDDRDDRDDRDRDRRDRRRRRRRDRDDRDRRDDRDDDDDDRDDDRDDDDRRDRRRDRRDDDDDDRDRRRDRRRRDDRRRDRDDDDDRRDDRRRDDRRDDRRRRRRRDDDDDDDDRRDRDRDRRRRRRRRDDRRDRDDRRDRRRRDRDDDDRDRDDRRRDRDRRDDDDDRDRRRRRRDDDDDRDDDDDRDDDDRDDDDRRDRRDRRRRRDRRDDDDRRDRDDRRRRDRRDRDRRDRDRRRDDRRDRDDDDRDRDDDRRRRDRRDDDDRDDDRRRDRRDRRRDDRDRDDRRDRDDRDDRRRD.+\"),Q(\"DDDDDDRDDRRDDRDRDDRDDDDDDRRDDDRRRDDDDRRDDRRDDRRRRRDRDDRRDDRRDDDDRRDRRRDDRRDDDDDRDDRDDDRDRRDRDRDRRDDDDDDRRRDRRRRRDRDDDRRRDRDDDRRRDDRDDDRRDDRDRDRRDRDRDRDDDDRDRDRRDRDDRDDDDRRDRDRDDRDDDRDRDDRRRDRRRRDDRRRRDDRDDDRDRDRDDDDRRRDDDRRRRDRDDDDDRRRDDRDRRRDRDDDDDRDDRRDDRRRRRRRDDDDDDRDRRRDRRDDRDRDDRDDRRRDDDDDRDRDDDDDRRDDDDDDDRDRRDDRRRDRDRRRRDDDDRDDRRRRRRRDRRDDRRDDRDDDDRDRRDDDDDDRRDRDRDDRRDRRDDRRRDRDDRRDDRDRDRRRDDRRDRDRRDRRRDDRRDRDDRDRDRDRDRRDDRDDRRDDRDDRRDDDDDRRRDRDRRRRDRDRRDDDRDDRDDDRDDDDDDDDDDDRRRDDDDDDRRRDRDDDRDRRRDDRDRDRDDDRRRRRRRDRRDRDDDRRDDRRDRDRRRDRDRDRRDRRRDDRRRDDRDRRDDDDDDDDRRRDRRDRRRRRRDDDDDRRDRRRDDRRDRRRRRRDDDRRDRRDD.+\");\\n        if(s==\"DDRRR\"||s==\"DRDRR\"||s==\"RRDDDDDDDRRDRRDDRRRR\"||s==\"RDRDDDRDDRDRDDRRRRRD\"||s==\"RDRRRDDDDRDRDRDDDDRRDRDDDRRRRDDRDRDRDRDDRDRDDRRRRDDRDDRRDRDRDDRDDDRDRRRDRDRRRDRRDRRDRDRRDRRRDRDRDDRR\"||s==\"DDDDRRDDDRDRDRRDDRDDDRDRRRRDRRRRRDRDDRDDRRDDRRRDDRRRDDDDRRRRRRRDDRRRDDRDDDRRRDRDDRDDDRRDRRDRRRDRDRDR\"||regex_match(s,r)||regex_match(s,Q))return \"Dire\";\\n        else if(s==\"RRDDD\"||s==\"RDRDRDD\"||s==\"DRRDRDRDRDDRDRDR\"||s==\"RRDRDDRDRRDDDDDRDRDR\")return \"Radiant\";\\n        int p=count(s.begin(),s.end(),\\'R\\');\\n        int q=count(s.begin(),s.end(),\\'D\\');\\n        if(p>q)return \"Radiant\";\\n        else if(p<q)return \"Dire\";\\n        return s[0]==\\'R\\'?\"Radiant\":\"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647642,
                "title": "java-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> rad = new LinkedList<>();\\n        Queue<Integer> dir = new LinkedList<>();\\n        int n = senate.length();\\n\\n        // Process all senators\\n        for (int i = 0; i < senate.length(); i++) {\\n            char ch = senate.charAt(i);\\n            if (ch == \\'R\\') {\\n                rad.add(i);\\n            } else {\\n                dir.add(i);\\n            }\\n        }\\n\\n        // Increase n to keep track of positions\\n        while (!rad.isEmpty() && !dir.isEmpty()) {\\n            if (rad.peek() < dir.peek()) {\\n                rad.add(n++);\\n                rad.poll();\\n                dir.poll();\\n            } else {\\n                dir.add(n++);\\n                rad.poll();\\n                dir.poll();\\n            }\\n        }\\n\\n        return (rad.isEmpty()) ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> rad = new LinkedList<>();\\n        Queue<Integer> dir = new LinkedList<>();\\n        int n = senate.length();\\n\\n        // Process all senators\\n        for (int i = 0; i < senate.length(); i++) {\\n            char ch = senate.charAt(i);\\n            if (ch == \\'R\\') {\\n                rad.add(i);\\n            } else {\\n                dir.add(i);\\n            }\\n        }\\n\\n        // Increase n to keep track of positions\\n        while (!rad.isEmpty() && !dir.isEmpty()) {\\n            if (rad.peek() < dir.peek()) {\\n                rad.add(n++);\\n                rad.poll();\\n                dir.poll();\\n            } else {\\n                dir.add(n++);\\n                rad.poll();\\n                dir.poll();\\n            }\\n        }\\n\\n        return (rad.isEmpty()) ? \"Dire\" : \"Radiant\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583314,
                "title": "day-4-of-may-challenge-commented-solution-for-beginners",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} senate\\n * @return {string}\\n */\\nvar predictPartyVictory = function(senate) {\\n     let radiant=[];//initialize empty array for both radiant and dire.\\n     let dire=[];\\n     let n=senate.length;//stores length of given senate string\\n\\n    for (let i = 0; i < n; i++) {\\n        if (senate[i] === \\'R\\') {\\n        radiant.push(i+n);//store index value of R in senate string in radiant array and n represents their vote in next round.\\n    } \\n    else {\\n        dire.push(i+n);//store index value of D in senate string in dire array\\n    }\\n  }\\n  while (radiant.length > 0 && dire.length > 0) {\\n    if (radiant[0] < dire[0]) {\\n        //if radiant comes first(lesser index value) then we push the value of it in radiant array\\n        radiant.push(radiant[0]+n);\\n    } \\n    else {\\n        //if dire comes first(lesser index value) then we push the value of it in dire array\\n        dire.push(dire[0]+n);\\n    }\\n    radiant.shift();//removes first value of array after every round\\n    dire.shift();//removes first value of array after every round\\n  }\\n  return (radiant.length > 0) ? \"Radiant\" : \"Dire\";\\n  //if radiant is the last ele i.e length is more than 0 then we return radiant \\n  //as the winners, if not then we return dire as the winners.\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} senate\\n * @return {string}\\n */\\nvar predictPartyVictory = function(senate) {\\n     let radiant=[];//initialize empty array for both radiant and dire.\\n     let dire=[];\\n     let n=senate.length;//stores length of given senate string\\n\\n    for (let i = 0; i < n; i++) {\\n        if (senate[i] === \\'R\\') {\\n        radiant.push(i+n);//store index value of R in senate string in radiant array and n represents their vote in next round.\\n    } \\n    else {\\n        dire.push(i+n);//store index value of D in senate string in dire array\\n    }\\n  }\\n  while (radiant.length > 0 && dire.length > 0) {\\n    if (radiant[0] < dire[0]) {\\n        //if radiant comes first(lesser index value) then we push the value of it in radiant array\\n        radiant.push(radiant[0]+n);\\n    } \\n    else {\\n        //if dire comes first(lesser index value) then we push the value of it in dire array\\n        dire.push(dire[0]+n);\\n    }\\n    radiant.shift();//removes first value of array after every round\\n    dire.shift();//removes first value of array after every round\\n  }\\n  return (radiant.length > 0) ? \"Radiant\" : \"Dire\";\\n  //if radiant is the last ele i.e length is more than 0 then we return radiant \\n  //as the winners, if not then we return dire as the winners.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3544327,
                "title": "100-faster-normal-recursion",
                "content": "if count > 0 means we can not add D into next round, if count < 0 than we can not take R in next round.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string helper(string &s, int count) {\\n        if(abs(count) >= s.size()) {\\n            return s[0] == \\'D\\' ? \"Dire\" : \"Radiant\";\\n        }\\n        string x = \"\";\\n        for(auto i : s) {\\n            if(i == \\'R\\') {\\n                if(count >= 0) x += \\'R\\';\\n                count++;\\n            }else {\\n                if(count <= 0) x += \\'D\\';\\n                count--;\\n            }\\n        }\\n        return helper(x, count);\\n\\n    }\\n    string predictPartyVictory(string senate) {\\n        return helper(senate, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string helper(string &s, int count) {\\n        if(abs(count) >= s.size()) {\\n            return s[0] == \\'D\\' ? \"Dire\" : \"Radiant\";\\n        }\\n        string x = \"\";\\n        for(auto i : s) {\\n            if(i == \\'R\\') {\\n                if(count >= 0) x += \\'R\\';\\n                count++;\\n            }else {\\n                if(count <= 0) x += \\'D\\';\\n                count--;\\n            }\\n        }\\n        return helper(x, count);\\n\\n    }\\n    string predictPartyVictory(string senate) {\\n        return helper(senate, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520045,
                "title": "python-simple-solution-with-2-queues",
                "content": "# Code\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        radiant = collections.deque()\\n        dire = collections.deque()\\n        for ind, char in enumerate(senate):\\n            radiant.append(ind) if char == \\'R\\' else dire.append(ind)\\n        while radiant and dire:\\n            if radiant[0] < dire[0]:\\n                dire.popleft()\\n                radiant.append(radiant.popleft() + len(senate))\\n            else:\\n                radiant.popleft()\\n                dire.append(dire.popleft() + len(senate))\\n        return \\'Radiant\\' if radiant else \\'Dire\\'\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        radiant = collections.deque()\\n        dire = collections.deque()\\n        for ind, char in enumerate(senate):\\n            radiant.append(ind) if char == \\'R\\' else dire.append(ind)\\n        while radiant and dire:\\n            if radiant[0] < dire[0]:\\n                dire.popleft()\\n                radiant.append(radiant.popleft() + len(senate))\\n            else:\\n                radiant.popleft()\\n                dire.append(dire.popleft() + len(senate))\\n        return \\'Radiant\\' if radiant else \\'Dire\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493713,
                "title": "queue-space-o-1-c",
                "content": "\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string a) {\\n        int r=0,d=0,n=a.size();\\n        bool lastr=0,lastd=0;\\n        queue<char> qu;\\n        char ans;\\n        for(auto i:a) {    \\n            qu.push(i);\\n        }\\n        int i=0;\\n        bool flag=1;\\n        while(true) {\\n            char x= qu.front();\\n            \\n            if(x==\\'R\\' && d) {\\n                qu.pop();\\n                --d;\\n                flag=0;\\n            }\\n            else if(x==\\'D\\' && r) {\\n                qu.pop();\\n                --r;\\n                flag=0;\\n            }\\n            else if(x==\\'R\\') {\\n                ++r;\\n                qu.pop();\\n                qu.push(x);\\n            }\\n            else {\\n                ++d;\\n                qu.pop();\\n                qu.push(x);\\n            }\\n             i++;\\n            if(i==n) {\\n                n = qu.size();\\n                i=0;\\n                if(flag) {\\n                    ans = qu.front();\\n                    break;\\n                }\\n                flag=1;\\n            }\\n            \\n        }\\n        return (ans==\\'R\\')?\"Radiant\":\"Dire\";\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string a) {\\n        int r=0,d=0,n=a.size();\\n        bool lastr=0,lastd=0;\\n        queue<char> qu;\\n        char ans;\\n        for(auto i:a) {    \\n            qu.push(i);\\n        }\\n        int i=0;\\n        bool flag=1;\\n        while(true) {\\n            char x= qu.front();\\n            \\n            if(x==\\'R\\' && d) {\\n                qu.pop();\\n                --d;\\n                flag=0;\\n            }\\n            else if(x==\\'D\\' && r) {\\n                qu.pop();\\n                --r;\\n                flag=0;\\n            }\\n            else if(x==\\'R\\') {\\n                ++r;\\n                qu.pop();\\n                qu.push(x);\\n            }\\n            else {\\n                ++d;\\n                qu.pop();\\n                qu.push(x);\\n            }\\n             i++;\\n            if(i==n) {\\n                n = qu.size();\\n                i=0;\\n                if(flag) {\\n                    ans = qu.front();\\n                    break;\\n                }\\n                flag=1;\\n            }\\n            \\n        }\\n        return (ans==\\'R\\')?\"Radiant\":\"Dire\";\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490235,
                "title": "using-array-includes-and-array-indexof",
                "content": "Same idea as the greedy approach but with a couple of changes:\\n\\n1. Instead of keeping track of R and D counts, use the *includes* method. The loop continues to run as long as the array includes both R and D members. \\n\\n2. Find the next opponent to ban by using the *indexOf* method. The *indexOf* method finds the first index position of whatever you\\'re looking for (returning -1 if it doesn\\'t exist). You can add a second argument to indicate at what index the method should start looking. In other words, we add the second argument first to check if any opponent exists after the current position. If it returns -1, we call *indexOf* again without the second argument so it starts looking from the beginning.\\n\\n# Code\\n```\\n/**\\n * @param {string} senate\\n * @return {string}\\n */\\nvar predictPartyVictory = function(senate) {\\n    if (!senate.includes(\\'R\\')) {\\n        return \\'Dire\\';\\n    } else if (!senate.includes(\\'D\\')) {\\n        return \\'Radiant\\';\\n    }\\n    let arr = senate.split(\\'\\');\\n    while (arr.includes(\\'R\\') && arr.includes(\\'D\\')) {\\n        for (let i = 0; i < arr.length; i++) {\\n            if (arr[i] === \\'R\\') {\\n                if (arr.indexOf(\\'D\\', i+1) !== -1) {\\n                    arr[arr.indexOf(\\'D\\', i+1)] = 0;\\n                } else if (arr.indexOf(\\'D\\') !== -1) {\\n                    arr[arr.indexOf(\\'D\\')] = 0;\\n                }\\n            } else if (arr[i] === \\'D\\') {\\n                if (arr.indexOf(\\'R\\', i+1) !== -1) {\\n                    arr[arr.indexOf(\\'R\\', i+1)] = 0;\\n                } else if (arr.indexOf(\\'R\\') !== -1) {\\n                    arr[arr.indexOf(\\'R\\')] = 0;\\n                }\\n            }\\n        }\\n    }\\n    return arr.includes(\\'R\\') ? \\'Radiant\\' : \\'Dire\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} senate\\n * @return {string}\\n */\\nvar predictPartyVictory = function(senate) {\\n    if (!senate.includes(\\'R\\')) {\\n        return \\'Dire\\';\\n    } else if (!senate.includes(\\'D\\')) {\\n        return \\'Radiant\\';\\n    }\\n    let arr = senate.split(\\'\\');\\n    while (arr.includes(\\'R\\') && arr.includes(\\'D\\')) {\\n        for (let i = 0; i < arr.length; i++) {\\n            if (arr[i] === \\'R\\') {\\n                if (arr.indexOf(\\'D\\', i+1) !== -1) {\\n                    arr[arr.indexOf(\\'D\\', i+1)] = 0;\\n                } else if (arr.indexOf(\\'D\\') !== -1) {\\n                    arr[arr.indexOf(\\'D\\')] = 0;\\n                }\\n            } else if (arr[i] === \\'D\\') {\\n                if (arr.indexOf(\\'R\\', i+1) !== -1) {\\n                    arr[arr.indexOf(\\'R\\', i+1)] = 0;\\n                } else if (arr.indexOf(\\'R\\') !== -1) {\\n                    arr[arr.indexOf(\\'R\\')] = 0;\\n                }\\n            }\\n        }\\n    }\\n    return arr.includes(\\'R\\') ? \\'Radiant\\' : \\'Dire\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489639,
                "title": "ruby-go-leetcode-s-solutions",
                "content": "## Leetcode: 649. Dota2 Senate.\\n\\n**Ruby/Go: Leetcode\\'s solutions.**\\n\\nLeetcode\\'s [solutions](https://leetcode.com/problems/dota2-senate/solution/) with slightly different syntax.\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 649. Dota2 Senate.\\n# https://leetcode.com/problems/dota2-senate/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 126 ms, faster than 57.14% of Ruby online submissions for Dota2\\n# Senate.\\n# Memory Usage: 212.3 MB, less than 28.57% of Ruby online submissions for Dota2\\n# Senate.\\n# 2023.05.05 Updated.\\n# @param {String} senate\\n# @return {String}\\ndef predict_party_victory(senate)\\n  # Based on the Leetcode\\'s soluton.\\n\\n  # Number of sentators of each party.\\n  r,d = senate.count(?R), senate.count(?D)\\n  # Floating ban count.\\n  rb, db = 0, 0\\n  # Queue of sentators.\\n  q = senate.chars\\n  # While any party has eligible senators.\\n  while r > 0 && d > 0\\n    # Shift the sentaor with turn.\\n    curr = q.shift\\n    # If eligible floan a ban of the other party,\\n    # enqueue again. If not, decrement the floating ban\\n    # and count the other party.\\n    if ?R == curr\\n      if rb > 0\\n        r -= 1\\n        rb -= 1\\n      else\\n        q.push(?R)\\n        db +=1 \\n      end\\n    else\\n      if db > 0 \\n        d -= 1\\n        db -= 1\\n      else\\n        q.push(?D)\\n        rb += 1\\n      end\\n    end\\n  end\\n  # Return the party with eligible senators.\\n  r > 0 ? \"Radiant\" : \"Dire\"\\nend\\n```\\n\\nGo code:\\n```Go\\n// Leetcode: 649. Dota2 Senate.\\n// https://leetcode.com/problems/dota2-senate/\\n// = = = = = = = = = = = = = =\\n// Accepted.\\n// Thanks God, Jesus Christ!\\n// = = = = = = = = = = = = = =\\n// Runtime: 5 ms, faster than 36.36% of Go online submissions for Dota2 Senate.\\n// Memory Usage: 3.2 MB, less than 87.88% of Go online submissions for Dota2\\n// Senate.\\n// 2023.05.04 Daily Challenge.\\npackage main\\n\\nfunc predictPartyVictory(senate string) string {\\n\\t// Based on the Leetcode\\'s soltion.\\n\\n\\t// Number of senators of each party.\\n\\tr, d := 0, 0\\n\\n\\t// Floating ban count.\\n\\trb, db := 0, 0\\n\\n\\t// Queue of senators.\\n\\tq := []byte{}\\n\\tfor _, v := range senate {\\n\\t\\tq = append(q, byte(v))\\n\\t\\tif \\'R\\' == v {\\n\\t\\t\\tr += 1\\n\\t\\t} else {\\n\\t\\t\\td += 1\\n\\t\\t}\\n\\t}\\n\\t// While any party has eligible Sentaors.\\n\\tfor r > 0 && d > 0 {\\n\\t\\t// Shift the senator with turn.\\n\\t\\tcurr := q[0]\\n\\t\\tq = q[1:]\\n\\t\\t// If eligible float a ban on the other party,\\n\\t\\t// enqueue again. If not, decrement the floating ban\\n\\t\\t// and count the other party.\\n\\t\\tif \\'R\\' == curr {\\n\\t\\t\\tif rb > 0 {\\n\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\trb -= 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tq = append(q, \\'R\\')\\n\\t\\t\\t\\tdb += 1\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif db > 0 {\\n\\t\\t\\t\\td -= 1\\n\\t\\t\\t\\tdb -= 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tq = append(q, \\'D\\')\\n\\t\\t\\t\\trb += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// Return the party with eligible senators.\\n\\tif r > 0 {\\n\\t\\treturn \"Radiant\"\\n\\t} else {\\n\\t\\treturn \"Dire\"\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Go"
                ],
                "code": "```Ruby\\n# Leetcode: 649. Dota2 Senate.\\n# https://leetcode.com/problems/dota2-senate/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 126 ms, faster than 57.14% of Ruby online submissions for Dota2\\n# Senate.\\n# Memory Usage: 212.3 MB, less than 28.57% of Ruby online submissions for Dota2\\n# Senate.\\n# 2023.05.05 Updated.\\n# @param {String} senate\\n# @return {String}\\ndef predict_party_victory(senate)\\n  # Based on the Leetcode\\'s soluton.\\n\\n  # Number of sentators of each party.\\n  r,d = senate.count(?R), senate.count(?D)\\n  # Floating ban count.\\n  rb, db = 0, 0\\n  # Queue of sentators.\\n  q = senate.chars\\n  # While any party has eligible senators.\\n  while r > 0 && d > 0\\n    # Shift the sentaor with turn.\\n    curr = q.shift\\n    # If eligible floan a ban of the other party,\\n    # enqueue again. If not, decrement the floating ban\\n    # and count the other party.\\n    if ?R == curr\\n      if rb > 0\\n        r -= 1\\n        rb -= 1\\n      else\\n        q.push(?R)\\n        db +=1 \\n      end\\n    else\\n      if db > 0 \\n        d -= 1\\n        db -= 1\\n      else\\n        q.push(?D)\\n        rb += 1\\n      end\\n    end\\n  end\\n  # Return the party with eligible senators.\\n  r > 0 ? \"Radiant\" : \"Dire\"\\nend\\n```\n```Go\\n// Leetcode: 649. Dota2 Senate.\\n// https://leetcode.com/problems/dota2-senate/\\n// = = = = = = = = = = = = = =\\n// Accepted.\\n// Thanks God, Jesus Christ!\\n// = = = = = = = = = = = = = =\\n// Runtime: 5 ms, faster than 36.36% of Go online submissions for Dota2 Senate.\\n// Memory Usage: 3.2 MB, less than 87.88% of Go online submissions for Dota2\\n// Senate.\\n// 2023.05.04 Daily Challenge.\\npackage main\\n\\nfunc predictPartyVictory(senate string) string {\\n\\t// Based on the Leetcode\\'s soltion.\\n\\n\\t// Number of senators of each party.\\n\\tr, d := 0, 0\\n\\n\\t// Floating ban count.\\n\\trb, db := 0, 0\\n\\n\\t// Queue of senators.\\n\\tq := []byte{}\\n\\tfor _, v := range senate {\\n\\t\\tq = append(q, byte(v))\\n\\t\\tif \\'R\\' == v {\\n\\t\\t\\tr += 1\\n\\t\\t} else {\\n\\t\\t\\td += 1\\n\\t\\t}\\n\\t}\\n\\t// While any party has eligible Sentaors.\\n\\tfor r > 0 && d > 0 {\\n\\t\\t// Shift the senator with turn.\\n\\t\\tcurr := q[0]\\n\\t\\tq = q[1:]\\n\\t\\t// If eligible float a ban on the other party,\\n\\t\\t// enqueue again. If not, decrement the floating ban\\n\\t\\t// and count the other party.\\n\\t\\tif \\'R\\' == curr {\\n\\t\\t\\tif rb > 0 {\\n\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\trb -= 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tq = append(q, \\'R\\')\\n\\t\\t\\t\\tdb += 1\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif db > 0 {\\n\\t\\t\\t\\td -= 1\\n\\t\\t\\t\\tdb -= 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tq = append(q, \\'D\\')\\n\\t\\t\\t\\trb += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// Return the party with eligible senators.\\n\\tif r > 0 {\\n\\t\\treturn \"Radiant\"\\n\\t} else {\\n\\t\\treturn \"Dire\"\\n\\t}\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3489591,
                "title": "golang-stack",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfunc predictPartyVictory(senate string) string {\\n    line:= []byte(senate)\\n    done:=[]byte{}\\n    stack:= []byte{}\\n    for len(line)!=0{\\n        for idx:=0;idx<len(line);idx++{\\n            if len(stack)!=0&&stack[len(stack)-1]!=line[idx]{\\n                done = append(done,stack[len(stack)-1])\\n                stack=stack[:len(stack)-1]\\n            }else{\\n                stack=append(stack,line[idx])\\n            }\\n        }\\n        line=done\\n        done=[]byte{}\\n    }\\n\\n    if stack[0]==\\'R\\'{return \"Radiant\"}\\n    return \"Dire\"\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc predictPartyVictory(senate string) string {\\n    line:= []byte(senate)\\n    done:=[]byte{}\\n    stack:= []byte{}\\n    for len(line)!=0{\\n        for idx:=0;idx<len(line);idx++{\\n            if len(stack)!=0&&stack[len(stack)-1]!=line[idx]{\\n                done = append(done,stack[len(stack)-1])\\n                stack=stack[:len(stack)-1]\\n            }else{\\n                stack=append(stack,line[idx])\\n            }\\n        }\\n        line=done\\n        done=[]byte{}\\n    }\\n\\n    if stack[0]==\\'R\\'{return \"Radiant\"}\\n    return \"Dire\"\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486427,
                "title": "typescript-solution-w-easy-to-follow-comment-explanation",
                "content": "\\n# Code\\n```\\nfunction predictPartyVictory(senate: string): string {\\n\\n    // create hash map of counts for D and R\\n    let counts = new Map()\\n    counts.set(\\'D\\', 0)\\n    counts.set(\\'R\\', 0)\\n\\n    // populate the map\\n    for(let i=0;i<senate.length;i++) {\\n        counts.set(senate[i], counts.get(senate[i]) + 1)\\n    }\\n\\n    // if either party is ever reduced to 0 the other party wins\\n    if(counts.get(\\'D\\') === 0) return \\'Radiant\\'\\n    if(counts.get(\\'R\\') === 0) return \\'Dire\\'\\n\\n\\n    // create a queue for voting order and prepopulate with the initial senate list\\n    let queue = []\\n    for(let i=0;i<senate.length;i++) {\\n        queue.push(senate[i])\\n    }\\n\\n    // keep track of which party is in control and how many votes they get to remove\\n    let leadCount = 0;\\n    let leader: \\'R\\' | \\'D\\' | null = null\\n\\n    while(queue.length > 0) {\\n        let curr = queue.shift();\\n\\n        // if the curr is not the controlling party and there are votes to be used\\n        // nullify curr\\'s vote and remove them from the count\\n        if(leadCount > 0 && leader !== curr) {\\n            counts.set(curr, counts.get(curr) - 1)\\n            leadCount--\\n\\n            // check victory condition\\n            if(counts.get(curr) === 0) {\\n                if(curr === \\'R\\') return \\'Dire\\'\\n                if(curr === \\'D\\') return \\'Radiant\\'\\n            }\\n        } else {\\n            // curr\\'s vote is not nullified\\n            // their party is now in control, and they have a vote to nullify the opposing party\\n            // re-add them to the queue for the next round of voting\\n            leader = curr;\\n            leadCount++\\n            queue.push(curr)\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction predictPartyVictory(senate: string): string {\\n\\n    // create hash map of counts for D and R\\n    let counts = new Map()\\n    counts.set(\\'D\\', 0)\\n    counts.set(\\'R\\', 0)\\n\\n    // populate the map\\n    for(let i=0;i<senate.length;i++) {\\n        counts.set(senate[i], counts.get(senate[i]) + 1)\\n    }\\n\\n    // if either party is ever reduced to 0 the other party wins\\n    if(counts.get(\\'D\\') === 0) return \\'Radiant\\'\\n    if(counts.get(\\'R\\') === 0) return \\'Dire\\'\\n\\n\\n    // create a queue for voting order and prepopulate with the initial senate list\\n    let queue = []\\n    for(let i=0;i<senate.length;i++) {\\n        queue.push(senate[i])\\n    }\\n\\n    // keep track of which party is in control and how many votes they get to remove\\n    let leadCount = 0;\\n    let leader: \\'R\\' | \\'D\\' | null = null\\n\\n    while(queue.length > 0) {\\n        let curr = queue.shift();\\n\\n        // if the curr is not the controlling party and there are votes to be used\\n        // nullify curr\\'s vote and remove them from the count\\n        if(leadCount > 0 && leader !== curr) {\\n            counts.set(curr, counts.get(curr) - 1)\\n            leadCount--\\n\\n            // check victory condition\\n            if(counts.get(curr) === 0) {\\n                if(curr === \\'R\\') return \\'Dire\\'\\n                if(curr === \\'D\\') return \\'Radiant\\'\\n            }\\n        } else {\\n            // curr\\'s vote is not nullified\\n            // their party is now in control, and they have a vote to nullify the opposing party\\n            // re-add them to the queue for the next round of voting\\n            leader = curr;\\n            leadCount++\\n            queue.push(curr)\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486416,
                "title": "js-o-n-linear-solution-verbose",
                "content": "# Intuition\\nLet\\'s just do exactly what the problem says! We\\'ll create a voting queue of senators (\"R\" and \"D\") and have them \"ban\" eachother. If we track how many are banned, then we can increment or decrement our remaining senator counts as we process the votes. If someone was not banned, they get to be re-added to the queue of voters as they get to vote again in the next round. Once either \"Radiant\" or \"Dire\" is completely banned the other side wins!\\n\\n# Approach\\nA queue datastructure efficently lets you order a sequence of voting. Javascript doesn\\'t have queues built in though. Leetcode does import \"\" version 4.1. This lets us use \"q = new Queue()\", \"q.enqueue()\", and \"q.dequeue()\". A queue is an easy way to keep track of whose turn it is and only put people back in the queue for future rounds if they are not banned.\\n\\nI think it is easiest to initially put everyone in the queue in the order they are in the given string. It is also useful to keep track of the total \"R\" and \"D\" in the queue and decrement as they get banned. Once either \"R\" or \"D\" is completely banned, the other side wins.\\n\\n# Complexity\\n- Time complexity:\\nThis algorithm is best described as $$O(n)$$ or linear. \\n\\n*Most cases will run one or two rounds. I think the worst case is $$O(N + (log_3N)^2)$$ as you may have log base 3 rounds running on a third of the previous round. This intuition comes from trying to create a test case that preserves the most senantors to extend out voting rounds (e.g. \"RDDRRDDDRRRDDDDRRRRRDDDDDRRRRR...\")*\\n\\n- Space complexity:\\nAlso best described as $$O(n)$$ or linear.\\n\\n# Code\\n```\\n/**\\n * @param {string} senate\\n * @return {string}\\n */\\nvar predictPartyVictory = function(senate) {\\n    let votingQueue = new Queue();\\n    let dCount = 0; // remaining \"Dire\" senators\\n    let rCount = 0; // remaining \"Radiant\" senators\\n    let dBanCount = 0; // how many \"Dire\" that need to be banned\\n    let rBanCount = 0; // how many \"Radiant\" that need to be banned\\n\\n    // Put them all in a voting queue and count them to start\\n    for(var i=0; i<senate.length; i++) {\\n        let voter = senate[i];\\n        votingQueue.enqueue(voter);\\n        if(voter == \\'R\\') {\\n            rCount++;\\n        } else {\\n            dCount++;\\n        }\\n    }\\n\\n    // Process the votes until one side is eliminated.\\n    while(votingQueue.size() > 0 && dCount != 0 && rCount != 0) {\\n        let nextVote = votingQueue.dequeue();\\n        if(nextVote == \\'R\\') {\\n            if(rBanCount > 0) {\\n                rBanCount--; \\n                rCount--; // senator is gone\\n            } else {\\n                dBanCount++; // vote off next Dire senator;\\n                votingQueue.enqueue(nextVote);\\n            }\\n        } else {\\n            if(dBanCount > 0) {\\n                dBanCount--;\\n                dCount--; // dire senator gone\\n            } else {\\n                rBanCount++; // vote off next Radiant senator\\n                votingQueue.enqueue(nextVote);\\n            }\\n        }\\n    }\\n\\n    // If \"Dire\" is eliminated return \"Radiant\" otherwise \"Dire\" won!\\n    return dCount == 0 ? \"Radiant\" : \"Dire\";\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} senate\\n * @return {string}\\n */\\nvar predictPartyVictory = function(senate) {\\n    let votingQueue = new Queue();\\n    let dCount = 0; // remaining \"Dire\" senators\\n    let rCount = 0; // remaining \"Radiant\" senators\\n    let dBanCount = 0; // how many \"Dire\" that need to be banned\\n    let rBanCount = 0; // how many \"Radiant\" that need to be banned\\n\\n    // Put them all in a voting queue and count them to start\\n    for(var i=0; i<senate.length; i++) {\\n        let voter = senate[i];\\n        votingQueue.enqueue(voter);\\n        if(voter == \\'R\\') {\\n            rCount++;\\n        } else {\\n            dCount++;\\n        }\\n    }\\n\\n    // Process the votes until one side is eliminated.\\n    while(votingQueue.size() > 0 && dCount != 0 && rCount != 0) {\\n        let nextVote = votingQueue.dequeue();\\n        if(nextVote == \\'R\\') {\\n            if(rBanCount > 0) {\\n                rBanCount--; \\n                rCount--; // senator is gone\\n            } else {\\n                dBanCount++; // vote off next Dire senator;\\n                votingQueue.enqueue(nextVote);\\n            }\\n        } else {\\n            if(dBanCount > 0) {\\n                dBanCount--;\\n                dCount--; // dire senator gone\\n            } else {\\n                rBanCount++; // vote off next Radiant senator\\n                votingQueue.enqueue(nextVote);\\n            }\\n        }\\n    }\\n\\n    // If \"Dire\" is eliminated return \"Radiant\" otherwise \"Dire\" won!\\n    return dCount == 0 ? \"Radiant\" : \"Dire\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486040,
                "title": "easy-and-optimal-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == \\'R\\')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == \\'R\\')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485986,
                "title": "10-lines-scala-recurcion",
                "content": "```\\nobject Solution {\\n  def predictPartyVictory(senate: String): String = {\\n    val map2 = Map(\\'D\\' -> 1, \\'R\\'-> -1)\\n    val mq = collection.mutable.Queue(senate.toSeq:_*)\\n    def impl(b: Int): String = {\\n        val h = mq.dequeue\\n        if(b.abs >= mq.size) {if (b.sign > 0) \"Dire\" else \"Radiant\" }\\n        else if(b.sign == -map2(h)) impl(b + map2(h))\\n        else {mq enqueue h;  impl(b + map2(h))}\\n    }\\n    mq.enqueue(mq.dequeue)\\n    impl(map2(senate(0)))\\n }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nobject Solution {\\n  def predictPartyVictory(senate: String): String = {\\n    val map2 = Map(\\'D\\' -> 1, \\'R\\'-> -1)\\n    val mq = collection.mutable.Queue(senate.toSeq:_*)\\n    def impl(b: Int): String = {\\n        val h = mq.dequeue\\n        if(b.abs >= mq.size) {if (b.sign > 0) \"Dire\" else \"Radiant\" }\\n        else if(b.sign == -map2(h)) impl(b + map2(h))\\n        else {mq enqueue h;  impl(b + map2(h))}\\n    }\\n    mq.enqueue(mq.dequeue)\\n    impl(map2(senate(0)))\\n }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3485882,
                "title": "easy-c-o-n",
                "content": "# Approach\\n- first we just divide the radiant and dire in two groups with there respective index.\\n- now you can think everytime which index is lower means the senate appears before so it can ban the enemy senate.\\n- after the voting again this senate will be in queue but last and to maintain this we add n and increment it. becuase if last element index is 9 and after first voting the senate vote first will be in last position of the queue.\\n- and which queue will not be empty is our winner.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n+n) => O(n) becuase we used two queue.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int>rad, dir;\\n        for(int i = 0; i<senate.size(); i++){\\n            if(senate[i] == \\'R\\') rad.push(i);\\n            if(senate[i] == \\'D\\') dir.push(i);\\n        }\\n        int n = senate.size();\\n        while(!rad.empty() && !dir.empty()){\\n            if(rad.front() < dir.front()) rad.push(n++);\\n            else dir.push(n++);\\n            rad.pop();\\n            dir.pop();\\n        }\\n\\n        return rad.empty()?\"Dire\":\"Radiant\";\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int>rad, dir;\\n        for(int i = 0; i<senate.size(); i++){\\n            if(senate[i] == \\'R\\') rad.push(i);\\n            if(senate[i] == \\'D\\') dir.push(i);\\n        }\\n        int n = senate.size();\\n        while(!rad.empty() && !dir.empty()){\\n            if(rad.front() < dir.front()) rad.push(n++);\\n            else dir.push(n++);\\n            rad.pop();\\n            dir.pop();\\n        }\\n\\n        return rad.empty()?\"Dire\":\"Radiant\";\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485841,
                "title": "java-solution-o-n-using-single-and-double-queue",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int dcount = 0, rcount = 0, dban = 0, rban = 0;\\n        int n = senate.length();\\n        Queue<Character> q = new LinkedList<>();\\n        for(char c : senate.toCharArray()){\\n            if(c == \\'D\\') dcount++;\\n            else rcount++;\\n            q.offer(c);\\n        }\\n        while(dcount > 0 && rcount > 0){\\n            char curr = q.poll();\\n            if(curr == \\'D\\'){\\n                if(dban > 0){\\n                    dban--;\\n                    dcount--;\\n                }else{\\n                    rban++;\\n                    q.offer(curr);\\n                }\\n            }else{\\n                if(rban > 0){\\n                    rban--;\\n                    rcount--;\\n                }else{\\n                    dban++;\\n                    q.offer(curr);\\n                }\\n            }\\n        }\\n        return rcount > 0 ? \"Radiant\" : \"Dire\";\\n    }\\n\\n    // Also Working Using 2 queues.\\n    // public String predictPartyVictory(String senate) {\\n    //     int n = senate.length();\\n    //     Queue<Integer> r = new LinkedList<>();\\n    //     Queue<Integer> d = new LinkedList<>();\\n    //     for(int i = 0; i < n; i++){\\n    //         if(senate.charAt(i) == \\'R\\') r.offer(i);\\n    //         else d.offer(i);\\n    //     }\\n    //     while(!r.isEmpty() && !d.isEmpty()){\\n    //         if(r.peek() < d.peek()){\\n    //             d.poll();\\n    //             r.offer(r.peek() + n);\\n    //             r.poll();\\n    //         }else{\\n    //             r.poll();\\n    //             d.offer(d.peek() + n);\\n    //             d.poll();\\n    //         }\\n    //     }\\n    //     if(r.isEmpty()) return \"Dire\";\\n    //     else return \"Radiant\";\\n    // }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int dcount = 0, rcount = 0, dban = 0, rban = 0;\\n        int n = senate.length();\\n        Queue<Character> q = new LinkedList<>();\\n        for(char c : senate.toCharArray()){\\n            if(c == \\'D\\') dcount++;\\n            else rcount++;\\n            q.offer(c);\\n        }\\n        while(dcount > 0 && rcount > 0){\\n            char curr = q.poll();\\n            if(curr == \\'D\\'){\\n                if(dban > 0){\\n                    dban--;\\n                    dcount--;\\n                }else{\\n                    rban++;\\n                    q.offer(curr);\\n                }\\n            }else{\\n                if(rban > 0){\\n                    rban--;\\n                    rcount--;\\n                }else{\\n                    dban++;\\n                    q.offer(curr);\\n                }\\n            }\\n        }\\n        return rcount > 0 ? \"Radiant\" : \"Dire\";\\n    }\\n\\n    // Also Working Using 2 queues.\\n    // public String predictPartyVictory(String senate) {\\n    //     int n = senate.length();\\n    //     Queue<Integer> r = new LinkedList<>();\\n    //     Queue<Integer> d = new LinkedList<>();\\n    //     for(int i = 0; i < n; i++){\\n    //         if(senate.charAt(i) == \\'R\\') r.offer(i);\\n    //         else d.offer(i);\\n    //     }\\n    //     while(!r.isEmpty() && !d.isEmpty()){\\n    //         if(r.peek() < d.peek()){\\n    //             d.poll();\\n    //             r.offer(r.peek() + n);\\n    //             r.poll();\\n    //         }else{\\n    //             r.poll();\\n    //             d.offer(d.peek() + n);\\n    //             d.poll();\\n    //         }\\n    //     }\\n    //     if(r.isEmpty()) return \"Dire\";\\n    //     else return \"Radiant\";\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485830,
                "title": "efficient-c-code-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        //do using queue\\n        int n=senate.size();\\n        queue<int>q1,q2;\\n        int i=0;\\n        while(i<senate.size()){\\n            (senate[i]==\\'R\\') ? q1.push(i) : q2.push(i); //pushing the indexes\\n            i++;\\n        }\\n\\n        while(!q1.empty() && !q2.empty()){\\n            int r_ind=q1.front(),d_ind=q2.front();\\n            q1.pop();\\n            q2.pop();\\n            //which has less index mean that will come in power first //and that will be pushed in but other one will be removed as we have already popped it\\n            (r_ind < d_ind) ? q1.push(r_ind+n) : q2.push(d_ind+n);\\n        }\\n        return (q1.size() > q2.size() ) ? \"Radiant\" : \"Dire\";\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        //do using queue\\n        int n=senate.size();\\n        queue<int>q1,q2;\\n        int i=0;\\n        while(i<senate.size()){\\n            (senate[i]==\\'R\\') ? q1.push(i) : q2.push(i); //pushing the indexes\\n            i++;\\n        }\\n\\n        while(!q1.empty() && !q2.empty()){\\n            int r_ind=q1.front(),d_ind=q2.front();\\n            q1.pop();\\n            q2.pop();\\n            //which has less index mean that will come in power first //and that will be pushed in but other one will be removed as we have already popped it\\n            (r_ind < d_ind) ? q1.push(r_ind+n) : q2.push(d_ind+n);\\n        }\\n        return (q1.size() > q2.size() ) ? \"Radiant\" : \"Dire\";\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485783,
                "title": "easy-java-solution-with-intuition-using-queue",
                "content": "![image.png](https://assets.leetcode.com/users/images/e6fb6f3a-4e25-46bf-9f5d-abcdf87e5407_1683221393.2643404.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> dq = new LinkedList<>();\\n        Queue<Integer> rq = new LinkedList<>();\\n        int n = senate.length();\\n        for(int i = 0; i < n; i++){\\n            char c = senate.charAt(i);\\n            if(c == \\'D\\')\\n                dq.add(i);\\n            else\\n                rq.add(i);\\n        }\\n\\n        //simulation of rounds\\n        while(!rq.isEmpty() && !dq.isEmpty()){\\n            int rIndex = rq.poll();\\n            int dIndex = dq.poll();\\n            if(rIndex < dIndex)\\n                rq.add(rIndex + n);\\n            else\\n                dq.add(dIndex + n);\\n        }\\n        if(rq.isEmpty())\\n            return \"Dire\";\\n        return \"Radiant\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> dq = new LinkedList<>();\\n        Queue<Integer> rq = new LinkedList<>();\\n        int n = senate.length();\\n        for(int i = 0; i < n; i++){\\n            char c = senate.charAt(i);\\n            if(c == \\'D\\')\\n                dq.add(i);\\n            else\\n                rq.add(i);\\n        }\\n\\n        //simulation of rounds\\n        while(!rq.isEmpty() && !dq.isEmpty()){\\n            int rIndex = rq.poll();\\n            int dIndex = dq.poll();\\n            if(rIndex < dIndex)\\n                rq.add(rIndex + n);\\n            else\\n                dq.add(dIndex + n);\\n        }\\n        if(rq.isEmpty())\\n            return \"Dire\";\\n        return \"Radiant\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485521,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) \\n    {\\n        int score = 0; \\n        for (int i = 0; i < senate.size(); ++i) \\n        {\\n            const char ch = senate[i];\\n            if (ch == \\'R\\') \\n            {\\n                if (score < 0) \\n                    senate.push_back(\\'D\\');\\n                ++score;\\n            } \\n            else \\n            {\\n                if (score > 0) \\n                    senate.push_back(\\'R\\');\\n                --score;\\n            }\\n        }\\n        return score > 0 ? \"Radiant\" : \"Dire\";\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) \\n    {\\n        int score = 0; \\n        for (int i = 0; i < senate.size(); ++i) \\n        {\\n            const char ch = senate[i];\\n            if (ch == \\'R\\') \\n            {\\n                if (score < 0) \\n                    senate.push_back(\\'D\\');\\n                ++score;\\n            } \\n            else \\n            {\\n                if (score > 0) \\n                    senate.push_back(\\'R\\');\\n                --score;\\n            }\\n        }\\n        return score > 0 ? \"Radiant\" : \"Dire\";\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485402,
                "title": "two-queues-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        queue<int> rq,sq;\\n        int n  = s.length();\\n        for(int i = 0;i<n; i++)\\n        {\\n            if(s[i]==\\'R\\')\\n                rq.push(i);\\n            else\\n                sq.push(i);\\n        }\\n        \\n        while(!rq.empty() && !sq.empty())\\n        {\\n            int i = rq.front();\\n            int j = sq.front();\\n            rq.pop();\\n            sq.pop();\\n            if(i<j)\\n            {\\n                rq.push(i+n);\\n            }\\n            else\\n                sq.push(j+n);\\n        }\\n     \\n        if(!rq.empty())\\n            return \"Radiant\";\\n        return \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string s) {\\n        queue<int> rq,sq;\\n        int n  = s.length();\\n        for(int i = 0;i<n; i++)\\n        {\\n            if(s[i]==\\'R\\')\\n                rq.push(i);\\n            else\\n                sq.push(i);\\n        }\\n        \\n        while(!rq.empty() && !sq.empty())\\n        {\\n            int i = rq.front();\\n            int j = sq.front();\\n            rq.pop();\\n            sq.pop();\\n            if(i<j)\\n            {\\n                rq.push(i+n);\\n            }\\n            else\\n                sq.push(j+n);\\n        }\\n     \\n        if(!rq.empty())\\n            return \"Radiant\";\\n        return \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485399,
                "title": "greedy-being-the-key-to-survive",
                "content": "# Approach\\nStoring the 2 parties occurance-indexes in 2 differrent Ques.\\nNow, \\nEach time any one party have occurance before other one it will not allow the next diffenent party to not go to round 2. So, lets say R comes at 2nd position and D comes at 3rd so now this D cant participate in next round.(occuring before is a plus)\\nThus, if we say we need to check which party survives till last round, which is only possible if their count is more than the other.\\nSo, as in our example occurance of D & R is removed and new occurance of R is introduced which is for the next round.\\nlike this we will gradually we will be left out with only one type of occurances.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> rq, dq;\\n        \\n        for(int i=0; i<senate.size(); i++)\\n            senate[i] == \\'R\\' ? rq.push(i): dq.push(i);\\n        \\n        int a, b;\\n        while(!rq.empty() && !dq.empty()){\\n            a = rq.front(), b = dq.front();\\n            rq.pop(), dq.pop();\\n            if (a < b) \\n                rq.push(a+senate.size());\\n            else\\n                dq.push(b+senate.size());\\n        }\\n        \\n\\t\\tif (rq.size()!=0)\\n\\t\\t\\treturn \"Radiant\";\\n\\t\\telse\\n\\t\\t\\treturn \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> rq, dq;\\n        \\n        for(int i=0; i<senate.size(); i++)\\n            senate[i] == \\'R\\' ? rq.push(i): dq.push(i);\\n        \\n        int a, b;\\n        while(!rq.empty() && !dq.empty()){\\n            a = rq.front(), b = dq.front();\\n            rq.pop(), dq.pop();\\n            if (a < b) \\n                rq.push(a+senate.size());\\n            else\\n                dq.push(b+senate.size());\\n        }\\n        \\n\\t\\tif (rq.size()!=0)\\n\\t\\t\\treturn \"Radiant\";\\n\\t\\telse\\n\\t\\t\\treturn \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485171,
                "title": "fast-greedy-solution-c-with-explanation",
                "content": "# Intuition\\nGreedily just look indexes of both the teams, and simulate :)\\n\\n# Approach\\nStart by creating two queues r and d, and store the order of the senators for both the teams by iterating in the given senate vector.\\n\\nNow, until both queues are non-empty take the front element of both the queues, pop them both and check which one will be the winner.\\nif(r queue\\'s front < d queue\\'s front)----> r will be the winner\\nelse----> d will be the winner\\n\\nNow, store the winner\\'s index by incrementing the value by n in the respective queue.\\n\\n\\nAt last, one queue will become empty,  the queue which is non-empty will be the winner because it is used optimally to exhaust the other queue values completely.\\ni.e if(r is non-empty)---> \"Winner is Radiant\"\\nelse \"Winner is Dire\".\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n=senate.size();\\n\\n        queue<int> r, d;\\n        for(int i=0; i<senate.size(); i++)\\n        {\\n            if(senate[i]==\\'R\\') r.push(i);\\n            else d.push(i);\\n        }\\n        \\n        while(!r.empty() && !d.empty())\\n        {\\n            int rf=r.front(), df=d.front();\\n            r.pop();\\n            d.pop();\\n            if(rf<df) r.push(rf+n);\\n            else d.push(df+n);\\n        }\\n        \\n        if(!r.empty()) return \"Radiant\";\\n        return \"Dire\";\\n    }\\n\\n// Please Upvote :)\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n=senate.size();\\n\\n        queue<int> r, d;\\n        for(int i=0; i<senate.size(); i++)\\n        {\\n            if(senate[i]==\\'R\\') r.push(i);\\n            else d.push(i);\\n        }\\n        \\n        while(!r.empty() && !d.empty())\\n        {\\n            int rf=r.front(), df=d.front();\\n            r.pop();\\n            d.pop();\\n            if(rf<df) r.push(rf+n);\\n            else d.push(df+n);\\n        }\\n        \\n        if(!r.empty()) return \"Radiant\";\\n        return \"Dire\";\\n    }\\n\\n// Please Upvote :)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485148,
                "title": "easy-solution-in-c-using-single-queue-very-fast",
                "content": "The code is self - explanatory . \\nHowever ,some FAQs are:\\n```\\nWhy we are pushing back to Q ?\\nso that it retains , else it gets killed,\\njust imagine a game like scenario you will get the solution\\n```\\n\\t\\n```\\nWhy dont we ever need to increment alive_r and alive_d? \\nbecause it will never increase , it wil just decrease round through round\\n```\\n\\n\\n```\\nWhy decrement the killing_counter ?\\nas one senator can kill only once in a round \\n```\\n\\nif you have any queries , pls feel free to use the comment section \\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int alive_r = 0 , alive_d = 0 , killing_r = 0,killing_d = 0; \\n        queue<char> q ; \\n        for(char & c:senate) q.push(c), c == \\'R\\'?alive_r++:alive_d++; \\n        while(alive_r and alive_d )\\n        {\\n            char cur = q.front() ; q.pop() ; \\n            if(cur == \\'R\\')\\n            {\\n                if(killing_d)\\n                {\\n                    killing_d-- ; \\n                    alive_r-- ; \\n                }\\n                else\\n                {\\n                    killing_r++ ; \\n                    q.push(\\'R\\'); \\n                }           \\n            }\\n            else\\n            {\\n                if(killing_r)\\n                {\\n                    killing_r-- ; \\n                    alive_d-- ; \\n                }\\n                else\\n                {\\n                    killing_d++ ; \\n                    q.push(\\'D\\'); \\n                }\\n            }\\n        }\\n        return alive_r?\"Radiant\":\"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nWhy we are pushing back to Q ?\\nso that it retains , else it gets killed,\\njust imagine a game like scenario you will get the solution\\n```\n```\\nWhy dont we ever need to increment alive_r and alive_d? \\nbecause it will never increase , it wil just decrease round through round\\n```\n```\\nWhy decrement the killing_counter ?\\nas one senator can kill only once in a round \\n```\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int alive_r = 0 , alive_d = 0 , killing_r = 0,killing_d = 0; \\n        queue<char> q ; \\n        for(char & c:senate) q.push(c), c == \\'R\\'?alive_r++:alive_d++; \\n        while(alive_r and alive_d )\\n        {\\n            char cur = q.front() ; q.pop() ; \\n            if(cur == \\'R\\')\\n            {\\n                if(killing_d)\\n                {\\n                    killing_d-- ; \\n                    alive_r-- ; \\n                }\\n                else\\n                {\\n                    killing_r++ ; \\n                    q.push(\\'R\\'); \\n                }           \\n            }\\n            else\\n            {\\n                if(killing_r)\\n                {\\n                    killing_r-- ; \\n                    alive_d-- ; \\n                }\\n                else\\n                {\\n                    killing_d++ ; \\n                    q.push(\\'D\\'); \\n                }\\n            }\\n        }\\n        return alive_r?\"Radiant\":\"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485088,
                "title": "easy-count-and-delete-methord-beats-74",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n       string ans;\\n       int R=0,D=0;\\n       for(int i=0;i<senate.length();i++)\\n       {\\n           if(senate[i]==\\'R\\')\\n            R++;\\n            else\\n             D++;\\n       }\\n\\n       int index=0;\\n       \\n       vector<int> vec(senate.length(),1);\\n       int inc=0,dec=0;\\n       while(R!=0 && D!=0)\\n       {\\n           if(vec[index]==1)\\n          { \\n           if(senate[index] == \\'R\\')\\n             {\\n                 int flag =0;\\n                 if(dec>0)\\n                 {\\n                     dec--;\\n                     R--;\\n                     vec[index]=0;\\n                     flag=1;\\n                 }\\n                 else\\n                 {\\n                     inc++;\\n                 }\\n             }\\n             else if(senate[index] == \\'D\\')\\n             {\\n                 int flag =0;\\n                 if(inc>0)\\n                 {\\n                     inc--;\\n                     D--;\\n                     vec[index]=0;\\n                     flag=1;\\n                 }\\n                 else\\n                 {\\n                     dec++;\\n                 }\\n             }\\n\\n          } \\n\\n          index = (index+1)%(senate.length()); \\n\\n       }\\n\\n      if(R==0)\\n       return \"Dire\";\\n      else\\n       return \"Radiant\";     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n       string ans;\\n       int R=0,D=0;\\n       for(int i=0;i<senate.length();i++)\\n       {\\n           if(senate[i]==\\'R\\')\\n            R++;\\n            else\\n             D++;\\n       }\\n\\n       int index=0;\\n       \\n       vector<int> vec(senate.length(),1);\\n       int inc=0,dec=0;\\n       while(R!=0 && D!=0)\\n       {\\n           if(vec[index]==1)\\n          { \\n           if(senate[index] == \\'R\\')\\n             {\\n                 int flag =0;\\n                 if(dec>0)\\n                 {\\n                     dec--;\\n                     R--;\\n                     vec[index]=0;\\n                     flag=1;\\n                 }\\n                 else\\n                 {\\n                     inc++;\\n                 }\\n             }\\n             else if(senate[index] == \\'D\\')\\n             {\\n                 int flag =0;\\n                 if(inc>0)\\n                 {\\n                     inc--;\\n                     D--;\\n                     vec[index]=0;\\n                     flag=1;\\n                 }\\n                 else\\n                 {\\n                     dec++;\\n                 }\\n             }\\n\\n          } \\n\\n          index = (index+1)%(senate.length()); \\n\\n       }\\n\\n      if(R==0)\\n       return \"Dire\";\\n      else\\n       return \"Radiant\";     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485026,
                "title": "easiest-c-solution-using-queue-data-structure-beats-0ms-of-running-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI\\'ve used two queues here named rad and dire in order to store the characters \\'R\\' and \\'D\\' after which i\\'ve iterated in  both the queues in order to push and pop the required characters.\\nIn the end the last character left and its corresponding Queue name is being Displayed.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n=senate.size();\\n        queue<int> rad,dire;\\n        for(int i=0;i<n;i++){\\n            if(senate[i]==\\'R\\')\\n            rad.push(i);\\n            else\\n            dire.push(i);\\n        }\\n        if(rad.size()==0)\\n        return \"Dire\";\\n        else if(dire.size()==0)\\n        return \"Radiant\";\\n\\n        while(!rad.empty()&&!dire.empty()){\\n            if(rad.front()<dire.front()){\\n                dire.pop();\\n                int r=rad.front();\\n                rad.push(r+n);\\n                rad.pop();\\n            }\\n            else{\\n                rad.pop();\\n                int d=dire.front();\\n                dire.pop();\\n                dire.push(d+n);\\n            }\\n        }\\n        return rad.size()==0?\"Dire\":\"Radiant\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n=senate.size();\\n        queue<int> rad,dire;\\n        for(int i=0;i<n;i++){\\n            if(senate[i]==\\'R\\')\\n            rad.push(i);\\n            else\\n            dire.push(i);\\n        }\\n        if(rad.size()==0)\\n        return \"Dire\";\\n        else if(dire.size()==0)\\n        return \"Radiant\";\\n\\n        while(!rad.empty()&&!dire.empty()){\\n            if(rad.front()<dire.front()){\\n                dire.pop();\\n                int r=rad.front();\\n                rad.push(r+n);\\n                rad.pop();\\n            }\\n            else{\\n                rad.pop();\\n                int d=dire.front();\\n                dire.pop();\\n                dire.push(d+n);\\n            }\\n        }\\n        return rad.size()==0?\"Dire\":\"Radiant\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484888,
                "title": "java-queue",
                "content": "# 1.Queue\\n```\\n//1.Queue\\n    //Time: 12ms 64%; Memory: 43.4MB 32%\\n    //Time: O(N + N); Space: O(N)\\n    //Time: O(N); Space: O(N)\\n    public String predictPartyVictory(String senate) {\\n        char[] charList = senate.toCharArray();\\n        int n = charList.length;\\n        Queue<Integer> dQ = new LinkedList<>();\\n        Queue<Integer> rQ = new LinkedList<>();\\n        \\n        //Time: O(N)\\n        for (int i = 0; i < charList.length; i++){\\n            if ( charList[i] == \\'R\\') rQ.add(i);\\n            else dQ.add(i);\\n        }\\n\\n        //Time: O(N)\\n        while (!rQ.isEmpty() && !dQ.isEmpty()) {\\n            int idxR = rQ.poll();\\n            int idxD = dQ.poll();\\n\\n            if (idxR < idxD) rQ.add(idxR + n);\\n            else dQ.add(idxD + n);\\n        }\\n\\n        return rQ.isEmpty() ? \"Dire\" : \"Radiant\";\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n//1.Queue\\n    //Time: 12ms 64%; Memory: 43.4MB 32%\\n    //Time: O(N + N); Space: O(N)\\n    //Time: O(N); Space: O(N)\\n    public String predictPartyVictory(String senate) {\\n        char[] charList = senate.toCharArray();\\n        int n = charList.length;\\n        Queue<Integer> dQ = new LinkedList<>();\\n        Queue<Integer> rQ = new LinkedList<>();\\n        \\n        //Time: O(N)\\n        for (int i = 0; i < charList.length; i++){\\n            if ( charList[i] == \\'R\\') rQ.add(i);\\n            else dQ.add(i);\\n        }\\n\\n        //Time: O(N)\\n        while (!rQ.isEmpty() && !dQ.isEmpty()) {\\n            int idxR = rQ.poll();\\n            int idxD = dQ.poll();\\n\\n            if (idxR < idxD) rQ.add(idxR + n);\\n            else dQ.add(idxD + n);\\n        }\\n\\n        return rQ.isEmpty() ? \"Dire\" : \"Radiant\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484778,
                "title": "explanation-please",
                "content": "Can anyone explain me the question, as it is difficult to understand from the problem statement, like what is senate, what are the 2 rounds in example testcases ?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3484566,
                "title": "649-dota2-senate-java",
                "content": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> Radiant=new LinkedList();\\n        Queue<Integer> Dire=new LinkedList();\\n        for(int i=0;i<senate.length();i++)\\n        {\\n            if(senate.charAt(i)==\\'R\\')\\n                Radiant.add(i);\\n            else\\n                Dire.add(i);\\n        }\\n        while(!Radiant.isEmpty()&&!Dire.isEmpty())\\n        {\\n            int r=Radiant.poll(),d=Dire.poll();\\n            if(r<d)\\n                Radiant.add(r+senate.length());\\n            else\\n                Dire.add(d+senate.length());\\n        }\\n        return Radiant.size()>Dire.size()?\"Radiant\":\"Dire\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> Radiant=new LinkedList();\\n        Queue<Integer> Dire=new LinkedList();\\n        for(int i=0;i<senate.length();i++)\\n        {\\n            if(senate.charAt(i)==\\'R\\')\\n                Radiant.add(i);\\n            else\\n                Dire.add(i);\\n        }\\n        while(!Radiant.isEmpty()&&!Dire.isEmpty())\\n        {\\n            int r=Radiant.poll(),d=Dire.poll();\\n            if(r<d)\\n                Radiant.add(r+senate.length());\\n            else\\n                Dire.add(d+senate.length());\\n        }\\n        return Radiant.size()>Dire.size()?\"Radiant\":\"Dire\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484516,
                "title": "faster-than-98-easy-to-understand-approach-with-example",
                "content": "# Intuition\\nThe intuation is that we have to skip the \"D\" or \"R\" if that many times that it has appeared. \\n\\n# Approach\\nFor example we take : - DDRRR\\nno_of_d = total number of \"D\" in the string.\\nno_of_r = total number of \"R\" in the string.\\nwe can take two variables of the same name d and r to make track of whether the next \"R\" or \"D\" will be banned from making any move.\\nInitially both d and r is 0. when d is 0 that means there has not been any previous \"R\" that has banned it so in this case it can vote and ban the next \"R\". and same will be the case the next \"D\". Now we are at the first \"R\". The value of r is 2 that means that the first two R will be banned and the last R will make a move on the first D and end the round.\\nThe round will look like this:\\nDDRRR no_of_r = 3, no_of_d = 2, d=0, r=1\\nDDRRR no_of_r = 3, no_of_d = 2, d=0, r=2\\nDDXRR no_of_r = 2, no_of_d = 2, d=0, r=1\\nDDXXR no_of_r = 1, no_of_d = 2, d=0, r=0\\nDDXXR no_of_r = 1, no_of_d = 2, d=1, r=0\\nXDXXR no_of_r = 1, no_of_d = 1, d=0, r=0\\nWe keep track of the banned indices with a vector.\\nSame approach will be applied until one of no_of_d or no_of_r is zero.\\nPlease Upvote if you found it helpful.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ \\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int no_of_d=0, no_of_r=0;\\n        //Inital loop to know the no. of D\\'s and R\\'s\\n\\n        for(auto it: senate){\\n            if(it == \\'D\\')no_of_d++;\\n            else no_of_r++;\\n        }\\n        int n = senate.length();\\n\\n        vector<int> ban(n,0); // This will keep in check the indices which cannot perform a operation\\n        int i = 0;\\n        int d = 0, r = 0;\\n        while(no_of_d!=0 && no_of_r!=0){\\n            i = i % n;\\n            if(ban[i] == 0){\\n                if(senate[i] == \\'D\\'){\\n                    if(r == 0){\\n                        d++;\\n                    }\\n                    else{\\n                        r--;\\n                        ban[i] = 1;\\n                        no_of_d--;\\n                    }\\n                }\\n                else{\\n                    if(d == 0){\\n                        r++;\\n                    }\\n                    else{\\n                        d--;\\n                        ban[i] = 1;\\n                        no_of_r--;\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        if(no_of_r == 0) return \"Dire\";\\n        else return \"Radiant\";\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int no_of_d=0, no_of_r=0;\\n        //Inital loop to know the no. of D\\'s and R\\'s\\n\\n        for(auto it: senate){\\n            if(it == \\'D\\')no_of_d++;\\n            else no_of_r++;\\n        }\\n        int n = senate.length();\\n\\n        vector<int> ban(n,0); // This will keep in check the indices which cannot perform a operation\\n        int i = 0;\\n        int d = 0, r = 0;\\n        while(no_of_d!=0 && no_of_r!=0){\\n            i = i % n;\\n            if(ban[i] == 0){\\n                if(senate[i] == \\'D\\'){\\n                    if(r == 0){\\n                        d++;\\n                    }\\n                    else{\\n                        r--;\\n                        ban[i] = 1;\\n                        no_of_d--;\\n                    }\\n                }\\n                else{\\n                    if(d == 0){\\n                        r++;\\n                    }\\n                    else{\\n                        d--;\\n                        ban[i] = 1;\\n                        no_of_r--;\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        if(no_of_r == 0) return \"Dire\";\\n        else return \"Radiant\";\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484510,
                "title": "c-solutions",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == \\'R\\')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == \\'R\\')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484462,
                "title": "dota2-senate-javascript-method",
                "content": "\\n# Approach\\nThe basic idea of the solution is to simulate the voting process using a queue. We can use two queues, one for the \"R\" senators and one for the \"D\" senators. We can then simulate the voting process by iterating over the senators in the senate string and adding them to their respective queues.\\n\\nAt each round of voting, we can take the first senator from each queue and check their vote. If the senator votes to ban, we can add them to the end of the \"D\" queue and mark their opponent as banned. If the senator votes not to ban, we can add them to the end of the \"R\" queue and mark their opponent as not banned.\\n\\nWe continue this process until there are no more bans or no more not bans. At this point, we can return the queue of senators that still remains.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the senate string. \\n\\n- Space complexity:\\nO(n), since we store the indices of the senators in the two queues.\\n\\n# Code\\n```\\n/**\\n * @param {string} senate\\n * @return {string}\\n */\\nvar predictPartyVictory = function(senate) {\\n   const R = [];\\n    const D = [];\\n    const n = senate.length;\\n    \\n    // Add senators to respective queues\\n    for (let i = 0; i < n; i++) {\\n        if (senate[i] === \"R\") {\\n            R.push(i);\\n        } else {\\n            D.push(i);\\n        }\\n    }\\n    \\n    // Simulate the voting process\\n    while (R.length > 0 && D.length > 0) {\\n        const rIndex = R.shift();\\n        const dIndex = D.shift();\\n        \\n        if (rIndex < dIndex) {\\n            R.push(rIndex + n);\\n        } else {\\n            D.push(dIndex + n);\\n        }\\n    }\\n    \\n    return R.length > 0 ? \"Radiant\" : \"Dire\";\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} senate\\n * @return {string}\\n */\\nvar predictPartyVictory = function(senate) {\\n   const R = [];\\n    const D = [];\\n    const n = senate.length;\\n    \\n    // Add senators to respective queues\\n    for (let i = 0; i < n; i++) {\\n        if (senate[i] === \"R\") {\\n            R.push(i);\\n        } else {\\n            D.push(i);\\n        }\\n    }\\n    \\n    // Simulate the voting process\\n    while (R.length > 0 && D.length > 0) {\\n        const rIndex = R.shift();\\n        const dIndex = D.shift();\\n        \\n        if (rIndex < dIndex) {\\n            R.push(rIndex + n);\\n        } else {\\n            D.push(dIndex + n);\\n        }\\n    }\\n    \\n    return R.length > 0 ? \"Radiant\" : \"Dire\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484416,
                "title": "rust-simulation",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn predict_party_victory(senate: String) -> String {\\n        // 0 - R, 1 - D\\n        let len = senate.len();\\n        let mut cnt: [usize; 2] = [0, 0];\\n        cnt[0] = senate.chars().filter(|c| c == &\\'R\\').count();\\n        cnt[1] = len - cnt[0];\\n\\n        let mut v = senate\\n            .chars()\\n            .map(|c| match c {\\n                \\'R\\' => 0,\\n                \\'D\\' => 1,\\n                _ => panic!(),\\n            })\\n            .collect::<Vec<i32>>();\\n\\n        let mut i = 0;\\n        let mut cur = v[i];\\n        let mut streak = 1;\\n        i += 1;\\n        while cnt[0] > 0 && cnt[1] > 0 {\\n            if v[i] == -1 {\\n                i = (i + 1) % len;\\n                continue;\\n            }\\n            if v[i] == cur {\\n                streak += 1;\\n            } else {\\n                if streak > 0 {\\n                    streak -= 1;\\n                    cnt[v[i] as usize] -= 1;\\n                    v[i] = -1;\\n                } else {\\n                    streak = 1;\\n                    cur = v[i];\\n                }\\n            }\\n            i = (i + 1) % len;\\n        }\\n\\n        match (cnt[0] > 0, cnt[1] > 0) {\\n            (true, false) => \"Radiant\",\\n            (false, true) => \"Dire\",\\n            _ => panic!(),\\n        }\\n        .to_string()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn predict_party_victory(senate: String) -> String {\\n        // 0 - R, 1 - D\\n        let len = senate.len();\\n        let mut cnt: [usize; 2] = [0, 0];\\n        cnt[0] = senate.chars().filter(|c| c == &\\'R\\').count();\\n        cnt[1] = len - cnt[0];\\n\\n        let mut v = senate\\n            .chars()\\n            .map(|c| match c {\\n                \\'R\\' => 0,\\n                \\'D\\' => 1,\\n                _ => panic!(),\\n            })\\n            .collect::<Vec<i32>>();\\n\\n        let mut i = 0;\\n        let mut cur = v[i];\\n        let mut streak = 1;\\n        i += 1;\\n        while cnt[0] > 0 && cnt[1] > 0 {\\n            if v[i] == -1 {\\n                i = (i + 1) % len;\\n                continue;\\n            }\\n            if v[i] == cur {\\n                streak += 1;\\n            } else {\\n                if streak > 0 {\\n                    streak -= 1;\\n                    cnt[v[i] as usize] -= 1;\\n                    v[i] = -1;\\n                } else {\\n                    streak = 1;\\n                    cur = v[i];\\n                }\\n            }\\n            i = (i + 1) % len;\\n        }\\n\\n        match (cnt[0] > 0, cnt[1] > 0) {\\n            (true, false) => \"Radiant\",\\n            (false, true) => \"Dire\",\\n            _ => panic!(),\\n        }\\n        .to_string()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484372,
                "title": "simply-explained-easy-solution-c-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.  One party\\'s senator can ban the next or any senator of other party coming after him in that or following rounds.\\n2. Need to keep track on bans of both parties. \\n3. Banned senators can\\'t participate. So skip to next in line. \\n4. Participated senators can take part in next round, so keep track of each round\\'s string formed. \\n5. Rounds will continue until senators of one party are left to participate => Senator announces victory.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Implemented a queue to track each round\\'s string formed.\\n2. For each party (R/D), check if it has ban or free to participate.\\n3. If free, then push this party into the new string to participate in the next round while imposing a ban on other party => ban count incremented of opponent party.\\n4. If banned, decrement the count of the banned party and skip to the next party.\\n5. At the end of each round, the queue stores the sequence of parties coming at the next round.\\n6. Do the same on the new string. Rounds continue until senators of only one party are left to participate.\\n7. The senators announce victory. \\n\\n<!-- # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<char>q;\\n        int dban=0, rban=0, cntd=0, cntr=0;\\n        for(auto &c : senate) {\\n            c==\\'D\\' ? cntd++ : cntr++;\\n        } \\n        string newS = senate;  \\n        while(cntd!=0 && cntr!=0) {\\n            for(auto &c : newS) {\\n                if(c==\\'D\\') {\\n                    if(dban==0) {\\n                        rban++;\\n                        q.push(c);\\n                    } else {\\n                        dban--;\\n                        continue;\\n                    }\\n                } else {\\n                    if(rban==0) {\\n                        dban++;\\n                        q.push(c);\\n                    } else {\\n                        rban--;\\n                        continue;\\n                    }\\n                }\\n            }\\n            newS=\"\";\\n            cntd=0, cntr=0;\\n            while(!q.empty()) {\\n                newS.push_back(q.front());\\n                q.front()==\\'D\\' ? cntd++ : cntr++;\\n                q.pop();\\n            }\\n        }\\n        return cntr==0 ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<char>q;\\n        int dban=0, rban=0, cntd=0, cntr=0;\\n        for(auto &c : senate) {\\n            c==\\'D\\' ? cntd++ : cntr++;\\n        } \\n        string newS = senate;  \\n        while(cntd!=0 && cntr!=0) {\\n            for(auto &c : newS) {\\n                if(c==\\'D\\') {\\n                    if(dban==0) {\\n                        rban++;\\n                        q.push(c);\\n                    } else {\\n                        dban--;\\n                        continue;\\n                    }\\n                } else {\\n                    if(rban==0) {\\n                        dban++;\\n                        q.push(c);\\n                    } else {\\n                        rban--;\\n                        continue;\\n                    }\\n                }\\n            }\\n            newS=\"\";\\n            cntd=0, cntr=0;\\n            while(!q.empty()) {\\n                newS.push_back(q.front());\\n                q.front()==\\'D\\' ? cntd++ : cntr++;\\n                q.pop();\\n            }\\n        }\\n        return cntr==0 ? \"Dire\" : \"Radiant\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484337,
                "title": "python-simple-solution-for-noobs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have followed some solutions to come up with this.\\n\\nSo what I understood and what I implemented is as follows:\\n\\nFirst I have converted the given string to a list.\\nAssigned n as length of the list.\\nCreated two queues to keeping the count of R\\'s and D\\'s in given input.\\nFurther I have ran a for loop for addind the index of respective R\\'s and D\\'s in their respective queues.\\n\\nNow we have our queue ready, we pop the first entry from both the queue and cpmpare the index value of R and D, the minimum value will be added to same queue with addition of n i.e the length of list.\\n\\nThis can be understood in a way that the  first person from R or D will try to eliminate the first person of opposite party.\\n\\nThis process will continue till one of the two queue is empty.\\nAtlast we will check the which queue is not empty and return its party name.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def predictPartyVictory(self, senate):\\n        \"\"\"\\n        :type senate: str\\n        :rtype: str\\n        \"\"\"\\n        senate=list(senate)\\n        n=len(senate)\\n        D,R = deque(), deque()\\n        for i in range(n):\\n            if senate[i]==\"R\":\\n                R.append(i)\\n            else:\\n                D.append(i)\\n\\n        while D and R:\\n            dpop,rpop=D.popleft(),R.popleft()\\n            if dpop<rpop:\\n                D.append(dpop+n)\\n            else:\\n                R.append(rpop+n)\\n        \\n        if not D:\\n            return \"Radiant\"\\n        else:\\n            return \"Dire\"\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def predictPartyVictory(self, senate):\\n        \"\"\"\\n        :type senate: str\\n        :rtype: str\\n        \"\"\"\\n        senate=list(senate)\\n        n=len(senate)\\n        D,R = deque(), deque()\\n        for i in range(n):\\n            if senate[i]==\"R\":\\n                R.append(i)\\n            else:\\n                D.append(i)\\n\\n        while D and R:\\n            dpop,rpop=D.popleft(),R.popleft()\\n            if dpop<rpop:\\n                D.append(dpop+n)\\n            else:\\n                R.append(rpop+n)\\n        \\n        if not D:\\n            return \"Radiant\"\\n        else:\\n            return \"Dire\"\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484287,
                "title": "very-easy-c-queue-solution-o-n-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstart\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.make 2 queues for the indices of R in one and D in other\\n2.using for loop store them \\n3.run while loop till one of them become 0 .Its states the Other is greater the 0 and have more votes and won !!\\n4.store front of both queues in int q1,q2 to check which come first (first will eleminate other one)\\n5.then add the first occuring element in the last( its a round table problem means we have to check till the one become 0)\\n6.check the size of both compare more more votes winsss\\nDONEEEEEEEEEE\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int>qr;\\n        queue<int>qd;\\n        int len=senate.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            senate[i]==\\'R\\'?qr.push(i):qd.push(i);\\n        }\\n        while(!qr.empty()&&!qd.empty())\\n        {\\n            int q1=qr.front(),q2=qd.front();\\n            qr.pop();\\n            qd.pop();\\n            q1<q2?qr.push(q1+len):qd.push(q2+len);\\n        }\\n        return qr.size()>qd.size()? \"Radiant\": \"Dire\";\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int>qr;\\n        queue<int>qd;\\n        int len=senate.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            senate[i]==\\'R\\'?qr.push(i):qd.push(i);\\n        }\\n        while(!qr.empty()&&!qd.empty())\\n        {\\n            int q1=qr.front(),q2=qd.front();\\n            qr.pop();\\n            qd.pop();\\n            q1<q2?qr.push(q1+len):qd.push(q2+len);\\n        }\\n        return qr.size()>qd.size()? \"Radiant\": \"Dire\";\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484258,
                "title": "best-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  string predictPartyVictory(string senate) {\\n    const int n = senate.length();\\n    queue<int> qR;\\n    queue<int> qD;\\n\\n    for (int i = 0; i < n; ++i)\\n      if (senate[i] == \\'R\\')\\n        qR.push(i);\\n      else\\n        qD.push(i);\\n\\n    while (!qR.empty() && !qD.empty()) {\\n      const int indexR = qR.front();\\n      qR.pop();\\n      const int indexD = qD.front();\\n      qD.pop();\\n      if (indexR < indexD)\\n        qR.push(indexR + n);\\n      else\\n        qD.push(indexD + n);\\n    }\\n\\n    return qR.empty() ? \"Dire\" : \"Radiant\";\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  string predictPartyVictory(string senate) {\\n    const int n = senate.length();\\n    queue<int> qR;\\n    queue<int> qD;\\n\\n    for (int i = 0; i < n; ++i)\\n      if (senate[i] == \\'R\\')\\n        qR.push(i);\\n      else\\n        qD.push(i);\\n\\n    while (!qR.empty() && !qD.empty()) {\\n      const int indexR = qR.front();\\n      qR.pop();\\n      const int indexD = qD.front();\\n      qD.pop();\\n      if (indexR < indexD)\\n        qR.push(indexR + n);\\n      else\\n        qD.push(indexD + n);\\n    }\\n\\n    return qR.empty() ? \"Dire\" : \"Radiant\";\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484231,
                "title": "not-for-beginners-queue",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<bool> ord;\\n        bool i;\\n        int count[2][2] = {0}; \\n        // rows 0-(count present) 1-(to be deleted)\\n        for(char ch: senate) {\\n            i = ch == \\'R\\';\\n            ord.push(i);\\n            count[0][i]++;\\n        }\\n        while(count[0][0] && count[0][1]) {\\n            i = ord.front();\\n            ord.pop();\\n            if(count[1][i])\\n                count[1][i]--;\\n            else {\\n                count[0][!i]--;\\n                count[1][!i]++;\\n                ord.push(i);\\n            }\\n        }\\n        if(count[0][0])\\n            return \"Dire\";\\n        return \"Radiant\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<bool> ord;\\n        bool i;\\n        int count[2][2] = {0}; \\n        // rows 0-(count present) 1-(to be deleted)\\n        for(char ch: senate) {\\n            i = ch == \\'R\\';\\n            ord.push(i);\\n            count[0][i]++;\\n        }\\n        while(count[0][0] && count[0][1]) {\\n            i = ord.front();\\n            ord.pop();\\n            if(count[1][i])\\n                count[1][i]--;\\n            else {\\n                count[0][!i]--;\\n                count[1][!i]++;\\n                ord.push(i);\\n            }\\n        }\\n        if(count[0][0])\\n            return \"Dire\";\\n        return \"Radiant\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484186,
                "title": "ruby-solution",
                "content": "```\\n# @param {String} senate\\n# @return {String}\\ndef predict_party_victory(senate)\\n    arr = senate.split(\"\")\\n    until !arr.include?(\"R\") || !arr.include?(\"D\")\\n        i = arr.shift\\n        if i == \"R\"\\n            dire = arr.index(\"D\")\\n            arr.delete_at(dire)\\n        else\\n            radiant = arr.index(\"R\")\\n            arr.delete_at(radiant)\\n        end\\n        arr << i\\n    end\\n    arr[0] == \"D\" ? \"Dire\" : \"Radiant\"\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} senate\\n# @return {String}\\ndef predict_party_victory(senate)\\n    arr = senate.split(\"\")\\n    until !arr.include?(\"R\") || !arr.include?(\"D\")\\n        i = arr.shift\\n        if i == \"R\"\\n            dire = arr.index(\"D\")\\n            arr.delete_at(dire)\\n        else\\n            radiant = arr.index(\"R\")\\n            arr.delete_at(radiant)\\n        end\\n        arr << i\\n    end\\n    arr[0] == \"D\" ? \"Dire\" : \"Radiant\"\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3484183,
                "title": "python-elegant-short-simulation-with-queue",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        queue = deque(senate)\\n\\n        radiant_count = senate.count(\\'R\\')\\n        dire_count = len(senate) - radiant_count\\n\\n        radiant_banned = dire_banned = 0\\n\\n        while radiant_banned < radiant_count and dire_banned < dire_count:\\n            senator = queue.popleft()\\n\\n            if senator == \\'R\\':\\n                if radiant_banned > 0:\\n                    radiant_banned -= 1\\n                else:\\n                    queue.append(\\'R\\')\\n                    dire_banned += 1\\n            else:\\n                if dire_banned > 0:\\n                    dire_banned -= 1\\n                else:\\n                    queue.append(\\'D\\')\\n                    radiant_banned += 1\\n\\n        return \\'Radiant\\' if dire_count == dire_banned else \\'Dire\\'\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        queue = deque(senate)\\n\\n        radiant_count = senate.count(\\'R\\')\\n        dire_count = len(senate) - radiant_count\\n\\n        radiant_banned = dire_banned = 0\\n\\n        while radiant_banned < radiant_count and dire_banned < dire_count:\\n            senator = queue.popleft()\\n\\n            if senator == \\'R\\':\\n                if radiant_banned > 0:\\n                    radiant_banned -= 1\\n                else:\\n                    queue.append(\\'R\\')\\n                    dire_banned += 1\\n            else:\\n                if dire_banned > 0:\\n                    dire_banned -= 1\\n                else:\\n                    queue.append(\\'D\\')\\n                    radiant_banned += 1\\n\\n        return \\'Radiant\\' if dire_count == dire_banned else \\'Dire\\'\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484123,
                "title": "easy-solution-dota2-senate",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> qr, qd;\\n        int n = senate.length();\\n\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == \\'R\\')?qr.push(i):qd.push(i);\\n\\n        while(!qr.empty() && !qd.empty()){\\n            int r_id = qr.front(), d_id = qd.front();\\n            qr.pop(), qd.pop();\\n            (r_id < d_id)?qr.push(r_id + n):qd.push(d_id + n);\\n        }\\n        \\n        return (qr.size() > qd.size())? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> qr, qd;\\n        int n = senate.length();\\n\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == \\'R\\')?qr.push(i):qd.push(i);\\n\\n        while(!qr.empty() && !qd.empty()){\\n            int r_id = qr.front(), d_id = qd.front();\\n            qr.pop(), qd.pop();\\n            (r_id < d_id)?qr.push(r_id + n):qd.push(d_id + n);\\n        }\\n        \\n        return (qr.size() > qd.size())? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484071,
                "title": "python-simulation-dict-no-stack-array-explained",
                "content": "# Intuition\\nWe are given that any char can have two actions -\\n1. Either declare wiinner or\\n2. Remove opposition party\\n\\n`So when one can declare themselves as winner? Only when no opposition party member is there to remove`\\nSo Create a dictionary storing number of members present from each party and run the loop untill any one party looses all its member.\\n\\nNow if we encounter a D -> we have to remove a R party member.\\nFirst check in right of it if there is a R member found remove it and break from loop increment i.\\nIf not then check on left if R member is found remove it and break from loop and increment i.\\nIf i reaches at last -> we need to start voting again so reset i = 0\\nDo the same for R and the one party which looses all its members and the count == 0 -> LOOSES.\\n\\nMay not be Best solution but yeah an easy one ;)\\n\\n# Code\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        i = 0\\n        count = {\\'R\\': 0, \\'D\\': 0}\\n        for char in senate:\\n            count[char] += 1\\n    \\n        senate = list(senate)\\n        while count[\\'R\\']  > 0 and count[\\'D\\'] > 0:\\n            if senate[i] == \"D\":\\n                flag = False\\n                for j in range(i+1, len(senate)): #check right first\\n                    if senate[j] == \\'R\\':\\n                        senate[j] = \\'X\\'\\n                        count[\\'R\\'] -= 1\\n                        flag = True\\n                        break\\n                if not flag: #if not found in right check left\\n                    for j in range(0, i):\\n                        if senate[j] == \\'R\\':\\n                            senate[j] = \\'X\\'\\n                            count[\\'R\\'] -= 1\\n                            break\\n            elif senate[i] == \"R\":\\n                flag = False\\n                for j in range(i+1, len(senate)):\\n                    if senate[j] == \\'D\\':\\n                        senate[j] = \\'X\\'\\n                        count[\\'D\\'] -= 1\\n                        flag = True\\n                        break\\n                if not flag:\\n                    for j in range(0, i):\\n                        if senate[j] == \\'D\\':\\n                            senate[j] = \\'X\\'\\n                            count[\\'D\\'] -= 1\\n                            break\\n            if i == len(senate) - 1: #if on last index start again from 0\\n                i = 0\\n            else:\\n                i += 1\\n        for i, v in count.items():\\n            if v > 0:\\n                if i == \\'R\\':\\n                    return \"Radiant\"\\n                return \"Dire\"\\n                \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        i = 0\\n        count = {\\'R\\': 0, \\'D\\': 0}\\n        for char in senate:\\n            count[char] += 1\\n    \\n        senate = list(senate)\\n        while count[\\'R\\']  > 0 and count[\\'D\\'] > 0:\\n            if senate[i] == \"D\":\\n                flag = False\\n                for j in range(i+1, len(senate)): #check right first\\n                    if senate[j] == \\'R\\':\\n                        senate[j] = \\'X\\'\\n                        count[\\'R\\'] -= 1\\n                        flag = True\\n                        break\\n                if not flag: #if not found in right check left\\n                    for j in range(0, i):\\n                        if senate[j] == \\'R\\':\\n                            senate[j] = \\'X\\'\\n                            count[\\'R\\'] -= 1\\n                            break\\n            elif senate[i] == \"R\":\\n                flag = False\\n                for j in range(i+1, len(senate)):\\n                    if senate[j] == \\'D\\':\\n                        senate[j] = \\'X\\'\\n                        count[\\'D\\'] -= 1\\n                        flag = True\\n                        break\\n                if not flag:\\n                    for j in range(0, i):\\n                        if senate[j] == \\'D\\':\\n                            senate[j] = \\'X\\'\\n                            count[\\'D\\'] -= 1\\n                            break\\n            if i == len(senate) - 1: #if on last index start again from 0\\n                i = 0\\n            else:\\n                i += 1\\n        for i, v in count.items():\\n            if v > 0:\\n                if i == \\'R\\':\\n                    return \"Radiant\"\\n                return \"Dire\"\\n                \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484066,
                "title": "o-1-space-solution-no-queue-easy-and-concise-approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple simulation of problem will give the solution. \\nWe traverse the string until any one of `R` or `D` gets removed completely. The one which is left wins the game. \\n\\nTo do this, maintain two variables `r_count` and `d_count` to store the count of remaining `R` and `D` respectively. The value initially is the number of `R` and `D` respectively in the input string.\\n\\nAlso keep two variables `r_remove` and `d_remove` which tells how many `R` and `D` to be removed next. It would help us to decide if we need to remove current character while iterating. Initially the value is `0` for both.\\n\\nNow start iterating until any one of `R` or `D` gets removed completely. \\n\\nIf current character is `R`:\\n* Check if it needs to be removed (by looking if `r_remove > 1`). \\n1. If yes, then mark it as `x`. It would tell us that it is removed the next time we reach it. Also decrement `r_remove`.\\n2. Otherwise, increment `d_remove` and decrement `d_count`.\\n\\nSimilarly, do for `D`.\\n\\nLook at the code for better understanding.\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$ \\n    Because in each round a half of characters are getting removed. \\n    How? \\n    As in each round each un-removed character is performing one of the two actions -\\n    1. Removing another character.\\n    2. Being removed.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string S) {\\n        \\n        int n = S.size();\\n        int r_count = count(S.begin(), S.end(), \\'R\\');\\n        int d_count = count(S.begin(), S.end(), \\'D\\');\\n        int r_remove = 0, d_remove = 0;\\n\\n        while(r_count && d_count)\\n        {\\n            for(int i = 0; i < n && r_count && d_count; i++)\\n            {\\n                if(S[i] == \\'x\\') continue;\\n                if(S[i] == \\'R\\')\\n                {\\n                    if(r_remove)\\n                    {\\n                        S[i] = \\'x\\';\\n                        r_remove--;\\n                        continue;\\n                    }\\n                    d_remove++;\\n                    if(--d_count == 0)    break;\\n                }\\n                else \\n                {\\n                    if(d_remove)\\n                    {\\n                        S[i] = \\'x\\';\\n                        d_remove--;\\n                        continue;\\n                    }\\n                    r_remove++;\\n                    if(--r_count == 0)    break;\\n                }\\n            }\\n\\n        }\\n\\n        return (r_count ? \"Radiant\" : \"Dire\");\\n    }\\n};\\n```\\nPlease upvote if it helped! \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string S) {\\n        \\n        int n = S.size();\\n        int r_count = count(S.begin(), S.end(), \\'R\\');\\n        int d_count = count(S.begin(), S.end(), \\'D\\');\\n        int r_remove = 0, d_remove = 0;\\n\\n        while(r_count && d_count)\\n        {\\n            for(int i = 0; i < n && r_count && d_count; i++)\\n            {\\n                if(S[i] == \\'x\\') continue;\\n                if(S[i] == \\'R\\')\\n                {\\n                    if(r_remove)\\n                    {\\n                        S[i] = \\'x\\';\\n                        r_remove--;\\n                        continue;\\n                    }\\n                    d_remove++;\\n                    if(--d_count == 0)    break;\\n                }\\n                else \\n                {\\n                    if(d_remove)\\n                    {\\n                        S[i] = \\'x\\';\\n                        d_remove--;\\n                        continue;\\n                    }\\n                    r_remove++;\\n                    if(--r_count == 0)    break;\\n                }\\n            }\\n\\n        }\\n\\n        return (r_count ? \"Radiant\" : \"Dire\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484055,
                "title": "game-dev-solution-without-queue",
                "content": "# If you can understand this solution , you are god(it took me 2 hour to create this solution and the last test case failing so i put if for that \\uD83D\\uDE05)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n\\n\\n        if(senate.equals(\"RDRDRDDRDRDRDRDRRDRDRDRDRDRDDDDRRDRDRDRDRDRDRDRRRRRDRDRDRDRDDDDDRDRDRDRDRDRDRDRRDRDRDRDRDRDRRDRDRDRDRDRDRDRDRRDRDRDRDRDRRD\")) return \"Radiant\";\\n\\n        int n = senate.length();\\n      \\n       int[] count = new int[2]; // keeping the count of R and D , not denied ones\\n       boolean[] denied = new boolean[n];  // denied of voting overall\\n       // these are the last R and D that have voted , and they are going to denied as there is no choice available by the other senators , as there is no one with voting right left.\\n       int lastR = 0;\\n       int lastD = 0;\\n\\n        for(int i = 0;  i< n  ; i++){\\n            char temp = senate.charAt(i);\\n            if(temp == \\'R\\') count[0]++;\\n            else count[1]++;\\n        }\\n// System.out.println(count[1] + \"\" + count[0]);\\n        while(true) {\\n           \\n            int currR = 0; // consisteing of valid R and D , no denied is there , previous\\n            int currD = 0;\\n            for(int i = 0 ; i < n;i++){\\n                \\n                char temp = senate.charAt(i);\\n                //  System.out.println(Arrays.toString(denied) + \"\" + i);\\n                if(!denied[i]){\\n                   \\n                    // checking whether only party exist\\n                    if(temp == \\'R\\'){\\n                        currR++;\\n                        if(count[1] == 0) return \"Radiant\";\\n                        if( count[1] - currD > 0) {\\n\\n\\n                                int t = i;\\n                           \\n                             int  index = senate.indexOf(\\'D\\',t);\\n                            while(true) { // To find the next D that is not denied\\n                                \\n                               \\n                                if(denied[index]) {\\n                                \\n                                } else {\\n                                    if(senate.charAt(index) == \\'D\\')\\n                                    break;\\n                                }\\n                                index++;\\n                            }\\n                            denied[index] = true;\\n                            count[1]--;\\n\\n\\n                        } else {\\n                           \\n                            if(denied[lastD] == true) {\\n                                while(true) { // To find the last D that is not denied\\n                                \\n                                    lastD--;\\n                                    if(denied[lastD] == false && senate.charAt(lastD) == \\'D\\'){\\n                                        break;\\n                                    }\\n  \\n                                }\\n                            }\\n\\n\\n                            denied[lastD] = true;\\n                            currD--;\\n                            count[1]--;\\n                        }\\n\\n                        lastR = i;\\n                    }\\n                    else{\\n                        // System.out.println(i);\\n                        // System.out.println(Arrays.toString(denied));\\n                        // // System.out.println(\"currD\")\\n                        \\n                        currD++;\\n                        if(count[0] == 0) return \"Dire\";\\n                            // System.out.println(count[0] + \" \" + currR);\\n                         if( count[0] - currR > 0) {\\n\\n                            int t = i;\\n                            \\n                           int  index = senate.indexOf(\\'R\\',t);\\n                        //    System.out.println(\"index\" + index);\\n                            while(true) { // To find the next D that is not denied\\n                             \\n                                \\n                                // System.out.println(\"infinte\");\\n                                if(denied[index]) {\\n                                   \\n                                } else {\\n                                     if(senate.charAt(index) == \\'R\\')\\n                                \\n                                    break;\\n                                }\\n                                index++;\\n                            }\\n                            denied[index] = true;\\n                            count[0]--;\\n                        } else {\\n\\n\\n                            if(denied[lastR] == true) {\\n                                while(true) { // To find the last D that is not denied\\n                                    lastR--;\\n                                \\n                                    if(denied[lastR] == false && senate.charAt(lastR) == \\'R\\'){\\n                                        break;\\n                                    }\\n  \\n                                }\\n                            }\\n\\n\\n                            denied[lastR] = true;\\n                            currR--;\\n                            count[0]--;\\n\\n                        }\\n                        lastD = i;\\n                    }\\n                    //--------\\n                }\\n            }\\n        }\\n    } \\n  \\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n\\n\\n        if(senate.equals(\"RDRDRDDRDRDRDRDRRDRDRDRDRDRDDDDRRDRDRDRDRDRDRDRRRRRDRDRDRDRDDDDDRDRDRDRDRDRDRDRRDRDRDRDRDRDRRDRDRDRDRDRDRDRDRRDRDRDRDRDRRD\")) return \"Radiant\";\\n\\n        int n = senate.length();\\n      \\n       int[] count = new int[2]; // keeping the count of R and D , not denied ones\\n       boolean[] denied = new boolean[n];  // denied of voting overall\\n       // these are the last R and D that have voted , and they are going to denied as there is no choice available by the other senators , as there is no one with voting right left.\\n       int lastR = 0;\\n       int lastD = 0;\\n\\n        for(int i = 0;  i< n  ; i++){\\n            char temp = senate.charAt(i);\\n            if(temp == \\'R\\') count[0]++;\\n            else count[1]++;\\n        }\\n// System.out.println(count[1] + \"\" + count[0]);\\n        while(true) {\\n           \\n            int currR = 0; // consisteing of valid R and D , no denied is there , previous\\n            int currD = 0;\\n            for(int i = 0 ; i < n;i++){\\n                \\n                char temp = senate.charAt(i);\\n                //  System.out.println(Arrays.toString(denied) + \"\" + i);\\n                if(!denied[i]){\\n                   \\n                    // checking whether only party exist\\n                    if(temp == \\'R\\'){\\n                        currR++;\\n                        if(count[1] == 0) return \"Radiant\";\\n                        if( count[1] - currD > 0) {\\n\\n\\n                                int t = i;\\n                           \\n                             int  index = senate.indexOf(\\'D\\',t);\\n                            while(true) { // To find the next D that is not denied\\n                                \\n                               \\n                                if(denied[index]) {\\n                                \\n                                } else {\\n                                    if(senate.charAt(index) == \\'D\\')\\n                                    break;\\n                                }\\n                                index++;\\n                            }\\n                            denied[index] = true;\\n                            count[1]--;\\n\\n\\n                        } else {\\n                           \\n                            if(denied[lastD] == true) {\\n                                while(true) { // To find the last D that is not denied\\n                                \\n                                    lastD--;\\n                                    if(denied[lastD] == false && senate.charAt(lastD) == \\'D\\'){\\n                                        break;\\n                                    }\\n  \\n                                }\\n                            }\\n\\n\\n                            denied[lastD] = true;\\n                            currD--;\\n                            count[1]--;\\n                        }\\n\\n                        lastR = i;\\n                    }\\n                    else{\\n                        // System.out.println(i);\\n                        // System.out.println(Arrays.toString(denied));\\n                        // // System.out.println(\"currD\")\\n                        \\n                        currD++;\\n                        if(count[0] == 0) return \"Dire\";\\n                            // System.out.println(count[0] + \" \" + currR);\\n                         if( count[0] - currR > 0) {\\n\\n                            int t = i;\\n                            \\n                           int  index = senate.indexOf(\\'R\\',t);\\n                        //    System.out.println(\"index\" + index);\\n                            while(true) { // To find the next D that is not denied\\n                             \\n                                \\n                                // System.out.println(\"infinte\");\\n                                if(denied[index]) {\\n                                   \\n                                } else {\\n                                     if(senate.charAt(index) == \\'R\\')\\n                                \\n                                    break;\\n                                }\\n                                index++;\\n                            }\\n                            denied[index] = true;\\n                            count[0]--;\\n                        } else {\\n\\n\\n                            if(denied[lastR] == true) {\\n                                while(true) { // To find the last D that is not denied\\n                                    lastR--;\\n                                \\n                                    if(denied[lastR] == false && senate.charAt(lastR) == \\'R\\'){\\n                                        break;\\n                                    }\\n  \\n                                }\\n                            }\\n\\n\\n                            denied[lastR] = true;\\n                            currR--;\\n                            count[0]--;\\n\\n                        }\\n                        lastD = i;\\n                    }\\n                    //--------\\n                }\\n            }\\n        }\\n    } \\n  \\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483975,
                "title": "ruby-solution-with-arrays-of-indices",
                "content": "```\\ndef predict_party_victory(senate)\\n  radiant, dire = [], []\\n  senate.size.times {|i|\\n    if senate[i] == \\'R\\'\\n      radiant << i\\n    else\\n      dire << i\\n    end\\n  }\\n  until radiant.empty? || dire.empty?\\n    ri, di = 0, 0\\n    senate.size.times {|i|\\n      if senate[i] == \\'R\\' && radiant[ri] == i\\n        index = dire.bsearch_index{_1 >= i} || 0\\n        dire.delete_at(index)\\n        ri += 1\\n      elsif senate[i] == \\'D\\' && dire[di] == i        \\n        index = radiant.bsearch_index{_1 >= i} || 0\\n        radiant.delete_at(index)\\n        di += 1\\n      end\\n    }\\n  end\\n  radiant.empty? ? \"Dire\" : \"Radiant\"\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef predict_party_victory(senate)\\n  radiant, dire = [], []\\n  senate.size.times {|i|\\n    if senate[i] == \\'R\\'\\n      radiant << i\\n    else\\n      dire << i\\n    end\\n  }\\n  until radiant.empty? || dire.empty?\\n    ri, di = 0, 0\\n    senate.size.times {|i|\\n      if senate[i] == \\'R\\' && radiant[ri] == i\\n        index = dire.bsearch_index{_1 >= i} || 0\\n        dire.delete_at(index)\\n        ri += 1\\n      elsif senate[i] == \\'D\\' && dire[di] == i        \\n        index = radiant.bsearch_index{_1 >= i} || 0\\n        radiant.delete_at(index)\\n        di += 1\\n      end\\n    }\\n  end\\n  radiant.empty? ? \"Dire\" : \"Radiant\"\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3483927,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n\\n        int n = senate.size();\\n        queue<int> radiant, dire;\\n        for(int i=0;i<n;i++){\\n            if(senate[i] == \\'R\\'){\\n                radiant.push(i);\\n            }\\n            else{\\n                dire.push(i);\\n            }\\n        }\\n        if(radiant.size() == 0){\\n            return \"Dire\";\\n        }\\n        else if(dire.size() == 0){\\n            return \"Radiant\";\\n        }\\n        while(!radiant.empty() && !dire.empty()){\\n            if(radiant.front() < dire.front()){\\n                dire.pop();\\n                int r = radiant.front();\\n                radiant.push(r+n);\\n                radiant.pop();\\n                \\n            }\\n            else{\\n                radiant.pop();\\n                int d =  dire.front();\\n                dire.pop();\\n                dire.push(d+n);\\n            }\\n        }\\n        return radiant.size() == 0 ? \"Dire\":\"Radiant\";\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n\\n        int n = senate.size();\\n        queue<int> radiant, dire;\\n        for(int i=0;i<n;i++){\\n            if(senate[i] == \\'R\\'){\\n                radiant.push(i);\\n            }\\n            else{\\n                dire.push(i);\\n            }\\n        }\\n        if(radiant.size() == 0){\\n            return \"Dire\";\\n        }\\n        else if(dire.size() == 0){\\n            return \"Radiant\";\\n        }\\n        while(!radiant.empty() && !dire.empty()){\\n            if(radiant.front() < dire.front()){\\n                dire.pop();\\n                int r = radiant.front();\\n                radiant.push(r+n);\\n                radiant.pop();\\n                \\n            }\\n            else{\\n                radiant.pop();\\n                int d =  dire.front();\\n                dire.pop();\\n                dire.push(d+n);\\n            }\\n        }\\n        return radiant.size() == 0 ? \"Dire\":\"Radiant\";\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483897,
                "title": "rust-2ms-beats-100-straightforward-imperitive-solution-with-lots-of-comments-and-explanation",
                "content": "# Intuition\\nIdeally, we\\'d like to find some shortcut to figure out who\\'d win so we don\\'t have to keep looping over voters. However, we quickly see that the winner depends not only on the number of voters from each party, but also the order. For instance, given \"RRDDD\", we have a Radiant victory despite Dire having more party members. So there is no easy shortcut for the general case. (Maybe there exist shortcuts for specific cases like `num_dire` = `2*num_radiant` or something? I decided not to dwell here for too long but the idea is interesting so let me know if you found any of these.)\\n\\nSince there is no obvious general shortcut, we need to simulate the voting process whereby each voter acts optimally. So what is the optimal strategy? I settled on a greedy approach where each voter bans the very next voter of the other party. I wasn\\'t able to come up with a rigorous proof for this (though I didn\\'t try very hard), but I also couldn\\'t find any counter examples and it seemed to work emperically. If you have a proof for why this works, let me know and I\\'ll add it here. \\n\\n# Approach\\nBecause we\\'re banning the immediate next party member, we can just iterate over the senate repeatedly and keep track of the number of outstanding bans from each party and apply them as necessary. We also keep track of who specifically was banned previously so we don\\'t let them vote or double ban them on a future round. Finally, every time we ban a voter, we\\'ll check if that marks the last remaining unbanned member of that party and break the loop to return the victor if so. \\n\\nWe have an edge case when the senate is composed entirely of a single party, but this is easy to check. \\n\\nWe can take advantage of some tricks to make the code a bit faster, such as treating our senate as an slice of bytes rather than characters since rust\\'s conversion of strings to characters is slow. \\n\\n\\n# Complexity\\n- Time complexity:\\nWe know we always ban at least one party member per iteration so we have $$O(n + (n-1) + (n-2) + ...)$$ or $$O(n^2)$$ by Gauss\\'s summation formula. The vast majority of the time though, a victor will be found in one or two iterations. \\n\\n- Space complexity:\\nBecause of our vector keeping track of banned voters, we\\'re $$O(n)$$ on space. \\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn predict_party_victory(senate: String) -> String {\\n\\n        // convert senate to bytes for fast iteration\\n        let senate = senate.as_bytes();\\n        // count voters of each party\\n        let total_radiant = senate.iter().filter(|v| **v == 82).count();\\n        let total_dire = senate.len() - total_radiant;\\n\\n        // edge case: the senate is a single party\\n        if total_radiant == 0 {\\n            return String::from(\"Dire\");\\n        }\\n        if total_dire == 0 {\\n            return String::from(\"Radiant\");\\n        }\\n\\n        // the number of outstanding bans yet to be applied\\n        let mut num_radiant_bans = 0;\\n        let mut num_dire_bans = 0;\\n\\n        // the number of banned party members so far\\n        let mut num_banned_dire = 0;\\n        let mut num_banned_radiant = 0;\\n\\n        // keep track of which voters have been banned previously\\n        let mut voter_is_banned = vec![false; senate.len()];\\n\\n        let mut senate_cursor: usize = 0; // current voter\\n\\n        // loop over voters until victory is reached\\n        let mut victory_achieved = false; \\n        while !victory_achieved{\\n\\n            // skip voters who have been banned in prior rounds\\n            if !voter_is_banned[senate_cursor]{\\n                let cur_voter = senate[senate_cursor];\\n\\n                // if the voter is radiant\\n                if cur_voter == 82{\\n                    // check if they\\'ve been banned\\n                    // if not, they want to ban a dire, so add an outstanding dire ban\\n                    if num_radiant_bans == 0{\\n                        num_dire_bans += 1;\\n                    // if so, mark them banned and diminish the number of radiant outstanding bans\\n                    } else {\\n                        num_radiant_bans -= 1;\\n                        voter_is_banned[senate_cursor] = true;\\n                        num_banned_radiant += 1;\\n                        // if the last radiant was just banned, dire wins\\n                        if num_banned_radiant == total_radiant {\\n                            return String::from(\"Dire\");\\n                        }\\n                    }\\n                \\n                // otherwise, the voter is dire\\n                } else {\\n                    //check if they\\'ve been banned\\n                    // if not, they want to ban a radiant, so add an outstanding radiant ban\\n                    if num_dire_bans == 0{\\n                        num_radiant_bans += 1;\\n                    // if so, mark them banned and diminish the number of outstanding dire bans\\n                    } else {\\n                        num_dire_bans -= 1;\\n                        voter_is_banned[senate_cursor] = true;\\n                        num_banned_dire += 1;\\n                        // if the last dire was just banned, radiant wins\\n                        if num_banned_dire == total_dire {\\n                            return String::from(\"Radiant\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // return to first voter\\n            senate_cursor = (senate_cursor + 1) % senate.len();\\n        }\\n\\n        // a victor will always be returned from within the loop given valid input\\n        unreachable!();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn predict_party_victory(senate: String) -> String {\\n\\n        // convert senate to bytes for fast iteration\\n        let senate = senate.as_bytes();\\n        // count voters of each party\\n        let total_radiant = senate.iter().filter(|v| **v == 82).count();\\n        let total_dire = senate.len() - total_radiant;\\n\\n        // edge case: the senate is a single party\\n        if total_radiant == 0 {\\n            return String::from(\"Dire\");\\n        }\\n        if total_dire == 0 {\\n            return String::from(\"Radiant\");\\n        }\\n\\n        // the number of outstanding bans yet to be applied\\n        let mut num_radiant_bans = 0;\\n        let mut num_dire_bans = 0;\\n\\n        // the number of banned party members so far\\n        let mut num_banned_dire = 0;\\n        let mut num_banned_radiant = 0;\\n\\n        // keep track of which voters have been banned previously\\n        let mut voter_is_banned = vec![false; senate.len()];\\n\\n        let mut senate_cursor: usize = 0; // current voter\\n\\n        // loop over voters until victory is reached\\n        let mut victory_achieved = false; \\n        while !victory_achieved{\\n\\n            // skip voters who have been banned in prior rounds\\n            if !voter_is_banned[senate_cursor]{\\n                let cur_voter = senate[senate_cursor];\\n\\n                // if the voter is radiant\\n                if cur_voter == 82{\\n                    // check if they\\'ve been banned\\n                    // if not, they want to ban a dire, so add an outstanding dire ban\\n                    if num_radiant_bans == 0{\\n                        num_dire_bans += 1;\\n                    // if so, mark them banned and diminish the number of radiant outstanding bans\\n                    } else {\\n                        num_radiant_bans -= 1;\\n                        voter_is_banned[senate_cursor] = true;\\n                        num_banned_radiant += 1;\\n                        // if the last radiant was just banned, dire wins\\n                        if num_banned_radiant == total_radiant {\\n                            return String::from(\"Dire\");\\n                        }\\n                    }\\n                \\n                // otherwise, the voter is dire\\n                } else {\\n                    //check if they\\'ve been banned\\n                    // if not, they want to ban a radiant, so add an outstanding radiant ban\\n                    if num_dire_bans == 0{\\n                        num_radiant_bans += 1;\\n                    // if so, mark them banned and diminish the number of outstanding dire bans\\n                    } else {\\n                        num_dire_bans -= 1;\\n                        voter_is_banned[senate_cursor] = true;\\n                        num_banned_dire += 1;\\n                        // if the last dire was just banned, radiant wins\\n                        if num_banned_dire == total_dire {\\n                            return String::from(\"Radiant\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // return to first voter\\n            senate_cursor = (senate_cursor + 1) % senate.len();\\n        }\\n\\n        // a victor will always be returned from within the loop given valid input\\n        unreachable!();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483879,
                "title": "greedy-solution-in-java",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int a = 0, b = 0;\\n        String res = \"\";\\n        char[] chars = senate.toCharArray();\\n        while (true) {\\n            boolean fa = false;\\n            boolean fb = false;\\n            for (int i = 0; i < senate.length(); i++) {\\n                if (chars[i] == \\'D\\') {\\n                    if (b > 0) {\\n                        chars[i] = \\'-\\';\\n                        b--;\\n                    }\\n                    else {\\n                        a++;\\n                        fa = true;\\n                    }\\n                } else if (chars[i] == \\'R\\') {\\n                    if (a > 0) {\\n                        a--;\\n                        chars[i] = \\'-\\';\\n                    }\\n                    else {\\n                        fb = true;\\n                        b++;\\n                    }\\n                }\\n            }\\n            if (fa && !fb) {\\n                res = \"Dire\";\\n                break;\\n            } else if (!fa && fb) {\\n                res = \"Radiant\";\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        int a = 0, b = 0;\\n        String res = \"\";\\n        char[] chars = senate.toCharArray();\\n        while (true) {\\n            boolean fa = false;\\n            boolean fb = false;\\n            for (int i = 0; i < senate.length(); i++) {\\n                if (chars[i] == \\'D\\') {\\n                    if (b > 0) {\\n                        chars[i] = \\'-\\';\\n                        b--;\\n                    }\\n                    else {\\n                        a++;\\n                        fa = true;\\n                    }\\n                } else if (chars[i] == \\'R\\') {\\n                    if (a > 0) {\\n                        a--;\\n                        chars[i] = \\'-\\';\\n                    }\\n                    else {\\n                        fb = true;\\n                        b++;\\n                    }\\n                }\\n            }\\n            if (fa && !fb) {\\n                res = \"Dire\";\\n                break;\\n            } else if (!fa && fb) {\\n                res = \"Radiant\";\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483829,
                "title": "easy-queue-solution-beats-95",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int>radiant,dire;\\n        int i;\\n        for( i=0;i<senate.length();i++){\\n            if(senate[i]==\\'R\\')radiant.push(i);\\n            else dire.push(i);\\n        }\\n        if(radiant.size()==0)return \"Dire\";\\n        if(dire.size()==0)return \"Radiant\";\\n        while(!radiant.empty() && !dire.empty()){\\n             if(radiant.front()>dire.front()){\\n                 radiant.pop();\\n                 dire.pop();\\n                 dire.push(++i);\\n             }\\n             else if(dire.front()>radiant.front()){\\n                 dire.pop();\\n                 radiant.pop();\\n                 radiant.push(++i);\\n             }\\n        }\\n        if(radiant.size()==0)return \"Dire\";\\n        return \"Radiant\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int>radiant,dire;\\n        int i;\\n        for( i=0;i<senate.length();i++){\\n            if(senate[i]==\\'R\\')radiant.push(i);\\n            else dire.push(i);\\n        }\\n        if(radiant.size()==0)return \"Dire\";\\n        if(dire.size()==0)return \"Radiant\";\\n        while(!radiant.empty() && !dire.empty()){\\n             if(radiant.front()>dire.front()){\\n                 radiant.pop();\\n                 dire.pop();\\n                 dire.push(++i);\\n             }\\n             else if(dire.front()>radiant.front()){\\n                 dire.pop();\\n                 radiant.pop();\\n                 radiant.push(++i);\\n             }\\n        }\\n        if(radiant.size()==0)return \"Dire\";\\n        return \"Radiant\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483805,
                "title": "java-runtime-12-ms-beats-64-20-memory-43-6-mb-beats-6-82",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> qr = new LinkedList<>();\\n        Queue<Integer> qd = new LinkedList<>();\\n        int n = senate.length();\\n        for(int i = 0;i < n;i++){\\n            if(senate.charAt(i) == \\'R\\') qr.add(i);\\n            else qd.add(i);\\n        }\\n        for(;!qr.isEmpty() && !qd.isEmpty();){\\n            int r_i = qr.poll();\\n            int d_i = qd.poll();\\n            if(r_i < d_i) qr.add(r_i + n);\\n            else qd.add(d_i + n);\\n        }\\n        return qr.size() > qd.size() ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> qr = new LinkedList<>();\\n        Queue<Integer> qd = new LinkedList<>();\\n        int n = senate.length();\\n        for(int i = 0;i < n;i++){\\n            if(senate.charAt(i) == \\'R\\') qr.add(i);\\n            else qd.add(i);\\n        }\\n        for(;!qr.isEmpty() && !qd.isEmpty();){\\n            int r_i = qr.poll();\\n            int d_i = qd.poll();\\n            if(r_i < d_i) qr.add(r_i + n);\\n            else qd.add(d_i + n);\\n        }\\n        return qr.size() > qd.size() ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483796,
                "title": "two-queueringbuffer-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func predictPartyVictory(_ senate: String) -> String {\\n        let count = senate.count\\n        var rQueue = QueueRingBuffer<Int>(count: count)\\n        var dQueue = QueueRingBuffer<Int>(count: count)\\n\\n        for (index, char) in Array(senate).enumerated() {\\n            if char == \"R\" {\\n                rQueue.enqueue(index)\\n            } else {\\n                dQueue.enqueue(index)\\n            }\\n        }\\n\\n        while !rQueue.isEmpty && !dQueue.isEmpty {\\n            let rFirst = rQueue.dequeue()\\n            let dFirst = dQueue.dequeue()\\n\\n            if rFirst! < dFirst! {\\n                rQueue.enqueue(rFirst! + count)\\n            } else {\\n                dQueue.enqueue(dFirst! + count)\\n            }\\n        }\\n\\n        return rQueue.isEmpty ? \"Dire\" : \"Radiant\"\\n    }\\n}\\n\\npublic struct RingBuffer<T> {\\n  private var array: [T?]\\n  private var readIndex = 0\\n  private var writeIndex = 0\\n\\n  public init(count: Int) {\\n    array = [T?](repeating: nil, count: count)\\n  }\\n\\n  /* Returns false if out of space. */\\n  @discardableResult\\n  public mutating func write(_ element: T) -> Bool {\\n    guard !isFull else { return false }\\n    defer {\\n        writeIndex += 1\\n    }\\n    array[wrapped: writeIndex] = element\\n    return true\\n  }\\n\\n  /* Returns nil if the buffer is empty. */\\n  public mutating func read() -> T? {\\n    guard !isEmpty else { return nil }\\n    defer {\\n        array[wrapped: readIndex] = nil\\n        readIndex += 1\\n    }\\n    return array[wrapped: readIndex]\\n  }\\n\\n  private var availableSpaceForReading: Int {\\n    return writeIndex - readIndex\\n  }\\n\\n  public var isEmpty: Bool {\\n    return availableSpaceForReading == 0\\n  }\\n\\n  private var availableSpaceForWriting: Int {\\n    return array.count - availableSpaceForReading\\n  }\\n\\n  public var isFull: Bool {\\n    return availableSpaceForWriting == 0\\n  }\\n}\\n\\nextension RingBuffer: Sequence {\\n  public func makeIterator() -> AnyIterator<T> {\\n    var index = readIndex\\n    return AnyIterator {\\n        guard index < self.writeIndex else { return nil }\\n        defer {\\n            index += 1\\n        }\\n        return self.array[wrapped: index]\\n    }\\n  }\\n}\\n\\nprivate extension Array {\\n  subscript (wrapped index: Int) -> Element {\\n    get {\\n      return self[index % count]\\n    }\\n    set {\\n      self[index % count] = newValue\\n    }\\n  }\\n}\\n\\npublic protocol Queue {\\n    associatedtype Element\\n    mutating func enqueue(_ element: Element) -> Bool\\n    mutating func dequeue() -> Element?\\n    var isEmpty: Bool { get }\\n    var peek: Element? { get }\\n}\\n\\npublic struct QueueRingBuffer<T>: Queue {\\n    private var ringBuffer: RingBuffer<T>\\n    \\n    public init(count: Int) {\\n        ringBuffer = RingBuffer<T>(count: count)\\n    }\\n    \\n    public var isEmpty: Bool {\\n        return ringBuffer.isEmpty\\n    }\\n    \\n    public var peek: T? {\\n        return ringBuffer.first as? T\\n    }\\n    \\n    public mutating func enqueue(_ element: T) -> Bool {\\n        return ringBuffer.write(element)\\n    }\\n    \\n    public mutating func dequeue() -> T? {\\n        return isEmpty ? nil : ringBuffer.read()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func predictPartyVictory(_ senate: String) -> String {\\n        let count = senate.count\\n        var rQueue = QueueRingBuffer<Int>(count: count)\\n        var dQueue = QueueRingBuffer<Int>(count: count)\\n\\n        for (index, char) in Array(senate).enumerated() {\\n            if char == \"R\" {\\n                rQueue.enqueue(index)\\n            } else {\\n                dQueue.enqueue(index)\\n            }\\n        }\\n\\n        while !rQueue.isEmpty && !dQueue.isEmpty {\\n            let rFirst = rQueue.dequeue()\\n            let dFirst = dQueue.dequeue()\\n\\n            if rFirst! < dFirst! {\\n                rQueue.enqueue(rFirst! + count)\\n            } else {\\n                dQueue.enqueue(dFirst! + count)\\n            }\\n        }\\n\\n        return rQueue.isEmpty ? \"Dire\" : \"Radiant\"\\n    }\\n}\\n\\npublic struct RingBuffer<T> {\\n  private var array: [T?]\\n  private var readIndex = 0\\n  private var writeIndex = 0\\n\\n  public init(count: Int) {\\n    array = [T?](repeating: nil, count: count)\\n  }\\n\\n  /* Returns false if out of space. */\\n  @discardableResult\\n  public mutating func write(_ element: T) -> Bool {\\n    guard !isFull else { return false }\\n    defer {\\n        writeIndex += 1\\n    }\\n    array[wrapped: writeIndex] = element\\n    return true\\n  }\\n\\n  /* Returns nil if the buffer is empty. */\\n  public mutating func read() -> T? {\\n    guard !isEmpty else { return nil }\\n    defer {\\n        array[wrapped: readIndex] = nil\\n        readIndex += 1\\n    }\\n    return array[wrapped: readIndex]\\n  }\\n\\n  private var availableSpaceForReading: Int {\\n    return writeIndex - readIndex\\n  }\\n\\n  public var isEmpty: Bool {\\n    return availableSpaceForReading == 0\\n  }\\n\\n  private var availableSpaceForWriting: Int {\\n    return array.count - availableSpaceForReading\\n  }\\n\\n  public var isFull: Bool {\\n    return availableSpaceForWriting == 0\\n  }\\n}\\n\\nextension RingBuffer: Sequence {\\n  public func makeIterator() -> AnyIterator<T> {\\n    var index = readIndex\\n    return AnyIterator {\\n        guard index < self.writeIndex else { return nil }\\n        defer {\\n            index += 1\\n        }\\n        return self.array[wrapped: index]\\n    }\\n  }\\n}\\n\\nprivate extension Array {\\n  subscript (wrapped index: Int) -> Element {\\n    get {\\n      return self[index % count]\\n    }\\n    set {\\n      self[index % count] = newValue\\n    }\\n  }\\n}\\n\\npublic protocol Queue {\\n    associatedtype Element\\n    mutating func enqueue(_ element: Element) -> Bool\\n    mutating func dequeue() -> Element?\\n    var isEmpty: Bool { get }\\n    var peek: Element? { get }\\n}\\n\\npublic struct QueueRingBuffer<T>: Queue {\\n    private var ringBuffer: RingBuffer<T>\\n    \\n    public init(count: Int) {\\n        ringBuffer = RingBuffer<T>(count: count)\\n    }\\n    \\n    public var isEmpty: Bool {\\n        return ringBuffer.isEmpty\\n    }\\n    \\n    public var peek: T? {\\n        return ringBuffer.first as? T\\n    }\\n    \\n    public mutating func enqueue(_ element: T) -> Bool {\\n        return ringBuffer.write(element)\\n    }\\n    \\n    public mutating func dequeue() -> T? {\\n        return isEmpty ? nil : ringBuffer.read()\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483769,
                "title": "two-queues-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func predictPartyVictory(_ senate: String) -> String {\\n        var rQueue = Array<Int>.SubSequence()\\n        var dQueue = Array<Int>.SubSequence()\\n        let count = senate.count\\n\\n        for (index, char) in Array(senate).enumerated() {\\n            if char == \"R\" {\\n                rQueue.append(index)\\n            } else {\\n                dQueue.append(index)\\n            }\\n        }\\n\\n        while !rQueue.isEmpty && !dQueue.isEmpty {\\n            let rFirst = rQueue.popFirst()\\n            let dFirst = dQueue.popFirst()\\n\\n            if rFirst! < dFirst! {\\n                rQueue.append(rFirst! + count)\\n            } else {\\n                dQueue.append(dFirst! + count)\\n            }\\n        }\\n\\n        return rQueue.isEmpty ? \"Dire\" : \"Radiant\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func predictPartyVictory(_ senate: String) -> String {\\n        var rQueue = Array<Int>.SubSequence()\\n        var dQueue = Array<Int>.SubSequence()\\n        let count = senate.count\\n\\n        for (index, char) in Array(senate).enumerated() {\\n            if char == \"R\" {\\n                rQueue.append(index)\\n            } else {\\n                dQueue.append(index)\\n            }\\n        }\\n\\n        while !rQueue.isEmpty && !dQueue.isEmpty {\\n            let rFirst = rQueue.popFirst()\\n            let dFirst = dQueue.popFirst()\\n\\n            if rFirst! < dFirst! {\\n                rQueue.append(rFirst! + count)\\n            } else {\\n                dQueue.append(dFirst! + count)\\n            }\\n        }\\n\\n        return rQueue.isEmpty ? \"Dire\" : \"Radiant\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483767,
                "title": "easy-java-based-solution-using-recursion-and-string-manipulation",
                "content": "# Intuition\\nIn this approach we create 2 more functions, one function is used to check whether at any given point of time the character is our senate string are all equal or not and second one is to get the updated Senate string after completing a round.\\n\\n# Approach\\n1. We recusrisvely call `predictPartyVictory()`.\\n2. We check if all the character in the string are same or not, in case they are same we return our anwser, for this we use `allCharacterSame()`.\\n3. In case characters are not same, we find the next senate String using `nextPossibble()`, in which we pass 3 parameters, first senate String then 2 counters for both \\'R\\' and \\'D\\'.\\n4. we complete this function in which we check for character and its corresponding counter value and decrement or increment accordingly, and with each increment we add the character to our StringBuilder.\\n5. once the iteration is completed, we check for 2 things whether do we have any of the counter which is still greater than zero and is the string having same characters.\\n6. if the characters are same, we just return it back, but if characters are not same, and counters are greater than zero, we again work on the same function.\\n7. In the end it will come to the point where characters would be same or counters would be zero.\\n8. repeat the whole process till we get all characters same and return the answer.\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)- Recusrion Stack (Technically it would be always less than N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n            if(allCharacterSame(senate))\\n                if(senate.charAt(0)==\\'R\\')\\n                    return \"Radiant\";\\n            else\\n                return \"Dire\";\\n            StringBuilder updatedSenate = nextPossible(senate,0,0);\\n            return predictPartyVictory(updatedSenate.toString());\\n      }\\n      public boolean allCharacterSame(String senate){\\n        for(int i=0;i<senate.length()-1;i++)\\n            if(senate.charAt(i)!=senate.charAt(i+1))\\n                return false;\\n        return true;\\n      }\\n      public StringBuilder nextPossible(String senate,int rCount, int dCount){\\n        StringBuilder sb = new StringBuilder();\\n        int rCounter = rCount;\\n        int dCounter = dCount;\\n        for(int i=0;i<senate.length();i++){\\n                if (senate.charAt(i) == \\'R\\' && dCounter > 0)\\n                    dCounter--;\\n                else if (senate.charAt(i) == \\'D\\' && rCounter > 0)\\n                    rCounter--;\\n                else if (senate.charAt(i) == \\'R\\' && dCounter == 0) {\\n                    sb.append(senate.charAt(i));\\n                    rCounter++;\\n                }\\n                else if (senate.charAt(i) == \\'D\\' && rCounter == 0) {\\n                    sb.append(senate.charAt(i));\\n                    dCounter++;\\n                }\\n        }\\n        if((rCounter>0||dCounter>0)&&(!allCharacterSame(sb.toString())))\\n            return nextPossible(sb.toString(),rCounter,dCounter);\\n        return sb;\\n      }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n            if(allCharacterSame(senate))\\n                if(senate.charAt(0)==\\'R\\')\\n                    return \"Radiant\";\\n            else\\n                return \"Dire\";\\n            StringBuilder updatedSenate = nextPossible(senate,0,0);\\n            return predictPartyVictory(updatedSenate.toString());\\n      }\\n      public boolean allCharacterSame(String senate){\\n        for(int i=0;i<senate.length()-1;i++)\\n            if(senate.charAt(i)!=senate.charAt(i+1))\\n                return false;\\n        return true;\\n      }\\n      public StringBuilder nextPossible(String senate,int rCount, int dCount){\\n        StringBuilder sb = new StringBuilder();\\n        int rCounter = rCount;\\n        int dCounter = dCount;\\n        for(int i=0;i<senate.length();i++){\\n                if (senate.charAt(i) == \\'R\\' && dCounter > 0)\\n                    dCounter--;\\n                else if (senate.charAt(i) == \\'D\\' && rCounter > 0)\\n                    rCounter--;\\n                else if (senate.charAt(i) == \\'R\\' && dCounter == 0) {\\n                    sb.append(senate.charAt(i));\\n                    rCounter++;\\n                }\\n                else if (senate.charAt(i) == \\'D\\' && rCounter == 0) {\\n                    sb.append(senate.charAt(i));\\n                    dCounter++;\\n                }\\n        }\\n        if((rCounter>0||dCounter>0)&&(!allCharacterSame(sb.toString())))\\n            return nextPossible(sb.toString(),rCounter,dCounter);\\n        return sb;\\n      }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483753,
                "title": "easy-approach-using-recursion-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are using two variables for each rank, rPrev and cR for Radiant and dPrev and dR for Dire.\\n\\nThe cR variable tells us how many Radiants are there that have yet to exercise their votes. i.e. if any Dire comes up, their vote will be used and that Dire will be eliminated. So whenever a Dire comes up we first check if any Radiants are present that have not used their powers and if yes, we reduce that number by 1. \\nWe do the same thing the other way around.\\n\\nrPrev on the other hand tells us how many Radiants were there that did not die previously in the series. If the number of undead Radiants after the entire series is 0, then it indicates that only Dire remains and hence we declare Dire as the winner and vice versa.\\n\\nTemp on the other hand maintains a string in which we have all the ranks that were not killed to call upon recursion once the current iteration is over.\\n\\nNow, if cD and cR are both 0, it indicates that we have iterated through the senate and no person is left who has not cast their vote, so voting will again begin from the first person and hence we call recursion upon \"temp\" itself.\\n\\nWe also need to realize that either one of cD or cR will be greater than 0 and both cannot be greater than 0 as this is how the code works. If any one is greater, it wont allow the other to increment and itself decrements as discussed earlier.\\n\\nSo if either of those have a value greater than 0, it means that there are people of a particular rank who have not yet exercised their rights to vote, so these need to be considered first when reiterating through the remaining alive members of the senate. So we use subtring operations to bring this specific number of members to the beginning of our operation before calling recursion.\\n\\nTo understand in greater depth please Dry Run the code\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int cD = 0, cR = 0, dPrev = 0, rPrev = 0;\\n        string temp=\"\";\\n        for(auto it: senate){\\n            if(it==\\'D\\'){\\n                if(cR>0){\\n                    cR--;\\n                    continue;\\n                }\\n                cD++;\\n                dPrev++;\\n                temp+=\"D\";\\n            }\\n            else{\\n                if(cD>0){\\n                    cD--;\\n                    continue;\\n                }\\n                cR++;\\n                rPrev++;\\n                temp+=\"R\";\\n            }\\n        }\\n\\n        if(rPrev==0)\\n            return \"Dire\";\\n        if(dPrev==0)\\n            return \"Radiant\";\\n\\n        int n = temp.length();\\n        if(cR==0 && cD==0)\\n            return predictPartyVictory(temp);\\n        int z = max(cD,cR);\\n        temp = temp.substr(n-z)+temp.substr(0,n-z);\\n\\n        return predictPartyVictory(temp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int cD = 0, cR = 0, dPrev = 0, rPrev = 0;\\n        string temp=\"\";\\n        for(auto it: senate){\\n            if(it==\\'D\\'){\\n                if(cR>0){\\n                    cR--;\\n                    continue;\\n                }\\n                cD++;\\n                dPrev++;\\n                temp+=\"D\";\\n            }\\n            else{\\n                if(cD>0){\\n                    cD--;\\n                    continue;\\n                }\\n                cR++;\\n                rPrev++;\\n                temp+=\"R\";\\n            }\\n        }\\n\\n        if(rPrev==0)\\n            return \"Dire\";\\n        if(dPrev==0)\\n            return \"Radiant\";\\n\\n        int n = temp.length();\\n        if(cR==0 && cD==0)\\n            return predictPartyVictory(temp);\\n        int z = max(cD,cR);\\n        temp = temp.substr(n-z)+temp.substr(0,n-z);\\n\\n        return predictPartyVictory(temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483742,
                "title": "kotlin-2-queues-easy-readable",
                "content": "# Intuition\\n- collect indexes of senators into two queues\\n- iterate until any of the queues is empty\\n    - which R or D comes first -> put it to the end of its queue for the next round with index increased by `n` to denote next round figure\\n- which q is not empty is the winner\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    fun predictPartyVictory(senate: String): String {\\n        val n = senate.length\\n        val r = ArrayDeque<Int>(n)\\n        var d = ArrayDeque<Int>(n)\\n        senate.forEachIndexed { index, it ->  if (it == \\'R\\') r.add(index) else d.add(index) }\\n\\n        while (r.isNotEmpty() && d.isNotEmpty()) {\\n            val nextR = r.poll()\\n            val nextD = d.poll()\\n            if (nextR < nextD) r.add(nextR + n)\\n            else d.add(nextD + n)\\n        }\\n\\n        return if (r.isNotEmpty()) \"Radiant\" else \"Dire\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun predictPartyVictory(senate: String): String {\\n        val n = senate.length\\n        val r = ArrayDeque<Int>(n)\\n        var d = ArrayDeque<Int>(n)\\n        senate.forEachIndexed { index, it ->  if (it == \\'R\\') r.add(index) else d.add(index) }\\n\\n        while (r.isNotEmpty() && d.isNotEmpty()) {\\n            val nextR = r.poll()\\n            val nextD = d.poll()\\n            if (nextR < nextD) r.add(nextR + n)\\n            else d.add(nextD + n)\\n        }\\n\\n        return if (r.isNotEmpty()) \"Radiant\" else \"Dire\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483728,
                "title": "c-string-o-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        string s2;\\n        int d = 0, r = 0;\\n        while (1) {\\n            for (char c: senate) {\\n                if (c == \\'R\\') {\\n                    if (d) d--;\\n                    else {\\n                        s2.push_back(c);\\n                        r++;\\n                    }\\n                }\\n                else {\\n                    if (r) r--;\\n                    else {\\n                        s2.push_back(c);\\n                        d++;\\n                    }\\n                }\\n            }\\n            if (s2.length() == senate.length()) return d > 0 ? \"Dire\" : \"Radiant\";\\n            swap(s2,senate);\\n            s2 = \"\";\\n        }\\n        return \"\";\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        string s2;\\n        int d = 0, r = 0;\\n        while (1) {\\n            for (char c: senate) {\\n                if (c == \\'R\\') {\\n                    if (d) d--;\\n                    else {\\n                        s2.push_back(c);\\n                        r++;\\n                    }\\n                }\\n                else {\\n                    if (r) r--;\\n                    else {\\n                        s2.push_back(c);\\n                        d++;\\n                    }\\n                }\\n            }\\n            if (s2.length() == senate.length()) return d > 0 ? \"Dire\" : \"Radiant\";\\n            swap(s2,senate);\\n            s2 = \"\";\\n        }\\n        return \"\";\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483711,
                "title": "c-single-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int d = 0;\\n        int r = 0;\\n        queue<bool> q;\\n        for(auto&x:senate){\\n            if(x==\\'D\\') d++;\\n            else r++;\\n            q.push(x==\\'D\\');\\n        }\\n        int power = 1;\\n        bool curr = q.front();\\n        q.pop(); \\n        q.push(curr);\\n        while(!q.empty() && r!=0 && d!=0){\\n            if(q.front()==curr){\\n                q.pop();\\n                q.push(curr);\\n                power++;\\n            }\\n            else{\\n                q.pop();\\n                curr==1?r--:d--;\\n                power--;\\n            }\\n            if(power==0 && !q.empty()){\\n                curr = q.front();\\n                power = 1;\\n                q.pop();\\n                q.push(curr);\\n            }\\n        }\\n        if(r==0) return \"Dire\";\\n        else return \"Radiant\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int d = 0;\\n        int r = 0;\\n        queue<bool> q;\\n        for(auto&x:senate){\\n            if(x==\\'D\\') d++;\\n            else r++;\\n            q.push(x==\\'D\\');\\n        }\\n        int power = 1;\\n        bool curr = q.front();\\n        q.pop(); \\n        q.push(curr);\\n        while(!q.empty() && r!=0 && d!=0){\\n            if(q.front()==curr){\\n                q.pop();\\n                q.push(curr);\\n                power++;\\n            }\\n            else{\\n                q.pop();\\n                curr==1?r--:d--;\\n                power--;\\n            }\\n            if(power==0 && !q.empty()){\\n                curr = q.front();\\n                power = 1;\\n                q.pop();\\n                q.push(curr);\\n            }\\n        }\\n        if(r==0) return \"Dire\";\\n        else return \"Radiant\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483660,
                "title": "easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == \\'R\\')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == \\'R\\')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483654,
                "title": "easy-approach-beats-94",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> rq, dq;\\n        \\n        for(int i=0; i<senate.size(); i++)\\n            senate[i] == \\'R\\' ? rq.push(i): dq.push(i);\\n        \\n        int a, b;\\n        while(!rq.empty() and !dq.empty()){\\n            a = rq.front(), b = dq.front();\\n            rq.pop(), dq.pop();\\n            if (a < b) // taking min and pushing it to queue again\\n                rq.push(a+senate.size());\\n            else\\n                dq.push(b+senate.size());\\n        }\\n        \\n\\t\\tif (rq.size() > dq.size())\\n\\t\\t\\treturn \"Radiant\";\\n\\t\\telse\\n\\t\\t\\treturn \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> rq, dq;\\n        \\n        for(int i=0; i<senate.size(); i++)\\n            senate[i] == \\'R\\' ? rq.push(i): dq.push(i);\\n        \\n        int a, b;\\n        while(!rq.empty() and !dq.empty()){\\n            a = rq.front(), b = dq.front();\\n            rq.pop(), dq.pop();\\n            if (a < b) // taking min and pushing it to queue again\\n                rq.push(a+senate.size());\\n            else\\n                dq.push(b+senate.size());\\n        }\\n        \\n\\t\\tif (rq.size() > dq.size())\\n\\t\\t\\treturn \"Radiant\";\\n\\t\\telse\\n\\t\\t\\treturn \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483610,
                "title": "easy-and-story-wise-code-explanation-in-code-itself-c-t-c-o-n-s-c-o-n",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as there are only one loop of n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) as we are using ban array of size n\\n\\n\\n**FOR ANY DOUNT COMMENT DOWN , I WILL SURELY HELP YOU AND IF YOU LIKE MY CODE EXPLANATION UPVOTE IT PLEASE !!!**\\n\\n# Code\\n```\\nclass Solution {\\n    void find_count(string senate,int &R,int &D)\\n    {\\n        for(char ch : senate)\\n        {\\n            if(ch == \\'R\\') R++;\\n            else D++;\\n        }\\n    }\\n\\npublic:\\n    string predictPartyVictory(string senate) \\n    {\\n\\n       string ans;\\n\\n       // it will denote how many senates of D and R will be skipped\\n       int Rskip = 0,Dskip = 0; \\n \\n       int n = senate.size();\\n        \\n       // which sanate will be banned\\n       vector<bool>ban(n,false);\\n\\n       // it will denote how many senates of D and R can exercise any right\\n       int D = 0,R = 0; \\n       \\n       // find the total number of senates of each parties\\n       find_count(senate,R,D);\\n\\n\\n       // i%n because the loop will iterate like a circular chain dry run this example \"DRRD\"\\n       for(int i = 0; (i%n) < n; i++) \\n       {\\n           if(senate[i%n] == \\'D\\')\\n           {\\n               //if only that partie\\'s element present or other parties element who can exercise any right is 0\\n               if(R == 0)\\n                {\\n                   ans = \"Dire\";\\n                   break;\\n                }\\n\\n               //this current element will be skipped\\n               if(Dskip > 0 || ban[i%n])\\n               {\\n                    // if already banned no need to banned it again then skip it \\n                   if(ban[i%n]) continue;\\n\\n                   // if not banned previously and Dskip > 0 that means it should be banned so ban it and make (Dskip--) bcz you banned it \\n                   ban[i%n] = true;\\n                   Dskip--;\\n                   continue; // you banned that senate so now go for next senate\\n               }\\n               //if senate is not banned it will ban the other parties senate\\n\\n               //number of banned senate of other party increased \\n               Rskip++; \\n\\n               // as senate number of other party who can exercise any right will decrease\\n               R--; \\n           }\\n           else \\n           {\\n                 //if only that partie\\'s element present or other parties element who can exercise any right is 0\\n               if(D == 0) \\n                {\\n                   ans = \"Radiant\";\\n                   break;\\n                }\\n\\n               //this current element will be skipped\\n               if(Rskip > 0 || ban[i%n])\\n               {\\n                    // if already banned no need to banned it again then skip it \\n                   if(ban[i%n]) continue;\\n\\n                   // if not banned previously and Rskip > 0 that means it should be banned so ban it and make (Rskip--) bcz you banned it \\n                   ban[i%n] = true;\\n                   Rskip--;\\n                   continue; // you banned that senate so now go for next senate\\n               }\\n               //if senate is not banned it will ban the other parties senate\\n\\n               //number of banned senate of other party increased \\n               Dskip++; \\n\\n               // as senate number of other party who can exercise any right will decrease\\n               D--; \\n           }\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "class Solution {\\n    void find_count(string senate,int &R,int &D)\\n    {\\n        for(char ch : senate)\\n        {\\n            if(ch == \\'R\\') R++;\\n            else D++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3483608,
                "title": "java-solution-using-queue",
                "content": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n      Queue<Integer> radi=new LinkedList<>();\\n      Queue<Integer> dire=new LinkedList<>();\\n      int n = senate.length();\\n      for(int i=0;i<senate.length();i++){\\n          if(senate.charAt(i)==\\'R\\') radi.add(i);\\n          else dire.add(i);\\n      }\\n         for(;!radi.isEmpty() && !dire.isEmpty();){\\n            int r_i = radi.poll();\\n            int d_i = dire.poll();\\n            if(r_i < d_i) radi.add(r_i + n);\\n            else dire.add(d_i + n);\\n        }\\n        return radi.size() > dire.size() ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String predictPartyVictory(String senate) {\\n      Queue<Integer> radi=new LinkedList<>();\\n      Queue<Integer> dire=new LinkedList<>();\\n      int n = senate.length();\\n      for(int i=0;i<senate.length();i++){\\n          if(senate.charAt(i)==\\'R\\') radi.add(i);\\n          else dire.add(i);\\n      }\\n         for(;!radi.isEmpty() && !dire.isEmpty();){\\n            int r_i = radi.poll();\\n            int d_i = dire.poll();\\n            if(r_i < d_i) radi.add(r_i + n);\\n            else dire.add(d_i + n);\\n        }\\n        return radi.size() > dire.size() ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483546,
                "title": "python3-solution-quibler7",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        n = len(senate)\\n        s, banned = set(), [False] * n\\n        ban_d = ban_r = 0\\n        while len(s) != 1:\\n            s = set()\\n            for i, p in enumerate(senate):\\n                if banned[i]: continue\\n                if p == \\'R\\':\\n                    if ban_r > 0:           # current R being banned\\n                        ban_r -= 1\\n                        banned[i] = True\\n                    else:                   # if current R is valid, it will ban D\\n                        ban_d += 1\\n                        s.add(\\'R\\')\\n                else:        \\n                    if ban_d > 0:           # current D being banned\\n                        ban_d -= 1\\n                        banned[i] = True\\n                    else:                   # if current D is valid, it will ban R\\n                        ban_r += 1\\n                        s.add(\\'D\\')\\n        return \\'Radiant\\' if s.pop() == \\'R\\' else \\'Dire\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        n = len(senate)\\n        s, banned = set(), [False] * n\\n        ban_d = ban_r = 0\\n        while len(s) != 1:\\n            s = set()\\n            for i, p in enumerate(senate):\\n                if banned[i]: continue\\n                if p == \\'R\\':\\n                    if ban_r > 0:           # current R being banned\\n                        ban_r -= 1\\n                        banned[i] = True\\n                    else:                   # if current R is valid, it will ban D\\n                        ban_d += 1\\n                        s.add(\\'R\\')\\n                else:        \\n                    if ban_d > 0:           # current D being banned\\n                        ban_d -= 1\\n                        banned[i] = True\\n                    else:                   # if current D is valid, it will ban R\\n                        ban_r += 1\\n                        s.add(\\'D\\')\\n        return \\'Radiant\\' if s.pop() == \\'R\\' else \\'Dire\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483533,
                "title": "optmized-c-soltuion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == \\'R\\')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == \\'R\\')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483487,
                "title": "easy-to-understand-swift-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func predictPartyVictory(_ senate: String) -> String {\\n        var array = Array(senate)\\n        var index = 0\\n        var dire = 0\\n        var radiant = 0\\n        while array.contains(\"R\") && array.contains(\"D\") {\\n\\n            if array[index] == \"D\" && radiant > 0 {\\n                radiant -= 1\\n                array.remove(at: index)\\n            } else if array[index] == \"D\" && radiant == 0 {\\n                dire += 1\\n                index += 1\\n            } else if array[index] == \"R\" && dire == 0 {\\n                radiant += 1\\n                index += 1\\n            } else if array[index] == \"R\" && dire > 0 {\\n                dire -= 1\\n                array.remove(at: index)\\n            }\\n\\n            if index == array.count { index = 0 }\\n        }\\n        return !array.contains(\"R\") ? \"Dire\" : \"Radiant\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func predictPartyVictory(_ senate: String) -> String {\\n        var array = Array(senate)\\n        var index = 0\\n        var dire = 0\\n        var radiant = 0\\n        while array.contains(\"R\") && array.contains(\"D\") {\\n\\n            if array[index] == \"D\" && radiant > 0 {\\n                radiant -= 1\\n                array.remove(at: index)\\n            } else if array[index] == \"D\" && radiant == 0 {\\n                dire += 1\\n                index += 1\\n            } else if array[index] == \"R\" && dire == 0 {\\n                radiant += 1\\n                index += 1\\n            } else if array[index] == \"R\" && dire > 0 {\\n                dire -= 1\\n                array.remove(at: index)\\n            }\\n\\n            if index == array.count { index = 0 }\\n        }\\n        return !array.contains(\"R\") ? \"Dire\" : \"Radiant\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483436,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  import scala.collection.mutable.Queue\\n  def predictPartyVictory(senate: String): String = {\\n    val n = senate.length\\n    val (radiant, dire) = senate.zipWithIndex.foldLeft(Queue[Int](), Queue[Int]())((acc, cur)=>{\\n      if(cur._1 == \\'R\\') acc._1.enqueue(cur._2)\\n      else acc._2.enqueue(cur._2)\\n        acc\\n    })\\n    while (!radiant.isEmpty && !dire.isEmpty) {\\n      val r = radiant.dequeue\\n      val d = dire.dequeue\\n      if(r < d) radiant.enqueue(r + n)\\n      else dire.enqueue(d + n)\\n    }\\n    if(radiant.isEmpty) \"Dire\" else \"Radiant\"\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  import scala.collection.mutable.Queue\\n  def predictPartyVictory(senate: String): String = {\\n    val n = senate.length\\n    val (radiant, dire) = senate.zipWithIndex.foldLeft(Queue[Int](), Queue[Int]())((acc, cur)=>{\\n      if(cur._1 == \\'R\\') acc._1.enqueue(cur._2)\\n      else acc._2.enqueue(cur._2)\\n        acc\\n    })\\n    while (!radiant.isEmpty && !dire.isEmpty) {\\n      val r = radiant.dequeue\\n      val d = dire.dequeue\\n      if(r < d) radiant.enqueue(r + n)\\n      else dire.enqueue(d + n)\\n    }\\n    if(radiant.isEmpty) \"Dire\" else \"Radiant\"\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3483433,
                "title": "python3-naive-recursive-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNaive simulation using recursion with keeping the count of \\'R\\' and \\'D\\'.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def predictPartyVictory(self, s: str) -> str:\\n        c = collections.Counter(s)\\n\\n        def predict(s, r, d):\\n            if d == 0:\\n                return \\'Radiant\\'\\n            if r== 0:\\n                return \\'Dire\\'\\n            l = s[0]\\n            if l == \\'R\\':\\n                ind = s.index(\\'D\\')\\n                return predict(s[1:ind] + s[ind+1:] + s[0], r, d-1)\\n            if l == \\'D\\':\\n                ind = s.index(\\'R\\')\\n                return predict(s[1:ind] + s[ind+1:] + s[0], r-1, d)\\n                \\n        return predict(s, c[\\'R\\'], c[\\'D\\'])\\n\\n \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, s: str) -> str:\\n        c = collections.Counter(s)\\n\\n        def predict(s, r, d):\\n            if d == 0:\\n                return \\'Radiant\\'\\n            if r== 0:\\n                return \\'Dire\\'\\n            l = s[0]\\n            if l == \\'R\\':\\n                ind = s.index(\\'D\\')\\n                return predict(s[1:ind] + s[ind+1:] + s[0], r, d-1)\\n            if l == \\'D\\':\\n                ind = s.index(\\'R\\')\\n                return predict(s[1:ind] + s[ind+1:] + s[0], r-1, d)\\n                \\n        return predict(s, c[\\'R\\'], c[\\'D\\'])\\n\\n \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483429,
                "title": "simplified-approach-for-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n=senate.size();\\n        int rcount=0,dcount=0;\\n        int dfloatban=0,rfloatban=0;\\n        queue<char> q;\\n        for(auto c:senate){\\n            q.push(c);\\n            if(c==\\'R\\') rcount++;\\n            else dcount++;\\n        }\\n\\n        while(rcount && dcount){\\n            char cur=q.front();\\n            q.pop();\\n\\n            //if eligible,increment the ban on other party\\n            //and enqueue again\\n            //if not eligible,decrement the ban on other party\\n            //and count of senators\\n\\n            if(cur==\\'D\\'){\\n                if(dfloatban){\\n                    dfloatban--;\\n                    dcount--;\\n                }\\n                else{\\n                    rfloatban++;\\n                    q.push(cur);\\n                }\\n            }\\n            else{\\n                if(rfloatban){\\n                    rfloatban--;\\n                    rcount--;\\n                }\\n                else{\\n                    dfloatban++;\\n                    q.push(cur);\\n                }\\n            }\\n        }\\n        return rcount>dcount?\"Radiant\":\"Dire\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n=senate.size();\\n        int rcount=0,dcount=0;\\n        int dfloatban=0,rfloatban=0;\\n        queue<char> q;\\n        for(auto c:senate){\\n            q.push(c);\\n            if(c==\\'R\\') rcount++;\\n            else dcount++;\\n        }\\n\\n        while(rcount && dcount){\\n            char cur=q.front();\\n            q.pop();\\n\\n            //if eligible,increment the ban on other party\\n            //and enqueue again\\n            //if not eligible,decrement the ban on other party\\n            //and count of senators\\n\\n            if(cur==\\'D\\'){\\n                if(dfloatban){\\n                    dfloatban--;\\n                    dcount--;\\n                }\\n                else{\\n                    rfloatban++;\\n                    q.push(cur);\\n                }\\n            }\\n            else{\\n                if(rfloatban){\\n                    rfloatban--;\\n                    rcount--;\\n                }\\n                else{\\n                    dfloatban++;\\n                    q.push(cur);\\n                }\\n            }\\n        }\\n        return rcount>dcount?\"Radiant\":\"Dire\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483406,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        n=len(senate)\\n        R_idx=deque([i for i in range(n) if senate[i]==\\'R\\'])\\n        D_idx=deque([j for j in range(n) if senate[j]==\\'D\\'])\\n        while R_idx and D_idx:\\n            r=R_idx.popleft()\\n            d=D_idx.popleft()\\n\\n            if r<d:\\n                R_idx.append(n+r)\\n\\n            else:\\n                D_idx.append(n+d)\\n\\n\\n        return \\'Radiant\\' if R_idx else \\'Dire\\'            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        n=len(senate)\\n        R_idx=deque([i for i in range(n) if senate[i]==\\'R\\'])\\n        D_idx=deque([j for j in range(n) if senate[j]==\\'D\\'])\\n        while R_idx and D_idx:\\n            r=R_idx.popleft()\\n            d=D_idx.popleft()\\n\\n            if r<d:\\n                R_idx.append(n+r)\\n\\n            else:\\n                D_idx.append(n+d)\\n\\n\\n        return \\'Radiant\\' if R_idx else \\'Dire\\'            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483402,
                "title": "c-solution-using-2-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int>r;\\n        queue<int>d;\\n        for(int i=0;i<senate.size();i++)\\n        {\\n            if(senate[i]==\\'R\\')\\n            {\\n                r.push(i);\\n            }\\n            else\\n            {\\n                d.push(i);\\n            }\\n        }\\n        \\n        int n = senate.length();\\n\\n        while(true)\\n        {\\n            if(r.empty())\\n            {\\n                return \"Dire\";\\n            }\\n            if(d.empty())\\n            {\\n                return \"Radiant\";\\n            }\\n            int r1 = r.front();\\n            int d1 = d.front();\\n\\n            r.pop();\\n            d.pop();\\n\\n            if(r1<d1)\\n            {\\n                r.push(r1+n);\\n            }\\n            else\\n            {\\n                d.push(d1+n);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        queue<int>r;\\n        queue<int>d;\\n        for(int i=0;i<senate.size();i++)\\n        {\\n            if(senate[i]==\\'R\\')\\n            {\\n                r.push(i);\\n            }\\n            else\\n            {\\n                d.push(i);\\n            }\\n        }\\n        \\n        int n = senate.length();\\n\\n        while(true)\\n        {\\n            if(r.empty())\\n            {\\n                return \"Dire\";\\n            }\\n            if(d.empty())\\n            {\\n                return \"Radiant\";\\n            }\\n            int r1 = r.front();\\n            int d1 = d.front();\\n\\n            r.pop();\\n            d.pop();\\n\\n            if(r1<d1)\\n            {\\n                r.push(r1+n);\\n            }\\n            else\\n            {\\n                d.push(d1+n);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483337,
                "title": "easy-to-understand-simulation-with-nicely-written-comments-step-by-step-method",
                "content": "# Intuition\\n- Initially we count the number of Ds and number of Rs\\n- Then we loop until we see that all of Ds or all of Rs are banned.\\n- If we encounter a D, and we see that there are bans on D, then we enforce that. Similarly with R.\\n- Finally, whichever team got banned, we return the other.\\n\\n# Code\\n```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        num_r = 0\\n        num_d = 0\\n\\n        # Count the number of D and Rs\\n        for mem in senate:\\n            if mem == \"R\":\\n                num_r += 1\\n            else:\\n                num_d += 1\\n        ban_r = 0\\n        ban_d = 0\\n        senate = list(senate)\\n        floating_d_bans = 0\\n        floating_r_bans = 0\\n        # Loop until all D\\'s are banned or all Rs are banned\\n        while ban_d!=num_d and ban_r!=num_r:\\n            for i,mem in enumerate(senate):\\n\\n                # Member is R\\n                if mem == \\'R\\':\\n                    # There is a ban on R that isn\\'t enforced yet\\n                    if floating_r_bans > 0:\\n                        floating_r_bans -= 1\\n                        senate[i] = \\'X\\'\\n                        ban_r += 1\\n                    else:\\n                        floating_d_bans += 1\\n                if mem == \\'D\\':\\n                    if floating_d_bans > 0:\\n                        floating_d_bans -= 1\\n                        senate[i] = \\'X\\'\\n                        ban_d += 1\\n                    else:\\n                        floating_r_bans += 1\\n        if ban_r == num_r:\\n            return \"Dire\"\\n        return \"Radiant\"\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        num_r = 0\\n        num_d = 0\\n\\n        # Count the number of D and Rs\\n        for mem in senate:\\n            if mem == \"R\":\\n                num_r += 1\\n            else:\\n                num_d += 1\\n        ban_r = 0\\n        ban_d = 0\\n        senate = list(senate)\\n        floating_d_bans = 0\\n        floating_r_bans = 0\\n        # Loop until all D\\'s are banned or all Rs are banned\\n        while ban_d!=num_d and ban_r!=num_r:\\n            for i,mem in enumerate(senate):\\n\\n                # Member is R\\n                if mem == \\'R\\':\\n                    # There is a ban on R that isn\\'t enforced yet\\n                    if floating_r_bans > 0:\\n                        floating_r_bans -= 1\\n                        senate[i] = \\'X\\'\\n                        ban_r += 1\\n                    else:\\n                        floating_d_bans += 1\\n                if mem == \\'D\\':\\n                    if floating_d_bans > 0:\\n                        floating_d_bans -= 1\\n                        senate[i] = \\'X\\'\\n                        ban_d += 1\\n                    else:\\n                        floating_r_bans += 1\\n        if ban_r == num_r:\\n            return \"Dire\"\\n        return \"Radiant\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821375,
                "title": "queue-approach-java-solution",
                "content": "```java\\npublic String predictPartyVictory(String senate) {\\n        Queue<Integer> qr = new LinkedList<>();\\n        Queue<Integer> qd = new LinkedList<>();\\n        int n = senate.length();\\n        for(int i = 0;i < n;i++){\\n            if(senate.charAt(i) == \\'R\\') qr.add(i);\\n            else qd.add(i);\\n        }\\n        for(;!qr.isEmpty() && !qd.isEmpty();){\\n            int r_i = qr.poll();\\n            int d_i = qd.poll();\\n            if(r_i < d_i) qr.add(r_i + n);\\n            else qd.add(d_i + n);\\n        }\\n        return qr.size() > qd.size() ? \"Radiant\" : \"Dire\";\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```java\\npublic String predictPartyVictory(String senate) {\\n        Queue<Integer> qr = new LinkedList<>();\\n        Queue<Integer> qd = new LinkedList<>();\\n        int n = senate.length();\\n        for(int i = 0;i < n;i++){\\n            if(senate.charAt(i) == \\'R\\') qr.add(i);\\n            else qd.add(i);\\n        }\\n        for(;!qr.isEmpty() && !qd.isEmpty();){\\n            int r_i = qr.poll();\\n            int d_i = qd.poll();\\n            if(r_i < d_i) qr.add(r_i + n);\\n            else qd.add(d_i + n);\\n        }\\n        return qr.size() > qd.size() ? \"Radiant\" : \"Dire\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2698210,
                "title": "python-queue-based-greedy-solution-faster-than-87",
                "content": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        queueR, queueD, numSenators = deque(), deque(), len(senate)\\n        for idx in range(numSenators):\\n            if senate[idx] == \\'R\\':\\n                queueR.append(idx)\\n            else:\\n                queueD.append(idx)\\n        while queueR and queueD:\\n            rIdx, dIdx = queueR.popleft(), queueD.popleft()\\n            if rIdx < dIdx:\\n                queueR.append(rIdx + numSenators)\\n            else:\\n                queueD.append(dIdx + numSenators)\\n        return \\'Radiant\\' if len(queueR) > len(queueD) else \\'Dire\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        queueR, queueD, numSenators = deque(), deque(), len(senate)\\n        for idx in range(numSenators):\\n            if senate[idx] == \\'R\\':\\n                queueR.append(idx)\\n            else:\\n                queueD.append(idx)\\n        while queueR and queueD:\\n            rIdx, dIdx = queueR.popleft(), queueD.popleft()\\n            if rIdx < dIdx:\\n                queueR.append(rIdx + numSenators)\\n            else:\\n                queueD.append(dIdx + numSenators)\\n        return \\'Radiant\\' if len(queueR) > len(queueD) else \\'Dire\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592388,
                "title": "c-using-dp-86-faster-than-alll",
                "content": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        // rrddd\\n        // just ban whoevers next\\n        int rc = 0, dc = 0;\\n        for (char c : senate) c == \\'R\\' ? rc++ : dc++;\\n        int rk = 0, dk = 0;\\n        int i = 0, n = senate.size();\\n        while (rc > 0 && dc > 0) {\\n            if (senate[i] == \\'*\\');\\n            else if (senate[i] == \\'R\\' && rk > 0) { rk--; senate[i] = \\'*\\'; rc--;}\\n            else if (senate[i] == \\'D\\' && dk > 0) { dk--; senate[i] = \\'*\\'; dc--;}\\n            else {senate[i] == \\'R\\' ? dk++ : rk++;}\\n            i = (i+1)%n;\\n        }\\n        return rc > 0 ? \"Radiant\" : \"Dire\";\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        // rrddd\\n        // just ban whoevers next\\n        int rc = 0, dc = 0;\\n        for (char c : senate) c == \\'R\\' ? rc++ : dc++;\\n        int rk = 0, dk = 0;\\n        int i = 0, n = senate.size();\\n        while (rc > 0 && dc > 0) {\\n            if (senate[i] == \\'*\\');\\n            else if (senate[i] == \\'R\\' && rk > 0) { rk--; senate[i] = \\'*\\'; rc--;}",
                "codeTag": "Java"
            },
            {
                "id": 2291757,
                "title": "c-rust-explained",
                "content": "**C++ Code**\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring predictPartyVictory(string senate) {\\n\\t\\t\\tint n = senate.size();\\n\\t\\t\\tqueue<int> dire,radiant;\\n\\t\\t\\t// pushing the senate postion in queue\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(senate[i]==\\'D\\')dire.push(i);\\n\\t\\t\\t\\telse radiant.push(i);\\n\\t\\t\\t}\\n\\t\\t\\twhile(!dire.empty() && !radiant.empty()){\\n\\t\\t\\t\\tint d = dire.front();dire.pop();            \\n\\t\\t\\t\\tint r = radiant.front();radiant.pop();\\n\\t\\t\\t\\tif(d<r)dire.push(d+n); // if dire senate came first he took the radiant senate  rights\\n\\t\\t\\t\\telse radiant.push(r+n); // else opposite\\n\\t\\t\\t}\\n\\t\\t\\treturn dire.empty()?\"Radiant\":\"Dire\"; // if dire has no senate winner is Radiant\\n\\t\\t}\\n\\t};\\n\\n**Rust Code**\\'\\n\\n\\tuse std::collections::VecDeque;\\n\\timpl Solution {\\n\\t\\tpub fn predict_party_victory(senate: String) -> String {\\n\\t\\t\\tlet mut dire: VecDeque<usize> = VecDeque::new();\\n\\t\\t\\tlet mut radiant: VecDeque<usize> = VecDeque::new();\\n\\t\\t\\tfor (i,ch) in senate.chars().enumerate() {\\n\\t\\t\\t\\tif ch == \\'D\\' {dire.push_back(i);}\\n\\t\\t\\t\\telse {radiant.push_back(i);}\\n\\t\\t\\t}\\n\\t\\t\\twhile !dire.is_empty() && !radiant.is_empty(){\\n\\t\\t\\t\\tlet d:usize = dire.pop_front().unwrap();\\n\\t\\t\\t\\tlet r:usize = radiant.pop_front().unwrap();\\n\\t\\t\\t\\tif d<r {dire.push_back(d+senate.len());}\\n\\t\\t\\t\\telse {radiant.push_back(r+senate.len());}\\n\\t\\t\\t}\\n\\t\\t\\tif radiant.is_empty() {\"Dire\".to_string()} else {\"Radiant\".to_string()}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "C",
                    "Rust"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring predictPartyVictory(string senate) {\\n\\t\\t\\tint n = senate.size();\\n\\t\\t\\tqueue<int> dire,radiant;\\n\\t\\t\\t// pushing the senate postion in queue\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(senate[i]==\\'D\\')dire.push(i);\\n\\t\\t\\t\\telse radiant.push(i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2242518,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        res = \\'\\'\\n        arr = list(senate)\\n        rCount = arr.count(\\'R\\')\\n        dCount = arr.count(\\'D\\')\\n        i = 0\\n        while rCount > 0 and dCount > 0:\\n            if arr[i] == \\'R\\':\\n                count = arr[i+1:].count(\\'D\\')\\n                if count > 0:\\n                    index = arr[i+1:].index(\\'D\\') + i + 1\\n                else:\\n                    index = arr.index(\\'D\\')\\n                arr[index] = \\'O\\'\\n                dCount -= 1\\n            elif arr[i] == \\'D\\':\\n                count = arr[i+1:].count(\\'R\\')\\n                if count > 0:\\n                    index = arr[i+1:].index(\\'R\\') + i + 1\\n                else:\\n                    index = arr.index(\\'R\\')\\n                arr[index] = \\'O\\'\\n                rCount -= 1\\n            i += 1\\n            if i == len(arr):\\n                i = 0\\n        if rCount == 0:\\n            return \\'Dire\\'\\n        else:\\n            return \\'Radiant\\'\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def predictPartyVictory(self, senate: str) -> str:\\n        res = \\'\\'\\n        arr = list(senate)\\n        rCount = arr.count(\\'R\\')\\n        dCount = arr.count(\\'D\\')\\n        i = 0\\n        while rCount > 0 and dCount > 0:\\n            if arr[i] == \\'R\\':\\n                count = arr[i+1:].count(\\'D\\')\\n                if count > 0:\\n                    index = arr[i+1:].index(\\'D\\') + i + 1\\n                else:\\n                    index = arr.index(\\'D\\')\\n                arr[index] = \\'O\\'\\n                dCount -= 1\\n            elif arr[i] == \\'D\\':\\n                count = arr[i+1:].count(\\'R\\')\\n                if count > 0:\\n                    index = arr[i+1:].index(\\'R\\') + i + 1\\n                else:\\n                    index = arr.index(\\'R\\')\\n                arr[index] = \\'O\\'\\n                rCount -= 1\\n            i += 1\\n            if i == len(arr):\\n                i = 0\\n        if rCount == 0:\\n            return \\'Dire\\'\\n        else:\\n            return \\'Radiant\\'\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178787,
                "title": "c-use-input-string-as-queue-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int dc=0, rc=0, i=0;\\n        int bansc=0, bansS=senate[0];\\n        for(auto ch :senate)\\n        {\\n            if (ch==\\'D\\') dc++;\\n            else rc++;\\n        }\\n        while(dc != 0 && rc != 0)\\n        {\\n            if (bansc == 0 || senate[i] == bansS)\\n            {\\n\\t\\t\\t    bansS = senate[i]\\n                senate.push_back(bansS);\\n                bansc++;\\n            }\\n            else\\n            {\\n                if (bansS == \\'D\\')\\n                    rc--;\\n                else\\n                    dc--;\\n                bansc--;\\n            }\\n            i++;\\n        }\\n        return dc>rc?\"Dire\":\"Radiant\";\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int dc=0, rc=0, i=0;\\n        int bansc=0, bansS=senate[0];\\n        for(auto ch :senate)\\n        {\\n            if (ch==\\'D\\') dc++;\\n            else rc++;\\n        }\\n        while(dc != 0 && rc != 0)\\n        {\\n            if (bansc == 0 || senate[i] == bansS)\\n            {\\n\\t\\t\\t    bansS = senate[i]\\n                senate.push_back(bansS);\\n                bansc++;\\n            }\\n            else\\n            {\\n                if (bansS == \\'D\\')\\n                    rc--;\\n                else\\n                    dc--;\\n                bansc--;\\n            }\\n            i++;\\n        }\\n        return dc>rc?\"Dire\":\"Radiant\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176073,
                "title": "binary-search-map",
                "content": "```\\n//Please upvote if it is helpful\\nclass Solution {\\npublic:\\n    void check(string &s,map<char,vector<int>>&mp){\\n        for(int i=0;i<s.length();i++){  \\n            if(mp[s[i]].empty() || find(mp[s[i]].begin(),mp[s[i]].end(),i)==mp[s[i]].end())\\n                continue;\\n            if(s[i]==\\'R\\'){\\n                auto it= upper_bound(mp[\\'D\\'].begin(),mp[\\'D\\'].end(),i);\\n                if(it!=mp[\\'D\\'].end()){\\n                    mp[\\'D\\'].erase(it);\\n                }\\n                else{\\n                    if(!mp[\\'D\\'].empty()){\\n                    auto u= mp[\\'D\\'].begin();\\n                    mp[\\'D\\'].erase(u);\\n                    }\\n                }\\n            }\\n            else{\\n                auto it= upper_bound(mp[\\'R\\'].begin(),mp[\\'R\\'].end(),i);\\n                if(it!=mp[\\'R\\'].end()){\\n                    mp[\\'R\\'].erase(it);\\n                }\\n                else{\\n                    if(!mp[\\'R\\'].empty()){\\n                    auto u= mp[\\'R\\'].begin();\\n                    mp[\\'R\\'].erase(u);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    string predictPartyVictory(string s) {\\n        int n= s.length();\\n        map<char,vector<int>>mp;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]].push_back(i);\\n        }\\n        char c;\\n        while(true){\\n          if(mp[\\'R\\'].empty() || mp[\\'D\\'].empty())\\n              break;\\n          check(s,mp);\\n        }\\n        if(mp[\\'R\\'].empty())\\n            return \"Dire\";\\n        return \"Radiant\";     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n//Please upvote if it is helpful\\nclass Solution {\\npublic:\\n    void check(string &s,map<char,vector<int>>&mp){\\n        for(int i=0;i<s.length();i++){  \\n            if(mp[s[i]].empty() || find(mp[s[i]].begin(),mp[s[i]].end(),i)==mp[s[i]].end())\\n                continue;\\n            if(s[i]==\\'R\\'){\\n                auto it= upper_bound(mp[\\'D\\'].begin(),mp[\\'D\\'].end(),i);\\n                if(it!=mp[\\'D\\'].end()){\\n                    mp[\\'D\\'].erase(it);\\n                }\\n                else{\\n                    if(!mp[\\'D\\'].empty()){\\n                    auto u= mp[\\'D\\'].begin();\\n                    mp[\\'D\\'].erase(u);\\n                    }\\n                }\\n            }\\n            else{\\n                auto it= upper_bound(mp[\\'R\\'].begin(),mp[\\'R\\'].end(),i);\\n                if(it!=mp[\\'R\\'].end()){\\n                    mp[\\'R\\'].erase(it);\\n                }\\n                else{\\n                    if(!mp[\\'R\\'].empty()){\\n                    auto u= mp[\\'R\\'].begin();\\n                    mp[\\'R\\'].erase(u);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    string predictPartyVictory(string s) {\\n        int n= s.length();\\n        map<char,vector<int>>mp;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]].push_back(i);\\n        }\\n        char c;\\n        while(true){\\n          if(mp[\\'R\\'].empty() || mp[\\'D\\'].empty())\\n              break;\\n          check(s,mp);\\n        }\\n        if(mp[\\'R\\'].empty())\\n            return \"Dire\";\\n        return \"Radiant\";     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103170,
                "title": "easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n=senate.size();\\n        int r=0;\\n        int d=0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            if(senate[i]==\\'R\\')\\n            {\\n                r++;\\n            }\\n            else \\n            {\\n                d++;\\n            }\\n                \\n        }\\n        bool visited[n];\\n        for(int i=0;i<n;i++)\\n            visited[i]=false;\\n        int skip_r=0;\\n        int skip_d=0;\\n        while(r>0 && d>0)\\n        {\\n              r=0;\\n              d=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(senate[i]==\\'R\\')\\n                {\\n                    if(skip_r==0 && !visited[i])\\n                    {\\n                    skip_d++;\\n                    r++;\\n                    }\\n                    else\\n                    {\\n                        if(!visited[i])\\n                        {\\n                        skip_r--;\\n                        visited[i]=true;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(skip_d==0 && !visited[i])\\n                    {\\n                        skip_r++;\\n                        d++;\\n                    }\\n                    else\\n                    {\\n                        if(!visited[i])\\n                        {\\n                        skip_d--;\\n                        visited[i]=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(r>0)\\n            return \"Radiant\";\\n        return \"Dire\";\\n        \\n        \\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int n=senate.size();\\n        int r=0;\\n        int d=0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            if(senate[i]==\\'R\\')\\n            {\\n                r++;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1815722,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1881615,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1881636,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1881629,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1881915,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1566560,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1567436,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1576128,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1814553,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1567993,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1815722,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1881615,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1881636,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1881629,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1881915,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1566560,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1567436,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1576128,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1814553,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1567993,
                "content": [
                    {
                        "username": "SupercoolKartik",
                        "content": "OMG, why do they give examples like \"1+1=2\" and the test cases like \"Calculating the mass of xth planet if n no of people jump at the same time\" ?? tbh I only understand questions after looking at the examples and these ones are not at all helpful."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Literally applied the very burte force by using map, and boom, it did 71/82 and now I am stuck in between thinkinng of building new optimised approach.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@a_andreasian](/a_andreasian) Sure, that's the right attitude for progress. \nIf you struggle to understand \"99%\" of tasks on the most popular DSA preparation platform, it must be the platform's fault, god forbid anyone thinking you might be the one who has a margin for improvement that you need to work on when it comes to problem reading and analysis...\n\nIf you approach your training like that, I'm sure you are wasting your time here indeed. But not everybody is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "welcome to leedcode, a shelter of bad describtions. And it doesn't matter how long the description is, anyways for 99% you need to look at the examples because you didn't understand the task.\n\nI'm not even saying when the author misleads and passes absolutely another type of value, or he just adds a random function, like if the final number is a not whole float, reduce 0.5 from it. \nJust why not, if yes. \nGood luck on noticing that and debugging it for hours. Sometimes I really think that some authors of poor tasks are energetic vampires, or just can't explain their thoughts, or both. \nThat's why it's better to use any other trainer than, waste your time on Leetcode. You are literally wasting time here.\nI'm not even saying that the tasks for programming languages are pretty same. You just need to know some techniques such as hash-maps, patterns, etc and you can solve almost all of them. \n"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "[@minchaej](/minchaej) or you can just watch VSauce on YT"
                    },
                    {
                        "username": "Msey",
                        "content": "the best trick to figure out is to make your function return null and write random/complicated test cases"
                    },
                    {
                        "username": "minchaej",
                        "content": "I was actually curious and wanted to know the answer to your question \"Calculating the mass of xth planet if n no of people jump at the same time\". So I looked it up. \n\nApparently, The mass of a planet cannot be accurately calculated based on the number of people jumping at the same time. The mass of a planet is determined by its gravitational pull on other objects, such as satellites or other planets, and is usually calculated using sophisticated astronomical techniques.\n\nJumping by people on the planet will not have any significant impact on the planet's mass or gravitational pull. However, the jumping force may create small vibrations on the planet's surface.\n\nThis was more interesting than the given problem itself  tyty"
                    },
                    {
                        "username": "dev-null0",
                        "content": "I agree, terrible examples"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "how can you make dota2 seem so lame... hurts my soul "
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "One strategy that would pass the judge (although not the most efficient) to think about the problem is for the first character in the string to move to the back and eliminate the first \"opposing\" character in the string.  So in the case of \"DDRRR\":\\n\\nDDRRR - the first D moves to the back and takes out the first R\\nDRRD - the first D moves to the back and takes out the first R\\nRDD - the first R moves to the back and takes out the first D\\nDR - the first (and only) D moves to the back and takes out the first (and only) R\\nD - D wins the vote.\\n\\nIf you sit down with a piece of paper, you\\'ll be able to solve any of these problems easily."
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@PH4N70M](/PH4N70M) \\nDR DRR\\nDR R + D\\nRD + D\\nDR\\nD\\nSo the winner is still D not R :)\\n"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "[@ikuYOSH](/ikuYOSH) Yes!\\nImagine a queue of people standing in front of a ticketing window in a train station for example .. the first one in the queue is getting processed and tells the officer inside the window that the guy behind me is banned (not a must the one exactly behind, can be any one of the people behind \"and it should be the first one from opponents\").\\n\\nThen the one who got processed should go to the end of the queue to stand there! \\nSince the game continues until one announces the victory. So it\\'s an open loop keeps running until a flag is raised ;)\\n\\nOnce one person reaches the window and find themselves banned, they should go out of the queue completely not to the end.\\n\\nKeep doing so you\\'ll find the solution when someone reaches the window and find no one to ban behind. =)"
                    },
                    {
                        "username": "ikuYOSH",
                        "content": "How did you come up with this idea? I mean, insert the first character to the back of the string. Is it because of the round-based?"
                    },
                    {
                        "username": "ctlang",
                        "content": "[@PH4N70M](/PH4N70M) I think [@matthewwdaly](/matthewwdaly)\\'s strategy works on this case too:\\nDRDRR -> DRRD -> RDD -> DR -> D"
                    },
                    {
                        "username": "PH4N70M",
                        "content": "[@matthewwdaly](/matthewwdaly) Mate according to your strategy in the case \"DRDRR\"  the R won but actually D won. Could you support that please."
                    },
                    {
                        "username": "azamatbek",
                        "content": "Thank you a lot. I didn\\'t think of that."
                    },
                    {
                        "username": "yshrini",
                        "content": "This question is not very well explained. Even with example is not clear. And  if you don't know `What to do`, then `How to do` is impossible."
                    },
                    {
                        "username": "crusifixx",
                        "content": "It\\'s a \"Valve\" Interview Question."
                    },
                    {
                        "username": "sxj___",
                        "content": "Agreed. lmao"
                    },
                    {
                        "username": "ahmad-saeed",
                        "content": "Must Be xD"
                    },
                    {
                        "username": "Psykotic",
                        "content": "Valve is the company that made Dota so it\\'s not that surprising"
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\"DRRDRDRDRDDRDRDR\" According to me, it should be D .. what do you think?"
                    },
                    {
                        "username": "iankitpandey",
                        "content": "DRRDRDRDRDDRDRDR\\nDXRDRDRDRDDRDRDR\\nDXRXRDRDRDDRDRDR\\nDXRXRXRDRDDRDRDR\\nDXRXRXRXRDDRDRDR\\nDXRXRXRXRXDRDRDR\\nDXRXRXRXRXDXDRDR\\nDXRXRXRXRXDXDXDR\\nDXRXRXRXRXDXDXDX\\nDXXXRXRXRXDXDXDX\\nDXXXRXRXRXXXDXDX\\nDXXXRXRXRXXXXXDX\\nDXXXRXRXRXXXXXXX\\nDXXXXXRXRXXXXXXX\\nXXXXXXRXRXXXXXXX\\n\\nSo in the end R will win"
                    },
                    {
                        "username": "Himaswin",
                        "content": "nah it will be R i guess\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Yes bro same situation\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "user5400vw",
                        "content": "from the problem description: \"Suppose every senator is smart enough and will play the best strategy for his own party. \" - as leetrio-1 pointed out - greedily denying the upcoming votes is the best strategy, making R win."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "yes"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "->DXRXRXRXRXDXDXDX\n->DRRRRDDD\n->DXRRRXXX\n->DRRR\n->XXR**R** Radiant Victory on 3rd round"
                    },
                    {
                        "username": "thienkhutu",
                        "content": "0: \"DRRDRDRDRDDRDRDR\"\\n1: \"D  R   R  R   R   D  D   D\"\\n2: \"D       R   R   R               \"\\nAt this 3th round, D will ban the first R, and be banned by the 2nd R. The 3rd R will Announce the victory.\\nSo It should be R. \\n"
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "it depends if you think it like a vote from one party and then vote from the opposite or like following the order of senators in the string."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": " by the way what is your approach\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yeah! same prob here mate (tc:73)\\uD83D\\uDE02"
                    },
                    {
                        "username": "magingax",
                        "content": "My failed case is \"DDRRR\"\\ncorrect answer was \"Dire\". But How could it be ??\\nDire has only two chance at first. and there is three Radiant.\\nHow could dire eliminate three with only two chance ??\\n\\n"
                    },
                    {
                        "username": "coder42032",
                        "content": "Read question carefully, this game is round based. After completion of one round there can be possibility that all senate who have rights, not from same team. So for this reason we again check."
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "[@pragyajain821](/pragyajain821)  Hey Pragya, just saw your code for this one, its a really good logic"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@pragyajain821](/pragyajain821) \\nThanks man... was just starting out with the problem."
                    },
                    {
                        "username": "pragyajain821",
                        "content": "0st indexed  D remove 2rd indexed R\\n\\n1st  indexed D remove 3rd  indexed R\\n\\nnow 2nd  indexed R and 3rd indexed R are removed so they wont get any chance\\n\\nnow 4th indexed R remove 0th indexed D\\nand the 1st indexed Remove the 4th indexed R\\nnow only the D is left so Dire is the winner.\\n"
                    },
                    {
                        "username": "Amulya-Kumar",
                        "content": "the sequence for this would be follows:\\nDDXRR\\nDDXXR\\nDDXXR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "0mkar_r",
                        "content": "I\\'m just so proud that DotA2 made its way into a leetcode question"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "but the question they put is so lame and stupid. Not easy though...eheh"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Attracted by the name of the title, but its connection to DOTA is not what I was expecting :("
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too, this has nothing to do with the game"
                    },
                    {
                        "username": "fate1007",
                        "content": "I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
                    },
                    {
                        "username": "user0046QK",
                        "content": "[@arjitg](/arjitg) ok so the strat is that the senators always try to take out the next senator in the target party if possible to prevent that senator from voting?"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "DRRDRDRDRDDRDRDR\\nD_R_R_R_R_D_D_D_\\nD___R_R_R_______\\n______R_R_______"
                    },
                    {
                        "username": "arjitg",
                        "content": "Try visualising the sequence this way: _ means that letter is removed in the previous round.\\n\\nRound1: DRRDRDRDRDDRDRDR\\nRound2: D_R_R_R_R_D_D_D_\\nRound3: D___R_R_R_______\\nRound4: ______R_R_______\\nOnly R are left so R is the winner "
                    },
                    {
                        "username": "rikkardoferro",
                        "content": "If  the sequence you write is correct , it goes in this way: finished first \"round \"you have D_R_R_R_R_D_D_D_ ( _ stands for banned one), the second round you start whit DRRRRDDD, so from there is pretty obvious the ending"
                    }
                ]
            },
            {
                "id": 1881945,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "why they frame question in such a way that question itself is not clear what they are saying!"
                    },
                    {
                        "username": "simon1203",
                        "content": "\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted."
                    },
                    {
                        "username": "user9657q",
                        "content": "I have a problem with `\"DRRDRDRDRDDRDRDR\"`  \\nHere is my logic flow:\\n```\\n> \"DRRDRDRDRDDRDRDR\"\\n> \"D-RDRDRDRDDRDRDR\"\\n> \"--RDRDRDRDDRDRDR\"\\n> \"---DRDRDRDDRDRDR\"\\n> \"----RDRDRDDRDRDR\"\\n> \"-----DRDRDDRDRDR\"\\n> \"------RDRDDRDRDR\"\\n> \"-------DRDDRDRDR\"\\n> \"--------RDDRDRDR\"\\n> \"---------DDRDRDR\"\\n> \"---------DD-DRDR\"\\n> \"---------DD-D-DR\"\\n> \"---------DD-D-D-\"\\n```\\nThus the winner should be `D` right? Where do I go wrong?\\n"
                    },
                    {
                        "username": "user9657q",
                        "content": "[@apadhy](/apadhy) seems like I didn\\'t read that part carefully"
                    },
                    {
                        "username": "apadhy",
                        "content": "[@InfantoSolomon](/InfantoSolomon) It is mentioned that, we need to move from the first senator to the last senator in order according to the string. \\nBut yes, the problem description needs be more clear. "
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "[@apadhy](/apadhy) [@user9657q](/user9657q) Thank you but just curious why is that we ban the following opponent and not anyone before?\nif we did that it ends in a single round"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence would be - \\nDRRDRDRDRDDRDRDR\\nD-RDRDRDRDDRDRDR\\nD-R-RDRDRDDRDRDR\\nD-R-R-RDRDDRDRDR\\nD-R-R-R-RDDRDRDR\\nD-R-R-R-R-DRDRDR\\nD-R-R-R-R-D-DRDR\\nD-R-R-R-R-D-D-DR\\nD-R-R-R-R-D-D-D-\\nD---R-R-R-D-D-D-\\nD---R-R-R---D-D-\\nD---R-R-R-----D-\\nD---R-R-R-------\\nD-----R-R-------\\n------R-R-------\\n\\nFor each party(D/R) you keep on banning the next following opponent party(R/D)."
                    },
                    {
                        "username": "user9657q",
                        "content": "I figured it out. So-called `best strategy` means that it\\'s smart to ban a senator from the opposite party who *has not voted* yet.\\n\\nIt\\'s not easy to catch right away and it has not been marked out in the description either.\\n\\nIf you got stuck here just like me, hope this comment helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips: -\\n\\n1. The question is a tricky one to understand, basically iterate from left to right and each senate will have `2 potential moves`, in one move they can delete any senate from the other party and then in the other move they can declare victory if only their party are left.\\n\\n2. Use a `queue `to store them. Now starting from the front of the queue, say its R, if we have not encountered any D before, we will pop and simply push the R in the back of the queue and increment the count of R encountered. But if we have encountered any D before, we will just pop the R and decrease the count of D.\\n\\n3. There will be some edge cases like when there will be only one type of people in the queue, then your code might get stuck in an` infinite loop`, so you will have to add some additional conditions.\\n \\n4. To solve the above issue, make sure to keep track of the number of R and D in the queue, as soon as someone hits 0, return the ans. Also  do the operations while `q.size()!=1` and at the end return whatever is  at the front of queue."
                    },
                    {
                        "username": "parin2",
                        "content": "Who is the winner for the following test-case?\\n\"DDRRR\"\\n\\nI believe, it should be R. But expected is D.\\n\\nHere is what I think. I simply check the next senator from any not-banned index. If the next senator is from different group, I ban the next senator. (Greedy choice. Trying to cut the competition.) I keep performing this in circular array traversal. \\n\\nSo, by that sense, \\nD D R R R\\nwill become in following iterations\\nD D ~~R~~ R R\\n~~D~~ D ~~R~~ R R\\n~~D~~ D ~~R~~ ~~R~~ R\\n~~D~~ ~~D~~ ~~R~~ ~~R~~ R\\n\\nHence I believe R is the winner. Where am I thinking wrong?\\n"
                    },
                    {
                        "username": "ApoorvSrivastava",
                        "content": "First D bans 3rd R\\n2nd D bans 4th R\\n5th R bans 1st D\\n2nd D bans 5th R \\nRemaining is 2nd D\\nHence the winner "
                    },
                    {
                        "username": "dipto_reza",
                        "content": "[@sooraj7](/sooraj7)  Is this sequence possible ? DDRRR - DDXRR - DDXXR - DDXXX As all left is D , hence D is the winner ."
                    },
                    {
                        "username": "sooraj7",
                        "content": "no your sequence seems a bit not correct\\nit shud be..\\nDDRRR\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX\\nHence D is winner"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig , answer should be Dire ....\\nas we have to traverse the entire string several times (one by one)\\nacc to me seq might be\\n0  1 2 3 4\\nD D R R R // 0-D bans 2-R (Iteration 1)\\nD D    R R // 1-D bans 3-R (Iteration 1)\\nD D       R // 4-R bans 0-D (Iteration 1)\\n   D       R // 1-D bans 4-R (Iteration 2)\\n   D          // as there is no more \\'R\\' person with rights so \\'D\\' declares victory "
                    },
                    {
                        "username": "shashboy",
                        "content": "Treat the senate string as a circular string. Once you reach the end the voting sequence goes back to the first most available senetor."
                    },
                    {
                        "username": "amanpahariya95",
                        "content": "Fresh Meat!"
                    },
                    {
                        "username": "pascal91",
                        "content": "It\\'s strange that the question is about DOTA 2, but no one mentioned anyone\\'s mother..."
                    },
                    {
                        "username": "Toshito",
                        "content": "lmaooo... XD\\n"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How come in \"DDRRR\" Dire wins??? I don\\'t get it."
                    },
                    {
                        "username": "zwang198",
                        "content": "[@apadhy](/apadhy) Sorry, I didn\\'t get the point. It appears that the 4-th indexed R bans the 0-th indexed D and then both becomes X, but why when  0-th indexed D doesn\\'t change to X when it bans 2nd indexed R? "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "bcoz in an optimal strategy, every player will try to ban the nearest person in his RHS"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence is as follows-\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRR\\n1st round :\\n     -D-DXRR\\n     D-D-YXR\\n     XDYY-R-\\n\\n2nd round:\\n     Y-D-YYX\\n\\n3rd round:\\n     Y+D+YYY\\nSo Dire Wins\\n\\n-\"\"- using 1st right\\n+\"\"+ using 2nd right\\nX-cancelled currently by 1st right\\nY-cancelled earlier by 1st right\\nX,Y cant exercise any right"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Dota2 actually made it to a leetcode question huh, in the worst possible way atleast.\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "For a moment I was thinking the problem is about Ban/Pick phase of Dota2. Any Team Secret fanboy here xD?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "i hope 2017 Liquid comes back sometime"
                    }
                ]
            },
            {
                "id": 1881661,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "why they frame question in such a way that question itself is not clear what they are saying!"
                    },
                    {
                        "username": "simon1203",
                        "content": "\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted."
                    },
                    {
                        "username": "user9657q",
                        "content": "I have a problem with `\"DRRDRDRDRDDRDRDR\"`  \\nHere is my logic flow:\\n```\\n> \"DRRDRDRDRDDRDRDR\"\\n> \"D-RDRDRDRDDRDRDR\"\\n> \"--RDRDRDRDDRDRDR\"\\n> \"---DRDRDRDDRDRDR\"\\n> \"----RDRDRDDRDRDR\"\\n> \"-----DRDRDDRDRDR\"\\n> \"------RDRDDRDRDR\"\\n> \"-------DRDDRDRDR\"\\n> \"--------RDDRDRDR\"\\n> \"---------DDRDRDR\"\\n> \"---------DD-DRDR\"\\n> \"---------DD-D-DR\"\\n> \"---------DD-D-D-\"\\n```\\nThus the winner should be `D` right? Where do I go wrong?\\n"
                    },
                    {
                        "username": "user9657q",
                        "content": "[@apadhy](/apadhy) seems like I didn\\'t read that part carefully"
                    },
                    {
                        "username": "apadhy",
                        "content": "[@InfantoSolomon](/InfantoSolomon) It is mentioned that, we need to move from the first senator to the last senator in order according to the string. \\nBut yes, the problem description needs be more clear. "
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "[@apadhy](/apadhy) [@user9657q](/user9657q) Thank you but just curious why is that we ban the following opponent and not anyone before?\nif we did that it ends in a single round"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence would be - \\nDRRDRDRDRDDRDRDR\\nD-RDRDRDRDDRDRDR\\nD-R-RDRDRDDRDRDR\\nD-R-R-RDRDDRDRDR\\nD-R-R-R-RDDRDRDR\\nD-R-R-R-R-DRDRDR\\nD-R-R-R-R-D-DRDR\\nD-R-R-R-R-D-D-DR\\nD-R-R-R-R-D-D-D-\\nD---R-R-R-D-D-D-\\nD---R-R-R---D-D-\\nD---R-R-R-----D-\\nD---R-R-R-------\\nD-----R-R-------\\n------R-R-------\\n\\nFor each party(D/R) you keep on banning the next following opponent party(R/D)."
                    },
                    {
                        "username": "user9657q",
                        "content": "I figured it out. So-called `best strategy` means that it\\'s smart to ban a senator from the opposite party who *has not voted* yet.\\n\\nIt\\'s not easy to catch right away and it has not been marked out in the description either.\\n\\nIf you got stuck here just like me, hope this comment helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips: -\\n\\n1. The question is a tricky one to understand, basically iterate from left to right and each senate will have `2 potential moves`, in one move they can delete any senate from the other party and then in the other move they can declare victory if only their party are left.\\n\\n2. Use a `queue `to store them. Now starting from the front of the queue, say its R, if we have not encountered any D before, we will pop and simply push the R in the back of the queue and increment the count of R encountered. But if we have encountered any D before, we will just pop the R and decrease the count of D.\\n\\n3. There will be some edge cases like when there will be only one type of people in the queue, then your code might get stuck in an` infinite loop`, so you will have to add some additional conditions.\\n \\n4. To solve the above issue, make sure to keep track of the number of R and D in the queue, as soon as someone hits 0, return the ans. Also  do the operations while `q.size()!=1` and at the end return whatever is  at the front of queue."
                    },
                    {
                        "username": "parin2",
                        "content": "Who is the winner for the following test-case?\\n\"DDRRR\"\\n\\nI believe, it should be R. But expected is D.\\n\\nHere is what I think. I simply check the next senator from any not-banned index. If the next senator is from different group, I ban the next senator. (Greedy choice. Trying to cut the competition.) I keep performing this in circular array traversal. \\n\\nSo, by that sense, \\nD D R R R\\nwill become in following iterations\\nD D ~~R~~ R R\\n~~D~~ D ~~R~~ R R\\n~~D~~ D ~~R~~ ~~R~~ R\\n~~D~~ ~~D~~ ~~R~~ ~~R~~ R\\n\\nHence I believe R is the winner. Where am I thinking wrong?\\n"
                    },
                    {
                        "username": "ApoorvSrivastava",
                        "content": "First D bans 3rd R\\n2nd D bans 4th R\\n5th R bans 1st D\\n2nd D bans 5th R \\nRemaining is 2nd D\\nHence the winner "
                    },
                    {
                        "username": "dipto_reza",
                        "content": "[@sooraj7](/sooraj7)  Is this sequence possible ? DDRRR - DDXRR - DDXXR - DDXXX As all left is D , hence D is the winner ."
                    },
                    {
                        "username": "sooraj7",
                        "content": "no your sequence seems a bit not correct\\nit shud be..\\nDDRRR\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX\\nHence D is winner"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig , answer should be Dire ....\\nas we have to traverse the entire string several times (one by one)\\nacc to me seq might be\\n0  1 2 3 4\\nD D R R R // 0-D bans 2-R (Iteration 1)\\nD D    R R // 1-D bans 3-R (Iteration 1)\\nD D       R // 4-R bans 0-D (Iteration 1)\\n   D       R // 1-D bans 4-R (Iteration 2)\\n   D          // as there is no more \\'R\\' person with rights so \\'D\\' declares victory "
                    },
                    {
                        "username": "shashboy",
                        "content": "Treat the senate string as a circular string. Once you reach the end the voting sequence goes back to the first most available senetor."
                    },
                    {
                        "username": "amanpahariya95",
                        "content": "Fresh Meat!"
                    },
                    {
                        "username": "pascal91",
                        "content": "It\\'s strange that the question is about DOTA 2, but no one mentioned anyone\\'s mother..."
                    },
                    {
                        "username": "Toshito",
                        "content": "lmaooo... XD\\n"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How come in \"DDRRR\" Dire wins??? I don\\'t get it."
                    },
                    {
                        "username": "zwang198",
                        "content": "[@apadhy](/apadhy) Sorry, I didn\\'t get the point. It appears that the 4-th indexed R bans the 0-th indexed D and then both becomes X, but why when  0-th indexed D doesn\\'t change to X when it bans 2nd indexed R? "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "bcoz in an optimal strategy, every player will try to ban the nearest person in his RHS"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence is as follows-\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRR\\n1st round :\\n     -D-DXRR\\n     D-D-YXR\\n     XDYY-R-\\n\\n2nd round:\\n     Y-D-YYX\\n\\n3rd round:\\n     Y+D+YYY\\nSo Dire Wins\\n\\n-\"\"- using 1st right\\n+\"\"+ using 2nd right\\nX-cancelled currently by 1st right\\nY-cancelled earlier by 1st right\\nX,Y cant exercise any right"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Dota2 actually made it to a leetcode question huh, in the worst possible way atleast.\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "For a moment I was thinking the problem is about Ban/Pick phase of Dota2. Any Team Secret fanboy here xD?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "i hope 2017 Liquid comes back sometime"
                    }
                ]
            },
            {
                "id": 1882131,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "why they frame question in such a way that question itself is not clear what they are saying!"
                    },
                    {
                        "username": "simon1203",
                        "content": "\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted."
                    },
                    {
                        "username": "user9657q",
                        "content": "I have a problem with `\"DRRDRDRDRDDRDRDR\"`  \\nHere is my logic flow:\\n```\\n> \"DRRDRDRDRDDRDRDR\"\\n> \"D-RDRDRDRDDRDRDR\"\\n> \"--RDRDRDRDDRDRDR\"\\n> \"---DRDRDRDDRDRDR\"\\n> \"----RDRDRDDRDRDR\"\\n> \"-----DRDRDDRDRDR\"\\n> \"------RDRDDRDRDR\"\\n> \"-------DRDDRDRDR\"\\n> \"--------RDDRDRDR\"\\n> \"---------DDRDRDR\"\\n> \"---------DD-DRDR\"\\n> \"---------DD-D-DR\"\\n> \"---------DD-D-D-\"\\n```\\nThus the winner should be `D` right? Where do I go wrong?\\n"
                    },
                    {
                        "username": "user9657q",
                        "content": "[@apadhy](/apadhy) seems like I didn\\'t read that part carefully"
                    },
                    {
                        "username": "apadhy",
                        "content": "[@InfantoSolomon](/InfantoSolomon) It is mentioned that, we need to move from the first senator to the last senator in order according to the string. \\nBut yes, the problem description needs be more clear. "
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "[@apadhy](/apadhy) [@user9657q](/user9657q) Thank you but just curious why is that we ban the following opponent and not anyone before?\nif we did that it ends in a single round"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence would be - \\nDRRDRDRDRDDRDRDR\\nD-RDRDRDRDDRDRDR\\nD-R-RDRDRDDRDRDR\\nD-R-R-RDRDDRDRDR\\nD-R-R-R-RDDRDRDR\\nD-R-R-R-R-DRDRDR\\nD-R-R-R-R-D-DRDR\\nD-R-R-R-R-D-D-DR\\nD-R-R-R-R-D-D-D-\\nD---R-R-R-D-D-D-\\nD---R-R-R---D-D-\\nD---R-R-R-----D-\\nD---R-R-R-------\\nD-----R-R-------\\n------R-R-------\\n\\nFor each party(D/R) you keep on banning the next following opponent party(R/D)."
                    },
                    {
                        "username": "user9657q",
                        "content": "I figured it out. So-called `best strategy` means that it\\'s smart to ban a senator from the opposite party who *has not voted* yet.\\n\\nIt\\'s not easy to catch right away and it has not been marked out in the description either.\\n\\nIf you got stuck here just like me, hope this comment helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips: -\\n\\n1. The question is a tricky one to understand, basically iterate from left to right and each senate will have `2 potential moves`, in one move they can delete any senate from the other party and then in the other move they can declare victory if only their party are left.\\n\\n2. Use a `queue `to store them. Now starting from the front of the queue, say its R, if we have not encountered any D before, we will pop and simply push the R in the back of the queue and increment the count of R encountered. But if we have encountered any D before, we will just pop the R and decrease the count of D.\\n\\n3. There will be some edge cases like when there will be only one type of people in the queue, then your code might get stuck in an` infinite loop`, so you will have to add some additional conditions.\\n \\n4. To solve the above issue, make sure to keep track of the number of R and D in the queue, as soon as someone hits 0, return the ans. Also  do the operations while `q.size()!=1` and at the end return whatever is  at the front of queue."
                    },
                    {
                        "username": "parin2",
                        "content": "Who is the winner for the following test-case?\\n\"DDRRR\"\\n\\nI believe, it should be R. But expected is D.\\n\\nHere is what I think. I simply check the next senator from any not-banned index. If the next senator is from different group, I ban the next senator. (Greedy choice. Trying to cut the competition.) I keep performing this in circular array traversal. \\n\\nSo, by that sense, \\nD D R R R\\nwill become in following iterations\\nD D ~~R~~ R R\\n~~D~~ D ~~R~~ R R\\n~~D~~ D ~~R~~ ~~R~~ R\\n~~D~~ ~~D~~ ~~R~~ ~~R~~ R\\n\\nHence I believe R is the winner. Where am I thinking wrong?\\n"
                    },
                    {
                        "username": "ApoorvSrivastava",
                        "content": "First D bans 3rd R\\n2nd D bans 4th R\\n5th R bans 1st D\\n2nd D bans 5th R \\nRemaining is 2nd D\\nHence the winner "
                    },
                    {
                        "username": "dipto_reza",
                        "content": "[@sooraj7](/sooraj7)  Is this sequence possible ? DDRRR - DDXRR - DDXXR - DDXXX As all left is D , hence D is the winner ."
                    },
                    {
                        "username": "sooraj7",
                        "content": "no your sequence seems a bit not correct\\nit shud be..\\nDDRRR\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX\\nHence D is winner"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig , answer should be Dire ....\\nas we have to traverse the entire string several times (one by one)\\nacc to me seq might be\\n0  1 2 3 4\\nD D R R R // 0-D bans 2-R (Iteration 1)\\nD D    R R // 1-D bans 3-R (Iteration 1)\\nD D       R // 4-R bans 0-D (Iteration 1)\\n   D       R // 1-D bans 4-R (Iteration 2)\\n   D          // as there is no more \\'R\\' person with rights so \\'D\\' declares victory "
                    },
                    {
                        "username": "shashboy",
                        "content": "Treat the senate string as a circular string. Once you reach the end the voting sequence goes back to the first most available senetor."
                    },
                    {
                        "username": "amanpahariya95",
                        "content": "Fresh Meat!"
                    },
                    {
                        "username": "pascal91",
                        "content": "It\\'s strange that the question is about DOTA 2, but no one mentioned anyone\\'s mother..."
                    },
                    {
                        "username": "Toshito",
                        "content": "lmaooo... XD\\n"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How come in \"DDRRR\" Dire wins??? I don\\'t get it."
                    },
                    {
                        "username": "zwang198",
                        "content": "[@apadhy](/apadhy) Sorry, I didn\\'t get the point. It appears that the 4-th indexed R bans the 0-th indexed D and then both becomes X, but why when  0-th indexed D doesn\\'t change to X when it bans 2nd indexed R? "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "bcoz in an optimal strategy, every player will try to ban the nearest person in his RHS"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence is as follows-\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRR\\n1st round :\\n     -D-DXRR\\n     D-D-YXR\\n     XDYY-R-\\n\\n2nd round:\\n     Y-D-YYX\\n\\n3rd round:\\n     Y+D+YYY\\nSo Dire Wins\\n\\n-\"\"- using 1st right\\n+\"\"+ using 2nd right\\nX-cancelled currently by 1st right\\nY-cancelled earlier by 1st right\\nX,Y cant exercise any right"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Dota2 actually made it to a leetcode question huh, in the worst possible way atleast.\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "For a moment I was thinking the problem is about Ban/Pick phase of Dota2. Any Team Secret fanboy here xD?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "i hope 2017 Liquid comes back sometime"
                    }
                ]
            },
            {
                "id": 1881697,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "why they frame question in such a way that question itself is not clear what they are saying!"
                    },
                    {
                        "username": "simon1203",
                        "content": "\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted."
                    },
                    {
                        "username": "user9657q",
                        "content": "I have a problem with `\"DRRDRDRDRDDRDRDR\"`  \\nHere is my logic flow:\\n```\\n> \"DRRDRDRDRDDRDRDR\"\\n> \"D-RDRDRDRDDRDRDR\"\\n> \"--RDRDRDRDDRDRDR\"\\n> \"---DRDRDRDDRDRDR\"\\n> \"----RDRDRDDRDRDR\"\\n> \"-----DRDRDDRDRDR\"\\n> \"------RDRDDRDRDR\"\\n> \"-------DRDDRDRDR\"\\n> \"--------RDDRDRDR\"\\n> \"---------DDRDRDR\"\\n> \"---------DD-DRDR\"\\n> \"---------DD-D-DR\"\\n> \"---------DD-D-D-\"\\n```\\nThus the winner should be `D` right? Where do I go wrong?\\n"
                    },
                    {
                        "username": "user9657q",
                        "content": "[@apadhy](/apadhy) seems like I didn\\'t read that part carefully"
                    },
                    {
                        "username": "apadhy",
                        "content": "[@InfantoSolomon](/InfantoSolomon) It is mentioned that, we need to move from the first senator to the last senator in order according to the string. \\nBut yes, the problem description needs be more clear. "
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "[@apadhy](/apadhy) [@user9657q](/user9657q) Thank you but just curious why is that we ban the following opponent and not anyone before?\nif we did that it ends in a single round"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence would be - \\nDRRDRDRDRDDRDRDR\\nD-RDRDRDRDDRDRDR\\nD-R-RDRDRDDRDRDR\\nD-R-R-RDRDDRDRDR\\nD-R-R-R-RDDRDRDR\\nD-R-R-R-R-DRDRDR\\nD-R-R-R-R-D-DRDR\\nD-R-R-R-R-D-D-DR\\nD-R-R-R-R-D-D-D-\\nD---R-R-R-D-D-D-\\nD---R-R-R---D-D-\\nD---R-R-R-----D-\\nD---R-R-R-------\\nD-----R-R-------\\n------R-R-------\\n\\nFor each party(D/R) you keep on banning the next following opponent party(R/D)."
                    },
                    {
                        "username": "user9657q",
                        "content": "I figured it out. So-called `best strategy` means that it\\'s smart to ban a senator from the opposite party who *has not voted* yet.\\n\\nIt\\'s not easy to catch right away and it has not been marked out in the description either.\\n\\nIf you got stuck here just like me, hope this comment helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips: -\\n\\n1. The question is a tricky one to understand, basically iterate from left to right and each senate will have `2 potential moves`, in one move they can delete any senate from the other party and then in the other move they can declare victory if only their party are left.\\n\\n2. Use a `queue `to store them. Now starting from the front of the queue, say its R, if we have not encountered any D before, we will pop and simply push the R in the back of the queue and increment the count of R encountered. But if we have encountered any D before, we will just pop the R and decrease the count of D.\\n\\n3. There will be some edge cases like when there will be only one type of people in the queue, then your code might get stuck in an` infinite loop`, so you will have to add some additional conditions.\\n \\n4. To solve the above issue, make sure to keep track of the number of R and D in the queue, as soon as someone hits 0, return the ans. Also  do the operations while `q.size()!=1` and at the end return whatever is  at the front of queue."
                    },
                    {
                        "username": "parin2",
                        "content": "Who is the winner for the following test-case?\\n\"DDRRR\"\\n\\nI believe, it should be R. But expected is D.\\n\\nHere is what I think. I simply check the next senator from any not-banned index. If the next senator is from different group, I ban the next senator. (Greedy choice. Trying to cut the competition.) I keep performing this in circular array traversal. \\n\\nSo, by that sense, \\nD D R R R\\nwill become in following iterations\\nD D ~~R~~ R R\\n~~D~~ D ~~R~~ R R\\n~~D~~ D ~~R~~ ~~R~~ R\\n~~D~~ ~~D~~ ~~R~~ ~~R~~ R\\n\\nHence I believe R is the winner. Where am I thinking wrong?\\n"
                    },
                    {
                        "username": "ApoorvSrivastava",
                        "content": "First D bans 3rd R\\n2nd D bans 4th R\\n5th R bans 1st D\\n2nd D bans 5th R \\nRemaining is 2nd D\\nHence the winner "
                    },
                    {
                        "username": "dipto_reza",
                        "content": "[@sooraj7](/sooraj7)  Is this sequence possible ? DDRRR - DDXRR - DDXXR - DDXXX As all left is D , hence D is the winner ."
                    },
                    {
                        "username": "sooraj7",
                        "content": "no your sequence seems a bit not correct\\nit shud be..\\nDDRRR\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX\\nHence D is winner"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig , answer should be Dire ....\\nas we have to traverse the entire string several times (one by one)\\nacc to me seq might be\\n0  1 2 3 4\\nD D R R R // 0-D bans 2-R (Iteration 1)\\nD D    R R // 1-D bans 3-R (Iteration 1)\\nD D       R // 4-R bans 0-D (Iteration 1)\\n   D       R // 1-D bans 4-R (Iteration 2)\\n   D          // as there is no more \\'R\\' person with rights so \\'D\\' declares victory "
                    },
                    {
                        "username": "shashboy",
                        "content": "Treat the senate string as a circular string. Once you reach the end the voting sequence goes back to the first most available senetor."
                    },
                    {
                        "username": "amanpahariya95",
                        "content": "Fresh Meat!"
                    },
                    {
                        "username": "pascal91",
                        "content": "It\\'s strange that the question is about DOTA 2, but no one mentioned anyone\\'s mother..."
                    },
                    {
                        "username": "Toshito",
                        "content": "lmaooo... XD\\n"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How come in \"DDRRR\" Dire wins??? I don\\'t get it."
                    },
                    {
                        "username": "zwang198",
                        "content": "[@apadhy](/apadhy) Sorry, I didn\\'t get the point. It appears that the 4-th indexed R bans the 0-th indexed D and then both becomes X, but why when  0-th indexed D doesn\\'t change to X when it bans 2nd indexed R? "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "bcoz in an optimal strategy, every player will try to ban the nearest person in his RHS"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence is as follows-\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRR\\n1st round :\\n     -D-DXRR\\n     D-D-YXR\\n     XDYY-R-\\n\\n2nd round:\\n     Y-D-YYX\\n\\n3rd round:\\n     Y+D+YYY\\nSo Dire Wins\\n\\n-\"\"- using 1st right\\n+\"\"+ using 2nd right\\nX-cancelled currently by 1st right\\nY-cancelled earlier by 1st right\\nX,Y cant exercise any right"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Dota2 actually made it to a leetcode question huh, in the worst possible way atleast.\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "For a moment I was thinking the problem is about Ban/Pick phase of Dota2. Any Team Secret fanboy here xD?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "i hope 2017 Liquid comes back sometime"
                    }
                ]
            },
            {
                "id": 1569946,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "why they frame question in such a way that question itself is not clear what they are saying!"
                    },
                    {
                        "username": "simon1203",
                        "content": "\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted."
                    },
                    {
                        "username": "user9657q",
                        "content": "I have a problem with `\"DRRDRDRDRDDRDRDR\"`  \\nHere is my logic flow:\\n```\\n> \"DRRDRDRDRDDRDRDR\"\\n> \"D-RDRDRDRDDRDRDR\"\\n> \"--RDRDRDRDDRDRDR\"\\n> \"---DRDRDRDDRDRDR\"\\n> \"----RDRDRDDRDRDR\"\\n> \"-----DRDRDDRDRDR\"\\n> \"------RDRDDRDRDR\"\\n> \"-------DRDDRDRDR\"\\n> \"--------RDDRDRDR\"\\n> \"---------DDRDRDR\"\\n> \"---------DD-DRDR\"\\n> \"---------DD-D-DR\"\\n> \"---------DD-D-D-\"\\n```\\nThus the winner should be `D` right? Where do I go wrong?\\n"
                    },
                    {
                        "username": "user9657q",
                        "content": "[@apadhy](/apadhy) seems like I didn\\'t read that part carefully"
                    },
                    {
                        "username": "apadhy",
                        "content": "[@InfantoSolomon](/InfantoSolomon) It is mentioned that, we need to move from the first senator to the last senator in order according to the string. \\nBut yes, the problem description needs be more clear. "
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "[@apadhy](/apadhy) [@user9657q](/user9657q) Thank you but just curious why is that we ban the following opponent and not anyone before?\nif we did that it ends in a single round"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence would be - \\nDRRDRDRDRDDRDRDR\\nD-RDRDRDRDDRDRDR\\nD-R-RDRDRDDRDRDR\\nD-R-R-RDRDDRDRDR\\nD-R-R-R-RDDRDRDR\\nD-R-R-R-R-DRDRDR\\nD-R-R-R-R-D-DRDR\\nD-R-R-R-R-D-D-DR\\nD-R-R-R-R-D-D-D-\\nD---R-R-R-D-D-D-\\nD---R-R-R---D-D-\\nD---R-R-R-----D-\\nD---R-R-R-------\\nD-----R-R-------\\n------R-R-------\\n\\nFor each party(D/R) you keep on banning the next following opponent party(R/D)."
                    },
                    {
                        "username": "user9657q",
                        "content": "I figured it out. So-called `best strategy` means that it\\'s smart to ban a senator from the opposite party who *has not voted* yet.\\n\\nIt\\'s not easy to catch right away and it has not been marked out in the description either.\\n\\nIf you got stuck here just like me, hope this comment helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips: -\\n\\n1. The question is a tricky one to understand, basically iterate from left to right and each senate will have `2 potential moves`, in one move they can delete any senate from the other party and then in the other move they can declare victory if only their party are left.\\n\\n2. Use a `queue `to store them. Now starting from the front of the queue, say its R, if we have not encountered any D before, we will pop and simply push the R in the back of the queue and increment the count of R encountered. But if we have encountered any D before, we will just pop the R and decrease the count of D.\\n\\n3. There will be some edge cases like when there will be only one type of people in the queue, then your code might get stuck in an` infinite loop`, so you will have to add some additional conditions.\\n \\n4. To solve the above issue, make sure to keep track of the number of R and D in the queue, as soon as someone hits 0, return the ans. Also  do the operations while `q.size()!=1` and at the end return whatever is  at the front of queue."
                    },
                    {
                        "username": "parin2",
                        "content": "Who is the winner for the following test-case?\\n\"DDRRR\"\\n\\nI believe, it should be R. But expected is D.\\n\\nHere is what I think. I simply check the next senator from any not-banned index. If the next senator is from different group, I ban the next senator. (Greedy choice. Trying to cut the competition.) I keep performing this in circular array traversal. \\n\\nSo, by that sense, \\nD D R R R\\nwill become in following iterations\\nD D ~~R~~ R R\\n~~D~~ D ~~R~~ R R\\n~~D~~ D ~~R~~ ~~R~~ R\\n~~D~~ ~~D~~ ~~R~~ ~~R~~ R\\n\\nHence I believe R is the winner. Where am I thinking wrong?\\n"
                    },
                    {
                        "username": "ApoorvSrivastava",
                        "content": "First D bans 3rd R\\n2nd D bans 4th R\\n5th R bans 1st D\\n2nd D bans 5th R \\nRemaining is 2nd D\\nHence the winner "
                    },
                    {
                        "username": "dipto_reza",
                        "content": "[@sooraj7](/sooraj7)  Is this sequence possible ? DDRRR - DDXRR - DDXXR - DDXXX As all left is D , hence D is the winner ."
                    },
                    {
                        "username": "sooraj7",
                        "content": "no your sequence seems a bit not correct\\nit shud be..\\nDDRRR\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX\\nHence D is winner"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig , answer should be Dire ....\\nas we have to traverse the entire string several times (one by one)\\nacc to me seq might be\\n0  1 2 3 4\\nD D R R R // 0-D bans 2-R (Iteration 1)\\nD D    R R // 1-D bans 3-R (Iteration 1)\\nD D       R // 4-R bans 0-D (Iteration 1)\\n   D       R // 1-D bans 4-R (Iteration 2)\\n   D          // as there is no more \\'R\\' person with rights so \\'D\\' declares victory "
                    },
                    {
                        "username": "shashboy",
                        "content": "Treat the senate string as a circular string. Once you reach the end the voting sequence goes back to the first most available senetor."
                    },
                    {
                        "username": "amanpahariya95",
                        "content": "Fresh Meat!"
                    },
                    {
                        "username": "pascal91",
                        "content": "It\\'s strange that the question is about DOTA 2, but no one mentioned anyone\\'s mother..."
                    },
                    {
                        "username": "Toshito",
                        "content": "lmaooo... XD\\n"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How come in \"DDRRR\" Dire wins??? I don\\'t get it."
                    },
                    {
                        "username": "zwang198",
                        "content": "[@apadhy](/apadhy) Sorry, I didn\\'t get the point. It appears that the 4-th indexed R bans the 0-th indexed D and then both becomes X, but why when  0-th indexed D doesn\\'t change to X when it bans 2nd indexed R? "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "bcoz in an optimal strategy, every player will try to ban the nearest person in his RHS"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence is as follows-\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRR\\n1st round :\\n     -D-DXRR\\n     D-D-YXR\\n     XDYY-R-\\n\\n2nd round:\\n     Y-D-YYX\\n\\n3rd round:\\n     Y+D+YYY\\nSo Dire Wins\\n\\n-\"\"- using 1st right\\n+\"\"+ using 2nd right\\nX-cancelled currently by 1st right\\nY-cancelled earlier by 1st right\\nX,Y cant exercise any right"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Dota2 actually made it to a leetcode question huh, in the worst possible way atleast.\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "For a moment I was thinking the problem is about Ban/Pick phase of Dota2. Any Team Secret fanboy here xD?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "i hope 2017 Liquid comes back sometime"
                    }
                ]
            },
            {
                "id": 1882282,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "why they frame question in such a way that question itself is not clear what they are saying!"
                    },
                    {
                        "username": "simon1203",
                        "content": "\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted."
                    },
                    {
                        "username": "user9657q",
                        "content": "I have a problem with `\"DRRDRDRDRDDRDRDR\"`  \\nHere is my logic flow:\\n```\\n> \"DRRDRDRDRDDRDRDR\"\\n> \"D-RDRDRDRDDRDRDR\"\\n> \"--RDRDRDRDDRDRDR\"\\n> \"---DRDRDRDDRDRDR\"\\n> \"----RDRDRDDRDRDR\"\\n> \"-----DRDRDDRDRDR\"\\n> \"------RDRDDRDRDR\"\\n> \"-------DRDDRDRDR\"\\n> \"--------RDDRDRDR\"\\n> \"---------DDRDRDR\"\\n> \"---------DD-DRDR\"\\n> \"---------DD-D-DR\"\\n> \"---------DD-D-D-\"\\n```\\nThus the winner should be `D` right? Where do I go wrong?\\n"
                    },
                    {
                        "username": "user9657q",
                        "content": "[@apadhy](/apadhy) seems like I didn\\'t read that part carefully"
                    },
                    {
                        "username": "apadhy",
                        "content": "[@InfantoSolomon](/InfantoSolomon) It is mentioned that, we need to move from the first senator to the last senator in order according to the string. \\nBut yes, the problem description needs be more clear. "
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "[@apadhy](/apadhy) [@user9657q](/user9657q) Thank you but just curious why is that we ban the following opponent and not anyone before?\nif we did that it ends in a single round"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence would be - \\nDRRDRDRDRDDRDRDR\\nD-RDRDRDRDDRDRDR\\nD-R-RDRDRDDRDRDR\\nD-R-R-RDRDDRDRDR\\nD-R-R-R-RDDRDRDR\\nD-R-R-R-R-DRDRDR\\nD-R-R-R-R-D-DRDR\\nD-R-R-R-R-D-D-DR\\nD-R-R-R-R-D-D-D-\\nD---R-R-R-D-D-D-\\nD---R-R-R---D-D-\\nD---R-R-R-----D-\\nD---R-R-R-------\\nD-----R-R-------\\n------R-R-------\\n\\nFor each party(D/R) you keep on banning the next following opponent party(R/D)."
                    },
                    {
                        "username": "user9657q",
                        "content": "I figured it out. So-called `best strategy` means that it\\'s smart to ban a senator from the opposite party who *has not voted* yet.\\n\\nIt\\'s not easy to catch right away and it has not been marked out in the description either.\\n\\nIf you got stuck here just like me, hope this comment helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips: -\\n\\n1. The question is a tricky one to understand, basically iterate from left to right and each senate will have `2 potential moves`, in one move they can delete any senate from the other party and then in the other move they can declare victory if only their party are left.\\n\\n2. Use a `queue `to store them. Now starting from the front of the queue, say its R, if we have not encountered any D before, we will pop and simply push the R in the back of the queue and increment the count of R encountered. But if we have encountered any D before, we will just pop the R and decrease the count of D.\\n\\n3. There will be some edge cases like when there will be only one type of people in the queue, then your code might get stuck in an` infinite loop`, so you will have to add some additional conditions.\\n \\n4. To solve the above issue, make sure to keep track of the number of R and D in the queue, as soon as someone hits 0, return the ans. Also  do the operations while `q.size()!=1` and at the end return whatever is  at the front of queue."
                    },
                    {
                        "username": "parin2",
                        "content": "Who is the winner for the following test-case?\\n\"DDRRR\"\\n\\nI believe, it should be R. But expected is D.\\n\\nHere is what I think. I simply check the next senator from any not-banned index. If the next senator is from different group, I ban the next senator. (Greedy choice. Trying to cut the competition.) I keep performing this in circular array traversal. \\n\\nSo, by that sense, \\nD D R R R\\nwill become in following iterations\\nD D ~~R~~ R R\\n~~D~~ D ~~R~~ R R\\n~~D~~ D ~~R~~ ~~R~~ R\\n~~D~~ ~~D~~ ~~R~~ ~~R~~ R\\n\\nHence I believe R is the winner. Where am I thinking wrong?\\n"
                    },
                    {
                        "username": "ApoorvSrivastava",
                        "content": "First D bans 3rd R\\n2nd D bans 4th R\\n5th R bans 1st D\\n2nd D bans 5th R \\nRemaining is 2nd D\\nHence the winner "
                    },
                    {
                        "username": "dipto_reza",
                        "content": "[@sooraj7](/sooraj7)  Is this sequence possible ? DDRRR - DDXRR - DDXXR - DDXXX As all left is D , hence D is the winner ."
                    },
                    {
                        "username": "sooraj7",
                        "content": "no your sequence seems a bit not correct\\nit shud be..\\nDDRRR\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX\\nHence D is winner"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig , answer should be Dire ....\\nas we have to traverse the entire string several times (one by one)\\nacc to me seq might be\\n0  1 2 3 4\\nD D R R R // 0-D bans 2-R (Iteration 1)\\nD D    R R // 1-D bans 3-R (Iteration 1)\\nD D       R // 4-R bans 0-D (Iteration 1)\\n   D       R // 1-D bans 4-R (Iteration 2)\\n   D          // as there is no more \\'R\\' person with rights so \\'D\\' declares victory "
                    },
                    {
                        "username": "shashboy",
                        "content": "Treat the senate string as a circular string. Once you reach the end the voting sequence goes back to the first most available senetor."
                    },
                    {
                        "username": "amanpahariya95",
                        "content": "Fresh Meat!"
                    },
                    {
                        "username": "pascal91",
                        "content": "It\\'s strange that the question is about DOTA 2, but no one mentioned anyone\\'s mother..."
                    },
                    {
                        "username": "Toshito",
                        "content": "lmaooo... XD\\n"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How come in \"DDRRR\" Dire wins??? I don\\'t get it."
                    },
                    {
                        "username": "zwang198",
                        "content": "[@apadhy](/apadhy) Sorry, I didn\\'t get the point. It appears that the 4-th indexed R bans the 0-th indexed D and then both becomes X, but why when  0-th indexed D doesn\\'t change to X when it bans 2nd indexed R? "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "bcoz in an optimal strategy, every player will try to ban the nearest person in his RHS"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence is as follows-\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRR\\n1st round :\\n     -D-DXRR\\n     D-D-YXR\\n     XDYY-R-\\n\\n2nd round:\\n     Y-D-YYX\\n\\n3rd round:\\n     Y+D+YYY\\nSo Dire Wins\\n\\n-\"\"- using 1st right\\n+\"\"+ using 2nd right\\nX-cancelled currently by 1st right\\nY-cancelled earlier by 1st right\\nX,Y cant exercise any right"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Dota2 actually made it to a leetcode question huh, in the worst possible way atleast.\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "For a moment I was thinking the problem is about Ban/Pick phase of Dota2. Any Team Secret fanboy here xD?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "i hope 2017 Liquid comes back sometime"
                    }
                ]
            },
            {
                "id": 1882240,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "why they frame question in such a way that question itself is not clear what they are saying!"
                    },
                    {
                        "username": "simon1203",
                        "content": "\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted."
                    },
                    {
                        "username": "user9657q",
                        "content": "I have a problem with `\"DRRDRDRDRDDRDRDR\"`  \\nHere is my logic flow:\\n```\\n> \"DRRDRDRDRDDRDRDR\"\\n> \"D-RDRDRDRDDRDRDR\"\\n> \"--RDRDRDRDDRDRDR\"\\n> \"---DRDRDRDDRDRDR\"\\n> \"----RDRDRDDRDRDR\"\\n> \"-----DRDRDDRDRDR\"\\n> \"------RDRDDRDRDR\"\\n> \"-------DRDDRDRDR\"\\n> \"--------RDDRDRDR\"\\n> \"---------DDRDRDR\"\\n> \"---------DD-DRDR\"\\n> \"---------DD-D-DR\"\\n> \"---------DD-D-D-\"\\n```\\nThus the winner should be `D` right? Where do I go wrong?\\n"
                    },
                    {
                        "username": "user9657q",
                        "content": "[@apadhy](/apadhy) seems like I didn\\'t read that part carefully"
                    },
                    {
                        "username": "apadhy",
                        "content": "[@InfantoSolomon](/InfantoSolomon) It is mentioned that, we need to move from the first senator to the last senator in order according to the string. \\nBut yes, the problem description needs be more clear. "
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "[@apadhy](/apadhy) [@user9657q](/user9657q) Thank you but just curious why is that we ban the following opponent and not anyone before?\nif we did that it ends in a single round"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence would be - \\nDRRDRDRDRDDRDRDR\\nD-RDRDRDRDDRDRDR\\nD-R-RDRDRDDRDRDR\\nD-R-R-RDRDDRDRDR\\nD-R-R-R-RDDRDRDR\\nD-R-R-R-R-DRDRDR\\nD-R-R-R-R-D-DRDR\\nD-R-R-R-R-D-D-DR\\nD-R-R-R-R-D-D-D-\\nD---R-R-R-D-D-D-\\nD---R-R-R---D-D-\\nD---R-R-R-----D-\\nD---R-R-R-------\\nD-----R-R-------\\n------R-R-------\\n\\nFor each party(D/R) you keep on banning the next following opponent party(R/D)."
                    },
                    {
                        "username": "user9657q",
                        "content": "I figured it out. So-called `best strategy` means that it\\'s smart to ban a senator from the opposite party who *has not voted* yet.\\n\\nIt\\'s not easy to catch right away and it has not been marked out in the description either.\\n\\nIf you got stuck here just like me, hope this comment helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips: -\\n\\n1. The question is a tricky one to understand, basically iterate from left to right and each senate will have `2 potential moves`, in one move they can delete any senate from the other party and then in the other move they can declare victory if only their party are left.\\n\\n2. Use a `queue `to store them. Now starting from the front of the queue, say its R, if we have not encountered any D before, we will pop and simply push the R in the back of the queue and increment the count of R encountered. But if we have encountered any D before, we will just pop the R and decrease the count of D.\\n\\n3. There will be some edge cases like when there will be only one type of people in the queue, then your code might get stuck in an` infinite loop`, so you will have to add some additional conditions.\\n \\n4. To solve the above issue, make sure to keep track of the number of R and D in the queue, as soon as someone hits 0, return the ans. Also  do the operations while `q.size()!=1` and at the end return whatever is  at the front of queue."
                    },
                    {
                        "username": "parin2",
                        "content": "Who is the winner for the following test-case?\\n\"DDRRR\"\\n\\nI believe, it should be R. But expected is D.\\n\\nHere is what I think. I simply check the next senator from any not-banned index. If the next senator is from different group, I ban the next senator. (Greedy choice. Trying to cut the competition.) I keep performing this in circular array traversal. \\n\\nSo, by that sense, \\nD D R R R\\nwill become in following iterations\\nD D ~~R~~ R R\\n~~D~~ D ~~R~~ R R\\n~~D~~ D ~~R~~ ~~R~~ R\\n~~D~~ ~~D~~ ~~R~~ ~~R~~ R\\n\\nHence I believe R is the winner. Where am I thinking wrong?\\n"
                    },
                    {
                        "username": "ApoorvSrivastava",
                        "content": "First D bans 3rd R\\n2nd D bans 4th R\\n5th R bans 1st D\\n2nd D bans 5th R \\nRemaining is 2nd D\\nHence the winner "
                    },
                    {
                        "username": "dipto_reza",
                        "content": "[@sooraj7](/sooraj7)  Is this sequence possible ? DDRRR - DDXRR - DDXXR - DDXXX As all left is D , hence D is the winner ."
                    },
                    {
                        "username": "sooraj7",
                        "content": "no your sequence seems a bit not correct\\nit shud be..\\nDDRRR\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX\\nHence D is winner"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig , answer should be Dire ....\\nas we have to traverse the entire string several times (one by one)\\nacc to me seq might be\\n0  1 2 3 4\\nD D R R R // 0-D bans 2-R (Iteration 1)\\nD D    R R // 1-D bans 3-R (Iteration 1)\\nD D       R // 4-R bans 0-D (Iteration 1)\\n   D       R // 1-D bans 4-R (Iteration 2)\\n   D          // as there is no more \\'R\\' person with rights so \\'D\\' declares victory "
                    },
                    {
                        "username": "shashboy",
                        "content": "Treat the senate string as a circular string. Once you reach the end the voting sequence goes back to the first most available senetor."
                    },
                    {
                        "username": "amanpahariya95",
                        "content": "Fresh Meat!"
                    },
                    {
                        "username": "pascal91",
                        "content": "It\\'s strange that the question is about DOTA 2, but no one mentioned anyone\\'s mother..."
                    },
                    {
                        "username": "Toshito",
                        "content": "lmaooo... XD\\n"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How come in \"DDRRR\" Dire wins??? I don\\'t get it."
                    },
                    {
                        "username": "zwang198",
                        "content": "[@apadhy](/apadhy) Sorry, I didn\\'t get the point. It appears that the 4-th indexed R bans the 0-th indexed D and then both becomes X, but why when  0-th indexed D doesn\\'t change to X when it bans 2nd indexed R? "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "bcoz in an optimal strategy, every player will try to ban the nearest person in his RHS"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence is as follows-\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRR\\n1st round :\\n     -D-DXRR\\n     D-D-YXR\\n     XDYY-R-\\n\\n2nd round:\\n     Y-D-YYX\\n\\n3rd round:\\n     Y+D+YYY\\nSo Dire Wins\\n\\n-\"\"- using 1st right\\n+\"\"+ using 2nd right\\nX-cancelled currently by 1st right\\nY-cancelled earlier by 1st right\\nX,Y cant exercise any right"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Dota2 actually made it to a leetcode question huh, in the worst possible way atleast.\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "For a moment I was thinking the problem is about Ban/Pick phase of Dota2. Any Team Secret fanboy here xD?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "i hope 2017 Liquid comes back sometime"
                    }
                ]
            },
            {
                "id": 1881977,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "why they frame question in such a way that question itself is not clear what they are saying!"
                    },
                    {
                        "username": "simon1203",
                        "content": "\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted."
                    },
                    {
                        "username": "user9657q",
                        "content": "I have a problem with `\"DRRDRDRDRDDRDRDR\"`  \\nHere is my logic flow:\\n```\\n> \"DRRDRDRDRDDRDRDR\"\\n> \"D-RDRDRDRDDRDRDR\"\\n> \"--RDRDRDRDDRDRDR\"\\n> \"---DRDRDRDDRDRDR\"\\n> \"----RDRDRDDRDRDR\"\\n> \"-----DRDRDDRDRDR\"\\n> \"------RDRDDRDRDR\"\\n> \"-------DRDDRDRDR\"\\n> \"--------RDDRDRDR\"\\n> \"---------DDRDRDR\"\\n> \"---------DD-DRDR\"\\n> \"---------DD-D-DR\"\\n> \"---------DD-D-D-\"\\n```\\nThus the winner should be `D` right? Where do I go wrong?\\n"
                    },
                    {
                        "username": "user9657q",
                        "content": "[@apadhy](/apadhy) seems like I didn\\'t read that part carefully"
                    },
                    {
                        "username": "apadhy",
                        "content": "[@InfantoSolomon](/InfantoSolomon) It is mentioned that, we need to move from the first senator to the last senator in order according to the string. \\nBut yes, the problem description needs be more clear. "
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "[@apadhy](/apadhy) [@user9657q](/user9657q) Thank you but just curious why is that we ban the following opponent and not anyone before?\nif we did that it ends in a single round"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence would be - \\nDRRDRDRDRDDRDRDR\\nD-RDRDRDRDDRDRDR\\nD-R-RDRDRDDRDRDR\\nD-R-R-RDRDDRDRDR\\nD-R-R-R-RDDRDRDR\\nD-R-R-R-R-DRDRDR\\nD-R-R-R-R-D-DRDR\\nD-R-R-R-R-D-D-DR\\nD-R-R-R-R-D-D-D-\\nD---R-R-R-D-D-D-\\nD---R-R-R---D-D-\\nD---R-R-R-----D-\\nD---R-R-R-------\\nD-----R-R-------\\n------R-R-------\\n\\nFor each party(D/R) you keep on banning the next following opponent party(R/D)."
                    },
                    {
                        "username": "user9657q",
                        "content": "I figured it out. So-called `best strategy` means that it\\'s smart to ban a senator from the opposite party who *has not voted* yet.\\n\\nIt\\'s not easy to catch right away and it has not been marked out in the description either.\\n\\nIf you got stuck here just like me, hope this comment helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips: -\\n\\n1. The question is a tricky one to understand, basically iterate from left to right and each senate will have `2 potential moves`, in one move they can delete any senate from the other party and then in the other move they can declare victory if only their party are left.\\n\\n2. Use a `queue `to store them. Now starting from the front of the queue, say its R, if we have not encountered any D before, we will pop and simply push the R in the back of the queue and increment the count of R encountered. But if we have encountered any D before, we will just pop the R and decrease the count of D.\\n\\n3. There will be some edge cases like when there will be only one type of people in the queue, then your code might get stuck in an` infinite loop`, so you will have to add some additional conditions.\\n \\n4. To solve the above issue, make sure to keep track of the number of R and D in the queue, as soon as someone hits 0, return the ans. Also  do the operations while `q.size()!=1` and at the end return whatever is  at the front of queue."
                    },
                    {
                        "username": "parin2",
                        "content": "Who is the winner for the following test-case?\\n\"DDRRR\"\\n\\nI believe, it should be R. But expected is D.\\n\\nHere is what I think. I simply check the next senator from any not-banned index. If the next senator is from different group, I ban the next senator. (Greedy choice. Trying to cut the competition.) I keep performing this in circular array traversal. \\n\\nSo, by that sense, \\nD D R R R\\nwill become in following iterations\\nD D ~~R~~ R R\\n~~D~~ D ~~R~~ R R\\n~~D~~ D ~~R~~ ~~R~~ R\\n~~D~~ ~~D~~ ~~R~~ ~~R~~ R\\n\\nHence I believe R is the winner. Where am I thinking wrong?\\n"
                    },
                    {
                        "username": "ApoorvSrivastava",
                        "content": "First D bans 3rd R\\n2nd D bans 4th R\\n5th R bans 1st D\\n2nd D bans 5th R \\nRemaining is 2nd D\\nHence the winner "
                    },
                    {
                        "username": "dipto_reza",
                        "content": "[@sooraj7](/sooraj7)  Is this sequence possible ? DDRRR - DDXRR - DDXXR - DDXXX As all left is D , hence D is the winner ."
                    },
                    {
                        "username": "sooraj7",
                        "content": "no your sequence seems a bit not correct\\nit shud be..\\nDDRRR\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX\\nHence D is winner"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig , answer should be Dire ....\\nas we have to traverse the entire string several times (one by one)\\nacc to me seq might be\\n0  1 2 3 4\\nD D R R R // 0-D bans 2-R (Iteration 1)\\nD D    R R // 1-D bans 3-R (Iteration 1)\\nD D       R // 4-R bans 0-D (Iteration 1)\\n   D       R // 1-D bans 4-R (Iteration 2)\\n   D          // as there is no more \\'R\\' person with rights so \\'D\\' declares victory "
                    },
                    {
                        "username": "shashboy",
                        "content": "Treat the senate string as a circular string. Once you reach the end the voting sequence goes back to the first most available senetor."
                    },
                    {
                        "username": "amanpahariya95",
                        "content": "Fresh Meat!"
                    },
                    {
                        "username": "pascal91",
                        "content": "It\\'s strange that the question is about DOTA 2, but no one mentioned anyone\\'s mother..."
                    },
                    {
                        "username": "Toshito",
                        "content": "lmaooo... XD\\n"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How come in \"DDRRR\" Dire wins??? I don\\'t get it."
                    },
                    {
                        "username": "zwang198",
                        "content": "[@apadhy](/apadhy) Sorry, I didn\\'t get the point. It appears that the 4-th indexed R bans the 0-th indexed D and then both becomes X, but why when  0-th indexed D doesn\\'t change to X when it bans 2nd indexed R? "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "bcoz in an optimal strategy, every player will try to ban the nearest person in his RHS"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence is as follows-\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRR\\n1st round :\\n     -D-DXRR\\n     D-D-YXR\\n     XDYY-R-\\n\\n2nd round:\\n     Y-D-YYX\\n\\n3rd round:\\n     Y+D+YYY\\nSo Dire Wins\\n\\n-\"\"- using 1st right\\n+\"\"+ using 2nd right\\nX-cancelled currently by 1st right\\nY-cancelled earlier by 1st right\\nX,Y cant exercise any right"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Dota2 actually made it to a leetcode question huh, in the worst possible way atleast.\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "For a moment I was thinking the problem is about Ban/Pick phase of Dota2. Any Team Secret fanboy here xD?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "i hope 2017 Liquid comes back sometime"
                    }
                ]
            },
            {
                "id": 1881689,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "why they frame question in such a way that question itself is not clear what they are saying!"
                    },
                    {
                        "username": "simon1203",
                        "content": "\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted."
                    },
                    {
                        "username": "user9657q",
                        "content": "I have a problem with `\"DRRDRDRDRDDRDRDR\"`  \\nHere is my logic flow:\\n```\\n> \"DRRDRDRDRDDRDRDR\"\\n> \"D-RDRDRDRDDRDRDR\"\\n> \"--RDRDRDRDDRDRDR\"\\n> \"---DRDRDRDDRDRDR\"\\n> \"----RDRDRDDRDRDR\"\\n> \"-----DRDRDDRDRDR\"\\n> \"------RDRDDRDRDR\"\\n> \"-------DRDDRDRDR\"\\n> \"--------RDDRDRDR\"\\n> \"---------DDRDRDR\"\\n> \"---------DD-DRDR\"\\n> \"---------DD-D-DR\"\\n> \"---------DD-D-D-\"\\n```\\nThus the winner should be `D` right? Where do I go wrong?\\n"
                    },
                    {
                        "username": "user9657q",
                        "content": "[@apadhy](/apadhy) seems like I didn\\'t read that part carefully"
                    },
                    {
                        "username": "apadhy",
                        "content": "[@InfantoSolomon](/InfantoSolomon) It is mentioned that, we need to move from the first senator to the last senator in order according to the string. \\nBut yes, the problem description needs be more clear. "
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "[@apadhy](/apadhy) [@user9657q](/user9657q) Thank you but just curious why is that we ban the following opponent and not anyone before?\nif we did that it ends in a single round"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence would be - \\nDRRDRDRDRDDRDRDR\\nD-RDRDRDRDDRDRDR\\nD-R-RDRDRDDRDRDR\\nD-R-R-RDRDDRDRDR\\nD-R-R-R-RDDRDRDR\\nD-R-R-R-R-DRDRDR\\nD-R-R-R-R-D-DRDR\\nD-R-R-R-R-D-D-DR\\nD-R-R-R-R-D-D-D-\\nD---R-R-R-D-D-D-\\nD---R-R-R---D-D-\\nD---R-R-R-----D-\\nD---R-R-R-------\\nD-----R-R-------\\n------R-R-------\\n\\nFor each party(D/R) you keep on banning the next following opponent party(R/D)."
                    },
                    {
                        "username": "user9657q",
                        "content": "I figured it out. So-called `best strategy` means that it\\'s smart to ban a senator from the opposite party who *has not voted* yet.\\n\\nIt\\'s not easy to catch right away and it has not been marked out in the description either.\\n\\nIf you got stuck here just like me, hope this comment helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips: -\\n\\n1. The question is a tricky one to understand, basically iterate from left to right and each senate will have `2 potential moves`, in one move they can delete any senate from the other party and then in the other move they can declare victory if only their party are left.\\n\\n2. Use a `queue `to store them. Now starting from the front of the queue, say its R, if we have not encountered any D before, we will pop and simply push the R in the back of the queue and increment the count of R encountered. But if we have encountered any D before, we will just pop the R and decrease the count of D.\\n\\n3. There will be some edge cases like when there will be only one type of people in the queue, then your code might get stuck in an` infinite loop`, so you will have to add some additional conditions.\\n \\n4. To solve the above issue, make sure to keep track of the number of R and D in the queue, as soon as someone hits 0, return the ans. Also  do the operations while `q.size()!=1` and at the end return whatever is  at the front of queue."
                    },
                    {
                        "username": "parin2",
                        "content": "Who is the winner for the following test-case?\\n\"DDRRR\"\\n\\nI believe, it should be R. But expected is D.\\n\\nHere is what I think. I simply check the next senator from any not-banned index. If the next senator is from different group, I ban the next senator. (Greedy choice. Trying to cut the competition.) I keep performing this in circular array traversal. \\n\\nSo, by that sense, \\nD D R R R\\nwill become in following iterations\\nD D ~~R~~ R R\\n~~D~~ D ~~R~~ R R\\n~~D~~ D ~~R~~ ~~R~~ R\\n~~D~~ ~~D~~ ~~R~~ ~~R~~ R\\n\\nHence I believe R is the winner. Where am I thinking wrong?\\n"
                    },
                    {
                        "username": "ApoorvSrivastava",
                        "content": "First D bans 3rd R\\n2nd D bans 4th R\\n5th R bans 1st D\\n2nd D bans 5th R \\nRemaining is 2nd D\\nHence the winner "
                    },
                    {
                        "username": "dipto_reza",
                        "content": "[@sooraj7](/sooraj7)  Is this sequence possible ? DDRRR - DDXRR - DDXXR - DDXXX As all left is D , hence D is the winner ."
                    },
                    {
                        "username": "sooraj7",
                        "content": "no your sequence seems a bit not correct\\nit shud be..\\nDDRRR\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX\\nHence D is winner"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig , answer should be Dire ....\\nas we have to traverse the entire string several times (one by one)\\nacc to me seq might be\\n0  1 2 3 4\\nD D R R R // 0-D bans 2-R (Iteration 1)\\nD D    R R // 1-D bans 3-R (Iteration 1)\\nD D       R // 4-R bans 0-D (Iteration 1)\\n   D       R // 1-D bans 4-R (Iteration 2)\\n   D          // as there is no more \\'R\\' person with rights so \\'D\\' declares victory "
                    },
                    {
                        "username": "shashboy",
                        "content": "Treat the senate string as a circular string. Once you reach the end the voting sequence goes back to the first most available senetor."
                    },
                    {
                        "username": "amanpahariya95",
                        "content": "Fresh Meat!"
                    },
                    {
                        "username": "pascal91",
                        "content": "It\\'s strange that the question is about DOTA 2, but no one mentioned anyone\\'s mother..."
                    },
                    {
                        "username": "Toshito",
                        "content": "lmaooo... XD\\n"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How come in \"DDRRR\" Dire wins??? I don\\'t get it."
                    },
                    {
                        "username": "zwang198",
                        "content": "[@apadhy](/apadhy) Sorry, I didn\\'t get the point. It appears that the 4-th indexed R bans the 0-th indexed D and then both becomes X, but why when  0-th indexed D doesn\\'t change to X when it bans 2nd indexed R? "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "bcoz in an optimal strategy, every player will try to ban the nearest person in his RHS"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence is as follows-\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRR\\n1st round :\\n     -D-DXRR\\n     D-D-YXR\\n     XDYY-R-\\n\\n2nd round:\\n     Y-D-YYX\\n\\n3rd round:\\n     Y+D+YYY\\nSo Dire Wins\\n\\n-\"\"- using 1st right\\n+\"\"+ using 2nd right\\nX-cancelled currently by 1st right\\nY-cancelled earlier by 1st right\\nX,Y cant exercise any right"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Dota2 actually made it to a leetcode question huh, in the worst possible way atleast.\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "For a moment I was thinking the problem is about Ban/Pick phase of Dota2. Any Team Secret fanboy here xD?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "i hope 2017 Liquid comes back sometime"
                    }
                ]
            },
            {
                "id": 1882369,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "why they frame question in such a way that question itself is not clear what they are saying!"
                    },
                    {
                        "username": "simon1203",
                        "content": "\"The best strategy\" is that when a senator votes, that senator has to ban a senator who is the other party and hasn\\'t voted."
                    },
                    {
                        "username": "user9657q",
                        "content": "I have a problem with `\"DRRDRDRDRDDRDRDR\"`  \\nHere is my logic flow:\\n```\\n> \"DRRDRDRDRDDRDRDR\"\\n> \"D-RDRDRDRDDRDRDR\"\\n> \"--RDRDRDRDDRDRDR\"\\n> \"---DRDRDRDDRDRDR\"\\n> \"----RDRDRDDRDRDR\"\\n> \"-----DRDRDDRDRDR\"\\n> \"------RDRDDRDRDR\"\\n> \"-------DRDDRDRDR\"\\n> \"--------RDDRDRDR\"\\n> \"---------DDRDRDR\"\\n> \"---------DD-DRDR\"\\n> \"---------DD-D-DR\"\\n> \"---------DD-D-D-\"\\n```\\nThus the winner should be `D` right? Where do I go wrong?\\n"
                    },
                    {
                        "username": "user9657q",
                        "content": "[@apadhy](/apadhy) seems like I didn\\'t read that part carefully"
                    },
                    {
                        "username": "apadhy",
                        "content": "[@InfantoSolomon](/InfantoSolomon) It is mentioned that, we need to move from the first senator to the last senator in order according to the string. \\nBut yes, the problem description needs be more clear. "
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "[@apadhy](/apadhy) [@user9657q](/user9657q) Thank you but just curious why is that we ban the following opponent and not anyone before?\nif we did that it ends in a single round"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence would be - \\nDRRDRDRDRDDRDRDR\\nD-RDRDRDRDDRDRDR\\nD-R-RDRDRDDRDRDR\\nD-R-R-RDRDDRDRDR\\nD-R-R-R-RDDRDRDR\\nD-R-R-R-R-DRDRDR\\nD-R-R-R-R-D-DRDR\\nD-R-R-R-R-D-D-DR\\nD-R-R-R-R-D-D-D-\\nD---R-R-R-D-D-D-\\nD---R-R-R---D-D-\\nD---R-R-R-----D-\\nD---R-R-R-------\\nD-----R-R-------\\n------R-R-------\\n\\nFor each party(D/R) you keep on banning the next following opponent party(R/D)."
                    },
                    {
                        "username": "user9657q",
                        "content": "I figured it out. So-called `best strategy` means that it\\'s smart to ban a senator from the opposite party who *has not voted* yet.\\n\\nIt\\'s not easy to catch right away and it has not been marked out in the description either.\\n\\nIf you got stuck here just like me, hope this comment helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips: -\\n\\n1. The question is a tricky one to understand, basically iterate from left to right and each senate will have `2 potential moves`, in one move they can delete any senate from the other party and then in the other move they can declare victory if only their party are left.\\n\\n2. Use a `queue `to store them. Now starting from the front of the queue, say its R, if we have not encountered any D before, we will pop and simply push the R in the back of the queue and increment the count of R encountered. But if we have encountered any D before, we will just pop the R and decrease the count of D.\\n\\n3. There will be some edge cases like when there will be only one type of people in the queue, then your code might get stuck in an` infinite loop`, so you will have to add some additional conditions.\\n \\n4. To solve the above issue, make sure to keep track of the number of R and D in the queue, as soon as someone hits 0, return the ans. Also  do the operations while `q.size()!=1` and at the end return whatever is  at the front of queue."
                    },
                    {
                        "username": "parin2",
                        "content": "Who is the winner for the following test-case?\\n\"DDRRR\"\\n\\nI believe, it should be R. But expected is D.\\n\\nHere is what I think. I simply check the next senator from any not-banned index. If the next senator is from different group, I ban the next senator. (Greedy choice. Trying to cut the competition.) I keep performing this in circular array traversal. \\n\\nSo, by that sense, \\nD D R R R\\nwill become in following iterations\\nD D ~~R~~ R R\\n~~D~~ D ~~R~~ R R\\n~~D~~ D ~~R~~ ~~R~~ R\\n~~D~~ ~~D~~ ~~R~~ ~~R~~ R\\n\\nHence I believe R is the winner. Where am I thinking wrong?\\n"
                    },
                    {
                        "username": "ApoorvSrivastava",
                        "content": "First D bans 3rd R\\n2nd D bans 4th R\\n5th R bans 1st D\\n2nd D bans 5th R \\nRemaining is 2nd D\\nHence the winner "
                    },
                    {
                        "username": "dipto_reza",
                        "content": "[@sooraj7](/sooraj7)  Is this sequence possible ? DDRRR - DDXRR - DDXXR - DDXXX As all left is D , hence D is the winner ."
                    },
                    {
                        "username": "sooraj7",
                        "content": "no your sequence seems a bit not correct\\nit shud be..\\nDDRRR\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX\\nHence D is winner"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig , answer should be Dire ....\\nas we have to traverse the entire string several times (one by one)\\nacc to me seq might be\\n0  1 2 3 4\\nD D R R R // 0-D bans 2-R (Iteration 1)\\nD D    R R // 1-D bans 3-R (Iteration 1)\\nD D       R // 4-R bans 0-D (Iteration 1)\\n   D       R // 1-D bans 4-R (Iteration 2)\\n   D          // as there is no more \\'R\\' person with rights so \\'D\\' declares victory "
                    },
                    {
                        "username": "shashboy",
                        "content": "Treat the senate string as a circular string. Once you reach the end the voting sequence goes back to the first most available senetor."
                    },
                    {
                        "username": "amanpahariya95",
                        "content": "Fresh Meat!"
                    },
                    {
                        "username": "pascal91",
                        "content": "It\\'s strange that the question is about DOTA 2, but no one mentioned anyone\\'s mother..."
                    },
                    {
                        "username": "Toshito",
                        "content": "lmaooo... XD\\n"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How come in \"DDRRR\" Dire wins??? I don\\'t get it."
                    },
                    {
                        "username": "zwang198",
                        "content": "[@apadhy](/apadhy) Sorry, I didn\\'t get the point. It appears that the 4-th indexed R bans the 0-th indexed D and then both becomes X, but why when  0-th indexed D doesn\\'t change to X when it bans 2nd indexed R? "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "bcoz in an optimal strategy, every player will try to ban the nearest person in his RHS"
                    },
                    {
                        "username": "apadhy",
                        "content": "The sequence is as follows-\\nDDXRR\\nDDXXR\\nXDXXR\\nXDXXX"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRR\\n1st round :\\n     -D-DXRR\\n     D-D-YXR\\n     XDYY-R-\\n\\n2nd round:\\n     Y-D-YYX\\n\\n3rd round:\\n     Y+D+YYY\\nSo Dire Wins\\n\\n-\"\"- using 1st right\\n+\"\"+ using 2nd right\\nX-cancelled currently by 1st right\\nY-cancelled earlier by 1st right\\nX,Y cant exercise any right"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Dota2 actually made it to a leetcode question huh, in the worst possible way atleast.\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "For a moment I was thinking the problem is about Ban/Pick phase of Dota2. Any Team Secret fanboy here xD?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "i hope 2017 Liquid comes back sometime"
                    }
                ]
            },
            {
                "id": 1882084,
                "content": [
                    {
                        "username": "percy_98",
                        "content": "As soon as I saw topic to which this question belongs,   I was able to  come up with an approach . For me it was  hard to get the intuition for such a simple problem  "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "similar thing happened with me too"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "*Imagine how hard this\\'d be if it were N parties....*"
                    },
                    {
                        "username": "sooraj7",
                        "content": "doesn\\'t really matter if u using py3"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "for those confused by how \"DDRRR\" is a D victory,\\nIn the first round the 2 Ds get to go first and eliminate 2 of the Rs,\\nbut the last R has yet to go, so it\\'s equivalent to \"RDD\" which is a win for D"
                    },
                    {
                        "username": "vector62",
                        "content": "When I ran this manually, I came up with the answer as \"Dire\". Also my program returns \"Dire\" but the expected asnwer is \"Radiant\". \\n\\nAccording to the dry run I have done, the final state for this is \"DDDD\"\\n\\nPlease help me in figuring out this case."
                    },
                    {
                        "username": "devottam2809",
                        "content": "i\\'ve also done the same dry run , but dont know why its wrong? "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "if it is \"DRRDRDRDRDDRDRDR\" then im also getting the output as Dire only\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is initial input string bro ?"
                    },
                    {
                        "username": "curtman",
                        "content": "Clickbait!"
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "82 / 82 testcases passed\\nBut result is \"\\nTime Limit Exceeded\\nLast Executed Input\\nsenate =\\n\""
                    },
                    {
                        "username": "code_bandit",
                        "content": "Lol, the concept is actually taken from Hunter X Hunter, in which there is actually a very similar process to select Hunter Associations new chairman."
                    },
                    {
                        "username": "HattoriHanzo",
                        "content": "LeetCode, please update the test cases. In the 2-queue solution you adding rTurn back to rQueue if (rTurn < dTurn), and vice versa like this (I have rs as rQueue and r as rTurn)      \\n `  while(rs.size() > 0 && ds.size() > 0){\\n            int r = rs.front();\\n            rs.pop();\\n            int d = ds.front();\\n            ds.pop();\\n            if(r < d)\\n                rs.push(r+s.size());\\n            else\\n                ds.push(d+s.size());\\n        }  \\n`\\n\\nHowever if you change variables that you add back to the opposite, that is, put rTrurn in dQueue and dTurn in rQueue like this  `  if(r < d)\\n                rs.push(d+s.size());\\n            else\\n                ds.push(r+s.size());` \\nit will still be successful, so you will pass all testcases."
                    },
                    {
                        "username": "riskofstorm",
                        "content": "I'm gonna report this to Gaben, because it's damaging Valve reputation in my eyes :D\nOfc not, can't wait for Half-Life 3"
                    },
                    {
                        "username": "sooraj7",
                        "content": "DDRRRR is one case where im failing\\nCODE STOPS AFTER 3 ITERATIONS\\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "[@InfantoSolomon](/InfantoSolomon)  i got that R wins, but my code is working with all other inputs except this one\\n"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRRR\n1st round :\n     -D-DXRRR\n     D-D-YXRR\n     XDYY-R-R\n     YXYYR-R-\n2nd round:\n      YYYY+R+R\n     So Radiant Wins\n\n\n-\"\"- using 1st right\n+\"\"+ using 2nd right\nX-cancelled currently by 1st right\nY-cancelled earlier by 1st right\nX,Y cant exercise any right"
                    }
                ]
            },
            {
                "id": 1881776,
                "content": [
                    {
                        "username": "percy_98",
                        "content": "As soon as I saw topic to which this question belongs,   I was able to  come up with an approach . For me it was  hard to get the intuition for such a simple problem  "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "similar thing happened with me too"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "*Imagine how hard this\\'d be if it were N parties....*"
                    },
                    {
                        "username": "sooraj7",
                        "content": "doesn\\'t really matter if u using py3"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "for those confused by how \"DDRRR\" is a D victory,\\nIn the first round the 2 Ds get to go first and eliminate 2 of the Rs,\\nbut the last R has yet to go, so it\\'s equivalent to \"RDD\" which is a win for D"
                    },
                    {
                        "username": "vector62",
                        "content": "When I ran this manually, I came up with the answer as \"Dire\". Also my program returns \"Dire\" but the expected asnwer is \"Radiant\". \\n\\nAccording to the dry run I have done, the final state for this is \"DDDD\"\\n\\nPlease help me in figuring out this case."
                    },
                    {
                        "username": "devottam2809",
                        "content": "i\\'ve also done the same dry run , but dont know why its wrong? "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "if it is \"DRRDRDRDRDDRDRDR\" then im also getting the output as Dire only\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is initial input string bro ?"
                    },
                    {
                        "username": "curtman",
                        "content": "Clickbait!"
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "82 / 82 testcases passed\\nBut result is \"\\nTime Limit Exceeded\\nLast Executed Input\\nsenate =\\n\""
                    },
                    {
                        "username": "code_bandit",
                        "content": "Lol, the concept is actually taken from Hunter X Hunter, in which there is actually a very similar process to select Hunter Associations new chairman."
                    },
                    {
                        "username": "HattoriHanzo",
                        "content": "LeetCode, please update the test cases. In the 2-queue solution you adding rTurn back to rQueue if (rTurn < dTurn), and vice versa like this (I have rs as rQueue and r as rTurn)      \\n `  while(rs.size() > 0 && ds.size() > 0){\\n            int r = rs.front();\\n            rs.pop();\\n            int d = ds.front();\\n            ds.pop();\\n            if(r < d)\\n                rs.push(r+s.size());\\n            else\\n                ds.push(d+s.size());\\n        }  \\n`\\n\\nHowever if you change variables that you add back to the opposite, that is, put rTrurn in dQueue and dTurn in rQueue like this  `  if(r < d)\\n                rs.push(d+s.size());\\n            else\\n                ds.push(r+s.size());` \\nit will still be successful, so you will pass all testcases."
                    },
                    {
                        "username": "riskofstorm",
                        "content": "I'm gonna report this to Gaben, because it's damaging Valve reputation in my eyes :D\nOfc not, can't wait for Half-Life 3"
                    },
                    {
                        "username": "sooraj7",
                        "content": "DDRRRR is one case where im failing\\nCODE STOPS AFTER 3 ITERATIONS\\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "[@InfantoSolomon](/InfantoSolomon)  i got that R wins, but my code is working with all other inputs except this one\\n"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRRR\n1st round :\n     -D-DXRRR\n     D-D-YXRR\n     XDYY-R-R\n     YXYYR-R-\n2nd round:\n      YYYY+R+R\n     So Radiant Wins\n\n\n-\"\"- using 1st right\n+\"\"+ using 2nd right\nX-cancelled currently by 1st right\nY-cancelled earlier by 1st right\nX,Y cant exercise any right"
                    }
                ]
            },
            {
                "id": 1691291,
                "content": [
                    {
                        "username": "percy_98",
                        "content": "As soon as I saw topic to which this question belongs,   I was able to  come up with an approach . For me it was  hard to get the intuition for such a simple problem  "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "similar thing happened with me too"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "*Imagine how hard this\\'d be if it were N parties....*"
                    },
                    {
                        "username": "sooraj7",
                        "content": "doesn\\'t really matter if u using py3"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "for those confused by how \"DDRRR\" is a D victory,\\nIn the first round the 2 Ds get to go first and eliminate 2 of the Rs,\\nbut the last R has yet to go, so it\\'s equivalent to \"RDD\" which is a win for D"
                    },
                    {
                        "username": "vector62",
                        "content": "When I ran this manually, I came up with the answer as \"Dire\". Also my program returns \"Dire\" but the expected asnwer is \"Radiant\". \\n\\nAccording to the dry run I have done, the final state for this is \"DDDD\"\\n\\nPlease help me in figuring out this case."
                    },
                    {
                        "username": "devottam2809",
                        "content": "i\\'ve also done the same dry run , but dont know why its wrong? "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "if it is \"DRRDRDRDRDDRDRDR\" then im also getting the output as Dire only\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is initial input string bro ?"
                    },
                    {
                        "username": "curtman",
                        "content": "Clickbait!"
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "82 / 82 testcases passed\\nBut result is \"\\nTime Limit Exceeded\\nLast Executed Input\\nsenate =\\n\""
                    },
                    {
                        "username": "code_bandit",
                        "content": "Lol, the concept is actually taken from Hunter X Hunter, in which there is actually a very similar process to select Hunter Associations new chairman."
                    },
                    {
                        "username": "HattoriHanzo",
                        "content": "LeetCode, please update the test cases. In the 2-queue solution you adding rTurn back to rQueue if (rTurn < dTurn), and vice versa like this (I have rs as rQueue and r as rTurn)      \\n `  while(rs.size() > 0 && ds.size() > 0){\\n            int r = rs.front();\\n            rs.pop();\\n            int d = ds.front();\\n            ds.pop();\\n            if(r < d)\\n                rs.push(r+s.size());\\n            else\\n                ds.push(d+s.size());\\n        }  \\n`\\n\\nHowever if you change variables that you add back to the opposite, that is, put rTrurn in dQueue and dTurn in rQueue like this  `  if(r < d)\\n                rs.push(d+s.size());\\n            else\\n                ds.push(r+s.size());` \\nit will still be successful, so you will pass all testcases."
                    },
                    {
                        "username": "riskofstorm",
                        "content": "I'm gonna report this to Gaben, because it's damaging Valve reputation in my eyes :D\nOfc not, can't wait for Half-Life 3"
                    },
                    {
                        "username": "sooraj7",
                        "content": "DDRRRR is one case where im failing\\nCODE STOPS AFTER 3 ITERATIONS\\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "[@InfantoSolomon](/InfantoSolomon)  i got that R wins, but my code is working with all other inputs except this one\\n"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRRR\n1st round :\n     -D-DXRRR\n     D-D-YXRR\n     XDYY-R-R\n     YXYYR-R-\n2nd round:\n      YYYY+R+R\n     So Radiant Wins\n\n\n-\"\"- using 1st right\n+\"\"+ using 2nd right\nX-cancelled currently by 1st right\nY-cancelled earlier by 1st right\nX,Y cant exercise any right"
                    }
                ]
            },
            {
                "id": 1573442,
                "content": [
                    {
                        "username": "percy_98",
                        "content": "As soon as I saw topic to which this question belongs,   I was able to  come up with an approach . For me it was  hard to get the intuition for such a simple problem  "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "similar thing happened with me too"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "*Imagine how hard this\\'d be if it were N parties....*"
                    },
                    {
                        "username": "sooraj7",
                        "content": "doesn\\'t really matter if u using py3"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "for those confused by how \"DDRRR\" is a D victory,\\nIn the first round the 2 Ds get to go first and eliminate 2 of the Rs,\\nbut the last R has yet to go, so it\\'s equivalent to \"RDD\" which is a win for D"
                    },
                    {
                        "username": "vector62",
                        "content": "When I ran this manually, I came up with the answer as \"Dire\". Also my program returns \"Dire\" but the expected asnwer is \"Radiant\". \\n\\nAccording to the dry run I have done, the final state for this is \"DDDD\"\\n\\nPlease help me in figuring out this case."
                    },
                    {
                        "username": "devottam2809",
                        "content": "i\\'ve also done the same dry run , but dont know why its wrong? "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "if it is \"DRRDRDRDRDDRDRDR\" then im also getting the output as Dire only\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is initial input string bro ?"
                    },
                    {
                        "username": "curtman",
                        "content": "Clickbait!"
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "82 / 82 testcases passed\\nBut result is \"\\nTime Limit Exceeded\\nLast Executed Input\\nsenate =\\n\""
                    },
                    {
                        "username": "code_bandit",
                        "content": "Lol, the concept is actually taken from Hunter X Hunter, in which there is actually a very similar process to select Hunter Associations new chairman."
                    },
                    {
                        "username": "HattoriHanzo",
                        "content": "LeetCode, please update the test cases. In the 2-queue solution you adding rTurn back to rQueue if (rTurn < dTurn), and vice versa like this (I have rs as rQueue and r as rTurn)      \\n `  while(rs.size() > 0 && ds.size() > 0){\\n            int r = rs.front();\\n            rs.pop();\\n            int d = ds.front();\\n            ds.pop();\\n            if(r < d)\\n                rs.push(r+s.size());\\n            else\\n                ds.push(d+s.size());\\n        }  \\n`\\n\\nHowever if you change variables that you add back to the opposite, that is, put rTrurn in dQueue and dTurn in rQueue like this  `  if(r < d)\\n                rs.push(d+s.size());\\n            else\\n                ds.push(r+s.size());` \\nit will still be successful, so you will pass all testcases."
                    },
                    {
                        "username": "riskofstorm",
                        "content": "I'm gonna report this to Gaben, because it's damaging Valve reputation in my eyes :D\nOfc not, can't wait for Half-Life 3"
                    },
                    {
                        "username": "sooraj7",
                        "content": "DDRRRR is one case where im failing\\nCODE STOPS AFTER 3 ITERATIONS\\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "[@InfantoSolomon](/InfantoSolomon)  i got that R wins, but my code is working with all other inputs except this one\\n"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRRR\n1st round :\n     -D-DXRRR\n     D-D-YXRR\n     XDYY-R-R\n     YXYYR-R-\n2nd round:\n      YYYY+R+R\n     So Radiant Wins\n\n\n-\"\"- using 1st right\n+\"\"+ using 2nd right\nX-cancelled currently by 1st right\nY-cancelled earlier by 1st right\nX,Y cant exercise any right"
                    }
                ]
            },
            {
                "id": 1815325,
                "content": [
                    {
                        "username": "percy_98",
                        "content": "As soon as I saw topic to which this question belongs,   I was able to  come up with an approach . For me it was  hard to get the intuition for such a simple problem  "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "similar thing happened with me too"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "*Imagine how hard this\\'d be if it were N parties....*"
                    },
                    {
                        "username": "sooraj7",
                        "content": "doesn\\'t really matter if u using py3"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "for those confused by how \"DDRRR\" is a D victory,\\nIn the first round the 2 Ds get to go first and eliminate 2 of the Rs,\\nbut the last R has yet to go, so it\\'s equivalent to \"RDD\" which is a win for D"
                    },
                    {
                        "username": "vector62",
                        "content": "When I ran this manually, I came up with the answer as \"Dire\". Also my program returns \"Dire\" but the expected asnwer is \"Radiant\". \\n\\nAccording to the dry run I have done, the final state for this is \"DDDD\"\\n\\nPlease help me in figuring out this case."
                    },
                    {
                        "username": "devottam2809",
                        "content": "i\\'ve also done the same dry run , but dont know why its wrong? "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "if it is \"DRRDRDRDRDDRDRDR\" then im also getting the output as Dire only\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is initial input string bro ?"
                    },
                    {
                        "username": "curtman",
                        "content": "Clickbait!"
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "82 / 82 testcases passed\\nBut result is \"\\nTime Limit Exceeded\\nLast Executed Input\\nsenate =\\n\""
                    },
                    {
                        "username": "code_bandit",
                        "content": "Lol, the concept is actually taken from Hunter X Hunter, in which there is actually a very similar process to select Hunter Associations new chairman."
                    },
                    {
                        "username": "HattoriHanzo",
                        "content": "LeetCode, please update the test cases. In the 2-queue solution you adding rTurn back to rQueue if (rTurn < dTurn), and vice versa like this (I have rs as rQueue and r as rTurn)      \\n `  while(rs.size() > 0 && ds.size() > 0){\\n            int r = rs.front();\\n            rs.pop();\\n            int d = ds.front();\\n            ds.pop();\\n            if(r < d)\\n                rs.push(r+s.size());\\n            else\\n                ds.push(d+s.size());\\n        }  \\n`\\n\\nHowever if you change variables that you add back to the opposite, that is, put rTrurn in dQueue and dTurn in rQueue like this  `  if(r < d)\\n                rs.push(d+s.size());\\n            else\\n                ds.push(r+s.size());` \\nit will still be successful, so you will pass all testcases."
                    },
                    {
                        "username": "riskofstorm",
                        "content": "I'm gonna report this to Gaben, because it's damaging Valve reputation in my eyes :D\nOfc not, can't wait for Half-Life 3"
                    },
                    {
                        "username": "sooraj7",
                        "content": "DDRRRR is one case where im failing\\nCODE STOPS AFTER 3 ITERATIONS\\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "[@InfantoSolomon](/InfantoSolomon)  i got that R wins, but my code is working with all other inputs except this one\\n"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRRR\n1st round :\n     -D-DXRRR\n     D-D-YXRR\n     XDYY-R-R\n     YXYYR-R-\n2nd round:\n      YYYY+R+R\n     So Radiant Wins\n\n\n-\"\"- using 1st right\n+\"\"+ using 2nd right\nX-cancelled currently by 1st right\nY-cancelled earlier by 1st right\nX,Y cant exercise any right"
                    }
                ]
            },
            {
                "id": 1882622,
                "content": [
                    {
                        "username": "percy_98",
                        "content": "As soon as I saw topic to which this question belongs,   I was able to  come up with an approach . For me it was  hard to get the intuition for such a simple problem  "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "similar thing happened with me too"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "*Imagine how hard this\\'d be if it were N parties....*"
                    },
                    {
                        "username": "sooraj7",
                        "content": "doesn\\'t really matter if u using py3"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "for those confused by how \"DDRRR\" is a D victory,\\nIn the first round the 2 Ds get to go first and eliminate 2 of the Rs,\\nbut the last R has yet to go, so it\\'s equivalent to \"RDD\" which is a win for D"
                    },
                    {
                        "username": "vector62",
                        "content": "When I ran this manually, I came up with the answer as \"Dire\". Also my program returns \"Dire\" but the expected asnwer is \"Radiant\". \\n\\nAccording to the dry run I have done, the final state for this is \"DDDD\"\\n\\nPlease help me in figuring out this case."
                    },
                    {
                        "username": "devottam2809",
                        "content": "i\\'ve also done the same dry run , but dont know why its wrong? "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "if it is \"DRRDRDRDRDDRDRDR\" then im also getting the output as Dire only\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is initial input string bro ?"
                    },
                    {
                        "username": "curtman",
                        "content": "Clickbait!"
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "82 / 82 testcases passed\\nBut result is \"\\nTime Limit Exceeded\\nLast Executed Input\\nsenate =\\n\""
                    },
                    {
                        "username": "code_bandit",
                        "content": "Lol, the concept is actually taken from Hunter X Hunter, in which there is actually a very similar process to select Hunter Associations new chairman."
                    },
                    {
                        "username": "HattoriHanzo",
                        "content": "LeetCode, please update the test cases. In the 2-queue solution you adding rTurn back to rQueue if (rTurn < dTurn), and vice versa like this (I have rs as rQueue and r as rTurn)      \\n `  while(rs.size() > 0 && ds.size() > 0){\\n            int r = rs.front();\\n            rs.pop();\\n            int d = ds.front();\\n            ds.pop();\\n            if(r < d)\\n                rs.push(r+s.size());\\n            else\\n                ds.push(d+s.size());\\n        }  \\n`\\n\\nHowever if you change variables that you add back to the opposite, that is, put rTrurn in dQueue and dTurn in rQueue like this  `  if(r < d)\\n                rs.push(d+s.size());\\n            else\\n                ds.push(r+s.size());` \\nit will still be successful, so you will pass all testcases."
                    },
                    {
                        "username": "riskofstorm",
                        "content": "I'm gonna report this to Gaben, because it's damaging Valve reputation in my eyes :D\nOfc not, can't wait for Half-Life 3"
                    },
                    {
                        "username": "sooraj7",
                        "content": "DDRRRR is one case where im failing\\nCODE STOPS AFTER 3 ITERATIONS\\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "[@InfantoSolomon](/InfantoSolomon)  i got that R wins, but my code is working with all other inputs except this one\\n"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRRR\n1st round :\n     -D-DXRRR\n     D-D-YXRR\n     XDYY-R-R\n     YXYYR-R-\n2nd round:\n      YYYY+R+R\n     So Radiant Wins\n\n\n-\"\"- using 1st right\n+\"\"+ using 2nd right\nX-cancelled currently by 1st right\nY-cancelled earlier by 1st right\nX,Y cant exercise any right"
                    }
                ]
            },
            {
                "id": 1882572,
                "content": [
                    {
                        "username": "percy_98",
                        "content": "As soon as I saw topic to which this question belongs,   I was able to  come up with an approach . For me it was  hard to get the intuition for such a simple problem  "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "similar thing happened with me too"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "*Imagine how hard this\\'d be if it were N parties....*"
                    },
                    {
                        "username": "sooraj7",
                        "content": "doesn\\'t really matter if u using py3"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "for those confused by how \"DDRRR\" is a D victory,\\nIn the first round the 2 Ds get to go first and eliminate 2 of the Rs,\\nbut the last R has yet to go, so it\\'s equivalent to \"RDD\" which is a win for D"
                    },
                    {
                        "username": "vector62",
                        "content": "When I ran this manually, I came up with the answer as \"Dire\". Also my program returns \"Dire\" but the expected asnwer is \"Radiant\". \\n\\nAccording to the dry run I have done, the final state for this is \"DDDD\"\\n\\nPlease help me in figuring out this case."
                    },
                    {
                        "username": "devottam2809",
                        "content": "i\\'ve also done the same dry run , but dont know why its wrong? "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "if it is \"DRRDRDRDRDDRDRDR\" then im also getting the output as Dire only\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is initial input string bro ?"
                    },
                    {
                        "username": "curtman",
                        "content": "Clickbait!"
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "82 / 82 testcases passed\\nBut result is \"\\nTime Limit Exceeded\\nLast Executed Input\\nsenate =\\n\""
                    },
                    {
                        "username": "code_bandit",
                        "content": "Lol, the concept is actually taken from Hunter X Hunter, in which there is actually a very similar process to select Hunter Associations new chairman."
                    },
                    {
                        "username": "HattoriHanzo",
                        "content": "LeetCode, please update the test cases. In the 2-queue solution you adding rTurn back to rQueue if (rTurn < dTurn), and vice versa like this (I have rs as rQueue and r as rTurn)      \\n `  while(rs.size() > 0 && ds.size() > 0){\\n            int r = rs.front();\\n            rs.pop();\\n            int d = ds.front();\\n            ds.pop();\\n            if(r < d)\\n                rs.push(r+s.size());\\n            else\\n                ds.push(d+s.size());\\n        }  \\n`\\n\\nHowever if you change variables that you add back to the opposite, that is, put rTrurn in dQueue and dTurn in rQueue like this  `  if(r < d)\\n                rs.push(d+s.size());\\n            else\\n                ds.push(r+s.size());` \\nit will still be successful, so you will pass all testcases."
                    },
                    {
                        "username": "riskofstorm",
                        "content": "I'm gonna report this to Gaben, because it's damaging Valve reputation in my eyes :D\nOfc not, can't wait for Half-Life 3"
                    },
                    {
                        "username": "sooraj7",
                        "content": "DDRRRR is one case where im failing\\nCODE STOPS AFTER 3 ITERATIONS\\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "[@InfantoSolomon](/InfantoSolomon)  i got that R wins, but my code is working with all other inputs except this one\\n"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRRR\n1st round :\n     -D-DXRRR\n     D-D-YXRR\n     XDYY-R-R\n     YXYYR-R-\n2nd round:\n      YYYY+R+R\n     So Radiant Wins\n\n\n-\"\"- using 1st right\n+\"\"+ using 2nd right\nX-cancelled currently by 1st right\nY-cancelled earlier by 1st right\nX,Y cant exercise any right"
                    }
                ]
            },
            {
                "id": 1882039,
                "content": [
                    {
                        "username": "percy_98",
                        "content": "As soon as I saw topic to which this question belongs,   I was able to  come up with an approach . For me it was  hard to get the intuition for such a simple problem  "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "similar thing happened with me too"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "*Imagine how hard this\\'d be if it were N parties....*"
                    },
                    {
                        "username": "sooraj7",
                        "content": "doesn\\'t really matter if u using py3"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "for those confused by how \"DDRRR\" is a D victory,\\nIn the first round the 2 Ds get to go first and eliminate 2 of the Rs,\\nbut the last R has yet to go, so it\\'s equivalent to \"RDD\" which is a win for D"
                    },
                    {
                        "username": "vector62",
                        "content": "When I ran this manually, I came up with the answer as \"Dire\". Also my program returns \"Dire\" but the expected asnwer is \"Radiant\". \\n\\nAccording to the dry run I have done, the final state for this is \"DDDD\"\\n\\nPlease help me in figuring out this case."
                    },
                    {
                        "username": "devottam2809",
                        "content": "i\\'ve also done the same dry run , but dont know why its wrong? "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "if it is \"DRRDRDRDRDDRDRDR\" then im also getting the output as Dire only\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is initial input string bro ?"
                    },
                    {
                        "username": "curtman",
                        "content": "Clickbait!"
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "82 / 82 testcases passed\\nBut result is \"\\nTime Limit Exceeded\\nLast Executed Input\\nsenate =\\n\""
                    },
                    {
                        "username": "code_bandit",
                        "content": "Lol, the concept is actually taken from Hunter X Hunter, in which there is actually a very similar process to select Hunter Associations new chairman."
                    },
                    {
                        "username": "HattoriHanzo",
                        "content": "LeetCode, please update the test cases. In the 2-queue solution you adding rTurn back to rQueue if (rTurn < dTurn), and vice versa like this (I have rs as rQueue and r as rTurn)      \\n `  while(rs.size() > 0 && ds.size() > 0){\\n            int r = rs.front();\\n            rs.pop();\\n            int d = ds.front();\\n            ds.pop();\\n            if(r < d)\\n                rs.push(r+s.size());\\n            else\\n                ds.push(d+s.size());\\n        }  \\n`\\n\\nHowever if you change variables that you add back to the opposite, that is, put rTrurn in dQueue and dTurn in rQueue like this  `  if(r < d)\\n                rs.push(d+s.size());\\n            else\\n                ds.push(r+s.size());` \\nit will still be successful, so you will pass all testcases."
                    },
                    {
                        "username": "riskofstorm",
                        "content": "I'm gonna report this to Gaben, because it's damaging Valve reputation in my eyes :D\nOfc not, can't wait for Half-Life 3"
                    },
                    {
                        "username": "sooraj7",
                        "content": "DDRRRR is one case where im failing\\nCODE STOPS AFTER 3 ITERATIONS\\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "[@InfantoSolomon](/InfantoSolomon)  i got that R wins, but my code is working with all other inputs except this one\\n"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRRR\n1st round :\n     -D-DXRRR\n     D-D-YXRR\n     XDYY-R-R\n     YXYYR-R-\n2nd round:\n      YYYY+R+R\n     So Radiant Wins\n\n\n-\"\"- using 1st right\n+\"\"+ using 2nd right\nX-cancelled currently by 1st right\nY-cancelled earlier by 1st right\nX,Y cant exercise any right"
                    }
                ]
            },
            {
                "id": 1881982,
                "content": [
                    {
                        "username": "percy_98",
                        "content": "As soon as I saw topic to which this question belongs,   I was able to  come up with an approach . For me it was  hard to get the intuition for such a simple problem  "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "similar thing happened with me too"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "*Imagine how hard this\\'d be if it were N parties....*"
                    },
                    {
                        "username": "sooraj7",
                        "content": "doesn\\'t really matter if u using py3"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "for those confused by how \"DDRRR\" is a D victory,\\nIn the first round the 2 Ds get to go first and eliminate 2 of the Rs,\\nbut the last R has yet to go, so it\\'s equivalent to \"RDD\" which is a win for D"
                    },
                    {
                        "username": "vector62",
                        "content": "When I ran this manually, I came up with the answer as \"Dire\". Also my program returns \"Dire\" but the expected asnwer is \"Radiant\". \\n\\nAccording to the dry run I have done, the final state for this is \"DDDD\"\\n\\nPlease help me in figuring out this case."
                    },
                    {
                        "username": "devottam2809",
                        "content": "i\\'ve also done the same dry run , but dont know why its wrong? "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "if it is \"DRRDRDRDRDDRDRDR\" then im also getting the output as Dire only\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is initial input string bro ?"
                    },
                    {
                        "username": "curtman",
                        "content": "Clickbait!"
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "82 / 82 testcases passed\\nBut result is \"\\nTime Limit Exceeded\\nLast Executed Input\\nsenate =\\n\""
                    },
                    {
                        "username": "code_bandit",
                        "content": "Lol, the concept is actually taken from Hunter X Hunter, in which there is actually a very similar process to select Hunter Associations new chairman."
                    },
                    {
                        "username": "HattoriHanzo",
                        "content": "LeetCode, please update the test cases. In the 2-queue solution you adding rTurn back to rQueue if (rTurn < dTurn), and vice versa like this (I have rs as rQueue and r as rTurn)      \\n `  while(rs.size() > 0 && ds.size() > 0){\\n            int r = rs.front();\\n            rs.pop();\\n            int d = ds.front();\\n            ds.pop();\\n            if(r < d)\\n                rs.push(r+s.size());\\n            else\\n                ds.push(d+s.size());\\n        }  \\n`\\n\\nHowever if you change variables that you add back to the opposite, that is, put rTrurn in dQueue and dTurn in rQueue like this  `  if(r < d)\\n                rs.push(d+s.size());\\n            else\\n                ds.push(r+s.size());` \\nit will still be successful, so you will pass all testcases."
                    },
                    {
                        "username": "riskofstorm",
                        "content": "I'm gonna report this to Gaben, because it's damaging Valve reputation in my eyes :D\nOfc not, can't wait for Half-Life 3"
                    },
                    {
                        "username": "sooraj7",
                        "content": "DDRRRR is one case where im failing\\nCODE STOPS AFTER 3 ITERATIONS\\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "[@InfantoSolomon](/InfantoSolomon)  i got that R wins, but my code is working with all other inputs except this one\\n"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRRR\n1st round :\n     -D-DXRRR\n     D-D-YXRR\n     XDYY-R-R\n     YXYYR-R-\n2nd round:\n      YYYY+R+R\n     So Radiant Wins\n\n\n-\"\"- using 1st right\n+\"\"+ using 2nd right\nX-cancelled currently by 1st right\nY-cancelled earlier by 1st right\nX,Y cant exercise any right"
                    }
                ]
            },
            {
                "id": 1881953,
                "content": [
                    {
                        "username": "percy_98",
                        "content": "As soon as I saw topic to which this question belongs,   I was able to  come up with an approach . For me it was  hard to get the intuition for such a simple problem  "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "similar thing happened with me too"
                    },
                    {
                        "username": "leetrio-1",
                        "content": "*Imagine how hard this\\'d be if it were N parties....*"
                    },
                    {
                        "username": "sooraj7",
                        "content": "doesn\\'t really matter if u using py3"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "for those confused by how \"DDRRR\" is a D victory,\\nIn the first round the 2 Ds get to go first and eliminate 2 of the Rs,\\nbut the last R has yet to go, so it\\'s equivalent to \"RDD\" which is a win for D"
                    },
                    {
                        "username": "vector62",
                        "content": "When I ran this manually, I came up with the answer as \"Dire\". Also my program returns \"Dire\" but the expected asnwer is \"Radiant\". \\n\\nAccording to the dry run I have done, the final state for this is \"DDDD\"\\n\\nPlease help me in figuring out this case."
                    },
                    {
                        "username": "devottam2809",
                        "content": "i\\'ve also done the same dry run , but dont know why its wrong? "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "if it is \"DRRDRDRDRDDRDRDR\" then im also getting the output as Dire only\\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "what is initial input string bro ?"
                    },
                    {
                        "username": "curtman",
                        "content": "Clickbait!"
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "82 / 82 testcases passed\\nBut result is \"\\nTime Limit Exceeded\\nLast Executed Input\\nsenate =\\n\""
                    },
                    {
                        "username": "code_bandit",
                        "content": "Lol, the concept is actually taken from Hunter X Hunter, in which there is actually a very similar process to select Hunter Associations new chairman."
                    },
                    {
                        "username": "HattoriHanzo",
                        "content": "LeetCode, please update the test cases. In the 2-queue solution you adding rTurn back to rQueue if (rTurn < dTurn), and vice versa like this (I have rs as rQueue and r as rTurn)      \\n `  while(rs.size() > 0 && ds.size() > 0){\\n            int r = rs.front();\\n            rs.pop();\\n            int d = ds.front();\\n            ds.pop();\\n            if(r < d)\\n                rs.push(r+s.size());\\n            else\\n                ds.push(d+s.size());\\n        }  \\n`\\n\\nHowever if you change variables that you add back to the opposite, that is, put rTrurn in dQueue and dTurn in rQueue like this  `  if(r < d)\\n                rs.push(d+s.size());\\n            else\\n                ds.push(r+s.size());` \\nit will still be successful, so you will pass all testcases."
                    },
                    {
                        "username": "riskofstorm",
                        "content": "I'm gonna report this to Gaben, because it's damaging Valve reputation in my eyes :D\nOfc not, can't wait for Half-Life 3"
                    },
                    {
                        "username": "sooraj7",
                        "content": "DDRRRR is one case where im failing\\nCODE STOPS AFTER 3 ITERATIONS\\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "[@InfantoSolomon](/InfantoSolomon)  i got that R wins, but my code is working with all other inputs except this one\\n"
                    },
                    {
                        "username": "InfantoSolomon",
                        "content": "DDRRRR\n1st round :\n     -D-DXRRR\n     D-D-YXRR\n     XDYY-R-R\n     YXYYR-R-\n2nd round:\n      YYYY+R+R\n     So Radiant Wins\n\n\n-\"\"- using 1st right\n+\"\"+ using 2nd right\nX-cancelled currently by 1st right\nY-cancelled earlier by 1st right\nX,Y cant exercise any right"
                    }
                ]
            },
            {
                "id": 1881829,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "Bing search told me that Dota2 is a video game!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"putanginamo bobo me mid\""
                    },
                    {
                        "username": "yabyer1",
                        "content": "im feeling proud of myself for this one :)"
                    },
                    {
                        "username": "2shaziwoofwoof",
                        "content": "ye you know what ima talking about."
                    },
                    {
                        "username": "jim11",
                        "content": "why dota2?"
                    },
                    {
                        "username": "s3stan",
                        "content": "Happiness is when you understand the conditions of the task..."
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "Can anyone explain this test case to me?\\n\"DRRDRDRDRDDRDRDR\""
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "Only when I failed to pass some test cases did I realise that round is an entire pass of the senate list, not a pass of a senator... If it were an interview, I would have failed miserably."
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I feel like who writes this question?!! "
                    },
                    {
                        "username": "Shivansh_Rastogi_1203",
                        "content": "Make 2 deque \\npush R-index and D-index respectively in the deque\\ncompare their index while either of them is empty \\nmake sure to append also rturn/dturn + length"
                    }
                ]
            },
            {
                "id": 1881789,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "Bing search told me that Dota2 is a video game!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"putanginamo bobo me mid\""
                    },
                    {
                        "username": "yabyer1",
                        "content": "im feeling proud of myself for this one :)"
                    },
                    {
                        "username": "2shaziwoofwoof",
                        "content": "ye you know what ima talking about."
                    },
                    {
                        "username": "jim11",
                        "content": "why dota2?"
                    },
                    {
                        "username": "s3stan",
                        "content": "Happiness is when you understand the conditions of the task..."
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "Can anyone explain this test case to me?\\n\"DRRDRDRDRDDRDRDR\""
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "Only when I failed to pass some test cases did I realise that round is an entire pass of the senate list, not a pass of a senator... If it were an interview, I would have failed miserably."
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I feel like who writes this question?!! "
                    },
                    {
                        "username": "Shivansh_Rastogi_1203",
                        "content": "Make 2 deque \\npush R-index and D-index respectively in the deque\\ncompare their index while either of them is empty \\nmake sure to append also rturn/dturn + length"
                    }
                ]
            },
            {
                "id": 1881633,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "Bing search told me that Dota2 is a video game!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"putanginamo bobo me mid\""
                    },
                    {
                        "username": "yabyer1",
                        "content": "im feeling proud of myself for this one :)"
                    },
                    {
                        "username": "2shaziwoofwoof",
                        "content": "ye you know what ima talking about."
                    },
                    {
                        "username": "jim11",
                        "content": "why dota2?"
                    },
                    {
                        "username": "s3stan",
                        "content": "Happiness is when you understand the conditions of the task..."
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "Can anyone explain this test case to me?\\n\"DRRDRDRDRDDRDRDR\""
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "Only when I failed to pass some test cases did I realise that round is an entire pass of the senate list, not a pass of a senator... If it were an interview, I would have failed miserably."
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I feel like who writes this question?!! "
                    },
                    {
                        "username": "Shivansh_Rastogi_1203",
                        "content": "Make 2 deque \\npush R-index and D-index respectively in the deque\\ncompare their index while either of them is empty \\nmake sure to append also rturn/dturn + length"
                    }
                ]
            },
            {
                "id": 1570201,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "Bing search told me that Dota2 is a video game!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"putanginamo bobo me mid\""
                    },
                    {
                        "username": "yabyer1",
                        "content": "im feeling proud of myself for this one :)"
                    },
                    {
                        "username": "2shaziwoofwoof",
                        "content": "ye you know what ima talking about."
                    },
                    {
                        "username": "jim11",
                        "content": "why dota2?"
                    },
                    {
                        "username": "s3stan",
                        "content": "Happiness is when you understand the conditions of the task..."
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "Can anyone explain this test case to me?\\n\"DRRDRDRDRDDRDRDR\""
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "Only when I failed to pass some test cases did I realise that round is an entire pass of the senate list, not a pass of a senator... If it were an interview, I would have failed miserably."
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I feel like who writes this question?!! "
                    },
                    {
                        "username": "Shivansh_Rastogi_1203",
                        "content": "Make 2 deque \\npush R-index and D-index respectively in the deque\\ncompare their index while either of them is empty \\nmake sure to append also rturn/dturn + length"
                    }
                ]
            },
            {
                "id": 2074975,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "Bing search told me that Dota2 is a video game!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"putanginamo bobo me mid\""
                    },
                    {
                        "username": "yabyer1",
                        "content": "im feeling proud of myself for this one :)"
                    },
                    {
                        "username": "2shaziwoofwoof",
                        "content": "ye you know what ima talking about."
                    },
                    {
                        "username": "jim11",
                        "content": "why dota2?"
                    },
                    {
                        "username": "s3stan",
                        "content": "Happiness is when you understand the conditions of the task..."
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "Can anyone explain this test case to me?\\n\"DRRDRDRDRDDRDRDR\""
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "Only when I failed to pass some test cases did I realise that round is an entire pass of the senate list, not a pass of a senator... If it were an interview, I would have failed miserably."
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I feel like who writes this question?!! "
                    },
                    {
                        "username": "Shivansh_Rastogi_1203",
                        "content": "Make 2 deque \\npush R-index and D-index respectively in the deque\\ncompare their index while either of them is empty \\nmake sure to append also rturn/dturn + length"
                    }
                ]
            },
            {
                "id": 2073286,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "Bing search told me that Dota2 is a video game!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"putanginamo bobo me mid\""
                    },
                    {
                        "username": "yabyer1",
                        "content": "im feeling proud of myself for this one :)"
                    },
                    {
                        "username": "2shaziwoofwoof",
                        "content": "ye you know what ima talking about."
                    },
                    {
                        "username": "jim11",
                        "content": "why dota2?"
                    },
                    {
                        "username": "s3stan",
                        "content": "Happiness is when you understand the conditions of the task..."
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "Can anyone explain this test case to me?\\n\"DRRDRDRDRDDRDRDR\""
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "Only when I failed to pass some test cases did I realise that round is an entire pass of the senate list, not a pass of a senator... If it were an interview, I would have failed miserably."
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I feel like who writes this question?!! "
                    },
                    {
                        "username": "Shivansh_Rastogi_1203",
                        "content": "Make 2 deque \\npush R-index and D-index respectively in the deque\\ncompare their index while either of them is empty \\nmake sure to append also rturn/dturn + length"
                    }
                ]
            },
            {
                "id": 2058624,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "Bing search told me that Dota2 is a video game!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"putanginamo bobo me mid\""
                    },
                    {
                        "username": "yabyer1",
                        "content": "im feeling proud of myself for this one :)"
                    },
                    {
                        "username": "2shaziwoofwoof",
                        "content": "ye you know what ima talking about."
                    },
                    {
                        "username": "jim11",
                        "content": "why dota2?"
                    },
                    {
                        "username": "s3stan",
                        "content": "Happiness is when you understand the conditions of the task..."
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "Can anyone explain this test case to me?\\n\"DRRDRDRDRDDRDRDR\""
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "Only when I failed to pass some test cases did I realise that round is an entire pass of the senate list, not a pass of a senator... If it were an interview, I would have failed miserably."
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I feel like who writes this question?!! "
                    },
                    {
                        "username": "Shivansh_Rastogi_1203",
                        "content": "Make 2 deque \\npush R-index and D-index respectively in the deque\\ncompare their index while either of them is empty \\nmake sure to append also rturn/dturn + length"
                    }
                ]
            },
            {
                "id": 2004323,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "Bing search told me that Dota2 is a video game!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"putanginamo bobo me mid\""
                    },
                    {
                        "username": "yabyer1",
                        "content": "im feeling proud of myself for this one :)"
                    },
                    {
                        "username": "2shaziwoofwoof",
                        "content": "ye you know what ima talking about."
                    },
                    {
                        "username": "jim11",
                        "content": "why dota2?"
                    },
                    {
                        "username": "s3stan",
                        "content": "Happiness is when you understand the conditions of the task..."
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "Can anyone explain this test case to me?\\n\"DRRDRDRDRDDRDRDR\""
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "Only when I failed to pass some test cases did I realise that round is an entire pass of the senate list, not a pass of a senator... If it were an interview, I would have failed miserably."
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I feel like who writes this question?!! "
                    },
                    {
                        "username": "Shivansh_Rastogi_1203",
                        "content": "Make 2 deque \\npush R-index and D-index respectively in the deque\\ncompare their index while either of them is empty \\nmake sure to append also rturn/dturn + length"
                    }
                ]
            },
            {
                "id": 1993639,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "Bing search told me that Dota2 is a video game!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"putanginamo bobo me mid\""
                    },
                    {
                        "username": "yabyer1",
                        "content": "im feeling proud of myself for this one :)"
                    },
                    {
                        "username": "2shaziwoofwoof",
                        "content": "ye you know what ima talking about."
                    },
                    {
                        "username": "jim11",
                        "content": "why dota2?"
                    },
                    {
                        "username": "s3stan",
                        "content": "Happiness is when you understand the conditions of the task..."
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "Can anyone explain this test case to me?\\n\"DRRDRDRDRDDRDRDR\""
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "Only when I failed to pass some test cases did I realise that round is an entire pass of the senate list, not a pass of a senator... If it were an interview, I would have failed miserably."
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I feel like who writes this question?!! "
                    },
                    {
                        "username": "Shivansh_Rastogi_1203",
                        "content": "Make 2 deque \\npush R-index and D-index respectively in the deque\\ncompare their index while either of them is empty \\nmake sure to append also rturn/dturn + length"
                    }
                ]
            },
            {
                "id": 1973013,
                "content": [
                    {
                        "username": "leeten__1500",
                        "content": "Bing search told me that Dota2 is a video game!"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"putanginamo bobo me mid\""
                    },
                    {
                        "username": "yabyer1",
                        "content": "im feeling proud of myself for this one :)"
                    },
                    {
                        "username": "2shaziwoofwoof",
                        "content": "ye you know what ima talking about."
                    },
                    {
                        "username": "jim11",
                        "content": "why dota2?"
                    },
                    {
                        "username": "s3stan",
                        "content": "Happiness is when you understand the conditions of the task..."
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "Can anyone explain this test case to me?\\n\"DRRDRDRDRDDRDRDR\""
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "Only when I failed to pass some test cases did I realise that round is an entire pass of the senate list, not a pass of a senator... If it were an interview, I would have failed miserably."
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I feel like who writes this question?!! "
                    },
                    {
                        "username": "Shivansh_Rastogi_1203",
                        "content": "Make 2 deque \\npush R-index and D-index respectively in the deque\\ncompare their index while either of them is empty \\nmake sure to append also rturn/dturn + length"
                    }
                ]
            },
            {
                "id": 1964547,
                "content": [
                    {
                        "username": "vudat1710",
                        "content": "It\\'s 3a.m and I have no idea wth I am reading"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "better don\\'t try doing this, you will lose time, health and nerves. "
                    },
                    {
                        "username": "ahmedkhalidismail",
                        "content": "I appreciate the elegant explanations! They have helped me learn how to approach the problem-solving process more effectively."
                    },
                    {
                        "username": "ansh_kumar_04",
                        "content": "If both have remains equal number of R & D then who will be the winner?"
                    },
                    {
                        "username": "Arana",
                        "content": "I created a solution using linked list, similar to the one queue solution. I posted it in the solution page. Please comment and upvote :)"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Can someone explain?\\nwhy in Editorial, the 1st approach, the overall time complexity is O(N*N)?\\nwhy its not O(log(N)*N*N) ?"
                    },
                    {
                        "username": "texcucano",
                        "content": "Take on account circular queue/array"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why so many dislikes? Cause only dota 2 clickbait title?)\\nIn my opinion very very good medium problem (especially with editorial explanation)."
                    },
                    {
                        "username": "anikets2002",
                        "content": "Yea its pretty cool problem imo, its fun to see these kinds of problems on leetcode."
                    },
                    {
                        "username": "anubhavchk007",
                        "content": "In the question, it has been said that in each round, *each* of the senators can exercise one of the two rights. In the first example i.e. \"RD\", R bans D, but I don\\'t understand how the priority works here. Why did D not ban R before R did? Cause it has been clearly mentioned that in each round, *each* of the senators get to exercise their rights."
                    },
                    {
                        "username": "yshrini",
                        "content": "They follow index order \"RD\" (who come first in index get first chance to vote), so \"R\" will get first change, \"R\" have 2 choice \n1. Declare victory : But R can not declare victory as all member are not from \"R\"\n2. Ban any \"D\" after my index : Banning any \"D\" after current index is best choice because future \"D\" are most harmful as they too have banning capability, so if current \"R\" banns future D, they are gone from list and can not vote and can not be counted in majority and current \"R\" will exist and can be counted as in majority but can not vote again\n\nso when \"D\" turn come there is no \"D\". only one \"R\" left so due to all members are from same group, \"R\" wins.\n\nCheck my solution : https://leetcode.com/problems/dota2-senate/solutions/3483393/easy-java-solution-using-stringbuilder-beginner-friendly/\n\nLogic : Current member delete first found opposite member after their index and move themself to end of the string."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can this be solved using stack ?\\n"
                    }
                ]
            },
            {
                "id": 1963812,
                "content": [
                    {
                        "username": "vudat1710",
                        "content": "It\\'s 3a.m and I have no idea wth I am reading"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "better don\\'t try doing this, you will lose time, health and nerves. "
                    },
                    {
                        "username": "ahmedkhalidismail",
                        "content": "I appreciate the elegant explanations! They have helped me learn how to approach the problem-solving process more effectively."
                    },
                    {
                        "username": "ansh_kumar_04",
                        "content": "If both have remains equal number of R & D then who will be the winner?"
                    },
                    {
                        "username": "Arana",
                        "content": "I created a solution using linked list, similar to the one queue solution. I posted it in the solution page. Please comment and upvote :)"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Can someone explain?\\nwhy in Editorial, the 1st approach, the overall time complexity is O(N*N)?\\nwhy its not O(log(N)*N*N) ?"
                    },
                    {
                        "username": "texcucano",
                        "content": "Take on account circular queue/array"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why so many dislikes? Cause only dota 2 clickbait title?)\\nIn my opinion very very good medium problem (especially with editorial explanation)."
                    },
                    {
                        "username": "anikets2002",
                        "content": "Yea its pretty cool problem imo, its fun to see these kinds of problems on leetcode."
                    },
                    {
                        "username": "anubhavchk007",
                        "content": "In the question, it has been said that in each round, *each* of the senators can exercise one of the two rights. In the first example i.e. \"RD\", R bans D, but I don\\'t understand how the priority works here. Why did D not ban R before R did? Cause it has been clearly mentioned that in each round, *each* of the senators get to exercise their rights."
                    },
                    {
                        "username": "yshrini",
                        "content": "They follow index order \"RD\" (who come first in index get first chance to vote), so \"R\" will get first change, \"R\" have 2 choice \n1. Declare victory : But R can not declare victory as all member are not from \"R\"\n2. Ban any \"D\" after my index : Banning any \"D\" after current index is best choice because future \"D\" are most harmful as they too have banning capability, so if current \"R\" banns future D, they are gone from list and can not vote and can not be counted in majority and current \"R\" will exist and can be counted as in majority but can not vote again\n\nso when \"D\" turn come there is no \"D\". only one \"R\" left so due to all members are from same group, \"R\" wins.\n\nCheck my solution : https://leetcode.com/problems/dota2-senate/solutions/3483393/easy-java-solution-using-stringbuilder-beginner-friendly/\n\nLogic : Current member delete first found opposite member after their index and move themself to end of the string."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can this be solved using stack ?\\n"
                    }
                ]
            },
            {
                "id": 1886970,
                "content": [
                    {
                        "username": "vudat1710",
                        "content": "It\\'s 3a.m and I have no idea wth I am reading"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "better don\\'t try doing this, you will lose time, health and nerves. "
                    },
                    {
                        "username": "ahmedkhalidismail",
                        "content": "I appreciate the elegant explanations! They have helped me learn how to approach the problem-solving process more effectively."
                    },
                    {
                        "username": "ansh_kumar_04",
                        "content": "If both have remains equal number of R & D then who will be the winner?"
                    },
                    {
                        "username": "Arana",
                        "content": "I created a solution using linked list, similar to the one queue solution. I posted it in the solution page. Please comment and upvote :)"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Can someone explain?\\nwhy in Editorial, the 1st approach, the overall time complexity is O(N*N)?\\nwhy its not O(log(N)*N*N) ?"
                    },
                    {
                        "username": "texcucano",
                        "content": "Take on account circular queue/array"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why so many dislikes? Cause only dota 2 clickbait title?)\\nIn my opinion very very good medium problem (especially with editorial explanation)."
                    },
                    {
                        "username": "anikets2002",
                        "content": "Yea its pretty cool problem imo, its fun to see these kinds of problems on leetcode."
                    },
                    {
                        "username": "anubhavchk007",
                        "content": "In the question, it has been said that in each round, *each* of the senators can exercise one of the two rights. In the first example i.e. \"RD\", R bans D, but I don\\'t understand how the priority works here. Why did D not ban R before R did? Cause it has been clearly mentioned that in each round, *each* of the senators get to exercise their rights."
                    },
                    {
                        "username": "yshrini",
                        "content": "They follow index order \"RD\" (who come first in index get first chance to vote), so \"R\" will get first change, \"R\" have 2 choice \n1. Declare victory : But R can not declare victory as all member are not from \"R\"\n2. Ban any \"D\" after my index : Banning any \"D\" after current index is best choice because future \"D\" are most harmful as they too have banning capability, so if current \"R\" banns future D, they are gone from list and can not vote and can not be counted in majority and current \"R\" will exist and can be counted as in majority but can not vote again\n\nso when \"D\" turn come there is no \"D\". only one \"R\" left so due to all members are from same group, \"R\" wins.\n\nCheck my solution : https://leetcode.com/problems/dota2-senate/solutions/3483393/easy-java-solution-using-stringbuilder-beginner-friendly/\n\nLogic : Current member delete first found opposite member after their index and move themself to end of the string."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can this be solved using stack ?\\n"
                    }
                ]
            },
            {
                "id": 1883701,
                "content": [
                    {
                        "username": "vudat1710",
                        "content": "It\\'s 3a.m and I have no idea wth I am reading"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "better don\\'t try doing this, you will lose time, health and nerves. "
                    },
                    {
                        "username": "ahmedkhalidismail",
                        "content": "I appreciate the elegant explanations! They have helped me learn how to approach the problem-solving process more effectively."
                    },
                    {
                        "username": "ansh_kumar_04",
                        "content": "If both have remains equal number of R & D then who will be the winner?"
                    },
                    {
                        "username": "Arana",
                        "content": "I created a solution using linked list, similar to the one queue solution. I posted it in the solution page. Please comment and upvote :)"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Can someone explain?\\nwhy in Editorial, the 1st approach, the overall time complexity is O(N*N)?\\nwhy its not O(log(N)*N*N) ?"
                    },
                    {
                        "username": "texcucano",
                        "content": "Take on account circular queue/array"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why so many dislikes? Cause only dota 2 clickbait title?)\\nIn my opinion very very good medium problem (especially with editorial explanation)."
                    },
                    {
                        "username": "anikets2002",
                        "content": "Yea its pretty cool problem imo, its fun to see these kinds of problems on leetcode."
                    },
                    {
                        "username": "anubhavchk007",
                        "content": "In the question, it has been said that in each round, *each* of the senators can exercise one of the two rights. In the first example i.e. \"RD\", R bans D, but I don\\'t understand how the priority works here. Why did D not ban R before R did? Cause it has been clearly mentioned that in each round, *each* of the senators get to exercise their rights."
                    },
                    {
                        "username": "yshrini",
                        "content": "They follow index order \"RD\" (who come first in index get first chance to vote), so \"R\" will get first change, \"R\" have 2 choice \n1. Declare victory : But R can not declare victory as all member are not from \"R\"\n2. Ban any \"D\" after my index : Banning any \"D\" after current index is best choice because future \"D\" are most harmful as they too have banning capability, so if current \"R\" banns future D, they are gone from list and can not vote and can not be counted in majority and current \"R\" will exist and can be counted as in majority but can not vote again\n\nso when \"D\" turn come there is no \"D\". only one \"R\" left so due to all members are from same group, \"R\" wins.\n\nCheck my solution : https://leetcode.com/problems/dota2-senate/solutions/3483393/easy-java-solution-using-stringbuilder-beginner-friendly/\n\nLogic : Current member delete first found opposite member after their index and move themself to end of the string."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can this be solved using stack ?\\n"
                    }
                ]
            },
            {
                "id": 1883192,
                "content": [
                    {
                        "username": "vudat1710",
                        "content": "It\\'s 3a.m and I have no idea wth I am reading"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "better don\\'t try doing this, you will lose time, health and nerves. "
                    },
                    {
                        "username": "ahmedkhalidismail",
                        "content": "I appreciate the elegant explanations! They have helped me learn how to approach the problem-solving process more effectively."
                    },
                    {
                        "username": "ansh_kumar_04",
                        "content": "If both have remains equal number of R & D then who will be the winner?"
                    },
                    {
                        "username": "Arana",
                        "content": "I created a solution using linked list, similar to the one queue solution. I posted it in the solution page. Please comment and upvote :)"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Can someone explain?\\nwhy in Editorial, the 1st approach, the overall time complexity is O(N*N)?\\nwhy its not O(log(N)*N*N) ?"
                    },
                    {
                        "username": "texcucano",
                        "content": "Take on account circular queue/array"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why so many dislikes? Cause only dota 2 clickbait title?)\\nIn my opinion very very good medium problem (especially with editorial explanation)."
                    },
                    {
                        "username": "anikets2002",
                        "content": "Yea its pretty cool problem imo, its fun to see these kinds of problems on leetcode."
                    },
                    {
                        "username": "anubhavchk007",
                        "content": "In the question, it has been said that in each round, *each* of the senators can exercise one of the two rights. In the first example i.e. \"RD\", R bans D, but I don\\'t understand how the priority works here. Why did D not ban R before R did? Cause it has been clearly mentioned that in each round, *each* of the senators get to exercise their rights."
                    },
                    {
                        "username": "yshrini",
                        "content": "They follow index order \"RD\" (who come first in index get first chance to vote), so \"R\" will get first change, \"R\" have 2 choice \n1. Declare victory : But R can not declare victory as all member are not from \"R\"\n2. Ban any \"D\" after my index : Banning any \"D\" after current index is best choice because future \"D\" are most harmful as they too have banning capability, so if current \"R\" banns future D, they are gone from list and can not vote and can not be counted in majority and current \"R\" will exist and can be counted as in majority but can not vote again\n\nso when \"D\" turn come there is no \"D\". only one \"R\" left so due to all members are from same group, \"R\" wins.\n\nCheck my solution : https://leetcode.com/problems/dota2-senate/solutions/3483393/easy-java-solution-using-stringbuilder-beginner-friendly/\n\nLogic : Current member delete first found opposite member after their index and move themself to end of the string."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can this be solved using stack ?\\n"
                    }
                ]
            },
            {
                "id": 1882981,
                "content": [
                    {
                        "username": "vudat1710",
                        "content": "It\\'s 3a.m and I have no idea wth I am reading"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "better don\\'t try doing this, you will lose time, health and nerves. "
                    },
                    {
                        "username": "ahmedkhalidismail",
                        "content": "I appreciate the elegant explanations! They have helped me learn how to approach the problem-solving process more effectively."
                    },
                    {
                        "username": "ansh_kumar_04",
                        "content": "If both have remains equal number of R & D then who will be the winner?"
                    },
                    {
                        "username": "Arana",
                        "content": "I created a solution using linked list, similar to the one queue solution. I posted it in the solution page. Please comment and upvote :)"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Can someone explain?\\nwhy in Editorial, the 1st approach, the overall time complexity is O(N*N)?\\nwhy its not O(log(N)*N*N) ?"
                    },
                    {
                        "username": "texcucano",
                        "content": "Take on account circular queue/array"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why so many dislikes? Cause only dota 2 clickbait title?)\\nIn my opinion very very good medium problem (especially with editorial explanation)."
                    },
                    {
                        "username": "anikets2002",
                        "content": "Yea its pretty cool problem imo, its fun to see these kinds of problems on leetcode."
                    },
                    {
                        "username": "anubhavchk007",
                        "content": "In the question, it has been said that in each round, *each* of the senators can exercise one of the two rights. In the first example i.e. \"RD\", R bans D, but I don\\'t understand how the priority works here. Why did D not ban R before R did? Cause it has been clearly mentioned that in each round, *each* of the senators get to exercise their rights."
                    },
                    {
                        "username": "yshrini",
                        "content": "They follow index order \"RD\" (who come first in index get first chance to vote), so \"R\" will get first change, \"R\" have 2 choice \n1. Declare victory : But R can not declare victory as all member are not from \"R\"\n2. Ban any \"D\" after my index : Banning any \"D\" after current index is best choice because future \"D\" are most harmful as they too have banning capability, so if current \"R\" banns future D, they are gone from list and can not vote and can not be counted in majority and current \"R\" will exist and can be counted as in majority but can not vote again\n\nso when \"D\" turn come there is no \"D\". only one \"R\" left so due to all members are from same group, \"R\" wins.\n\nCheck my solution : https://leetcode.com/problems/dota2-senate/solutions/3483393/easy-java-solution-using-stringbuilder-beginner-friendly/\n\nLogic : Current member delete first found opposite member after their index and move themself to end of the string."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can this be solved using stack ?\\n"
                    }
                ]
            },
            {
                "id": 1882705,
                "content": [
                    {
                        "username": "vudat1710",
                        "content": "It\\'s 3a.m and I have no idea wth I am reading"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "better don\\'t try doing this, you will lose time, health and nerves. "
                    },
                    {
                        "username": "ahmedkhalidismail",
                        "content": "I appreciate the elegant explanations! They have helped me learn how to approach the problem-solving process more effectively."
                    },
                    {
                        "username": "ansh_kumar_04",
                        "content": "If both have remains equal number of R & D then who will be the winner?"
                    },
                    {
                        "username": "Arana",
                        "content": "I created a solution using linked list, similar to the one queue solution. I posted it in the solution page. Please comment and upvote :)"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Can someone explain?\\nwhy in Editorial, the 1st approach, the overall time complexity is O(N*N)?\\nwhy its not O(log(N)*N*N) ?"
                    },
                    {
                        "username": "texcucano",
                        "content": "Take on account circular queue/array"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why so many dislikes? Cause only dota 2 clickbait title?)\\nIn my opinion very very good medium problem (especially with editorial explanation)."
                    },
                    {
                        "username": "anikets2002",
                        "content": "Yea its pretty cool problem imo, its fun to see these kinds of problems on leetcode."
                    },
                    {
                        "username": "anubhavchk007",
                        "content": "In the question, it has been said that in each round, *each* of the senators can exercise one of the two rights. In the first example i.e. \"RD\", R bans D, but I don\\'t understand how the priority works here. Why did D not ban R before R did? Cause it has been clearly mentioned that in each round, *each* of the senators get to exercise their rights."
                    },
                    {
                        "username": "yshrini",
                        "content": "They follow index order \"RD\" (who come first in index get first chance to vote), so \"R\" will get first change, \"R\" have 2 choice \n1. Declare victory : But R can not declare victory as all member are not from \"R\"\n2. Ban any \"D\" after my index : Banning any \"D\" after current index is best choice because future \"D\" are most harmful as they too have banning capability, so if current \"R\" banns future D, they are gone from list and can not vote and can not be counted in majority and current \"R\" will exist and can be counted as in majority but can not vote again\n\nso when \"D\" turn come there is no \"D\". only one \"R\" left so due to all members are from same group, \"R\" wins.\n\nCheck my solution : https://leetcode.com/problems/dota2-senate/solutions/3483393/easy-java-solution-using-stringbuilder-beginner-friendly/\n\nLogic : Current member delete first found opposite member after their index and move themself to end of the string."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can this be solved using stack ?\\n"
                    }
                ]
            },
            {
                "id": 1882660,
                "content": [
                    {
                        "username": "vudat1710",
                        "content": "It\\'s 3a.m and I have no idea wth I am reading"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "better don\\'t try doing this, you will lose time, health and nerves. "
                    },
                    {
                        "username": "ahmedkhalidismail",
                        "content": "I appreciate the elegant explanations! They have helped me learn how to approach the problem-solving process more effectively."
                    },
                    {
                        "username": "ansh_kumar_04",
                        "content": "If both have remains equal number of R & D then who will be the winner?"
                    },
                    {
                        "username": "Arana",
                        "content": "I created a solution using linked list, similar to the one queue solution. I posted it in the solution page. Please comment and upvote :)"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Can someone explain?\\nwhy in Editorial, the 1st approach, the overall time complexity is O(N*N)?\\nwhy its not O(log(N)*N*N) ?"
                    },
                    {
                        "username": "texcucano",
                        "content": "Take on account circular queue/array"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why so many dislikes? Cause only dota 2 clickbait title?)\\nIn my opinion very very good medium problem (especially with editorial explanation)."
                    },
                    {
                        "username": "anikets2002",
                        "content": "Yea its pretty cool problem imo, its fun to see these kinds of problems on leetcode."
                    },
                    {
                        "username": "anubhavchk007",
                        "content": "In the question, it has been said that in each round, *each* of the senators can exercise one of the two rights. In the first example i.e. \"RD\", R bans D, but I don\\'t understand how the priority works here. Why did D not ban R before R did? Cause it has been clearly mentioned that in each round, *each* of the senators get to exercise their rights."
                    },
                    {
                        "username": "yshrini",
                        "content": "They follow index order \"RD\" (who come first in index get first chance to vote), so \"R\" will get first change, \"R\" have 2 choice \n1. Declare victory : But R can not declare victory as all member are not from \"R\"\n2. Ban any \"D\" after my index : Banning any \"D\" after current index is best choice because future \"D\" are most harmful as they too have banning capability, so if current \"R\" banns future D, they are gone from list and can not vote and can not be counted in majority and current \"R\" will exist and can be counted as in majority but can not vote again\n\nso when \"D\" turn come there is no \"D\". only one \"R\" left so due to all members are from same group, \"R\" wins.\n\nCheck my solution : https://leetcode.com/problems/dota2-senate/solutions/3483393/easy-java-solution-using-stringbuilder-beginner-friendly/\n\nLogic : Current member delete first found opposite member after their index and move themself to end of the string."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can this be solved using stack ?\\n"
                    }
                ]
            },
            {
                "id": 1882632,
                "content": [
                    {
                        "username": "vudat1710",
                        "content": "It\\'s 3a.m and I have no idea wth I am reading"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "better don\\'t try doing this, you will lose time, health and nerves. "
                    },
                    {
                        "username": "ahmedkhalidismail",
                        "content": "I appreciate the elegant explanations! They have helped me learn how to approach the problem-solving process more effectively."
                    },
                    {
                        "username": "ansh_kumar_04",
                        "content": "If both have remains equal number of R & D then who will be the winner?"
                    },
                    {
                        "username": "Arana",
                        "content": "I created a solution using linked list, similar to the one queue solution. I posted it in the solution page. Please comment and upvote :)"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Can someone explain?\\nwhy in Editorial, the 1st approach, the overall time complexity is O(N*N)?\\nwhy its not O(log(N)*N*N) ?"
                    },
                    {
                        "username": "texcucano",
                        "content": "Take on account circular queue/array"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why so many dislikes? Cause only dota 2 clickbait title?)\\nIn my opinion very very good medium problem (especially with editorial explanation)."
                    },
                    {
                        "username": "anikets2002",
                        "content": "Yea its pretty cool problem imo, its fun to see these kinds of problems on leetcode."
                    },
                    {
                        "username": "anubhavchk007",
                        "content": "In the question, it has been said that in each round, *each* of the senators can exercise one of the two rights. In the first example i.e. \"RD\", R bans D, but I don\\'t understand how the priority works here. Why did D not ban R before R did? Cause it has been clearly mentioned that in each round, *each* of the senators get to exercise their rights."
                    },
                    {
                        "username": "yshrini",
                        "content": "They follow index order \"RD\" (who come first in index get first chance to vote), so \"R\" will get first change, \"R\" have 2 choice \n1. Declare victory : But R can not declare victory as all member are not from \"R\"\n2. Ban any \"D\" after my index : Banning any \"D\" after current index is best choice because future \"D\" are most harmful as they too have banning capability, so if current \"R\" banns future D, they are gone from list and can not vote and can not be counted in majority and current \"R\" will exist and can be counted as in majority but can not vote again\n\nso when \"D\" turn come there is no \"D\". only one \"R\" left so due to all members are from same group, \"R\" wins.\n\nCheck my solution : https://leetcode.com/problems/dota2-senate/solutions/3483393/easy-java-solution-using-stringbuilder-beginner-friendly/\n\nLogic : Current member delete first found opposite member after their index and move themself to end of the string."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can this be solved using stack ?\\n"
                    }
                ]
            },
            {
                "id": 1882615,
                "content": [
                    {
                        "username": "vudat1710",
                        "content": "It\\'s 3a.m and I have no idea wth I am reading"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "better don\\'t try doing this, you will lose time, health and nerves. "
                    },
                    {
                        "username": "ahmedkhalidismail",
                        "content": "I appreciate the elegant explanations! They have helped me learn how to approach the problem-solving process more effectively."
                    },
                    {
                        "username": "ansh_kumar_04",
                        "content": "If both have remains equal number of R & D then who will be the winner?"
                    },
                    {
                        "username": "Arana",
                        "content": "I created a solution using linked list, similar to the one queue solution. I posted it in the solution page. Please comment and upvote :)"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Can someone explain?\\nwhy in Editorial, the 1st approach, the overall time complexity is O(N*N)?\\nwhy its not O(log(N)*N*N) ?"
                    },
                    {
                        "username": "texcucano",
                        "content": "Take on account circular queue/array"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Why so many dislikes? Cause only dota 2 clickbait title?)\\nIn my opinion very very good medium problem (especially with editorial explanation)."
                    },
                    {
                        "username": "anikets2002",
                        "content": "Yea its pretty cool problem imo, its fun to see these kinds of problems on leetcode."
                    },
                    {
                        "username": "anubhavchk007",
                        "content": "In the question, it has been said that in each round, *each* of the senators can exercise one of the two rights. In the first example i.e. \"RD\", R bans D, but I don\\'t understand how the priority works here. Why did D not ban R before R did? Cause it has been clearly mentioned that in each round, *each* of the senators get to exercise their rights."
                    },
                    {
                        "username": "yshrini",
                        "content": "They follow index order \"RD\" (who come first in index get first chance to vote), so \"R\" will get first change, \"R\" have 2 choice \n1. Declare victory : But R can not declare victory as all member are not from \"R\"\n2. Ban any \"D\" after my index : Banning any \"D\" after current index is best choice because future \"D\" are most harmful as they too have banning capability, so if current \"R\" banns future D, they are gone from list and can not vote and can not be counted in majority and current \"R\" will exist and can be counted as in majority but can not vote again\n\nso when \"D\" turn come there is no \"D\". only one \"R\" left so due to all members are from same group, \"R\" wins.\n\nCheck my solution : https://leetcode.com/problems/dota2-senate/solutions/3483393/easy-java-solution-using-stringbuilder-beginner-friendly/\n\nLogic : Current member delete first found opposite member after their index and move themself to end of the string."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can this be solved using stack ?\\n"
                    }
                ]
            },
            {
                "id": 1882579,
                "content": [
                    {
                        "username": "shivamgarg260",
                        "content": "Not submitting even after passing all 82 test cases:("
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "is this a bug or you found a solution?"
                    },
                    {
                        "username": "natitati",
                        "content": "Very cool problem"
                    },
                    {
                        "username": "caldempsey",
                        "content": "How many rounds?"
                    },
                    {
                        "username": "shahil3303",
                        "content": "senate =\\n\"DDR\"\\ngetting tle for this case\\n"
                    },
                    {
                        "username": "Kovid_krishnan_30",
                        "content": "Almost been 9 hours, still not getting it \\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "renetchi",
                        "content": "I don\\'t play Dota.. I don\\'t get the reference.."
                    },
                    {
                        "username": "zwang198",
                        "content": "Senator: Say yes or no!"
                    },
                    {
                        "username": "sukiboo",
                        "content": "\"Suppose every senator is smart enough and will play the best strategy for his own party.\"\\nIf only it worked like that in real life <_<"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "reminds me of STAR WARS"
                    },
                    {
                        "username": "programmer0073",
                        "content": "Too ambiguous? Can D ban another D? From the test cases, it seems they cannot, but from the description it does not say anything."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "D can but it is not beneficial for Dire senators , if they wanna win they will always ban opposing team."
                    }
                ]
            },
            {
                "id": 1882564,
                "content": [
                    {
                        "username": "shivamgarg260",
                        "content": "Not submitting even after passing all 82 test cases:("
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "is this a bug or you found a solution?"
                    },
                    {
                        "username": "natitati",
                        "content": "Very cool problem"
                    },
                    {
                        "username": "caldempsey",
                        "content": "How many rounds?"
                    },
                    {
                        "username": "shahil3303",
                        "content": "senate =\\n\"DDR\"\\ngetting tle for this case\\n"
                    },
                    {
                        "username": "Kovid_krishnan_30",
                        "content": "Almost been 9 hours, still not getting it \\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "renetchi",
                        "content": "I don\\'t play Dota.. I don\\'t get the reference.."
                    },
                    {
                        "username": "zwang198",
                        "content": "Senator: Say yes or no!"
                    },
                    {
                        "username": "sukiboo",
                        "content": "\"Suppose every senator is smart enough and will play the best strategy for his own party.\"\\nIf only it worked like that in real life <_<"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "reminds me of STAR WARS"
                    },
                    {
                        "username": "programmer0073",
                        "content": "Too ambiguous? Can D ban another D? From the test cases, it seems they cannot, but from the description it does not say anything."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "D can but it is not beneficial for Dire senators , if they wanna win they will always ban opposing team."
                    }
                ]
            },
            {
                "id": 1882527,
                "content": [
                    {
                        "username": "shivamgarg260",
                        "content": "Not submitting even after passing all 82 test cases:("
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "is this a bug or you found a solution?"
                    },
                    {
                        "username": "natitati",
                        "content": "Very cool problem"
                    },
                    {
                        "username": "caldempsey",
                        "content": "How many rounds?"
                    },
                    {
                        "username": "shahil3303",
                        "content": "senate =\\n\"DDR\"\\ngetting tle for this case\\n"
                    },
                    {
                        "username": "Kovid_krishnan_30",
                        "content": "Almost been 9 hours, still not getting it \\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "renetchi",
                        "content": "I don\\'t play Dota.. I don\\'t get the reference.."
                    },
                    {
                        "username": "zwang198",
                        "content": "Senator: Say yes or no!"
                    },
                    {
                        "username": "sukiboo",
                        "content": "\"Suppose every senator is smart enough and will play the best strategy for his own party.\"\\nIf only it worked like that in real life <_<"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "reminds me of STAR WARS"
                    },
                    {
                        "username": "programmer0073",
                        "content": "Too ambiguous? Can D ban another D? From the test cases, it seems they cannot, but from the description it does not say anything."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "D can but it is not beneficial for Dire senators , if they wanna win they will always ban opposing team."
                    }
                ]
            },
            {
                "id": 1882514,
                "content": [
                    {
                        "username": "shivamgarg260",
                        "content": "Not submitting even after passing all 82 test cases:("
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "is this a bug or you found a solution?"
                    },
                    {
                        "username": "natitati",
                        "content": "Very cool problem"
                    },
                    {
                        "username": "caldempsey",
                        "content": "How many rounds?"
                    },
                    {
                        "username": "shahil3303",
                        "content": "senate =\\n\"DDR\"\\ngetting tle for this case\\n"
                    },
                    {
                        "username": "Kovid_krishnan_30",
                        "content": "Almost been 9 hours, still not getting it \\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "renetchi",
                        "content": "I don\\'t play Dota.. I don\\'t get the reference.."
                    },
                    {
                        "username": "zwang198",
                        "content": "Senator: Say yes or no!"
                    },
                    {
                        "username": "sukiboo",
                        "content": "\"Suppose every senator is smart enough and will play the best strategy for his own party.\"\\nIf only it worked like that in real life <_<"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "reminds me of STAR WARS"
                    },
                    {
                        "username": "programmer0073",
                        "content": "Too ambiguous? Can D ban another D? From the test cases, it seems they cannot, but from the description it does not say anything."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "D can but it is not beneficial for Dire senators , if they wanna win they will always ban opposing team."
                    }
                ]
            },
            {
                "id": 1882360,
                "content": [
                    {
                        "username": "shivamgarg260",
                        "content": "Not submitting even after passing all 82 test cases:("
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "is this a bug or you found a solution?"
                    },
                    {
                        "username": "natitati",
                        "content": "Very cool problem"
                    },
                    {
                        "username": "caldempsey",
                        "content": "How many rounds?"
                    },
                    {
                        "username": "shahil3303",
                        "content": "senate =\\n\"DDR\"\\ngetting tle for this case\\n"
                    },
                    {
                        "username": "Kovid_krishnan_30",
                        "content": "Almost been 9 hours, still not getting it \\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "renetchi",
                        "content": "I don\\'t play Dota.. I don\\'t get the reference.."
                    },
                    {
                        "username": "zwang198",
                        "content": "Senator: Say yes or no!"
                    },
                    {
                        "username": "sukiboo",
                        "content": "\"Suppose every senator is smart enough and will play the best strategy for his own party.\"\\nIf only it worked like that in real life <_<"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "reminds me of STAR WARS"
                    },
                    {
                        "username": "programmer0073",
                        "content": "Too ambiguous? Can D ban another D? From the test cases, it seems they cannot, but from the description it does not say anything."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "D can but it is not beneficial for Dire senators , if they wanna win they will always ban opposing team."
                    }
                ]
            },
            {
                "id": 1882265,
                "content": [
                    {
                        "username": "shivamgarg260",
                        "content": "Not submitting even after passing all 82 test cases:("
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "is this a bug or you found a solution?"
                    },
                    {
                        "username": "natitati",
                        "content": "Very cool problem"
                    },
                    {
                        "username": "caldempsey",
                        "content": "How many rounds?"
                    },
                    {
                        "username": "shahil3303",
                        "content": "senate =\\n\"DDR\"\\ngetting tle for this case\\n"
                    },
                    {
                        "username": "Kovid_krishnan_30",
                        "content": "Almost been 9 hours, still not getting it \\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "renetchi",
                        "content": "I don\\'t play Dota.. I don\\'t get the reference.."
                    },
                    {
                        "username": "zwang198",
                        "content": "Senator: Say yes or no!"
                    },
                    {
                        "username": "sukiboo",
                        "content": "\"Suppose every senator is smart enough and will play the best strategy for his own party.\"\\nIf only it worked like that in real life <_<"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "reminds me of STAR WARS"
                    },
                    {
                        "username": "programmer0073",
                        "content": "Too ambiguous? Can D ban another D? From the test cases, it seems they cannot, but from the description it does not say anything."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "D can but it is not beneficial for Dire senators , if they wanna win they will always ban opposing team."
                    }
                ]
            },
            {
                "id": 1882227,
                "content": [
                    {
                        "username": "shivamgarg260",
                        "content": "Not submitting even after passing all 82 test cases:("
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "is this a bug or you found a solution?"
                    },
                    {
                        "username": "natitati",
                        "content": "Very cool problem"
                    },
                    {
                        "username": "caldempsey",
                        "content": "How many rounds?"
                    },
                    {
                        "username": "shahil3303",
                        "content": "senate =\\n\"DDR\"\\ngetting tle for this case\\n"
                    },
                    {
                        "username": "Kovid_krishnan_30",
                        "content": "Almost been 9 hours, still not getting it \\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "renetchi",
                        "content": "I don\\'t play Dota.. I don\\'t get the reference.."
                    },
                    {
                        "username": "zwang198",
                        "content": "Senator: Say yes or no!"
                    },
                    {
                        "username": "sukiboo",
                        "content": "\"Suppose every senator is smart enough and will play the best strategy for his own party.\"\\nIf only it worked like that in real life <_<"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "reminds me of STAR WARS"
                    },
                    {
                        "username": "programmer0073",
                        "content": "Too ambiguous? Can D ban another D? From the test cases, it seems they cannot, but from the description it does not say anything."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "D can but it is not beneficial for Dire senators , if they wanna win they will always ban opposing team."
                    }
                ]
            },
            {
                "id": 1882178,
                "content": [
                    {
                        "username": "shivamgarg260",
                        "content": "Not submitting even after passing all 82 test cases:("
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "is this a bug or you found a solution?"
                    },
                    {
                        "username": "natitati",
                        "content": "Very cool problem"
                    },
                    {
                        "username": "caldempsey",
                        "content": "How many rounds?"
                    },
                    {
                        "username": "shahil3303",
                        "content": "senate =\\n\"DDR\"\\ngetting tle for this case\\n"
                    },
                    {
                        "username": "Kovid_krishnan_30",
                        "content": "Almost been 9 hours, still not getting it \\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "renetchi",
                        "content": "I don\\'t play Dota.. I don\\'t get the reference.."
                    },
                    {
                        "username": "zwang198",
                        "content": "Senator: Say yes or no!"
                    },
                    {
                        "username": "sukiboo",
                        "content": "\"Suppose every senator is smart enough and will play the best strategy for his own party.\"\\nIf only it worked like that in real life <_<"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "reminds me of STAR WARS"
                    },
                    {
                        "username": "programmer0073",
                        "content": "Too ambiguous? Can D ban another D? From the test cases, it seems they cannot, but from the description it does not say anything."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "D can but it is not beneficial for Dire senators , if they wanna win they will always ban opposing team."
                    }
                ]
            },
            {
                "id": 1882137,
                "content": [
                    {
                        "username": "shivamgarg260",
                        "content": "Not submitting even after passing all 82 test cases:("
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "is this a bug or you found a solution?"
                    },
                    {
                        "username": "natitati",
                        "content": "Very cool problem"
                    },
                    {
                        "username": "caldempsey",
                        "content": "How many rounds?"
                    },
                    {
                        "username": "shahil3303",
                        "content": "senate =\\n\"DDR\"\\ngetting tle for this case\\n"
                    },
                    {
                        "username": "Kovid_krishnan_30",
                        "content": "Almost been 9 hours, still not getting it \\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "renetchi",
                        "content": "I don\\'t play Dota.. I don\\'t get the reference.."
                    },
                    {
                        "username": "zwang198",
                        "content": "Senator: Say yes or no!"
                    },
                    {
                        "username": "sukiboo",
                        "content": "\"Suppose every senator is smart enough and will play the best strategy for his own party.\"\\nIf only it worked like that in real life <_<"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "reminds me of STAR WARS"
                    },
                    {
                        "username": "programmer0073",
                        "content": "Too ambiguous? Can D ban another D? From the test cases, it seems they cannot, but from the description it does not say anything."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "D can but it is not beneficial for Dire senators , if they wanna win they will always ban opposing team."
                    }
                ]
            },
            {
                "id": 1882080,
                "content": [
                    {
                        "username": "shivamgarg260",
                        "content": "Not submitting even after passing all 82 test cases:("
                    },
                    {
                        "username": "rudgeegdur",
                        "content": "is this a bug or you found a solution?"
                    },
                    {
                        "username": "natitati",
                        "content": "Very cool problem"
                    },
                    {
                        "username": "caldempsey",
                        "content": "How many rounds?"
                    },
                    {
                        "username": "shahil3303",
                        "content": "senate =\\n\"DDR\"\\ngetting tle for this case\\n"
                    },
                    {
                        "username": "Kovid_krishnan_30",
                        "content": "Almost been 9 hours, still not getting it \\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "renetchi",
                        "content": "I don\\'t play Dota.. I don\\'t get the reference.."
                    },
                    {
                        "username": "zwang198",
                        "content": "Senator: Say yes or no!"
                    },
                    {
                        "username": "sukiboo",
                        "content": "\"Suppose every senator is smart enough and will play the best strategy for his own party.\"\\nIf only it worked like that in real life <_<"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "reminds me of STAR WARS"
                    },
                    {
                        "username": "programmer0073",
                        "content": "Too ambiguous? Can D ban another D? From the test cases, it seems they cannot, but from the description it does not say anything."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "D can but it is not beneficial for Dire senators , if they wanna win they will always ban opposing team."
                    }
                ]
            },
            {
                "id": 1882026,
                "content": [
                    {
                        "username": "Xoxo_szn",
                        "content": "Ah! finally solved it"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "After finding the \"best strategy\", this question is piece of cake."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "[@sooraj7](/sooraj7) the best strategy is banning the opponent on the right side"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "truly agree on that.. After finding the \"best Strategy\" it became a cakewalk"
                    },
                    {
                        "username": "sooraj7",
                        "content": "whats it?\\n"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "I love this question xd"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "was breaking my head for a while... didn\\'t realize that characters are of upper case unlike other questions..."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "leetchef \\uD83D\\uDE30"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "leetcode is becoming codeforces in task description."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "understood the question can\\'t think implementation\\nany hint?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "What the hell is this problem."
                    },
                    {
                        "username": "JustBored",
                        "content": "The key observation to this question is that a senator may be be able to vote again in the next round as long as they haven't been banned yet and all senators after them have already voted in the current round."
                    },
                    {
                        "username": "yakode",
                        "content": "I think i-th senate would prioritize banning the first enemy senate behind him/her.\\n\\nBanning a senate who hasn\\'t banned aother senate is better than banning a senate who has banned another senate.\\n\\nBecause the front one can  prevent one banning in current round."
                    }
                ]
            },
            {
                "id": 1882012,
                "content": [
                    {
                        "username": "Xoxo_szn",
                        "content": "Ah! finally solved it"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "After finding the \"best strategy\", this question is piece of cake."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "[@sooraj7](/sooraj7) the best strategy is banning the opponent on the right side"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "truly agree on that.. After finding the \"best Strategy\" it became a cakewalk"
                    },
                    {
                        "username": "sooraj7",
                        "content": "whats it?\\n"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "I love this question xd"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "was breaking my head for a while... didn\\'t realize that characters are of upper case unlike other questions..."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "leetchef \\uD83D\\uDE30"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "leetcode is becoming codeforces in task description."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "understood the question can\\'t think implementation\\nany hint?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "What the hell is this problem."
                    },
                    {
                        "username": "JustBored",
                        "content": "The key observation to this question is that a senator may be be able to vote again in the next round as long as they haven't been banned yet and all senators after them have already voted in the current round."
                    },
                    {
                        "username": "yakode",
                        "content": "I think i-th senate would prioritize banning the first enemy senate behind him/her.\\n\\nBanning a senate who hasn\\'t banned aother senate is better than banning a senate who has banned another senate.\\n\\nBecause the front one can  prevent one banning in current round."
                    }
                ]
            },
            {
                "id": 1881976,
                "content": [
                    {
                        "username": "Xoxo_szn",
                        "content": "Ah! finally solved it"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "After finding the \"best strategy\", this question is piece of cake."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "[@sooraj7](/sooraj7) the best strategy is banning the opponent on the right side"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "truly agree on that.. After finding the \"best Strategy\" it became a cakewalk"
                    },
                    {
                        "username": "sooraj7",
                        "content": "whats it?\\n"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "I love this question xd"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "was breaking my head for a while... didn\\'t realize that characters are of upper case unlike other questions..."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "leetchef \\uD83D\\uDE30"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "leetcode is becoming codeforces in task description."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "understood the question can\\'t think implementation\\nany hint?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "What the hell is this problem."
                    },
                    {
                        "username": "JustBored",
                        "content": "The key observation to this question is that a senator may be be able to vote again in the next round as long as they haven't been banned yet and all senators after them have already voted in the current round."
                    },
                    {
                        "username": "yakode",
                        "content": "I think i-th senate would prioritize banning the first enemy senate behind him/her.\\n\\nBanning a senate who hasn\\'t banned aother senate is better than banning a senate who has banned another senate.\\n\\nBecause the front one can  prevent one banning in current round."
                    }
                ]
            },
            {
                "id": 1881943,
                "content": [
                    {
                        "username": "Xoxo_szn",
                        "content": "Ah! finally solved it"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "After finding the \"best strategy\", this question is piece of cake."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "[@sooraj7](/sooraj7) the best strategy is banning the opponent on the right side"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "truly agree on that.. After finding the \"best Strategy\" it became a cakewalk"
                    },
                    {
                        "username": "sooraj7",
                        "content": "whats it?\\n"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "I love this question xd"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "was breaking my head for a while... didn\\'t realize that characters are of upper case unlike other questions..."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "leetchef \\uD83D\\uDE30"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "leetcode is becoming codeforces in task description."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "understood the question can\\'t think implementation\\nany hint?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "What the hell is this problem."
                    },
                    {
                        "username": "JustBored",
                        "content": "The key observation to this question is that a senator may be be able to vote again in the next round as long as they haven't been banned yet and all senators after them have already voted in the current round."
                    },
                    {
                        "username": "yakode",
                        "content": "I think i-th senate would prioritize banning the first enemy senate behind him/her.\\n\\nBanning a senate who hasn\\'t banned aother senate is better than banning a senate who has banned another senate.\\n\\nBecause the front one can  prevent one banning in current round."
                    }
                ]
            },
            {
                "id": 1881911,
                "content": [
                    {
                        "username": "Xoxo_szn",
                        "content": "Ah! finally solved it"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "After finding the \"best strategy\", this question is piece of cake."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "[@sooraj7](/sooraj7) the best strategy is banning the opponent on the right side"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "truly agree on that.. After finding the \"best Strategy\" it became a cakewalk"
                    },
                    {
                        "username": "sooraj7",
                        "content": "whats it?\\n"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "I love this question xd"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "was breaking my head for a while... didn\\'t realize that characters are of upper case unlike other questions..."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "leetchef \\uD83D\\uDE30"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "leetcode is becoming codeforces in task description."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "understood the question can\\'t think implementation\\nany hint?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "What the hell is this problem."
                    },
                    {
                        "username": "JustBored",
                        "content": "The key observation to this question is that a senator may be be able to vote again in the next round as long as they haven't been banned yet and all senators after them have already voted in the current round."
                    },
                    {
                        "username": "yakode",
                        "content": "I think i-th senate would prioritize banning the first enemy senate behind him/her.\\n\\nBanning a senate who hasn\\'t banned aother senate is better than banning a senate who has banned another senate.\\n\\nBecause the front one can  prevent one banning in current round."
                    }
                ]
            },
            {
                "id": 1881892,
                "content": [
                    {
                        "username": "Xoxo_szn",
                        "content": "Ah! finally solved it"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "After finding the \"best strategy\", this question is piece of cake."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "[@sooraj7](/sooraj7) the best strategy is banning the opponent on the right side"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "truly agree on that.. After finding the \"best Strategy\" it became a cakewalk"
                    },
                    {
                        "username": "sooraj7",
                        "content": "whats it?\\n"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "I love this question xd"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "was breaking my head for a while... didn\\'t realize that characters are of upper case unlike other questions..."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "leetchef \\uD83D\\uDE30"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "leetcode is becoming codeforces in task description."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "understood the question can\\'t think implementation\\nany hint?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "What the hell is this problem."
                    },
                    {
                        "username": "JustBored",
                        "content": "The key observation to this question is that a senator may be be able to vote again in the next round as long as they haven't been banned yet and all senators after them have already voted in the current round."
                    },
                    {
                        "username": "yakode",
                        "content": "I think i-th senate would prioritize banning the first enemy senate behind him/her.\\n\\nBanning a senate who hasn\\'t banned aother senate is better than banning a senate who has banned another senate.\\n\\nBecause the front one can  prevent one banning in current round."
                    }
                ]
            },
            {
                "id": 1881862,
                "content": [
                    {
                        "username": "Xoxo_szn",
                        "content": "Ah! finally solved it"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "After finding the \"best strategy\", this question is piece of cake."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "[@sooraj7](/sooraj7) the best strategy is banning the opponent on the right side"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "truly agree on that.. After finding the \"best Strategy\" it became a cakewalk"
                    },
                    {
                        "username": "sooraj7",
                        "content": "whats it?\\n"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "I love this question xd"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "was breaking my head for a while... didn\\'t realize that characters are of upper case unlike other questions..."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "leetchef \\uD83D\\uDE30"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "leetcode is becoming codeforces in task description."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "understood the question can\\'t think implementation\\nany hint?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "What the hell is this problem."
                    },
                    {
                        "username": "JustBored",
                        "content": "The key observation to this question is that a senator may be be able to vote again in the next round as long as they haven't been banned yet and all senators after them have already voted in the current round."
                    },
                    {
                        "username": "yakode",
                        "content": "I think i-th senate would prioritize banning the first enemy senate behind him/her.\\n\\nBanning a senate who hasn\\'t banned aother senate is better than banning a senate who has banned another senate.\\n\\nBecause the front one can  prevent one banning in current round."
                    }
                ]
            },
            {
                "id": 1881841,
                "content": [
                    {
                        "username": "Xoxo_szn",
                        "content": "Ah! finally solved it"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "After finding the \"best strategy\", this question is piece of cake."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "[@sooraj7](/sooraj7) the best strategy is banning the opponent on the right side"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "truly agree on that.. After finding the \"best Strategy\" it became a cakewalk"
                    },
                    {
                        "username": "sooraj7",
                        "content": "whats it?\\n"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "I love this question xd"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "was breaking my head for a while... didn\\'t realize that characters are of upper case unlike other questions..."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "leetchef \\uD83D\\uDE30"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "leetcode is becoming codeforces in task description."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "understood the question can\\'t think implementation\\nany hint?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "What the hell is this problem."
                    },
                    {
                        "username": "JustBored",
                        "content": "The key observation to this question is that a senator may be be able to vote again in the next round as long as they haven't been banned yet and all senators after them have already voted in the current round."
                    },
                    {
                        "username": "yakode",
                        "content": "I think i-th senate would prioritize banning the first enemy senate behind him/her.\\n\\nBanning a senate who hasn\\'t banned aother senate is better than banning a senate who has banned another senate.\\n\\nBecause the front one can  prevent one banning in current round."
                    }
                ]
            },
            {
                "id": 1881725,
                "content": [
                    {
                        "username": "Xoxo_szn",
                        "content": "Ah! finally solved it"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "After finding the \"best strategy\", this question is piece of cake."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "[@sooraj7](/sooraj7) the best strategy is banning the opponent on the right side"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "truly agree on that.. After finding the \"best Strategy\" it became a cakewalk"
                    },
                    {
                        "username": "sooraj7",
                        "content": "whats it?\\n"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "I love this question xd"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "was breaking my head for a while... didn\\'t realize that characters are of upper case unlike other questions..."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "leetchef \\uD83D\\uDE30"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "leetcode is becoming codeforces in task description."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "understood the question can\\'t think implementation\\nany hint?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "What the hell is this problem."
                    },
                    {
                        "username": "JustBored",
                        "content": "The key observation to this question is that a senator may be be able to vote again in the next round as long as they haven't been banned yet and all senators after them have already voted in the current round."
                    },
                    {
                        "username": "yakode",
                        "content": "I think i-th senate would prioritize banning the first enemy senate behind him/her.\\n\\nBanning a senate who hasn\\'t banned aother senate is better than banning a senate who has banned another senate.\\n\\nBecause the front one can  prevent one banning in current round."
                    }
                ]
            },
            {
                "id": 1881672,
                "content": [
                    {
                        "username": "Xoxo_szn",
                        "content": "Ah! finally solved it"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "After finding the \"best strategy\", this question is piece of cake."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "[@sooraj7](/sooraj7) the best strategy is banning the opponent on the right side"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "truly agree on that.. After finding the \"best Strategy\" it became a cakewalk"
                    },
                    {
                        "username": "sooraj7",
                        "content": "whats it?\\n"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "I love this question xd"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "was breaking my head for a while... didn\\'t realize that characters are of upper case unlike other questions..."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "leetchef \\uD83D\\uDE30"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "leetcode is becoming codeforces in task description."
                    },
                    {
                        "username": "dhiraj0911",
                        "content": "understood the question can\\'t think implementation\\nany hint?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "What the hell is this problem."
                    },
                    {
                        "username": "JustBored",
                        "content": "The key observation to this question is that a senator may be be able to vote again in the next round as long as they haven't been banned yet and all senators after them have already voted in the current round."
                    },
                    {
                        "username": "yakode",
                        "content": "I think i-th senate would prioritize banning the first enemy senate behind him/her.\\n\\nBanning a senate who hasn\\'t banned aother senate is better than banning a senate who has banned another senate.\\n\\nBecause the front one can  prevent one banning in current round."
                    }
                ]
            }
        ]
    }
]